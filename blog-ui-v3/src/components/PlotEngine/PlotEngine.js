function UUID() {
  if (typeof UUID.instance == "object")
    return UUID.instance;
  UUID.instance = this;
}
UUID.prototype.create = function() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
    var n = Math.random() * 16 | 0, r = e == "x" ? n : n & 3 | 8;
    return r.toString(16);
  });
};
class BaseObject {
  constructor() {
    this._id = new UUID().create(), this._className = "BaseObject";
  }
  getClassName() {
    return this._className;
  }
}
let Point$1 = class extends BaseObject {
  constructor(n, r, o = 0) {
    super(), this._x = n, this._y = r, this._z = o, this._className = "Point";
  }
};
class GeoPoint2D extends Point$1 {
  constructor(n = 0, r = 0) {
    super(n, r, 0), this._className = "GeoPoint2D";
  }
  getLat() {
    return this._y;
  }
  getLon() {
    return this._x;
  }
}
function numberEqual(e, n) {
  let r = 1e-9;
  return Number(e) && Number(n) ? Number(e) - Number(n) < r : !1;
}
var FeatureType = /* @__PURE__ */ ((e) => (e[e.default = 0] = "default", e[e.Polyline = 1] = "Polyline", e[e.Polygon = 2] = "Polygon", e[e.Pin = 3] = "Pin", e[e.Rectangle = 4] = "Rectangle", e[e.PlotPng = 5] = "PlotPng", e[e.Text = 6] = "Text", e[e.Circle = 7] = "Circle", e[e.Ellipse = 8] = "Ellipse", e[e.DistanceResult = 9] = "DistanceResult", e[e.AreaResult = 10] = "AreaResult", e[e.AngleResult = 11] = "AngleResult", e[e.PositionResult = 12] = "PositionResult", e[e.MultiLines = 13] = "MultiLines", e[e.MultiText = 14] = "MultiText", e[e.SVG = 15] = "SVG", e[e.Region = 16] = "Region", e[e.Entity = 17] = "Entity", e))(FeatureType || {}), MouseEventType = /* @__PURE__ */ ((e) => (e[e.default = 0] = "default", e[e.MouseLClick = 1] = "MouseLClick", e[e.MouseEnter = 2] = "MouseEnter", e[e.MouseOut = 3] = "MouseOut", e))(MouseEventType || {}), LayerType = /* @__PURE__ */ ((e) => (e[e.default = 0] = "default", e[e.WMTS = 1] = "WMTS", e[e.WMS = 2] = "WMS", e[e.XYZ = 3] = "XYZ", e[e.FEATURE = 4] = "FEATURE", e[e.PLOT = 5] = "PLOT", e[e.Text = 6] = "Text", e))(LayerType || {}), SymbolCellType = /* @__PURE__ */ ((e) => (e[e.default = 0] = "default", e[e.PolyLine = 1] = "PolyLine", e[e.Polygon = 2] = "Polygon", e[e.Pin = 3] = "Pin", e[e.PlotPng = 4] = "PlotPng", e[e.image = 5] = "image", e[e.Text = 6] = "Text", e[e.DistancePoint = 7] = "DistancePoint", e[e.circleMark = 8] = "circleMark", e))(SymbolCellType || {});
const DEFAULT_PRECISION = 14, TypesDefined = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_PRECISION,
  FeatureType,
  LayerType,
  MouseEventType,
  SymbolCellType
}, Symbol.toStringTag, { value: "Module" }));
var earthRadius = 63710088e-1, factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
function feature(e, n, r) {
  r === void 0 && (r = {});
  var o = { type: "Feature" };
  return (r.id === 0 || r.id) && (o.id = r.id), r.bbox && (o.bbox = r.bbox), o.properties = n || {}, o.geometry = e, o;
}
function point(e, n, r) {
  if (r === void 0 && (r = {}), !e)
    throw new Error("coordinates is required");
  if (!Array.isArray(e))
    throw new Error("coordinates must be an Array");
  if (e.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!isNumber$2(e[0]) || !isNumber$2(e[1]))
    throw new Error("coordinates must contain numbers");
  var o = {
    type: "Point",
    coordinates: e
  };
  return feature(o, n, r);
}
function polygon(e, n, r) {
  r === void 0 && (r = {});
  for (var o = 0, l = e; o < l.length; o++) {
    var u = l[o];
    if (u.length < 4)
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    for (var h = 0; h < u[u.length - 1].length; h++)
      if (u[u.length - 1][h] !== u[0][h])
        throw new Error("First and last Position are not equivalent.");
  }
  var c = {
    type: "Polygon",
    coordinates: e
  };
  return feature(c, n, r);
}
function lineString(e, n, r) {
  if (r === void 0 && (r = {}), e.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  var o = {
    type: "LineString",
    coordinates: e
  };
  return feature(o, n, r);
}
function radiansToLength(e, n) {
  n === void 0 && (n = "kilometers");
  var r = factors[n];
  if (!r)
    throw new Error(n + " units is invalid");
  return e * r;
}
function lengthToRadians(e, n) {
  n === void 0 && (n = "kilometers");
  var r = factors[n];
  if (!r)
    throw new Error(n + " units is invalid");
  return e / r;
}
function radiansToDegrees(e) {
  var n = e % (2 * Math.PI);
  return n * 180 / Math.PI;
}
function degreesToRadians(e) {
  var n = e % 360;
  return n * Math.PI / 180;
}
function convertLength(e, n, r) {
  if (n === void 0 && (n = "kilometers"), r === void 0 && (r = "kilometers"), !(e >= 0))
    throw new Error("length must be a positive number");
  return radiansToLength(lengthToRadians(e, n), r);
}
function isNumber$2(e) {
  return !isNaN(e) && e !== null && !Array.isArray(e);
}
function isObject$2(e) {
  return !!e && e.constructor === Object;
}
function coordEach(e, n, r) {
  if (e !== null)
    for (var o, l, u, h, c, f, v, m = 0, g = 0, y, w = e.type, E = w === "FeatureCollection", x = w === "Feature", D = E ? e.features.length : 1, F = 0; F < D; F++) {
      v = E ? e.features[F].geometry : x ? e.geometry : e, y = v ? v.type === "GeometryCollection" : !1, c = y ? v.geometries.length : 1;
      for (var k = 0; k < c; k++) {
        var N = 0, H = 0;
        if (h = y ? v.geometries[k] : v, h !== null) {
          f = h.coordinates;
          var R = h.type;
          switch (m = r && (R === "Polygon" || R === "MultiPolygon") ? 1 : 0, R) {
            case null:
              break;
            case "Point":
              if (n(
                f,
                g,
                F,
                N,
                H
              ) === !1)
                return !1;
              g++, N++;
              break;
            case "LineString":
            case "MultiPoint":
              for (o = 0; o < f.length; o++) {
                if (n(
                  f[o],
                  g,
                  F,
                  N,
                  H
                ) === !1)
                  return !1;
                g++, R === "MultiPoint" && N++;
              }
              R === "LineString" && N++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (o = 0; o < f.length; o++) {
                for (l = 0; l < f[o].length - m; l++) {
                  if (n(
                    f[o][l],
                    g,
                    F,
                    N,
                    H
                  ) === !1)
                    return !1;
                  g++;
                }
                R === "MultiLineString" && N++, R === "Polygon" && H++;
              }
              R === "Polygon" && N++;
              break;
            case "MultiPolygon":
              for (o = 0; o < f.length; o++) {
                for (H = 0, l = 0; l < f[o].length; l++) {
                  for (u = 0; u < f[o][l].length - m; u++) {
                    if (n(
                      f[o][l][u],
                      g,
                      F,
                      N,
                      H
                    ) === !1)
                      return !1;
                    g++;
                  }
                  H++;
                }
                N++;
              }
              break;
            case "GeometryCollection":
              for (o = 0; o < h.geometries.length; o++)
                if (coordEach(h.geometries[o], n, r) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function geomEach(e, n) {
  var r, o, l, u, h, c, f, v, m, g, y = 0, w = e.type === "FeatureCollection", E = e.type === "Feature", x = w ? e.features.length : 1;
  for (r = 0; r < x; r++) {
    for (c = w ? e.features[r].geometry : E ? e.geometry : e, v = w ? e.features[r].properties : E ? e.properties : {}, m = w ? e.features[r].bbox : E ? e.bbox : void 0, g = w ? e.features[r].id : E ? e.id : void 0, f = c ? c.type === "GeometryCollection" : !1, h = f ? c.geometries.length : 1, l = 0; l < h; l++) {
      if (u = f ? c.geometries[l] : c, u === null) {
        if (n(
          null,
          y,
          v,
          m,
          g
        ) === !1)
          return !1;
        continue;
      }
      switch (u.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (n(
            u,
            y,
            v,
            m,
            g
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (o = 0; o < u.geometries.length; o++)
            if (n(
              u.geometries[o],
              y,
              v,
              m,
              g
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    y++;
  }
}
function geomReduce(e, n, r) {
  var o = r;
  return geomEach(
    e,
    function(l, u, h, c, f) {
      u === 0 && r === void 0 ? o = l : o = n(
        o,
        l,
        u,
        h,
        c,
        f
      );
    }
  ), o;
}
function flattenEach(e, n) {
  geomEach(e, function(r, o, l, u, h) {
    var c = r === null ? null : r.type;
    switch (c) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return n(
          feature(r, l, { bbox: u, id: h }),
          o,
          0
        ) === !1 ? !1 : void 0;
    }
    var f;
    switch (c) {
      case "MultiPoint":
        f = "Point";
        break;
      case "MultiLineString":
        f = "LineString";
        break;
      case "MultiPolygon":
        f = "Polygon";
        break;
    }
    for (var v = 0; v < r.coordinates.length; v++) {
      var m = r.coordinates[v], g = {
        type: f,
        coordinates: m
      };
      if (n(feature(g, l), o, v) === !1)
        return !1;
    }
  });
}
function segmentEach(e, n) {
  flattenEach(e, function(r, o, l) {
    var u = 0;
    if (r.geometry) {
      var h = r.geometry.type;
      if (!(h === "Point" || h === "MultiPoint")) {
        var c, f = 0, v = 0, m = 0;
        if (coordEach(
          r,
          function(g, y, w, E, x) {
            if (c === void 0 || o > f || E > v || x > m) {
              c = g, f = o, v = E, m = x, u = 0;
              return;
            }
            var D = lineString(
              [c, g],
              r.properties
            );
            if (n(
              D,
              o,
              l,
              x,
              u
            ) === !1)
              return !1;
            u++, c = g;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
function segmentReduce(e, n, r) {
  var o = r, l = !1;
  return segmentEach(
    e,
    function(u, h, c, f, v) {
      l === !1 && r === void 0 ? o = u : o = n(
        o,
        u,
        h,
        c,
        f,
        v
      ), l = !0;
    }
  ), o;
}
function getCoord(e) {
  if (!e)
    throw new Error("coord is required");
  if (!Array.isArray(e)) {
    if (e.type === "Feature" && e.geometry !== null && e.geometry.type === "Point")
      return e.geometry.coordinates;
    if (e.type === "Point")
      return e.coordinates;
  }
  if (Array.isArray(e) && e.length >= 2 && !Array.isArray(e[0]) && !Array.isArray(e[1]))
    return e;
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(e) {
  if (Array.isArray(e))
    return e;
  if (e.type === "Feature") {
    if (e.geometry !== null)
      return e.geometry.coordinates;
  } else if (e.coordinates)
    return e.coordinates;
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function featureOf(e, n, r) {
  if (!e)
    throw new Error("No feature passed");
  if (!r)
    throw new Error(".featureOf() requires a name");
  if (!e || e.type !== "Feature" || !e.geometry)
    throw new Error("Invalid input to " + r + ", Feature with geometry required");
  if (!e.geometry || e.geometry.type !== n)
    throw new Error("Invalid input to " + r + ": must be a " + n + ", given " + e.geometry.type);
}
function getGeom(e) {
  return e.type === "Feature" ? e.geometry : e;
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function booleanPointInPolygon(e, n, r) {
  if (r === void 0 && (r = {}), !e)
    throw new Error("point is required");
  if (!n)
    throw new Error("polygon is required");
  var o = getCoord(e), l = getGeom(n), u = l.type, h = n.bbox, c = l.coordinates;
  if (h && inBBox(o, h) === !1)
    return !1;
  u === "Polygon" && (c = [c]);
  for (var f = !1, v = 0; v < c.length && !f; v++)
    if (inRing(o, c[v][0], r.ignoreBoundary)) {
      for (var m = !1, g = 1; g < c[v].length && !m; )
        inRing(o, c[v][g], !r.ignoreBoundary) && (m = !0), g++;
      m || (f = !0);
    }
  return f;
}
function inRing(e, n, r) {
  var o = !1;
  n[0][0] === n[n.length - 1][0] && n[0][1] === n[n.length - 1][1] && (n = n.slice(0, n.length - 1));
  for (var l = 0, u = n.length - 1; l < n.length; u = l++) {
    var h = n[l][0], c = n[l][1], f = n[u][0], v = n[u][1], m = e[1] * (h - f) + c * (f - e[0]) + v * (e[0] - h) === 0 && (h - e[0]) * (f - e[0]) <= 0 && (c - e[1]) * (v - e[1]) <= 0;
    if (m)
      return !r;
    var g = c > e[1] != v > e[1] && e[0] < (f - h) * (e[1] - c) / (v - c) + h;
    g && (o = !o);
  }
  return o;
}
function inBBox(e, n) {
  return n[0] <= e[0] && n[1] <= e[1] && n[2] >= e[0] && n[3] >= e[1];
}
function distance(e, n, r) {
  r === void 0 && (r = {});
  var o = getCoord(e), l = getCoord(n), u = degreesToRadians(l[1] - o[1]), h = degreesToRadians(l[0] - o[0]), c = degreesToRadians(o[1]), f = degreesToRadians(l[1]), v = Math.pow(Math.sin(u / 2), 2) + Math.pow(Math.sin(h / 2), 2) * Math.cos(c) * Math.cos(f);
  return radiansToLength(2 * Math.atan2(Math.sqrt(v), Math.sqrt(1 - v)), r.units);
}
function clone$3(e) {
  if (!e)
    throw new Error("geojson is required");
  switch (e.type) {
    case "Feature":
      return cloneFeature(e);
    case "FeatureCollection":
      return cloneFeatureCollection(e);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(e);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function cloneFeature(e) {
  var n = { type: "Feature" };
  return Object.keys(e).forEach(function(r) {
    switch (r) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        n[r] = e[r];
    }
  }), n.properties = cloneProperties(e.properties), n.geometry = cloneGeometry(e.geometry), n;
}
function cloneProperties(e) {
  var n = {};
  return e && Object.keys(e).forEach(function(r) {
    var o = e[r];
    typeof o == "object" ? o === null ? n[r] = null : Array.isArray(o) ? n[r] = o.map(function(l) {
      return l;
    }) : n[r] = cloneProperties(o) : n[r] = o;
  }), n;
}
function cloneFeatureCollection(e) {
  var n = { type: "FeatureCollection" };
  return Object.keys(e).forEach(function(r) {
    switch (r) {
      case "type":
      case "features":
        return;
      default:
        n[r] = e[r];
    }
  }), n.features = e.features.map(function(r) {
    return cloneFeature(r);
  }), n;
}
function cloneGeometry(e) {
  var n = { type: e.type };
  return e.bbox && (n.bbox = e.bbox), e.type === "GeometryCollection" ? (n.geometries = e.geometries.map(function(r) {
    return cloneGeometry(r);
  }), n) : (n.coordinates = deepSlice(e.coordinates), n);
}
function deepSlice(e) {
  var n = e;
  return typeof n[0] != "object" ? n.slice() : n.map(function(r) {
    return deepSlice(r);
  });
}
function destination(e, n, r, o) {
  o === void 0 && (o = {});
  var l = getCoord(e), u = degreesToRadians(l[0]), h = degreesToRadians(l[1]), c = degreesToRadians(r), f = lengthToRadians(n, o.units), v = Math.asin(Math.sin(h) * Math.cos(f) + Math.cos(h) * Math.sin(f) * Math.cos(c)), m = u + Math.atan2(Math.sin(c) * Math.sin(f) * Math.cos(h), Math.cos(f) - Math.sin(h) * Math.sin(v)), g = radiansToDegrees(m), y = radiansToDegrees(v);
  return point([g, y], o.properties);
}
function circle(e, n, r) {
  r === void 0 && (r = {});
  for (var o = r.steps || 64, l = r.properties ? r.properties : !Array.isArray(e) && e.type === "Feature" && e.properties ? e.properties : {}, u = [], h = 0; h < o; h++)
    u.push(destination(e, n, h * -360 / o, r).geometry.coordinates);
  return u.push(u[0]), polygon([u], l);
}
function bearing(e, n, r) {
  if (r === void 0 && (r = {}), r.final === !0)
    return calculateFinalBearing(e, n);
  var o = getCoord(e), l = getCoord(n), u = degreesToRadians(o[0]), h = degreesToRadians(l[0]), c = degreesToRadians(o[1]), f = degreesToRadians(l[1]), v = Math.sin(h - u) * Math.cos(f), m = Math.cos(c) * Math.sin(f) - Math.sin(c) * Math.cos(f) * Math.cos(h - u);
  return radiansToDegrees(Math.atan2(v, m));
}
function calculateFinalBearing(e, n) {
  var r = bearing(n, e);
  return r = (r + 180) % 360, r;
}
function midpoint(e, n) {
  var r = distance(e, n), o = bearing(e, n), l = destination(e, r / 2, o);
  return l;
}
function centroid(e, n) {
  n === void 0 && (n = {});
  var r = 0, o = 0, l = 0;
  return coordEach(e, function(u) {
    r += u[0], o += u[1], l++;
  }, !0), point([r / l, o / l], n.properties);
}
function rhumbDistance(e, n, r) {
  r === void 0 && (r = {});
  var o = getCoord(e), l = getCoord(n);
  l[0] += l[0] - o[0] > 180 ? -360 : o[0] - l[0] > 180 ? 360 : 0;
  var u = calculateRhumbDistance(o, l), h = convertLength(u, "meters", r.units);
  return h;
}
function calculateRhumbDistance(e, n, r) {
  r = r === void 0 ? earthRadius : Number(r);
  var o = r, l = e[1] * Math.PI / 180, u = n[1] * Math.PI / 180, h = u - l, c = Math.abs(n[0] - e[0]) * Math.PI / 180;
  c > Math.PI && (c -= 2 * Math.PI);
  var f = Math.log(Math.tan(u / 2 + Math.PI / 4) / Math.tan(l / 2 + Math.PI / 4)), v = Math.abs(f) > 1e-11 ? h / f : Math.cos(l), m = Math.sqrt(h * h + v * v * c * c), g = m * o;
  return g;
}
function pointToLineDistance(e, n, r) {
  if (r === void 0 && (r = {}), r.method || (r.method = "geodesic"), r.units || (r.units = "kilometers"), !e)
    throw new Error("pt is required");
  if (Array.isArray(e) ? e = point(e) : e.type === "Point" ? e = feature(e) : featureOf(e, "Point", "point"), !n)
    throw new Error("line is required");
  Array.isArray(n) ? n = lineString(n) : n.type === "LineString" ? n = feature(n) : featureOf(n, "LineString", "line");
  var o = 1 / 0, l = e.geometry.coordinates;
  return segmentEach(n, function(u) {
    var h = u.geometry.coordinates[0], c = u.geometry.coordinates[1], f = distanceToSegment(l, h, c, r);
    f < o && (o = f);
  }), convertLength(o, "degrees", r.units);
}
function distanceToSegment(e, n, r, o) {
  var l = [r[0] - n[0], r[1] - n[1]], u = [e[0] - n[0], e[1] - n[1]], h = dot$1(u, l);
  if (h <= 0)
    return calcDistance(e, n, { method: o.method, units: "degrees" });
  var c = dot$1(l, l);
  if (c <= h)
    return calcDistance(e, r, { method: o.method, units: "degrees" });
  var f = h / c, v = [n[0] + f * l[0], n[1] + f * l[1]];
  return calcDistance(e, v, { method: o.method, units: "degrees" });
}
function dot$1(e, n) {
  return e[0] * n[0] + e[1] * n[1];
}
function calcDistance(e, n, r) {
  return r.method === "planar" ? rhumbDistance(e, n, r) : distance(e, n, r);
}
var RADIUS = 6378137;
function area(e) {
  return geomReduce(e, function(n, r) {
    return n + calculateArea(r);
  }, 0);
}
function calculateArea(e) {
  var n = 0, r;
  switch (e.type) {
    case "Polygon":
      return polygonArea(e.coordinates);
    case "MultiPolygon":
      for (r = 0; r < e.coordinates.length; r++)
        n += polygonArea(e.coordinates[r]);
      return n;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function polygonArea(e) {
  var n = 0;
  if (e && e.length > 0) {
    n += Math.abs(ringArea(e[0]));
    for (var r = 1; r < e.length; r++)
      n -= Math.abs(ringArea(e[r]));
  }
  return n;
}
function ringArea(e) {
  var n, r, o, l, u, h, c, f = 0, v = e.length;
  if (v > 2) {
    for (c = 0; c < v; c++)
      c === v - 2 ? (l = v - 2, u = v - 1, h = 0) : c === v - 1 ? (l = v - 1, u = 0, h = 1) : (l = c, u = c + 1, h = c + 2), n = e[l], r = e[u], o = e[h], f += (rad(o[0]) - rad(n[0])) * Math.sin(rad(r[1]));
    f = f * RADIUS * RADIUS / 2;
  }
  return f;
}
function rad(e) {
  return e * Math.PI / 180;
}
function length(e, n) {
  return n === void 0 && (n = {}), segmentReduce(e, function(r, o) {
    var l = o.geometry.coordinates;
    return r + distance(l[0], l[1], n);
  }, 0);
}
function lineArc(e, n, r, o, l) {
  l === void 0 && (l = {});
  var u = l.steps || 64, h = convertAngleTo360$1(r), c = convertAngleTo360$1(o), f = !Array.isArray(e) && e.type === "Feature" ? e.properties : {};
  if (h === c)
    return lineString(circle(e, n, l).geometry.coordinates[0], f);
  for (var v = h, m = h < c ? c : c + 360, g = v, y = [], w = 0; g < m; )
    y.push(destination(e, n, g, l).geometry.coordinates), w++, g = v + w * 360 / u;
  return g > m && y.push(destination(e, n, m, l).geometry.coordinates), lineString(y, f);
}
function convertAngleTo360$1(e) {
  var n = e % 360;
  return n < 0 && (n += 360), n;
}
function sector(e, n, r, o, l) {
  if (l = l || {}, !isObject$2(l))
    throw new Error("options is invalid");
  var u = l.properties;
  if (!e)
    throw new Error("center is required");
  if (r == null)
    throw new Error("bearing1 is required");
  if (o == null)
    throw new Error("bearing2 is required");
  if (!n)
    throw new Error("radius is required");
  if (typeof l != "object")
    throw new Error("options must be an object");
  if (convertAngleTo360(r) === convertAngleTo360(o))
    return circle(e, n, l);
  var h = getCoords(e), c = lineArc(e, n, r, o, l), f = [[h]];
  return coordEach(c, function(v) {
    f[0].push(v);
  }), f[0].push(h), polygon(f, u);
}
function convertAngleTo360(e) {
  var n = e % 360;
  return n < 0 && (n += 360), n;
}
function rhumbBearing(e, n, r) {
  r === void 0 && (r = {});
  var o;
  r.final ? o = calculateRhumbBearing(getCoord(n), getCoord(e)) : o = calculateRhumbBearing(getCoord(e), getCoord(n));
  var l = o > 180 ? -(360 - o) : o;
  return l;
}
function calculateRhumbBearing(e, n) {
  var r = degreesToRadians(e[1]), o = degreesToRadians(n[1]), l = degreesToRadians(n[0] - e[0]);
  l > Math.PI && (l -= 2 * Math.PI), l < -Math.PI && (l += 2 * Math.PI);
  var u = Math.log(Math.tan(o / 2 + Math.PI / 4) / Math.tan(r / 2 + Math.PI / 4)), h = Math.atan2(l, u);
  return (radiansToDegrees(h) + 360) % 360;
}
function rhumbDestination(e, n, r, o) {
  o === void 0 && (o = {});
  var l = n < 0, u = convertLength(Math.abs(n), o.units, "meters");
  l && (u = -Math.abs(u));
  var h = getCoord(e), c = calculateRhumbDestination(h, u, r);
  return c[0] += c[0] - h[0] > 180 ? -360 : h[0] - c[0] > 180 ? 360 : 0, point(c, o.properties);
}
function calculateRhumbDestination(e, n, r, o) {
  o = o === void 0 ? earthRadius : Number(o);
  var l = n / o, u = e[0] * Math.PI / 180, h = degreesToRadians(e[1]), c = degreesToRadians(r), f = l * Math.cos(c), v = h + f;
  Math.abs(v) > Math.PI / 2 && (v = v > 0 ? Math.PI - v : -Math.PI - v);
  var m = Math.log(Math.tan(v / 2 + Math.PI / 4) / Math.tan(h / 2 + Math.PI / 4)), g = Math.abs(m) > 1e-11 ? f / m : Math.cos(h), y = l * Math.sin(c) / g, w = u + y;
  return [
    (w * 180 / Math.PI + 540) % 360 - 180,
    v * 180 / Math.PI
  ];
}
function transformRotate(e, n, r) {
  if (r = r || {}, !isObject$2(r))
    throw new Error("options is invalid");
  var o = r.pivot, l = r.mutate;
  if (!e)
    throw new Error("geojson is required");
  if (n == null || isNaN(n))
    throw new Error("angle is required");
  return n === 0 || (o || (o = centroid(e)), (l === !1 || l === void 0) && (e = clone$3(e)), coordEach(e, function(u) {
    var h = rhumbBearing(o, u), c = h + n, f = rhumbDistance(o, u), v = getCoords(rhumbDestination(o, f, c));
    u[0] = v[0], u[1] = v[1];
  })), e;
}
function ellipse(e, n, r, o) {
  o = o || {};
  var l = o.steps || 64, u = o.units || "kilometers", h = o.angle || 0, c = o.pivot || e, f = o.properties || e.properties || {};
  if (!e)
    throw new Error("center is required");
  if (!n)
    throw new Error("xSemiAxis is required");
  if (!r)
    throw new Error("ySemiAxis is required");
  if (!isObject$2(o))
    throw new Error("options must be an object");
  if (!isNumber$2(l))
    throw new Error("steps must be a number");
  if (!isNumber$2(h))
    throw new Error("angle must be a number");
  var v = getCoord(e);
  if (u === "degrees")
    var m = degreesToRadians(h);
  else
    n = rhumbDestination(e, n, 90, { units: u }), r = rhumbDestination(e, r, 0, { units: u }), n = getCoord(n)[0] - v[0], r = getCoord(r)[1] - v[1];
  for (var g = [], y = 0; y < l; y += 1) {
    var w = y * -360 / l, E = n * r / Math.sqrt(
      Math.pow(r, 2) + Math.pow(n, 2) * Math.pow(getTanDeg(w), 2)
    ), x = n * r / Math.sqrt(
      Math.pow(n, 2) + Math.pow(r, 2) / Math.pow(getTanDeg(w), 2)
    );
    if (w < -90 && w >= -270 && (E = -E), w < -180 && w >= -360 && (x = -x), u === "degrees") {
      var D = E * Math.cos(m) + x * Math.sin(m), F = x * Math.cos(m) - E * Math.sin(m);
      E = D, x = F;
    }
    g.push([E + v[0], x + v[1]]);
  }
  return g.push(g[0]), u === "degrees" ? polygon([g], f) : transformRotate(polygon([g], f), h, {
    pivot: c
  });
}
function getTanDeg(e) {
  var n = e * Math.PI / 180;
  return Math.tan(n);
}
function Clone(e) {
  return Object.assign({}, e);
}
function defined(e) {
  return e != null;
}
function getTextWidth(e, n) {
  n === " " && (n = "_");
  var r = 1;
  e.fontSize < 12 && (r = e.fontSize / 12);
  let o = document.createElement("span");
  document.body.appendChild(o), o.style.width = "auto", o.style.height = "auto", e.fontSize && (o.style.fontSize = new String(e.fontSize) + "px"), e.fontFamily && (o.style.fontFamily = e.fontFamily), e.fontWeight && (o.style.fontWeight = e.fontWeight), o.style.position = "absolute", o.style.visibility = "hidden", o.style.display = "inline-block", o.innerHTML = n;
  var l = o.clientWidth, u = n.length;
  return e.fontSpace === void 0 && e.fontPercent === void 0 || (e.fontSpace !== 0 && e.fontPercent !== 100 && e.fontSpace !== void 0 || e.fontPercent !== void 0 ? l = e.fontPercent / 100 * l + e.fontSpace * (e.fontPercent / 100) * (u - 1) : e.fontSpace === 0 && e.fontPercent !== 100 && e.fontPercent !== void 0 ? l = e.fontPercent / 100 * l : e.fontSpace !== 0 && e.fontPercent === 100 && e.fontSpace !== void 0 && (l += e.fontSpace * (u - 1))), document.body.removeChild(o), l * r;
}
function rotateAngle(e, n, r) {
  let o = n, l = Math.cos(o), u = Math.sin(o), h = r.x - e.x, c = r.y - e.y;
  return r.x = h * l - c * u + e.x, r.y = h * u + c * l + e.y, r;
}
function equalFuzzy(e, n) {
  return Math.abs(e - n) <= 1e-18;
}
function midPoint(e, n) {
  var r = point([e.getLon(), e.getLat()]), o = point([n.getLon(), n.getLat()]), l = midpoint(r, o), u = getCoord(l);
  return new GeoPoint3D(u[0], u[1], (e.getAlt() + n.getAlt()) * 0.5);
}
class GeoPoint3D extends Point$1 {
  constructor(n = 0, r = 0, o = 0) {
    super(n, r, o), this._className = "GeoPoint3D";
  }
  getLat() {
    return this._y;
  }
  getLon() {
    return this._x;
  }
  getAlt() {
    return this._z;
  }
  equal(n) {
    return defined(n) ? !!(numberEqual(this._x, n.getLon()) && numberEqual(this._y, n.getLat()) && numberEqual(this._z, n.getAlt())) : !1;
  }
}
class Layer extends BaseObject {
  constructor() {
    super(), this._isShow = !0, this._className = "Layer", this._layerType = LayerType.default, this._layerName = "";
  }
  getLayerType() {
    return this._layerType;
  }
  getLayerID() {
    return this._id;
  }
  isShow() {
    return this._isShow;
  }
  hide() {
    this._isShow = !1;
  }
  show() {
    this._isShow = !0;
  }
}
class ImageryLayer extends Layer {
  constructor(n) {
    super(), defined(n) && (this._layerName = n.layerName);
  }
  hide() {
    if (this._isShow)
      try {
        this._layer.setOpacity(0), this._isShow = !1;
      } catch (n) {
        console.log(n);
      }
  }
  show() {
    try {
      if (this._isShow)
        return;
      this._layer.setOpacity(1), this._isShow = !0;
    } catch (n) {
      console.log(n);
    }
  }
  setView(n, r) {
    this._center = n, this._zoom = r;
  }
  /**
   * @作者: Wangjianbo
   * @时间: 2024/04/15 11:05:29
   * @描述:定位到设置的中线点和层级
   * @参数：
   */
  reset() {
    this._layer && this._map && this._map.setView(this._center, this._zoom);
  }
  //地图层级
}
class WebMapServiceImageryLayer extends ImageryLayer {
  constructor(n) {
    super(n), this._options = n, this._layerType = LayerType.WMS, this._className = "WebMapServiceImageryLayer", this._layer = null;
  }
}
class WebMapTileServiceImageryLayer extends ImageryLayer {
  constructor(n) {
    super(n), this._options = n, this._layerType = LayerType.WMTS, this._layer = null, this._className = "WebMapTileServiceImageryLayer";
  }
}
var EPSGType = /* @__PURE__ */ ((e) => {
})();
class Options extends BaseObject {
  constructor() {
    super(), this._className = "Options";
  }
}
class LayerOptions extends Options {
  //图层命名 默认为空
  constructor(n = "") {
    super(), this.layerName = n;
  }
}
class FeatureLayerOptions extends LayerOptions {
  constructor(n = "") {
    super(n);
  }
}
class ImageryLayerOptions extends LayerOptions {
  //地图范围 [西,南,东,北]
  constructor(n, r = null) {
    super(n), defined(r) || (r = new Object()), this.crs = r.hasOwnProperty("crs") ? r.crs : "EPSG:3857", this.transparent = r.hasOwnProperty("transparent") ? r.transparent : !0, this.url = r.hasOwnProperty("url") ? r.url : "", this.format = r.hasOwnProperty("format") ? r.format : "image/png", this.maxZoom = r.hasOwnProperty("maxZoom") ? r.maxZoom : 19, this.style = r.hasOwnProperty("style") ? r.style : "", this._className = "ImageryLayerOptions";
  }
}
class XYZOptions extends ImageryLayerOptions {
  constructor(n, r = null) {
    super(n, r);
  }
}
class WMSOptions extends ImageryLayerOptions {
  //地图图层名称
  constructor(n, r = null) {
    super(n, r), defined(r) || (r = new Object()), this.layers = r.hasOwnProperty("layers") ? r.layers : "", this.layer = r.hasOwnProperty("layer") ? r.layers : "", this._className = "WMSOptions";
  }
}
class WMTSOptions extends ImageryLayerOptions {
  //地图图层名称
  constructor(n, r = null) {
    super(n, r), defined(r) || (r = new Object()), this.layer = r.hasOwnProperty("layer") ? r.layer : "", this._className = "WMTSOptions";
  }
}
class MapOptions extends BaseObject {
  //地图最大层级
  constructor(n = null) {
    super(), defined(n) || (n = new Object()), this.crs = n.hasOwnProperty("crs") ? n.crs : "EPSG:3857", this.zoom = n.hasOwnProperty("zoom") ? n.zoom : 5, this.center = n.hasOwnProperty("center") ? n.center : new GeoPoint2D(109, 34), this.layerPanel = n.hasOwnProperty("layerPanel") ? n.layerPanel : !1, this.navPanel = n.hasOwnProperty("navPanel") ? n.navPanel : !1, this.plotPanel = n.hasOwnProperty("plotPanel") ? n.plotPanel : !1, this.elementPanel = n.hasOwnProperty("elementPanel") ? n.elementPanel : !1, this.toolPanel = n.hasOwnProperty("toolPanel") ? n.toolPanel : !1, this.coordinate = n.hasOwnProperty("coordinate") ? n.coordinate : !1, this.squareRid = n.hasOwnProperty("squareRid") ? n.squareRid : !1, this.assist = n.hasOwnProperty("assist") ? n.assist : !1, this.minZoom = n.hasOwnProperty("minZoom") ? n.minZoom : 1, this.maxZoom = n.hasOwnProperty("maxZoom") ? n.maxZoom : 19;
  }
}
class FeatureStyle extends BaseObject {
  //对象名称
  constructor(n = null) {
    super(), this._className = "FeatureStyle", defined(n) || (n = new Object()), this.lineColor = n.hasOwnProperty("lineColor") ? n.lineColor : "#FF0000", this.lineWidth = n.hasOwnProperty("lineWidth") ? n.lineWidth : 3, this.lineOpacity = n.hasOwnProperty("lineOpacity") ? n.lineOpacity : 1, this.fillColor = n.hasOwnProperty("fillColor") ? n.fillColor : "#FF0000", this.fillOpacity = n.hasOwnProperty("fillOpacity") ? n.fillOpacity : 0.2, this.plotPntURL = n.hasOwnProperty("plotpntURL") ? n.plotPntURL : "", this.text = n.hasOwnProperty("text") ? n.text : "", this.fontSize = n.hasOwnProperty("fontSize") ? n.fontSize : 16, this.name = n.hasOwnProperty("plotpntURL") ? n.name : "";
  }
}
class DemLayer extends BaseObject {
  constructor(n = null) {
    super(), this._className = "FeatureStyle", defined(n) || (n = new Object()), this.layers = n.hasOwnProperty("layers") ? n.layers : "", this.layerBonds = n.hasOwnProperty("layerBonds") ? n.layerBonds : [0, 0, 0, 0], this.layerHeight = n.hasOwnProperty("layerHeight") ? n.layerHeight : 0, this.layerWidth = n.hasOwnProperty("layerWidth") ? n.layerWidth : 0, this.url = n.hasOwnProperty("url") ? n.url : "";
  }
}
const Defineds = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DemLayer,
  EPSGType,
  FeatureLayerOptions,
  FeatureStyle,
  ImageryLayerOptions,
  LayerOptions,
  MapOptions,
  Options,
  WMSOptions,
  WMTSOptions,
  XYZOptions
}, Symbol.toStringTag, { value: "Module" }));
var leafletSrc = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
(function(e, n) {
  (function(r, o) {
    o(n);
  })(commonjsGlobal, function(r) {
    var o = "1.9.4";
    function l(d) {
      var _, C, B, q;
      for (C = 1, B = arguments.length; C < B; C++) {
        q = arguments[C];
        for (_ in q)
          d[_] = q[_];
      }
      return d;
    }
    var u = Object.create || /* @__PURE__ */ function() {
      function d() {
      }
      return function(_) {
        return d.prototype = _, new d();
      };
    }();
    function h(d, _) {
      var C = Array.prototype.slice;
      if (d.bind)
        return d.bind.apply(d, C.call(arguments, 1));
      var B = C.call(arguments, 2);
      return function() {
        return d.apply(_, B.length ? B.concat(C.call(arguments)) : arguments);
      };
    }
    var c = 0;
    function f(d) {
      return "_leaflet_id" in d || (d._leaflet_id = ++c), d._leaflet_id;
    }
    function v(d, _, C) {
      var B, q, Q, dt;
      return dt = function() {
        B = !1, q && (Q.apply(C, q), q = !1);
      }, Q = function() {
        B ? q = arguments : (d.apply(C, arguments), setTimeout(dt, _), B = !0);
      }, Q;
    }
    function m(d, _, C) {
      var B = _[1], q = _[0], Q = B - q;
      return d === B && C ? d : ((d - q) % Q + Q) % Q + q;
    }
    function g() {
      return !1;
    }
    function y(d, _) {
      if (_ === !1)
        return d;
      var C = Math.pow(10, _ === void 0 ? 6 : _);
      return Math.round(d * C) / C;
    }
    function w(d) {
      return d.trim ? d.trim() : d.replace(/^\s+|\s+$/g, "");
    }
    function E(d) {
      return w(d).split(/\s+/);
    }
    function x(d, _) {
      Object.prototype.hasOwnProperty.call(d, "options") || (d.options = d.options ? u(d.options) : {});
      for (var C in _)
        d.options[C] = _[C];
      return d.options;
    }
    function D(d, _, C) {
      var B = [];
      for (var q in d)
        B.push(encodeURIComponent(C ? q.toUpperCase() : q) + "=" + encodeURIComponent(d[q]));
      return (!_ || _.indexOf("?") === -1 ? "?" : "&") + B.join("&");
    }
    var F = /\{ *([\w_ -]+) *\}/g;
    function k(d, _) {
      return d.replace(F, function(C, B) {
        var q = _[B];
        if (q === void 0)
          throw new Error("No value provided for variable " + C);
        return typeof q == "function" && (q = q(_)), q;
      });
    }
    var N = Array.isArray || function(d) {
      return Object.prototype.toString.call(d) === "[object Array]";
    };
    function H(d, _) {
      for (var C = 0; C < d.length; C++)
        if (d[C] === _)
          return C;
      return -1;
    }
    var R = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
    function j(d) {
      return window["webkit" + d] || window["moz" + d] || window["ms" + d];
    }
    var S = 0;
    function tt(d) {
      var _ = +/* @__PURE__ */ new Date(), C = Math.max(0, 16 - (_ - S));
      return S = _ + C, window.setTimeout(d, C);
    }
    var nt = window.requestAnimationFrame || j("RequestAnimationFrame") || tt, ft = window.cancelAnimationFrame || j("CancelAnimationFrame") || j("CancelRequestAnimationFrame") || function(d) {
      window.clearTimeout(d);
    };
    function pt(d, _, C) {
      if (C && nt === tt)
        d.call(_);
      else
        return nt.call(window, h(d, _));
    }
    function ct(d) {
      d && ft.call(window, d);
    }
    var Nt = {
      __proto__: null,
      extend: l,
      create: u,
      bind: h,
      get lastId() {
        return c;
      },
      stamp: f,
      throttle: v,
      wrapNum: m,
      falseFn: g,
      formatNum: y,
      trim: w,
      splitWords: E,
      setOptions: x,
      getParamString: D,
      template: k,
      isArray: N,
      indexOf: H,
      emptyImageUrl: R,
      requestFn: nt,
      cancelFn: ft,
      requestAnimFrame: pt,
      cancelAnimFrame: ct
    };
    function kt() {
    }
    kt.extend = function(d) {
      var _ = function() {
        x(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
      }, C = _.__super__ = this.prototype, B = u(C);
      B.constructor = _, _.prototype = B;
      for (var q in this)
        Object.prototype.hasOwnProperty.call(this, q) && q !== "prototype" && q !== "__super__" && (_[q] = this[q]);
      return d.statics && l(_, d.statics), d.includes && (Rt(d.includes), l.apply(null, [B].concat(d.includes))), l(B, d), delete B.statics, delete B.includes, B.options && (B.options = C.options ? u(C.options) : {}, l(B.options, d.options)), B._initHooks = [], B.callInitHooks = function() {
        if (!this._initHooksCalled) {
          C.callInitHooks && C.callInitHooks.call(this), this._initHooksCalled = !0;
          for (var Q = 0, dt = B._initHooks.length; Q < dt; Q++)
            B._initHooks[Q].call(this);
        }
      }, _;
    }, kt.include = function(d) {
      var _ = this.prototype.options;
      return l(this.prototype, d), d.options && (this.prototype.options = _, this.mergeOptions(d.options)), this;
    }, kt.mergeOptions = function(d) {
      return l(this.prototype.options, d), this;
    }, kt.addInitHook = function(d) {
      var _ = Array.prototype.slice.call(arguments, 1), C = typeof d == "function" ? d : function() {
        this[d].apply(this, _);
      };
      return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(C), this;
    };
    function Rt(d) {
      if (!(typeof L > "u" || !L || !L.Mixin)) {
        d = N(d) ? d : [d];
        for (var _ = 0; _ < d.length; _++)
          d[_] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
      }
    }
    var Mt = {
      /* @method on(type: String, fn: Function, context?: Object): this
       * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
       *
       * @alternative
       * @method on(eventMap: Object): this
       * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
       */
      on: function(d, _, C) {
        if (typeof d == "object")
          for (var B in d)
            this._on(B, d[B], _);
        else {
          d = E(d);
          for (var q = 0, Q = d.length; q < Q; q++)
            this._on(d[q], _, C);
        }
        return this;
      },
      /* @method off(type: String, fn?: Function, context?: Object): this
       * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
       *
       * @alternative
       * @method off(eventMap: Object): this
       * Removes a set of type/listener pairs.
       *
       * @alternative
       * @method off: this
       * Removes all listeners to all events on the object. This includes implicitly attached events.
       */
      off: function(d, _, C) {
        if (!arguments.length)
          delete this._events;
        else if (typeof d == "object")
          for (var B in d)
            this._off(B, d[B], _);
        else {
          d = E(d);
          for (var q = arguments.length === 1, Q = 0, dt = d.length; Q < dt; Q++)
            q ? this._off(d[Q]) : this._off(d[Q], _, C);
        }
        return this;
      },
      // attach listener (without syntactic sugar now)
      _on: function(d, _, C, B) {
        if (typeof _ != "function") {
          console.warn("wrong listener type: " + typeof _);
          return;
        }
        if (this._listens(d, _, C) === !1) {
          C === this && (C = void 0);
          var q = { fn: _, ctx: C };
          B && (q.once = !0), this._events = this._events || {}, this._events[d] = this._events[d] || [], this._events[d].push(q);
        }
      },
      _off: function(d, _, C) {
        var B, q, Q;
        if (this._events && (B = this._events[d], !!B)) {
          if (arguments.length === 1) {
            if (this._firingCount)
              for (q = 0, Q = B.length; q < Q; q++)
                B[q].fn = g;
            delete this._events[d];
            return;
          }
          if (typeof _ != "function") {
            console.warn("wrong listener type: " + typeof _);
            return;
          }
          var dt = this._listens(d, _, C);
          if (dt !== !1) {
            var Dt = B[dt];
            this._firingCount && (Dt.fn = g, this._events[d] = B = B.slice()), B.splice(dt, 1);
          }
        }
      },
      // @method fire(type: String, data?: Object, propagate?: Boolean): this
      // Fires an event of the specified type. You can optionally provide a data
      // object — the first argument of the listener function will contain its
      // properties. The event can optionally be propagated to event parents.
      fire: function(d, _, C) {
        if (!this.listens(d, C))
          return this;
        var B = l({}, _, {
          type: d,
          target: this,
          sourceTarget: _ && _.sourceTarget || this
        });
        if (this._events) {
          var q = this._events[d];
          if (q) {
            this._firingCount = this._firingCount + 1 || 1;
            for (var Q = 0, dt = q.length; Q < dt; Q++) {
              var Dt = q[Q], Tt = Dt.fn;
              Dt.once && this.off(d, Tt, Dt.ctx), Tt.call(Dt.ctx || this, B);
            }
            this._firingCount--;
          }
        }
        return C && this._propagateEvent(B), this;
      },
      // @method listens(type: String, propagate?: Boolean): Boolean
      // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
      // Returns `true` if a particular event type has any listeners attached to it.
      // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
      listens: function(d, _, C, B) {
        typeof d != "string" && console.warn('"string" type argument expected');
        var q = _;
        typeof _ != "function" && (B = !!_, q = void 0, C = void 0);
        var Q = this._events && this._events[d];
        if (Q && Q.length && this._listens(d, q, C) !== !1)
          return !0;
        if (B) {
          for (var dt in this._eventParents)
            if (this._eventParents[dt].listens(d, _, C, B))
              return !0;
        }
        return !1;
      },
      // returns the index (number) or false
      _listens: function(d, _, C) {
        if (!this._events)
          return !1;
        var B = this._events[d] || [];
        if (!_)
          return !!B.length;
        C === this && (C = void 0);
        for (var q = 0, Q = B.length; q < Q; q++)
          if (B[q].fn === _ && B[q].ctx === C)
            return q;
        return !1;
      },
      // @method once(…): this
      // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
      once: function(d, _, C) {
        if (typeof d == "object")
          for (var B in d)
            this._on(B, d[B], _, !0);
        else {
          d = E(d);
          for (var q = 0, Q = d.length; q < Q; q++)
            this._on(d[q], _, C, !0);
        }
        return this;
      },
      // @method addEventParent(obj: Evented): this
      // Adds an event parent - an `Evented` that will receive propagated events
      addEventParent: function(d) {
        return this._eventParents = this._eventParents || {}, this._eventParents[f(d)] = d, this;
      },
      // @method removeEventParent(obj: Evented): this
      // Removes an event parent, so it will stop receiving propagated events
      removeEventParent: function(d) {
        return this._eventParents && delete this._eventParents[f(d)], this;
      },
      _propagateEvent: function(d) {
        for (var _ in this._eventParents)
          this._eventParents[_].fire(d.type, l({
            layer: d.target,
            propagatedFrom: d.target
          }, d), !0);
      }
    };
    Mt.addEventListener = Mt.on, Mt.removeEventListener = Mt.clearAllEventListeners = Mt.off, Mt.addOneTimeEventListener = Mt.once, Mt.fireEvent = Mt.fire, Mt.hasEventListeners = Mt.listens;
    var G = kt.extend(Mt);
    function Y(d, _, C) {
      this.x = C ? Math.round(d) : d, this.y = C ? Math.round(_) : _;
    }
    var it = Math.trunc || function(d) {
      return d > 0 ? Math.floor(d) : Math.ceil(d);
    };
    Y.prototype = {
      // @method clone(): Point
      // Returns a copy of the current point.
      clone: function() {
        return new Y(this.x, this.y);
      },
      // @method add(otherPoint: Point): Point
      // Returns the result of addition of the current and the given points.
      add: function(d) {
        return this.clone()._add(rt(d));
      },
      _add: function(d) {
        return this.x += d.x, this.y += d.y, this;
      },
      // @method subtract(otherPoint: Point): Point
      // Returns the result of subtraction of the given point from the current.
      subtract: function(d) {
        return this.clone()._subtract(rt(d));
      },
      _subtract: function(d) {
        return this.x -= d.x, this.y -= d.y, this;
      },
      // @method divideBy(num: Number): Point
      // Returns the result of division of the current point by the given number.
      divideBy: function(d) {
        return this.clone()._divideBy(d);
      },
      _divideBy: function(d) {
        return this.x /= d, this.y /= d, this;
      },
      // @method multiplyBy(num: Number): Point
      // Returns the result of multiplication of the current point by the given number.
      multiplyBy: function(d) {
        return this.clone()._multiplyBy(d);
      },
      _multiplyBy: function(d) {
        return this.x *= d, this.y *= d, this;
      },
      // @method scaleBy(scale: Point): Point
      // Multiply each coordinate of the current point by each coordinate of
      // `scale`. In linear algebra terms, multiply the point by the
      // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
      // defined by `scale`.
      scaleBy: function(d) {
        return new Y(this.x * d.x, this.y * d.y);
      },
      // @method unscaleBy(scale: Point): Point
      // Inverse of `scaleBy`. Divide each coordinate of the current point by
      // each coordinate of `scale`.
      unscaleBy: function(d) {
        return new Y(this.x / d.x, this.y / d.y);
      },
      // @method round(): Point
      // Returns a copy of the current point with rounded coordinates.
      round: function() {
        return this.clone()._round();
      },
      _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      },
      // @method floor(): Point
      // Returns a copy of the current point with floored coordinates (rounded down).
      floor: function() {
        return this.clone()._floor();
      },
      _floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
      },
      // @method ceil(): Point
      // Returns a copy of the current point with ceiled coordinates (rounded up).
      ceil: function() {
        return this.clone()._ceil();
      },
      _ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
      },
      // @method trunc(): Point
      // Returns a copy of the current point with truncated coordinates (rounded towards zero).
      trunc: function() {
        return this.clone()._trunc();
      },
      _trunc: function() {
        return this.x = it(this.x), this.y = it(this.y), this;
      },
      // @method distanceTo(otherPoint: Point): Number
      // Returns the cartesian distance between the current and the given points.
      distanceTo: function(d) {
        d = rt(d);
        var _ = d.x - this.x, C = d.y - this.y;
        return Math.sqrt(_ * _ + C * C);
      },
      // @method equals(otherPoint: Point): Boolean
      // Returns `true` if the given point has the same coordinates.
      equals: function(d) {
        return d = rt(d), d.x === this.x && d.y === this.y;
      },
      // @method contains(otherPoint: Point): Boolean
      // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
      contains: function(d) {
        return d = rt(d), Math.abs(d.x) <= Math.abs(this.x) && Math.abs(d.y) <= Math.abs(this.y);
      },
      // @method toString(): String
      // Returns a string representation of the point for debugging purposes.
      toString: function() {
        return "Point(" + y(this.x) + ", " + y(this.y) + ")";
      }
    };
    function rt(d, _, C) {
      return d instanceof Y ? d : N(d) ? new Y(d[0], d[1]) : d == null ? d : typeof d == "object" && "x" in d && "y" in d ? new Y(d.x, d.y) : new Y(d, _, C);
    }
    function ht(d, _) {
      if (d)
        for (var C = _ ? [d, _] : d, B = 0, q = C.length; B < q; B++)
          this.extend(C[B]);
    }
    ht.prototype = {
      // @method extend(point: Point): this
      // Extends the bounds to contain the given point.
      // @alternative
      // @method extend(otherBounds: Bounds): this
      // Extend the bounds to contain the given bounds
      extend: function(d) {
        var _, C;
        if (!d)
          return this;
        if (d instanceof Y || typeof d[0] == "number" || "x" in d)
          _ = C = rt(d);
        else if (d = bt(d), _ = d.min, C = d.max, !_ || !C)
          return this;
        return !this.min && !this.max ? (this.min = _.clone(), this.max = C.clone()) : (this.min.x = Math.min(_.x, this.min.x), this.max.x = Math.max(C.x, this.max.x), this.min.y = Math.min(_.y, this.min.y), this.max.y = Math.max(C.y, this.max.y)), this;
      },
      // @method getCenter(round?: Boolean): Point
      // Returns the center point of the bounds.
      getCenter: function(d) {
        return rt(
          (this.min.x + this.max.x) / 2,
          (this.min.y + this.max.y) / 2,
          d
        );
      },
      // @method getBottomLeft(): Point
      // Returns the bottom-left point of the bounds.
      getBottomLeft: function() {
        return rt(this.min.x, this.max.y);
      },
      // @method getTopRight(): Point
      // Returns the top-right point of the bounds.
      getTopRight: function() {
        return rt(this.max.x, this.min.y);
      },
      // @method getTopLeft(): Point
      // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
      getTopLeft: function() {
        return this.min;
      },
      // @method getBottomRight(): Point
      // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
      getBottomRight: function() {
        return this.max;
      },
      // @method getSize(): Point
      // Returns the size of the given bounds
      getSize: function() {
        return this.max.subtract(this.min);
      },
      // @method contains(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle contains the given one.
      // @alternative
      // @method contains(point: Point): Boolean
      // Returns `true` if the rectangle contains the given point.
      contains: function(d) {
        var _, C;
        return typeof d[0] == "number" || d instanceof Y ? d = rt(d) : d = bt(d), d instanceof ht ? (_ = d.min, C = d.max) : _ = C = d, _.x >= this.min.x && C.x <= this.max.x && _.y >= this.min.y && C.y <= this.max.y;
      },
      // @method intersects(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle intersects the given bounds. Two bounds
      // intersect if they have at least one point in common.
      intersects: function(d) {
        d = bt(d);
        var _ = this.min, C = this.max, B = d.min, q = d.max, Q = q.x >= _.x && B.x <= C.x, dt = q.y >= _.y && B.y <= C.y;
        return Q && dt;
      },
      // @method overlaps(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle overlaps the given bounds. Two bounds
      // overlap if their intersection is an area.
      overlaps: function(d) {
        d = bt(d);
        var _ = this.min, C = this.max, B = d.min, q = d.max, Q = q.x > _.x && B.x < C.x, dt = q.y > _.y && B.y < C.y;
        return Q && dt;
      },
      // @method isValid(): Boolean
      // Returns `true` if the bounds are properly initialized.
      isValid: function() {
        return !!(this.min && this.max);
      },
      // @method pad(bufferRatio: Number): Bounds
      // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
      // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
      // Negative values will retract the bounds.
      pad: function(d) {
        var _ = this.min, C = this.max, B = Math.abs(_.x - C.x) * d, q = Math.abs(_.y - C.y) * d;
        return bt(
          rt(_.x - B, _.y - q),
          rt(C.x + B, C.y + q)
        );
      },
      // @method equals(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle is equivalent to the given bounds.
      equals: function(d) {
        return d ? (d = bt(d), this.min.equals(d.getTopLeft()) && this.max.equals(d.getBottomRight())) : !1;
      }
    };
    function bt(d, _) {
      return !d || d instanceof ht ? d : new ht(d, _);
    }
    function yt(d, _) {
      if (d)
        for (var C = _ ? [d, _] : d, B = 0, q = C.length; B < q; B++)
          this.extend(C[B]);
    }
    yt.prototype = {
      // @method extend(latlng: LatLng): this
      // Extend the bounds to contain the given point
      // @alternative
      // @method extend(otherBounds: LatLngBounds): this
      // Extend the bounds to contain the given bounds
      extend: function(d) {
        var _ = this._southWest, C = this._northEast, B, q;
        if (d instanceof Ft)
          B = d, q = d;
        else if (d instanceof yt) {
          if (B = d._southWest, q = d._northEast, !B || !q)
            return this;
        } else
          return d ? this.extend(zt(d) || St(d)) : this;
        return !_ && !C ? (this._southWest = new Ft(B.lat, B.lng), this._northEast = new Ft(q.lat, q.lng)) : (_.lat = Math.min(B.lat, _.lat), _.lng = Math.min(B.lng, _.lng), C.lat = Math.max(q.lat, C.lat), C.lng = Math.max(q.lng, C.lng)), this;
      },
      // @method pad(bufferRatio: Number): LatLngBounds
      // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
      // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
      // Negative values will retract the bounds.
      pad: function(d) {
        var _ = this._southWest, C = this._northEast, B = Math.abs(_.lat - C.lat) * d, q = Math.abs(_.lng - C.lng) * d;
        return new yt(
          new Ft(_.lat - B, _.lng - q),
          new Ft(C.lat + B, C.lng + q)
        );
      },
      // @method getCenter(): LatLng
      // Returns the center point of the bounds.
      getCenter: function() {
        return new Ft(
          (this._southWest.lat + this._northEast.lat) / 2,
          (this._southWest.lng + this._northEast.lng) / 2
        );
      },
      // @method getSouthWest(): LatLng
      // Returns the south-west point of the bounds.
      getSouthWest: function() {
        return this._southWest;
      },
      // @method getNorthEast(): LatLng
      // Returns the north-east point of the bounds.
      getNorthEast: function() {
        return this._northEast;
      },
      // @method getNorthWest(): LatLng
      // Returns the north-west point of the bounds.
      getNorthWest: function() {
        return new Ft(this.getNorth(), this.getWest());
      },
      // @method getSouthEast(): LatLng
      // Returns the south-east point of the bounds.
      getSouthEast: function() {
        return new Ft(this.getSouth(), this.getEast());
      },
      // @method getWest(): Number
      // Returns the west longitude of the bounds
      getWest: function() {
        return this._southWest.lng;
      },
      // @method getSouth(): Number
      // Returns the south latitude of the bounds
      getSouth: function() {
        return this._southWest.lat;
      },
      // @method getEast(): Number
      // Returns the east longitude of the bounds
      getEast: function() {
        return this._northEast.lng;
      },
      // @method getNorth(): Number
      // Returns the north latitude of the bounds
      getNorth: function() {
        return this._northEast.lat;
      },
      // @method contains(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle contains the given one.
      // @alternative
      // @method contains (latlng: LatLng): Boolean
      // Returns `true` if the rectangle contains the given point.
      contains: function(d) {
        typeof d[0] == "number" || d instanceof Ft || "lat" in d ? d = zt(d) : d = St(d);
        var _ = this._southWest, C = this._northEast, B, q;
        return d instanceof yt ? (B = d.getSouthWest(), q = d.getNorthEast()) : B = q = d, B.lat >= _.lat && q.lat <= C.lat && B.lng >= _.lng && q.lng <= C.lng;
      },
      // @method intersects(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
      intersects: function(d) {
        d = St(d);
        var _ = this._southWest, C = this._northEast, B = d.getSouthWest(), q = d.getNorthEast(), Q = q.lat >= _.lat && B.lat <= C.lat, dt = q.lng >= _.lng && B.lng <= C.lng;
        return Q && dt;
      },
      // @method overlaps(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
      overlaps: function(d) {
        d = St(d);
        var _ = this._southWest, C = this._northEast, B = d.getSouthWest(), q = d.getNorthEast(), Q = q.lat > _.lat && B.lat < C.lat, dt = q.lng > _.lng && B.lng < C.lng;
        return Q && dt;
      },
      // @method toBBoxString(): String
      // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
      toBBoxString: function() {
        return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
      },
      // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
      // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
      equals: function(d, _) {
        return d ? (d = St(d), this._southWest.equals(d.getSouthWest(), _) && this._northEast.equals(d.getNorthEast(), _)) : !1;
      },
      // @method isValid(): Boolean
      // Returns `true` if the bounds are properly initialized.
      isValid: function() {
        return !!(this._southWest && this._northEast);
      }
    };
    function St(d, _) {
      return d instanceof yt ? d : new yt(d, _);
    }
    function Ft(d, _, C) {
      if (isNaN(d) || isNaN(_))
        throw new Error("Invalid LatLng object: (" + d + ", " + _ + ")");
      this.lat = +d, this.lng = +_, C !== void 0 && (this.alt = +C);
    }
    Ft.prototype = {
      // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
      // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
      equals: function(d, _) {
        if (!d)
          return !1;
        d = zt(d);
        var C = Math.max(
          Math.abs(this.lat - d.lat),
          Math.abs(this.lng - d.lng)
        );
        return C <= (_ === void 0 ? 1e-9 : _);
      },
      // @method toString(): String
      // Returns a string representation of the point (for debugging purposes).
      toString: function(d) {
        return "LatLng(" + y(this.lat, d) + ", " + y(this.lng, d) + ")";
      },
      // @method distanceTo(otherLatLng: LatLng): Number
      // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
      distanceTo: function(d) {
        return J.distance(this, zt(d));
      },
      // @method wrap(): LatLng
      // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
      wrap: function() {
        return J.wrapLatLng(this);
      },
      // @method toBounds(sizeInMeters: Number): LatLngBounds
      // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
      toBounds: function(d) {
        var _ = 180 * d / 40075017, C = _ / Math.cos(Math.PI / 180 * this.lat);
        return St(
          [this.lat - _, this.lng - C],
          [this.lat + _, this.lng + C]
        );
      },
      clone: function() {
        return new Ft(this.lat, this.lng, this.alt);
      }
    };
    function zt(d, _, C) {
      return d instanceof Ft ? d : N(d) && typeof d[0] != "object" ? d.length === 3 ? new Ft(d[0], d[1], d[2]) : d.length === 2 ? new Ft(d[0], d[1]) : null : d == null ? d : typeof d == "object" && "lat" in d ? new Ft(d.lat, "lng" in d ? d.lng : d.lon, d.alt) : _ === void 0 ? null : new Ft(d, _, C);
    }
    var Zt = {
      // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
      // Projects geographical coordinates into pixel coordinates for a given zoom.
      latLngToPoint: function(d, _) {
        var C = this.projection.project(d), B = this.scale(_);
        return this.transformation._transform(C, B);
      },
      // @method pointToLatLng(point: Point, zoom: Number): LatLng
      // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
      // zoom into geographical coordinates.
      pointToLatLng: function(d, _) {
        var C = this.scale(_), B = this.transformation.untransform(d, C);
        return this.projection.unproject(B);
      },
      // @method project(latlng: LatLng): Point
      // Projects geographical coordinates into coordinates in units accepted for
      // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
      project: function(d) {
        return this.projection.project(d);
      },
      // @method unproject(point: Point): LatLng
      // Given a projected coordinate returns the corresponding LatLng.
      // The inverse of `project`.
      unproject: function(d) {
        return this.projection.unproject(d);
      },
      // @method scale(zoom: Number): Number
      // Returns the scale used when transforming projected coordinates into
      // pixel coordinates for a particular zoom. For example, it returns
      // `256 * 2^zoom` for Mercator-based CRS.
      scale: function(d) {
        return 256 * Math.pow(2, d);
      },
      // @method zoom(scale: Number): Number
      // Inverse of `scale()`, returns the zoom level corresponding to a scale
      // factor of `scale`.
      zoom: function(d) {
        return Math.log(d / 256) / Math.LN2;
      },
      // @method getProjectedBounds(zoom: Number): Bounds
      // Returns the projection's bounds scaled and transformed for the provided `zoom`.
      getProjectedBounds: function(d) {
        if (this.infinite)
          return null;
        var _ = this.projection.bounds, C = this.scale(d), B = this.transformation.transform(_.min, C), q = this.transformation.transform(_.max, C);
        return new ht(B, q);
      },
      // @method distance(latlng1: LatLng, latlng2: LatLng): Number
      // Returns the distance between two geographical coordinates.
      // @property code: String
      // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
      //
      // @property wrapLng: Number[]
      // An array of two numbers defining whether the longitude (horizontal) coordinate
      // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
      // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
      //
      // @property wrapLat: Number[]
      // Like `wrapLng`, but for the latitude (vertical) axis.
      // wrapLng: [min, max],
      // wrapLat: [min, max],
      // @property infinite: Boolean
      // If true, the coordinate space will be unbounded (infinite in both axes)
      infinite: !1,
      // @method wrapLatLng(latlng: LatLng): LatLng
      // Returns a `LatLng` where lat and lng has been wrapped according to the
      // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
      wrapLatLng: function(d) {
        var _ = this.wrapLng ? m(d.lng, this.wrapLng, !0) : d.lng, C = this.wrapLat ? m(d.lat, this.wrapLat, !0) : d.lat, B = d.alt;
        return new Ft(C, _, B);
      },
      // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
      // Returns a `LatLngBounds` with the same size as the given one, ensuring
      // that its center is within the CRS's bounds.
      // Only accepts actual `L.LatLngBounds` instances, not arrays.
      wrapLatLngBounds: function(d) {
        var _ = d.getCenter(), C = this.wrapLatLng(_), B = _.lat - C.lat, q = _.lng - C.lng;
        if (B === 0 && q === 0)
          return d;
        var Q = d.getSouthWest(), dt = d.getNorthEast(), Dt = new Ft(Q.lat - B, Q.lng - q), Tt = new Ft(dt.lat - B, dt.lng - q);
        return new yt(Dt, Tt);
      }
    }, J = l({}, Zt, {
      wrapLng: [-180, 180],
      // Mean Earth Radius, as recommended for use by
      // the International Union of Geodesy and Geophysics,
      // see https://rosettacode.org/wiki/Haversine_formula
      R: 6371e3,
      // distance between two geographical points using spherical law of cosines approximation
      distance: function(d, _) {
        var C = Math.PI / 180, B = d.lat * C, q = _.lat * C, Q = Math.sin((_.lat - d.lat) * C / 2), dt = Math.sin((_.lng - d.lng) * C / 2), Dt = Q * Q + Math.cos(B) * Math.cos(q) * dt * dt, Tt = 2 * Math.atan2(Math.sqrt(Dt), Math.sqrt(1 - Dt));
        return this.R * Tt;
      }
    }), et = 6378137, at = {
      R: et,
      MAX_LATITUDE: 85.0511287798,
      project: function(d) {
        var _ = Math.PI / 180, C = this.MAX_LATITUDE, B = Math.max(Math.min(C, d.lat), -C), q = Math.sin(B * _);
        return new Y(
          this.R * d.lng * _,
          this.R * Math.log((1 + q) / (1 - q)) / 2
        );
      },
      unproject: function(d) {
        var _ = 180 / Math.PI;
        return new Ft(
          (2 * Math.atan(Math.exp(d.y / this.R)) - Math.PI / 2) * _,
          d.x * _ / this.R
        );
      },
      bounds: function() {
        var d = et * Math.PI;
        return new ht([-d, -d], [d, d]);
      }()
    };
    function gt(d, _, C, B) {
      if (N(d)) {
        this._a = d[0], this._b = d[1], this._c = d[2], this._d = d[3];
        return;
      }
      this._a = d, this._b = _, this._c = C, this._d = B;
    }
    gt.prototype = {
      // @method transform(point: Point, scale?: Number): Point
      // Returns a transformed point, optionally multiplied by the given scale.
      // Only accepts actual `L.Point` instances, not arrays.
      transform: function(d, _) {
        return this._transform(d.clone(), _);
      },
      // destructive transform (faster)
      _transform: function(d, _) {
        return _ = _ || 1, d.x = _ * (this._a * d.x + this._b), d.y = _ * (this._c * d.y + this._d), d;
      },
      // @method untransform(point: Point, scale?: Number): Point
      // Returns the reverse transformation of the given point, optionally divided
      // by the given scale. Only accepts actual `L.Point` instances, not arrays.
      untransform: function(d, _) {
        return _ = _ || 1, new Y(
          (d.x / _ - this._b) / this._a,
          (d.y / _ - this._d) / this._c
        );
      }
    };
    function wt(d, _, C, B) {
      return new gt(d, _, C, B);
    }
    var Et = l({}, J, {
      code: "EPSG:3857",
      projection: at,
      transformation: function() {
        var d = 0.5 / (Math.PI * at.R);
        return wt(d, 0.5, -d, 0.5);
      }()
    }), qt = l({}, Et, {
      code: "EPSG:900913"
    });
    function Jt(d) {
      return document.createElementNS("http://www.w3.org/2000/svg", d);
    }
    function Gt(d, _) {
      var C = "", B, q, Q, dt, Dt, Tt;
      for (B = 0, Q = d.length; B < Q; B++) {
        for (Dt = d[B], q = 0, dt = Dt.length; q < dt; q++)
          Tt = Dt[q], C += (q ? "L" : "M") + Tt.x + " " + Tt.y;
        C += _ ? ae.svg ? "z" : "x" : "";
      }
      return C || "M0 0";
    }
    var Yt = document.documentElement.style, he = "ActiveXObject" in window, Pe = he && !document.addEventListener, ce = "msLaunchUri" in navigator && !("documentMode" in document), di = Je("webkit"), fe = Je("android"), st = Je("android 2") || Je("android 3"), xt = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), mt = fe && Je("Google") && xt < 537 && !("AudioNode" in window), Ot = !!window.opera, jt = !ce && Je("chrome"), Ht = Je("gecko") && !di && !Ot && !he, $t = !jt && Je("safari"), Xt = Je("phantom"), Qt = "OTransition" in Yt, Ut = navigator.platform.indexOf("Win") === 0, ve = he && "transition" in Yt, we = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !st, Te = "MozPerspective" in Yt, Ve = !window.L_DISABLE_3D && (ve || we || Te) && !Qt && !Xt, Le = typeof orientation < "u" || Je("mobile"), Ke = Le && di, Qe = Le && we, Ti = !window.PointerEvent && window.MSPointerEvent, ai = !!(window.PointerEvent || Ti), Bi = "ontouchstart" in window || !!window.TouchEvent, In = !window.L_NO_TOUCH && (Bi || ai), Bn = Le && Ot, $e = Le && Ht, Ze = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1, sn = function() {
      var d = !1;
      try {
        var _ = Object.defineProperty({}, "passive", {
          get: function() {
            d = !0;
          }
        });
        window.addEventListener("testPassiveEventSupport", g, _), window.removeEventListener("testPassiveEventSupport", g, _);
      } catch {
      }
      return d;
    }(), $n = function() {
      return !!document.createElement("canvas").getContext;
    }(), Ki = !!(document.createElementNS && Jt("svg").createSVGRect), zn = !!Ki && function() {
      var d = document.createElement("div");
      return d.innerHTML = "<svg/>", (d.firstChild && d.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
    }(), zi = !Ki && function() {
      try {
        var d = document.createElement("div");
        d.innerHTML = '<v:shape adj="1"/>';
        var _ = d.firstChild;
        return _.style.behavior = "url(#default#VML)", _ && typeof _.adj == "object";
      } catch {
        return !1;
      }
    }(), Ri = navigator.platform.indexOf("Mac") === 0, un = navigator.platform.indexOf("Linux") === 0;
    function Je(d) {
      return navigator.userAgent.toLowerCase().indexOf(d) >= 0;
    }
    var ae = {
      ie: he,
      ielt9: Pe,
      edge: ce,
      webkit: di,
      android: fe,
      android23: st,
      androidStock: mt,
      opera: Ot,
      chrome: jt,
      gecko: Ht,
      safari: $t,
      phantom: Xt,
      opera12: Qt,
      win: Ut,
      ie3d: ve,
      webkit3d: we,
      gecko3d: Te,
      any3d: Ve,
      mobile: Le,
      mobileWebkit: Ke,
      mobileWebkit3d: Qe,
      msPointer: Ti,
      pointer: ai,
      touch: In,
      touchNative: Bi,
      mobileOpera: Bn,
      mobileGecko: $e,
      retina: Ze,
      passiveEvents: sn,
      canvas: $n,
      svg: Ki,
      vml: zi,
      inlineSvg: zn,
      mac: Ri,
      linux: un
    }, Rn = ae.msPointer ? "MSPointerDown" : "pointerdown", Hn = ae.msPointer ? "MSPointerMove" : "pointermove", hn = ae.msPointer ? "MSPointerUp" : "pointerup", Wn = ae.msPointer ? "MSPointerCancel" : "pointercancel", dn = {
      touchstart: Rn,
      touchmove: Hn,
      touchend: hn,
      touchcancel: Wn
    }, cn = {
      touchstart: Se,
      touchmove: ti,
      touchend: ti,
      touchcancel: ti
    }, Hi = {}, Fi = !1;
    function jn(d, _, C) {
      return _ === "touchstart" && er(), cn[_] ? (C = cn[_].bind(this, C), d.addEventListener(dn[_], C, !1), C) : (console.warn("wrong event specified:", _), g);
    }
    function fn(d, _, C) {
      if (!dn[_]) {
        console.warn("wrong event specified:", _);
        return;
      }
      d.removeEventListener(dn[_], C, !1);
    }
    function pn(d) {
      Hi[d.pointerId] = d;
    }
    function Qi(d) {
      Hi[d.pointerId] && (Hi[d.pointerId] = d);
    }
    function gn(d) {
      delete Hi[d.pointerId];
    }
    function er() {
      Fi || (document.addEventListener(Rn, pn, !0), document.addEventListener(Hn, Qi, !0), document.addEventListener(hn, gn, !0), document.addEventListener(Wn, gn, !0), Fi = !0);
    }
    function ti(d, _) {
      if (_.pointerType !== (_.MSPOINTER_TYPE_MOUSE || "mouse")) {
        _.touches = [];
        for (var C in Hi)
          _.touches.push(Hi[C]);
        _.changedTouches = [_], d(_);
      }
    }
    function Se(d, _) {
      _.MSPOINTER_TYPE_TOUCH && _.pointerType === _.MSPOINTER_TYPE_TOUCH && He(_), ti(d, _);
    }
    function je(d) {
      var _ = {}, C, B;
      for (B in d)
        C = d[B], _[B] = C && C.bind ? C.bind(d) : C;
      return d = _, _.type = "dblclick", _.detail = 2, _.isTrusted = !1, _._simulated = !0, _;
    }
    var qn = 200;
    function ji(d, _) {
      d.addEventListener("dblclick", _);
      var C = 0, B;
      function q(Q) {
        if (Q.detail !== 1) {
          B = Q.detail;
          return;
        }
        if (!(Q.pointerType === "mouse" || Q.sourceCapabilities && !Q.sourceCapabilities.firesTouchEvents)) {
          var dt = dr(Q);
          if (!(dt.some(function(Tt) {
            return Tt instanceof HTMLLabelElement && Tt.attributes.for;
          }) && !dt.some(function(Tt) {
            return Tt instanceof HTMLInputElement || Tt instanceof HTMLSelectElement;
          }))) {
            var Dt = Date.now();
            Dt - C <= qn ? (B++, B === 2 && _(je(Q))) : B = 1, C = Dt;
          }
        }
      }
      return d.addEventListener("click", q), {
        dblclick: _,
        simDblclick: q
      };
    }
    function qi(d, _) {
      d.removeEventListener("dblclick", _.dblclick), d.removeEventListener("click", _.simDblclick);
    }
    var Gi = Un(
      ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
    ), vn = Un(
      ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
    ), _r = vn === "webkitTransition" || vn === "OTransition" ? vn + "End" : "transitionend";
    function ir(d) {
      return typeof d == "string" ? document.getElementById(d) : d;
    }
    function $i(d, _) {
      var C = d.style[_] || d.currentStyle && d.currentStyle[_];
      if ((!C || C === "auto") && document.defaultView) {
        var B = document.defaultView.getComputedStyle(d, null);
        C = B ? B[_] : null;
      }
      return C === "auto" ? null : C;
    }
    function Me(d, _, C) {
      var B = document.createElement(d);
      return B.className = _ || "", C && C.appendChild(B), B;
    }
    function ke(d) {
      var _ = d.parentNode;
      _ && _.removeChild(d);
    }
    function qe(d) {
      for (; d.firstChild; )
        d.removeChild(d.firstChild);
    }
    function ci(d) {
      var _ = d.parentNode;
      _ && _.lastChild !== d && _.appendChild(d);
    }
    function Li(d) {
      var _ = d.parentNode;
      _ && _.firstChild !== d && _.insertBefore(d, _.firstChild);
    }
    function nr(d, _) {
      if (d.classList !== void 0)
        return d.classList.contains(_);
      var C = Ui(d);
      return C.length > 0 && new RegExp("(^|\\s)" + _ + "(\\s|$)").test(C);
    }
    function pe(d, _) {
      if (d.classList !== void 0)
        for (var C = E(_), B = 0, q = C.length; B < q; B++)
          d.classList.add(C[B]);
      else if (!nr(d, _)) {
        var Q = Ui(d);
        Gn(d, (Q ? Q + " " : "") + _);
      }
    }
    function Ne(d, _) {
      d.classList !== void 0 ? d.classList.remove(_) : Gn(d, w((" " + Ui(d) + " ").replace(" " + _ + " ", " ")));
    }
    function Gn(d, _) {
      d.className.baseVal === void 0 ? d.className = _ : d.className.baseVal = _;
    }
    function Ui(d) {
      return d.correspondingElement && (d = d.correspondingElement), d.className.baseVal === void 0 ? d.className : d.className.baseVal;
    }
    function ni(d, _) {
      "opacity" in d.style ? d.style.opacity = _ : "filter" in d.style && Ar(d, _);
    }
    function Ar(d, _) {
      var C = !1, B = "DXImageTransform.Microsoft.Alpha";
      try {
        C = d.filters.item(B);
      } catch {
        if (_ === 1)
          return;
      }
      _ = Math.round(_ * 100), C ? (C.Enabled = _ !== 100, C.Opacity = _) : d.style.filter += " progid:" + B + "(opacity=" + _ + ")";
    }
    function Un(d) {
      for (var _ = document.documentElement.style, C = 0; C < d.length; C++)
        if (d[C] in _)
          return d[C];
      return !1;
    }
    function Ge(d, _, C) {
      var B = _ || new Y(0, 0);
      d.style[Gi] = (ae.ie3d ? "translate(" + B.x + "px," + B.y + "px)" : "translate3d(" + B.x + "px," + B.y + "px,0)") + (C ? " scale(" + C + ")" : "");
    }
    function Ie(d, _) {
      d._leaflet_pos = _, ae.any3d ? Ge(d, _) : (d.style.left = _.x + "px", d.style.top = _.y + "px");
    }
    function fi(d) {
      return d._leaflet_pos || new Y(0, 0);
    }
    var mn, _n, ki;
    if ("onselectstart" in document)
      mn = function() {
        de(window, "selectstart", He);
      }, _n = function() {
        Fe(window, "selectstart", He);
      };
    else {
      var pi = Un(
        ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
      );
      mn = function() {
        if (pi) {
          var d = document.documentElement.style;
          ki = d[pi], d[pi] = "none";
        }
      }, _n = function() {
        pi && (document.documentElement.style[pi] = ki, ki = void 0);
      };
    }
    function yn() {
      de(window, "dragstart", He);
    }
    function rr() {
      Fe(window, "dragstart", He);
    }
    var Wi, Vn;
    function bn(d) {
      for (; d.tabIndex === -1; )
        d = d.parentNode;
      d.style && (xn(), Wi = d, Vn = d.style.outlineStyle, d.style.outlineStyle = "none", de(window, "keydown", xn));
    }
    function xn() {
      Wi && (Wi.style.outlineStyle = Vn, Wi = void 0, Vn = void 0, Fe(window, "keydown", xn));
    }
    function ar(d) {
      do
        d = d.parentNode;
      while ((!d.offsetWidth || !d.offsetHeight) && d !== document.body);
      return d;
    }
    function or(d) {
      var _ = d.getBoundingClientRect();
      return {
        x: _.width / d.offsetWidth || 1,
        y: _.height / d.offsetHeight || 1,
        boundingClientRect: _
      };
    }
    var yr = {
      __proto__: null,
      TRANSFORM: Gi,
      TRANSITION: vn,
      TRANSITION_END: _r,
      get: ir,
      getStyle: $i,
      create: Me,
      remove: ke,
      empty: qe,
      toFront: ci,
      toBack: Li,
      hasClass: nr,
      addClass: pe,
      removeClass: Ne,
      setClass: Gn,
      getClass: Ui,
      setOpacity: ni,
      testProp: Un,
      setTransform: Ge,
      setPosition: Ie,
      getPosition: fi,
      get disableTextSelection() {
        return mn;
      },
      get enableTextSelection() {
        return _n;
      },
      disableImageDrag: yn,
      enableImageDrag: rr,
      preventOutline: bn,
      restoreOutline: xn,
      getSizedParentNode: ar,
      getScale: or
    };
    function de(d, _, C, B) {
      if (_ && typeof _ == "object")
        for (var q in _)
          lr(d, q, _[q], C);
      else {
        _ = E(_);
        for (var Q = 0, dt = _.length; Q < dt; Q++)
          lr(d, _[Q], C, B);
      }
      return this;
    }
    var xi = "_leaflet_events";
    function Fe(d, _, C, B) {
      if (arguments.length === 1)
        br(d), delete d[xi];
      else if (_ && typeof _ == "object")
        for (var q in _)
          ur(d, q, _[q], C);
      else if (_ = E(_), arguments.length === 2)
        br(d, function(Dt) {
          return H(_, Dt) !== -1;
        });
      else
        for (var Q = 0, dt = _.length; Q < dt; Q++)
          ur(d, _[Q], C, B);
      return this;
    }
    function br(d, _) {
      for (var C in d[xi]) {
        var B = C.split(/\d/)[0];
        (!_ || _(B)) && ur(d, B, null, null, C);
      }
    }
    var sr = {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      wheel: !("onwheel" in window) && "mousewheel"
    };
    function lr(d, _, C, B) {
      var q = _ + f(C) + (B ? "_" + f(B) : "");
      if (d[xi] && d[xi][q])
        return this;
      var Q = function(Dt) {
        return C.call(B || d, Dt || window.event);
      }, dt = Q;
      !ae.touchNative && ae.pointer && _.indexOf("touch") === 0 ? Q = jn(d, _, Q) : ae.touch && _ === "dblclick" ? Q = ji(d, Q) : "addEventListener" in d ? _ === "touchstart" || _ === "touchmove" || _ === "wheel" || _ === "mousewheel" ? d.addEventListener(sr[_] || _, Q, ae.passiveEvents ? { passive: !1 } : !1) : _ === "mouseenter" || _ === "mouseleave" ? (Q = function(Dt) {
        Dt = Dt || window.event, Cn(d, Dt) && dt(Dt);
      }, d.addEventListener(sr[_], Q, !1)) : d.addEventListener(_, dt, !1) : d.attachEvent("on" + _, Q), d[xi] = d[xi] || {}, d[xi][q] = Q;
    }
    function ur(d, _, C, B, q) {
      q = q || _ + f(C) + (B ? "_" + f(B) : "");
      var Q = d[xi] && d[xi][q];
      if (!Q)
        return this;
      !ae.touchNative && ae.pointer && _.indexOf("touch") === 0 ? fn(d, _, Q) : ae.touch && _ === "dblclick" ? qi(d, Q) : "removeEventListener" in d ? d.removeEventListener(sr[_] || _, Q, !1) : d.detachEvent("on" + _, Q), d[xi][q] = null;
    }
    function Vi(d) {
      return d.stopPropagation ? d.stopPropagation() : d.originalEvent ? d.originalEvent._stopped = !0 : d.cancelBubble = !0, this;
    }
    function hr(d) {
      return lr(d, "wheel", Vi), this;
    }
    function wn(d) {
      return de(d, "mousedown touchstart dblclick contextmenu", Vi), d._leaflet_disable_click = !0, this;
    }
    function He(d) {
      return d.preventDefault ? d.preventDefault() : d.returnValue = !1, this;
    }
    function Ni(d) {
      return He(d), Vi(d), this;
    }
    function dr(d) {
      if (d.composedPath)
        return d.composedPath();
      for (var _ = [], C = d.target; C; )
        _.push(C), C = C.parentNode;
      return _;
    }
    function Zn(d, _) {
      if (!_)
        return new Y(d.clientX, d.clientY);
      var C = or(_), B = C.boundingClientRect;
      return new Y(
        // offset.left/top values are in page scale (like clientX/Y),
        // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
        (d.clientX - B.left) / C.x - _.clientLeft,
        (d.clientY - B.top) / C.y - _.clientTop
      );
    }
    var xr = ae.linux && ae.chrome ? window.devicePixelRatio : ae.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
    function cr(d) {
      return ae.edge ? d.wheelDeltaY / 2 : (
        // Don't trust window-geometry-based delta
        d.deltaY && d.deltaMode === 0 ? -d.deltaY / xr : (
          // Pixels
          d.deltaY && d.deltaMode === 1 ? -d.deltaY * 20 : (
            // Lines
            d.deltaY && d.deltaMode === 2 ? -d.deltaY * 60 : (
              // Pages
              d.deltaX || d.deltaZ ? 0 : (
                // Skip horizontal/depth wheel events
                d.wheelDelta ? (d.wheelDeltaY || d.wheelDelta) / 2 : (
                  // Legacy IE pixels
                  d.detail && Math.abs(d.detail) < 32765 ? -d.detail * 20 : (
                    // Legacy Moz lines
                    d.detail ? d.detail / -32765 * 60 : (
                      // Legacy Moz pages
                      0
                    )
                  )
                )
              )
            )
          )
        )
      );
    }
    function Cn(d, _) {
      var C = _.relatedTarget;
      if (!C)
        return !0;
      try {
        for (; C && C !== d; )
          C = C.parentNode;
      } catch {
        return !1;
      }
      return C !== d;
    }
    var Tr = {
      __proto__: null,
      on: de,
      off: Fe,
      stopPropagation: Vi,
      disableScrollPropagation: hr,
      disableClickPropagation: wn,
      preventDefault: He,
      stop: Ni,
      getPropagationPath: dr,
      getMousePosition: Zn,
      getWheelDelta: cr,
      isExternalTarget: Cn,
      addListener: de,
      removeListener: Fe
    }, wr = G.extend({
      // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
      // Run an animation of a given element to a new position, optionally setting
      // duration in seconds (`0.25` by default) and easing linearity factor (3rd
      // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
      // `0.5` by default).
      run: function(d, _, C, B) {
        this.stop(), this._el = d, this._inProgress = !0, this._duration = C || 0.25, this._easeOutPower = 1 / Math.max(B || 0.5, 0.2), this._startPos = fi(d), this._offset = _.subtract(this._startPos), this._startTime = +/* @__PURE__ */ new Date(), this.fire("start"), this._animate();
      },
      // @method stop()
      // Stops the animation (if currently running).
      stop: function() {
        this._inProgress && (this._step(!0), this._complete());
      },
      _animate: function() {
        this._animId = pt(this._animate, this), this._step();
      },
      _step: function(d) {
        var _ = +/* @__PURE__ */ new Date() - this._startTime, C = this._duration * 1e3;
        _ < C ? this._runFrame(this._easeOut(_ / C), d) : (this._runFrame(1), this._complete());
      },
      _runFrame: function(d, _) {
        var C = this._startPos.add(this._offset.multiplyBy(d));
        _ && C._round(), Ie(this._el, C), this.fire("step");
      },
      _complete: function() {
        ct(this._animId), this._inProgress = !1, this.fire("end");
      },
      _easeOut: function(d) {
        return 1 - Math.pow(1 - d, this._easeOutPower);
      }
    }), Ee = G.extend({
      options: {
        // @section Map State Options
        // @option crs: CRS = L.CRS.EPSG3857
        // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
        // sure what it means.
        crs: Et,
        // @option center: LatLng = undefined
        // Initial geographic center of the map
        center: void 0,
        // @option zoom: Number = undefined
        // Initial map zoom level
        zoom: void 0,
        // @option minZoom: Number = *
        // Minimum zoom level of the map.
        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
        // the lowest of their `minZoom` options will be used instead.
        minZoom: void 0,
        // @option maxZoom: Number = *
        // Maximum zoom level of the map.
        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
        // the highest of their `maxZoom` options will be used instead.
        maxZoom: void 0,
        // @option layers: Layer[] = []
        // Array of layers that will be added to the map initially
        layers: [],
        // @option maxBounds: LatLngBounds = null
        // When this option is set, the map restricts the view to the given
        // geographical bounds, bouncing the user back if the user tries to pan
        // outside the view. To set the restriction dynamically, use
        // [`setMaxBounds`](#map-setmaxbounds) method.
        maxBounds: void 0,
        // @option renderer: Renderer = *
        // The default method for drawing vector layers on the map. `L.SVG`
        // or `L.Canvas` by default depending on browser support.
        renderer: void 0,
        // @section Animation Options
        // @option zoomAnimation: Boolean = true
        // Whether the map zoom animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        zoomAnimation: !0,
        // @option zoomAnimationThreshold: Number = 4
        // Won't animate zoom if the zoom difference exceeds this value.
        zoomAnimationThreshold: 4,
        // @option fadeAnimation: Boolean = true
        // Whether the tile fade animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        fadeAnimation: !0,
        // @option markerZoomAnimation: Boolean = true
        // Whether markers animate their zoom with the zoom animation, if disabled
        // they will disappear for the length of the animation. By default it's
        // enabled in all browsers that support CSS3 Transitions except Android.
        markerZoomAnimation: !0,
        // @option transform3DLimit: Number = 2^23
        // Defines the maximum size of a CSS translation transform. The default
        // value should not be changed unless a web browser positions layers in
        // the wrong place after doing a large `panBy`.
        transform3DLimit: 8388608,
        // Precision limit of a 32-bit float
        // @section Interaction Options
        // @option zoomSnap: Number = 1
        // Forces the map's zoom level to always be a multiple of this, particularly
        // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
        // By default, the zoom level snaps to the nearest integer; lower values
        // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
        // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
        zoomSnap: 1,
        // @option zoomDelta: Number = 1
        // Controls how much the map's zoom level will change after a
        // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
        // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
        // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
        zoomDelta: 1,
        // @option trackResize: Boolean = true
        // Whether the map automatically handles browser window resize to update itself.
        trackResize: !0
      },
      initialize: function(d, _) {
        _ = x(this, _), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(d), this._initLayout(), this._onResize = h(this._onResize, this), this._initEvents(), _.maxBounds && this.setMaxBounds(_.maxBounds), _.zoom !== void 0 && (this._zoom = this._limitZoom(_.zoom)), _.center && _.zoom !== void 0 && this.setView(zt(_.center), _.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = vn && ae.any3d && !ae.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), de(this._proxy, _r, this._catchTransitionEnd, this)), this._addLayers(this.options.layers);
      },
      // @section Methods for modifying map state
      // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
      // Sets the view of the map (geographical center and zoom) with the given
      // animation options.
      setView: function(d, _, C) {
        if (_ = _ === void 0 ? this._zoom : this._limitZoom(_), d = this._limitCenter(zt(d), _, this.options.maxBounds), C = C || {}, this._stop(), this._loaded && !C.reset && C !== !0) {
          C.animate !== void 0 && (C.zoom = l({ animate: C.animate }, C.zoom), C.pan = l({ animate: C.animate, duration: C.duration }, C.pan));
          var B = this._zoom !== _ ? this._tryAnimatedZoom && this._tryAnimatedZoom(d, _, C.zoom) : this._tryAnimatedPan(d, C.pan);
          if (B)
            return clearTimeout(this._sizeTimer), this;
        }
        return this._resetView(d, _, C.pan && C.pan.noMoveStart), this;
      },
      // @method setZoom(zoom: Number, options?: Zoom/pan options): this
      // Sets the zoom of the map.
      setZoom: function(d, _) {
        return this._loaded ? this.setView(this.getCenter(), d, { zoom: _ }) : (this._zoom = d, this);
      },
      // @method zoomIn(delta?: Number, options?: Zoom options): this
      // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
      zoomIn: function(d, _) {
        return d = d || (ae.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + d, _);
      },
      // @method zoomOut(delta?: Number, options?: Zoom options): this
      // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
      zoomOut: function(d, _) {
        return d = d || (ae.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - d, _);
      },
      // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
      // Zooms the map while keeping a specified geographical point on the map
      // stationary (e.g. used internally for scroll zoom and double-click zoom).
      // @alternative
      // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
      // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
      setZoomAround: function(d, _, C) {
        var B = this.getZoomScale(_), q = this.getSize().divideBy(2), Q = d instanceof Y ? d : this.latLngToContainerPoint(d), dt = Q.subtract(q).multiplyBy(1 - 1 / B), Dt = this.containerPointToLatLng(q.add(dt));
        return this.setView(Dt, _, { zoom: C });
      },
      _getBoundsCenterZoom: function(d, _) {
        _ = _ || {}, d = d.getBounds ? d.getBounds() : St(d);
        var C = rt(_.paddingTopLeft || _.padding || [0, 0]), B = rt(_.paddingBottomRight || _.padding || [0, 0]), q = this.getBoundsZoom(d, !1, C.add(B));
        if (q = typeof _.maxZoom == "number" ? Math.min(_.maxZoom, q) : q, q === 1 / 0)
          return {
            center: d.getCenter(),
            zoom: q
          };
        var Q = B.subtract(C).divideBy(2), dt = this.project(d.getSouthWest(), q), Dt = this.project(d.getNorthEast(), q), Tt = this.unproject(dt.add(Dt).divideBy(2).add(Q), q);
        return {
          center: Tt,
          zoom: q
        };
      },
      // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
      // Sets a map view that contains the given geographical bounds with the
      // maximum zoom level possible.
      fitBounds: function(d, _) {
        if (d = St(d), !d.isValid())
          throw new Error("Bounds are not valid.");
        var C = this._getBoundsCenterZoom(d, _);
        return this.setView(C.center, C.zoom, _);
      },
      // @method fitWorld(options?: fitBounds options): this
      // Sets a map view that mostly contains the whole world with the maximum
      // zoom level possible.
      fitWorld: function(d) {
        return this.fitBounds([[-90, -180], [90, 180]], d);
      },
      // @method panTo(latlng: LatLng, options?: Pan options): this
      // Pans the map to a given center.
      panTo: function(d, _) {
        return this.setView(d, this._zoom, { pan: _ });
      },
      // @method panBy(offset: Point, options?: Pan options): this
      // Pans the map by a given number of pixels (animated).
      panBy: function(d, _) {
        if (d = rt(d).round(), _ = _ || {}, !d.x && !d.y)
          return this.fire("moveend");
        if (_.animate !== !0 && !this.getSize().contains(d))
          return this._resetView(this.unproject(this.project(this.getCenter()).add(d)), this.getZoom()), this;
        if (this._panAnim || (this._panAnim = new wr(), this._panAnim.on({
          step: this._onPanTransitionStep,
          end: this._onPanTransitionEnd
        }, this)), _.noMoveStart || this.fire("movestart"), _.animate !== !1) {
          pe(this._mapPane, "leaflet-pan-anim");
          var C = this._getMapPanePos().subtract(d).round();
          this._panAnim.run(this._mapPane, C, _.duration || 0.25, _.easeLinearity);
        } else
          this._rawPanBy(d), this.fire("move").fire("moveend");
        return this;
      },
      // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
      // Sets the view of the map (geographical center and zoom) performing a smooth
      // pan-zoom animation.
      flyTo: function(d, _, C) {
        if (C = C || {}, C.animate === !1 || !ae.any3d)
          return this.setView(d, _, C);
        this._stop();
        var B = this.project(this.getCenter()), q = this.project(d), Q = this.getSize(), dt = this._zoom;
        d = zt(d), _ = _ === void 0 ? dt : _;
        var Dt = Math.max(Q.x, Q.y), Tt = Dt * this.getZoomScale(dt, _), Wt = q.distanceTo(B) || 1, ie = 1.42, le = ie * ie;
        function Ce(We) {
          var Sr = We ? -1 : 1, sa = We ? Tt : Dt, la = Tt * Tt - Dt * Dt + Sr * le * le * Wt * Wt, ua = 2 * sa * le * Wt, kr = la / ua, Yr = Math.sqrt(kr * kr + 1) - kr, ha = Yr < 1e-9 ? -18 : Math.log(Yr);
          return ha;
        }
        function ri(We) {
          return (Math.exp(We) - Math.exp(-We)) / 2;
        }
        function Ye(We) {
          return (Math.exp(We) + Math.exp(-We)) / 2;
        }
        function Ai(We) {
          return ri(We) / Ye(We);
        }
        var hi = Ce(0);
        function Qn(We) {
          return Dt * (Ye(hi) / Ye(hi + ie * We));
        }
        function ia(We) {
          return Dt * (Ye(hi) * Ai(hi + ie * We) - ri(hi)) / le;
        }
        function na(We) {
          return 1 - Math.pow(1 - We, 1.5);
        }
        var ra = Date.now(), Zr = (Ce(1) - hi) / ie, oa = C.duration ? 1e3 * C.duration : 1e3 * Zr * 0.8;
        function Xr() {
          var We = (Date.now() - ra) / oa, Sr = na(We) * Zr;
          We <= 1 ? (this._flyToFrame = pt(Xr, this), this._move(
            this.unproject(B.add(q.subtract(B).multiplyBy(ia(Sr) / Wt)), dt),
            this.getScaleZoom(Dt / Qn(Sr), dt),
            { flyTo: !0 }
          )) : this._move(d, _)._moveEnd(!0);
        }
        return this._moveStart(!0, C.noMoveStart), Xr.call(this), this;
      },
      // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
      // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
      // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
      flyToBounds: function(d, _) {
        var C = this._getBoundsCenterZoom(d, _);
        return this.flyTo(C.center, C.zoom, _);
      },
      // @method setMaxBounds(bounds: LatLngBounds): this
      // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
      setMaxBounds: function(d) {
        return d = St(d), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), d.isValid() ? (this.options.maxBounds = d, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this);
      },
      // @method setMinZoom(zoom: Number): this
      // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
      setMinZoom: function(d) {
        var _ = this.options.minZoom;
        return this.options.minZoom = d, this._loaded && _ !== d && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(d) : this;
      },
      // @method setMaxZoom(zoom: Number): this
      // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
      setMaxZoom: function(d) {
        var _ = this.options.maxZoom;
        return this.options.maxZoom = d, this._loaded && _ !== d && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(d) : this;
      },
      // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
      // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
      panInsideBounds: function(d, _) {
        this._enforcingBounds = !0;
        var C = this.getCenter(), B = this._limitCenter(C, this._zoom, St(d));
        return C.equals(B) || this.panTo(B, _), this._enforcingBounds = !1, this;
      },
      // @method panInside(latlng: LatLng, options?: padding options): this
      // Pans the map the minimum amount to make the `latlng` visible. Use
      // padding options to fit the display to more restricted bounds.
      // If `latlng` is already within the (optionally padded) display bounds,
      // the map will not be panned.
      panInside: function(d, _) {
        _ = _ || {};
        var C = rt(_.paddingTopLeft || _.padding || [0, 0]), B = rt(_.paddingBottomRight || _.padding || [0, 0]), q = this.project(this.getCenter()), Q = this.project(d), dt = this.getPixelBounds(), Dt = bt([dt.min.add(C), dt.max.subtract(B)]), Tt = Dt.getSize();
        if (!Dt.contains(Q)) {
          this._enforcingBounds = !0;
          var Wt = Q.subtract(Dt.getCenter()), ie = Dt.extend(Q).getSize().subtract(Tt);
          q.x += Wt.x < 0 ? -ie.x : ie.x, q.y += Wt.y < 0 ? -ie.y : ie.y, this.panTo(this.unproject(q), _), this._enforcingBounds = !1;
        }
        return this;
      },
      // @method invalidateSize(options: Zoom/pan options): this
      // Checks if the map container size changed and updates the map if so —
      // call it after you've changed the map size dynamically, also animating
      // pan by default. If `options.pan` is `false`, panning will not occur.
      // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
      // that it doesn't happen often even if the method is called many
      // times in a row.
      // @alternative
      // @method invalidateSize(animate: Boolean): this
      // Checks if the map container size changed and updates the map if so —
      // call it after you've changed the map size dynamically, also animating
      // pan by default.
      invalidateSize: function(d) {
        if (!this._loaded)
          return this;
        d = l({
          animate: !1,
          pan: !0
        }, d === !0 ? { animate: !0 } : d);
        var _ = this.getSize();
        this._sizeChanged = !0, this._lastCenter = null;
        var C = this.getSize(), B = _.divideBy(2).round(), q = C.divideBy(2).round(), Q = B.subtract(q);
        return !Q.x && !Q.y ? this : (d.animate && d.pan ? this.panBy(Q) : (d.pan && this._rawPanBy(Q), this.fire("move"), d.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(h(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
          oldSize: _,
          newSize: C
        }));
      },
      // @section Methods for modifying map state
      // @method stop(): this
      // Stops the currently running `panTo` or `flyTo` animation, if any.
      stop: function() {
        return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop();
      },
      // @section Geolocation methods
      // @method locate(options?: Locate options): this
      // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
      // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
      // and optionally sets the map view to the user's location with respect to
      // detection accuracy (or to the world view if geolocation failed).
      // Note that, if your page doesn't use HTTPS, this method will fail in
      // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
      // See `Locate options` for more details.
      locate: function(d) {
        if (d = this._locateOptions = l({
          timeout: 1e4,
          watch: !1
          // setView: false
          // maxZoom: <Number>
          // maximumAge: 0
          // enableHighAccuracy: false
        }, d), !("geolocation" in navigator))
          return this._handleGeolocationError({
            code: 0,
            message: "Geolocation not supported."
          }), this;
        var _ = h(this._handleGeolocationResponse, this), C = h(this._handleGeolocationError, this);
        return d.watch ? this._locationWatchId = navigator.geolocation.watchPosition(_, C, d) : navigator.geolocation.getCurrentPosition(_, C, d), this;
      },
      // @method stopLocate(): this
      // Stops watching location previously initiated by `map.locate({watch: true})`
      // and aborts resetting the map view if map.locate was called with
      // `{setView: true}`.
      stopLocate: function() {
        return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;
      },
      _handleGeolocationError: function(d) {
        if (this._container._leaflet_id) {
          var _ = d.code, C = d.message || (_ === 1 ? "permission denied" : _ === 2 ? "position unavailable" : "timeout");
          this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
            code: _,
            message: "Geolocation error: " + C + "."
          });
        }
      },
      _handleGeolocationResponse: function(d) {
        if (this._container._leaflet_id) {
          var _ = d.coords.latitude, C = d.coords.longitude, B = new Ft(_, C), q = B.toBounds(d.coords.accuracy * 2), Q = this._locateOptions;
          if (Q.setView) {
            var dt = this.getBoundsZoom(q);
            this.setView(B, Q.maxZoom ? Math.min(dt, Q.maxZoom) : dt);
          }
          var Dt = {
            latlng: B,
            bounds: q,
            timestamp: d.timestamp
          };
          for (var Tt in d.coords)
            typeof d.coords[Tt] == "number" && (Dt[Tt] = d.coords[Tt]);
          this.fire("locationfound", Dt);
        }
      },
      // TODO Appropriate docs section?
      // @section Other Methods
      // @method addHandler(name: String, HandlerClass: Function): this
      // Adds a new `Handler` to the map, given its name and constructor function.
      addHandler: function(d, _) {
        if (!_)
          return this;
        var C = this[d] = new _(this);
        return this._handlers.push(C), this.options[d] && C.enable(), this;
      },
      // @method remove(): this
      // Destroys the map and clears all related event listeners.
      remove: function() {
        if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id)
          throw new Error("Map container is being reused by another instance");
        try {
          delete this._container._leaflet_id, delete this._containerId;
        } catch {
          this._container._leaflet_id = void 0, this._containerId = void 0;
        }
        this._locationWatchId !== void 0 && this.stopLocate(), this._stop(), ke(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (ct(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload");
        var d;
        for (d in this._layers)
          this._layers[d].remove();
        for (d in this._panes)
          ke(this._panes[d]);
        return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;
      },
      // @section Other Methods
      // @method createPane(name: String, container?: HTMLElement): HTMLElement
      // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
      // then returns it. The pane is created as a child of `container`, or
      // as a child of the main map pane if not set.
      createPane: function(d, _) {
        var C = "leaflet-pane" + (d ? " leaflet-" + d.replace("Pane", "") + "-pane" : ""), B = Me("div", C, _ || this._mapPane);
        return d && (this._panes[d] = B), B;
      },
      // @section Methods for Getting Map State
      // @method getCenter(): LatLng
      // Returns the geographical center of the map view
      getCenter: function() {
        return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
      },
      // @method getZoom(): Number
      // Returns the current zoom level of the map view
      getZoom: function() {
        return this._zoom;
      },
      // @method getBounds(): LatLngBounds
      // Returns the geographical bounds visible in the current map view
      getBounds: function() {
        var d = this.getPixelBounds(), _ = this.unproject(d.getBottomLeft()), C = this.unproject(d.getTopRight());
        return new yt(_, C);
      },
      // @method getMinZoom(): Number
      // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
      getMinZoom: function() {
        return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
      },
      // @method getMaxZoom(): Number
      // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
      getMaxZoom: function() {
        return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
      },
      // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
      // Returns the maximum zoom level on which the given bounds fit to the map
      // view in its entirety. If `inside` (optional) is set to `true`, the method
      // instead returns the minimum zoom level on which the map view fits into
      // the given bounds in its entirety.
      getBoundsZoom: function(d, _, C) {
        d = St(d), C = rt(C || [0, 0]);
        var B = this.getZoom() || 0, q = this.getMinZoom(), Q = this.getMaxZoom(), dt = d.getNorthWest(), Dt = d.getSouthEast(), Tt = this.getSize().subtract(C), Wt = bt(this.project(Dt, B), this.project(dt, B)).getSize(), ie = ae.any3d ? this.options.zoomSnap : 1, le = Tt.x / Wt.x, Ce = Tt.y / Wt.y, ri = _ ? Math.max(le, Ce) : Math.min(le, Ce);
        return B = this.getScaleZoom(ri, B), ie && (B = Math.round(B / (ie / 100)) * (ie / 100), B = _ ? Math.ceil(B / ie) * ie : Math.floor(B / ie) * ie), Math.max(q, Math.min(Q, B));
      },
      // @method getSize(): Point
      // Returns the current size of the map container (in pixels).
      getSize: function() {
        return (!this._size || this._sizeChanged) && (this._size = new Y(
          this._container.clientWidth || 0,
          this._container.clientHeight || 0
        ), this._sizeChanged = !1), this._size.clone();
      },
      // @method getPixelBounds(): Bounds
      // Returns the bounds of the current map view in projected pixel
      // coordinates (sometimes useful in layer and overlay implementations).
      getPixelBounds: function(d, _) {
        var C = this._getTopLeftPoint(d, _);
        return new ht(C, C.add(this.getSize()));
      },
      // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
      // the map pane? "left point of the map layer" can be confusing, specially
      // since there can be negative offsets.
      // @method getPixelOrigin(): Point
      // Returns the projected pixel coordinates of the top left point of
      // the map layer (useful in custom layer and overlay implementations).
      getPixelOrigin: function() {
        return this._checkIfLoaded(), this._pixelOrigin;
      },
      // @method getPixelWorldBounds(zoom?: Number): Bounds
      // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
      // If `zoom` is omitted, the map's current zoom level is used.
      getPixelWorldBounds: function(d) {
        return this.options.crs.getProjectedBounds(d === void 0 ? this.getZoom() : d);
      },
      // @section Other Methods
      // @method getPane(pane: String|HTMLElement): HTMLElement
      // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
      getPane: function(d) {
        return typeof d == "string" ? this._panes[d] : d;
      },
      // @method getPanes(): Object
      // Returns a plain object containing the names of all [panes](#map-pane) as keys and
      // the panes as values.
      getPanes: function() {
        return this._panes;
      },
      // @method getContainer: HTMLElement
      // Returns the HTML element that contains the map.
      getContainer: function() {
        return this._container;
      },
      // @section Conversion Methods
      // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
      // Returns the scale factor to be applied to a map transition from zoom level
      // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
      getZoomScale: function(d, _) {
        var C = this.options.crs;
        return _ = _ === void 0 ? this._zoom : _, C.scale(d) / C.scale(_);
      },
      // @method getScaleZoom(scale: Number, fromZoom: Number): Number
      // Returns the zoom level that the map would end up at, if it is at `fromZoom`
      // level and everything is scaled by a factor of `scale`. Inverse of
      // [`getZoomScale`](#map-getZoomScale).
      getScaleZoom: function(d, _) {
        var C = this.options.crs;
        _ = _ === void 0 ? this._zoom : _;
        var B = C.zoom(d * C.scale(_));
        return isNaN(B) ? 1 / 0 : B;
      },
      // @method project(latlng: LatLng, zoom: Number): Point
      // Projects a geographical coordinate `LatLng` according to the projection
      // of the map's CRS, then scales it according to `zoom` and the CRS's
      // `Transformation`. The result is pixel coordinate relative to
      // the CRS origin.
      project: function(d, _) {
        return _ = _ === void 0 ? this._zoom : _, this.options.crs.latLngToPoint(zt(d), _);
      },
      // @method unproject(point: Point, zoom: Number): LatLng
      // Inverse of [`project`](#map-project).
      unproject: function(d, _) {
        return _ = _ === void 0 ? this._zoom : _, this.options.crs.pointToLatLng(rt(d), _);
      },
      // @method layerPointToLatLng(point: Point): LatLng
      // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
      // returns the corresponding geographical coordinate (for the current zoom level).
      layerPointToLatLng: function(d) {
        var _ = rt(d).add(this.getPixelOrigin());
        return this.unproject(_);
      },
      // @method latLngToLayerPoint(latlng: LatLng): Point
      // Given a geographical coordinate, returns the corresponding pixel coordinate
      // relative to the [origin pixel](#map-getpixelorigin).
      latLngToLayerPoint: function(d) {
        var _ = this.project(zt(d))._round();
        return _._subtract(this.getPixelOrigin());
      },
      // @method wrapLatLng(latlng: LatLng): LatLng
      // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
      // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
      // CRS's bounds.
      // By default this means longitude is wrapped around the dateline so its
      // value is between -180 and +180 degrees.
      wrapLatLng: function(d) {
        return this.options.crs.wrapLatLng(zt(d));
      },
      // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
      // Returns a `LatLngBounds` with the same size as the given one, ensuring that
      // its center is within the CRS's bounds.
      // By default this means the center longitude is wrapped around the dateline so its
      // value is between -180 and +180 degrees, and the majority of the bounds
      // overlaps the CRS's bounds.
      wrapLatLngBounds: function(d) {
        return this.options.crs.wrapLatLngBounds(St(d));
      },
      // @method distance(latlng1: LatLng, latlng2: LatLng): Number
      // Returns the distance between two geographical coordinates according to
      // the map's CRS. By default this measures distance in meters.
      distance: function(d, _) {
        return this.options.crs.distance(zt(d), zt(_));
      },
      // @method containerPointToLayerPoint(point: Point): Point
      // Given a pixel coordinate relative to the map container, returns the corresponding
      // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
      containerPointToLayerPoint: function(d) {
        return rt(d).subtract(this._getMapPanePos());
      },
      // @method layerPointToContainerPoint(point: Point): Point
      // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
      // returns the corresponding pixel coordinate relative to the map container.
      layerPointToContainerPoint: function(d) {
        return rt(d).add(this._getMapPanePos());
      },
      // @method containerPointToLatLng(point: Point): LatLng
      // Given a pixel coordinate relative to the map container, returns
      // the corresponding geographical coordinate (for the current zoom level).
      containerPointToLatLng: function(d) {
        var _ = this.containerPointToLayerPoint(rt(d));
        return this.layerPointToLatLng(_);
      },
      // @method latLngToContainerPoint(latlng: LatLng): Point
      // Given a geographical coordinate, returns the corresponding pixel coordinate
      // relative to the map container.
      latLngToContainerPoint: function(d) {
        return this.layerPointToContainerPoint(this.latLngToLayerPoint(zt(d)));
      },
      // @method mouseEventToContainerPoint(ev: MouseEvent): Point
      // Given a MouseEvent object, returns the pixel coordinate relative to the
      // map container where the event took place.
      mouseEventToContainerPoint: function(d) {
        return Zn(d, this._container);
      },
      // @method mouseEventToLayerPoint(ev: MouseEvent): Point
      // Given a MouseEvent object, returns the pixel coordinate relative to
      // the [origin pixel](#map-getpixelorigin) where the event took place.
      mouseEventToLayerPoint: function(d) {
        return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(d));
      },
      // @method mouseEventToLatLng(ev: MouseEvent): LatLng
      // Given a MouseEvent object, returns geographical coordinate where the
      // event took place.
      mouseEventToLatLng: function(d) {
        return this.layerPointToLatLng(this.mouseEventToLayerPoint(d));
      },
      // map initialization methods
      _initContainer: function(d) {
        var _ = this._container = ir(d);
        if (_) {
          if (_._leaflet_id)
            throw new Error("Map container is already initialized.");
        } else
          throw new Error("Map container not found.");
        de(_, "scroll", this._onScroll, this), this._containerId = f(_);
      },
      _initLayout: function() {
        var d = this._container;
        this._fadeAnimated = this.options.fadeAnimation && ae.any3d, pe(d, "leaflet-container" + (ae.touch ? " leaflet-touch" : "") + (ae.retina ? " leaflet-retina" : "") + (ae.ielt9 ? " leaflet-oldie" : "") + (ae.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
        var _ = $i(d, "position");
        _ !== "absolute" && _ !== "relative" && _ !== "fixed" && _ !== "sticky" && (d.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();
      },
      _initPanes: function() {
        var d = this._panes = {};
        this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), Ie(this._mapPane, new Y(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (pe(d.markerPane, "leaflet-zoom-hide"), pe(d.shadowPane, "leaflet-zoom-hide"));
      },
      // private methods that modify map state
      // @section Map state change events
      _resetView: function(d, _, C) {
        Ie(this._mapPane, new Y(0, 0));
        var B = !this._loaded;
        this._loaded = !0, _ = this._limitZoom(_), this.fire("viewprereset");
        var q = this._zoom !== _;
        this._moveStart(q, C)._move(d, _)._moveEnd(q), this.fire("viewreset"), B && this.fire("load");
      },
      _moveStart: function(d, _) {
        return d && this.fire("zoomstart"), _ || this.fire("movestart"), this;
      },
      _move: function(d, _, C, B) {
        _ === void 0 && (_ = this._zoom);
        var q = this._zoom !== _;
        return this._zoom = _, this._lastCenter = d, this._pixelOrigin = this._getNewPixelOrigin(d), B ? C && C.pinch && this.fire("zoom", C) : ((q || C && C.pinch) && this.fire("zoom", C), this.fire("move", C)), this;
      },
      _moveEnd: function(d) {
        return d && this.fire("zoomend"), this.fire("moveend");
      },
      _stop: function() {
        return ct(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
      },
      _rawPanBy: function(d) {
        Ie(this._mapPane, this._getMapPanePos().subtract(d));
      },
      _getZoomSpan: function() {
        return this.getMaxZoom() - this.getMinZoom();
      },
      _panInsideMaxBounds: function() {
        this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
      },
      _checkIfLoaded: function() {
        if (!this._loaded)
          throw new Error("Set map center and zoom first.");
      },
      // DOM event handling
      // @section Interaction events
      _initEvents: function(d) {
        this._targets = {}, this._targets[f(this._container)] = this;
        var _ = d ? Fe : de;
        _(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && _(window, "resize", this._onResize, this), ae.any3d && this.options.transform3DLimit && (d ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
      },
      _onResize: function() {
        ct(this._resizeRequest), this._resizeRequest = pt(
          function() {
            this.invalidateSize({ debounceMoveend: !0 });
          },
          this
        );
      },
      _onScroll: function() {
        this._container.scrollTop = 0, this._container.scrollLeft = 0;
      },
      _onMoveEnd: function() {
        var d = this._getMapPanePos();
        Math.max(Math.abs(d.x), Math.abs(d.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
      },
      _findEventTargets: function(d, _) {
        for (var C = [], B, q = _ === "mouseout" || _ === "mouseover", Q = d.target || d.srcElement, dt = !1; Q; ) {
          if (B = this._targets[f(Q)], B && (_ === "click" || _ === "preclick") && this._draggableMoved(B)) {
            dt = !0;
            break;
          }
          if (B && B.listens(_, !0) && (q && !Cn(Q, d) || (C.push(B), q)) || Q === this._container)
            break;
          Q = Q.parentNode;
        }
        return !C.length && !dt && !q && this.listens(_, !0) && (C = [this]), C;
      },
      _isClickDisabled: function(d) {
        for (; d && d !== this._container; ) {
          if (d._leaflet_disable_click)
            return !0;
          d = d.parentNode;
        }
      },
      _handleDOMEvent: function(d) {
        var _ = d.target || d.srcElement;
        if (!(!this._loaded || _._leaflet_disable_events || d.type === "click" && this._isClickDisabled(_))) {
          var C = d.type;
          C === "mousedown" && bn(_), this._fireDOMEvent(d, C);
        }
      },
      _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
      _fireDOMEvent: function(d, _, C) {
        if (d.type === "click") {
          var B = l({}, d);
          B.type = "preclick", this._fireDOMEvent(B, B.type, C);
        }
        var q = this._findEventTargets(d, _);
        if (C) {
          for (var Q = [], dt = 0; dt < C.length; dt++)
            C[dt].listens(_, !0) && Q.push(C[dt]);
          q = Q.concat(q);
        }
        if (q.length) {
          _ === "contextmenu" && He(d);
          var Dt = q[0], Tt = {
            originalEvent: d
          };
          if (d.type !== "keypress" && d.type !== "keydown" && d.type !== "keyup") {
            var Wt = Dt.getLatLng && (!Dt._radius || Dt._radius <= 10);
            Tt.containerPoint = Wt ? this.latLngToContainerPoint(Dt.getLatLng()) : this.mouseEventToContainerPoint(d), Tt.layerPoint = this.containerPointToLayerPoint(Tt.containerPoint), Tt.latlng = Wt ? Dt.getLatLng() : this.layerPointToLatLng(Tt.layerPoint);
          }
          for (dt = 0; dt < q.length; dt++)
            if (q[dt].fire(_, Tt, !0), Tt.originalEvent._stopped || q[dt].options.bubblingMouseEvents === !1 && H(this._mouseEvents, _) !== -1)
              return;
        }
      },
      _draggableMoved: function(d) {
        return d = d.dragging && d.dragging.enabled() ? d : this, d.dragging && d.dragging.moved() || this.boxZoom && this.boxZoom.moved();
      },
      _clearHandlers: function() {
        for (var d = 0, _ = this._handlers.length; d < _; d++)
          this._handlers[d].disable();
      },
      // @section Other Methods
      // @method whenReady(fn: Function, context?: Object): this
      // Runs the given function `fn` when the map gets initialized with
      // a view (center and zoom) and at least one layer, or immediately
      // if it's already initialized, optionally passing a function context.
      whenReady: function(d, _) {
        return this._loaded ? d.call(_ || this, { target: this }) : this.on("load", d, _), this;
      },
      // private methods for getting map state
      _getMapPanePos: function() {
        return fi(this._mapPane) || new Y(0, 0);
      },
      _moved: function() {
        var d = this._getMapPanePos();
        return d && !d.equals([0, 0]);
      },
      _getTopLeftPoint: function(d, _) {
        var C = d && _ !== void 0 ? this._getNewPixelOrigin(d, _) : this.getPixelOrigin();
        return C.subtract(this._getMapPanePos());
      },
      _getNewPixelOrigin: function(d, _) {
        var C = this.getSize()._divideBy(2);
        return this.project(d, _)._subtract(C)._add(this._getMapPanePos())._round();
      },
      _latLngToNewLayerPoint: function(d, _, C) {
        var B = this._getNewPixelOrigin(C, _);
        return this.project(d, _)._subtract(B);
      },
      _latLngBoundsToNewLayerBounds: function(d, _, C) {
        var B = this._getNewPixelOrigin(C, _);
        return bt([
          this.project(d.getSouthWest(), _)._subtract(B),
          this.project(d.getNorthWest(), _)._subtract(B),
          this.project(d.getSouthEast(), _)._subtract(B),
          this.project(d.getNorthEast(), _)._subtract(B)
        ]);
      },
      // layer point of the current center
      _getCenterLayerPoint: function() {
        return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
      },
      // offset of the specified place to the current center in pixels
      _getCenterOffset: function(d) {
        return this.latLngToLayerPoint(d).subtract(this._getCenterLayerPoint());
      },
      // adjust center for view to get inside bounds
      _limitCenter: function(d, _, C) {
        if (!C)
          return d;
        var B = this.project(d, _), q = this.getSize().divideBy(2), Q = new ht(B.subtract(q), B.add(q)), dt = this._getBoundsOffset(Q, C, _);
        return Math.abs(dt.x) <= 1 && Math.abs(dt.y) <= 1 ? d : this.unproject(B.add(dt), _);
      },
      // adjust offset for view to get inside bounds
      _limitOffset: function(d, _) {
        if (!_)
          return d;
        var C = this.getPixelBounds(), B = new ht(C.min.add(d), C.max.add(d));
        return d.add(this._getBoundsOffset(B, _));
      },
      // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
      _getBoundsOffset: function(d, _, C) {
        var B = bt(
          this.project(_.getNorthEast(), C),
          this.project(_.getSouthWest(), C)
        ), q = B.min.subtract(d.min), Q = B.max.subtract(d.max), dt = this._rebound(q.x, -Q.x), Dt = this._rebound(q.y, -Q.y);
        return new Y(dt, Dt);
      },
      _rebound: function(d, _) {
        return d + _ > 0 ? Math.round(d - _) / 2 : Math.max(0, Math.ceil(d)) - Math.max(0, Math.floor(_));
      },
      _limitZoom: function(d) {
        var _ = this.getMinZoom(), C = this.getMaxZoom(), B = ae.any3d ? this.options.zoomSnap : 1;
        return B && (d = Math.round(d / B) * B), Math.max(_, Math.min(C, d));
      },
      _onPanTransitionStep: function() {
        this.fire("move");
      },
      _onPanTransitionEnd: function() {
        Ne(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
      },
      _tryAnimatedPan: function(d, _) {
        var C = this._getCenterOffset(d)._trunc();
        return (_ && _.animate) !== !0 && !this.getSize().contains(C) ? !1 : (this.panBy(C, _), !0);
      },
      _createAnimProxy: function() {
        var d = this._proxy = Me("div", "leaflet-proxy leaflet-zoom-animated");
        this._panes.mapPane.appendChild(d), this.on("zoomanim", function(_) {
          var C = Gi, B = this._proxy.style[C];
          Ge(this._proxy, this.project(_.center, _.zoom), this.getZoomScale(_.zoom, 1)), B === this._proxy.style[C] && this._animatingZoom && this._onZoomTransitionEnd();
        }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
      },
      _destroyAnimProxy: function() {
        ke(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
      },
      _animMoveEnd: function() {
        var d = this.getCenter(), _ = this.getZoom();
        Ge(this._proxy, this.project(d, _), this.getZoomScale(_, 1));
      },
      _catchTransitionEnd: function(d) {
        this._animatingZoom && d.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();
      },
      _nothingToAnimate: function() {
        return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
      },
      _tryAnimatedZoom: function(d, _, C) {
        if (this._animatingZoom)
          return !0;
        if (C = C || {}, !this._zoomAnimated || C.animate === !1 || this._nothingToAnimate() || Math.abs(_ - this._zoom) > this.options.zoomAnimationThreshold)
          return !1;
        var B = this.getZoomScale(_), q = this._getCenterOffset(d)._divideBy(1 - 1 / B);
        return C.animate !== !0 && !this.getSize().contains(q) ? !1 : (pt(function() {
          this._moveStart(!0, C.noMoveStart || !1)._animateZoom(d, _, !0);
        }, this), !0);
      },
      _animateZoom: function(d, _, C, B) {
        this._mapPane && (C && (this._animatingZoom = !0, this._animateToCenter = d, this._animateToZoom = _, pe(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
          center: d,
          zoom: _,
          noUpdate: B
        }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(h(this._onZoomTransitionEnd, this), 250));
      },
      _onZoomTransitionEnd: function() {
        this._animatingZoom && (this._mapPane && Ne(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0));
      }
    });
    function Dn(d, _) {
      return new Ee(d, _);
    }
    var oi = kt.extend({
      // @section
      // @aka Control Options
      options: {
        // @option position: String = 'topright'
        // The position of the control (one of the map corners). Possible values are `'topleft'`,
        // `'topright'`, `'bottomleft'` or `'bottomright'`
        position: "topright"
      },
      initialize: function(d) {
        x(this, d);
      },
      /* @section
       * Classes extending L.Control will inherit the following methods:
       *
       * @method getPosition: string
       * Returns the position of the control.
       */
      getPosition: function() {
        return this.options.position;
      },
      // @method setPosition(position: string): this
      // Sets the position of the control.
      setPosition: function(d) {
        var _ = this._map;
        return _ && _.removeControl(this), this.options.position = d, _ && _.addControl(this), this;
      },
      // @method getContainer: HTMLElement
      // Returns the HTMLElement that contains the control.
      getContainer: function() {
        return this._container;
      },
      // @method addTo(map: Map): this
      // Adds the control to the given map.
      addTo: function(d) {
        this.remove(), this._map = d;
        var _ = this._container = this.onAdd(d), C = this.getPosition(), B = d._controlCorners[C];
        return pe(_, "leaflet-control"), C.indexOf("bottom") !== -1 ? B.insertBefore(_, B.firstChild) : B.appendChild(_), this._map.on("unload", this.remove, this), this;
      },
      // @method remove: this
      // Removes the control from the map it is currently active on.
      remove: function() {
        return this._map ? (ke(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null, this) : this;
      },
      _refocusOnMap: function(d) {
        this._map && d && d.screenX > 0 && d.screenY > 0 && this._map.getContainer().focus();
      }
    }), Zi = function(d) {
      return new oi(d);
    };
    Ee.include({
      // @method addControl(control: Control): this
      // Adds the given control to the map
      addControl: function(d) {
        return d.addTo(this), this;
      },
      // @method removeControl(control: Control): this
      // Removes the given control from the map
      removeControl: function(d) {
        return d.remove(), this;
      },
      _initControlPos: function() {
        var d = this._controlCorners = {}, _ = "leaflet-", C = this._controlContainer = Me("div", _ + "control-container", this._container);
        function B(q, Q) {
          var dt = _ + q + " " + _ + Q;
          d[q + Q] = Me("div", dt, C);
        }
        B("top", "left"), B("top", "right"), B("bottom", "left"), B("bottom", "right");
      },
      _clearControlPos: function() {
        for (var d in this._controlCorners)
          ke(this._controlCorners[d]);
        ke(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
      }
    });
    var Cr = oi.extend({
      // @section
      // @aka Control.Layers options
      options: {
        // @option collapsed: Boolean = true
        // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
        collapsed: !0,
        position: "topright",
        // @option autoZIndex: Boolean = true
        // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
        autoZIndex: !0,
        // @option hideSingleBase: Boolean = false
        // If `true`, the base layers in the control will be hidden when there is only one.
        hideSingleBase: !1,
        // @option sortLayers: Boolean = false
        // Whether to sort the layers. When `false`, layers will keep the order
        // in which they were added to the control.
        sortLayers: !1,
        // @option sortFunction: Function = *
        // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
        // that will be used for sorting the layers, when `sortLayers` is `true`.
        // The function receives both the `L.Layer` instances and their names, as in
        // `sortFunction(layerA, layerB, nameA, nameB)`.
        // By default, it sorts layers alphabetically by their name.
        sortFunction: function(d, _, C, B) {
          return C < B ? -1 : B < C ? 1 : 0;
        }
      },
      initialize: function(d, _, C) {
        x(this, C), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, this._preventClick = !1;
        for (var B in d)
          this._addLayer(d[B], B);
        for (B in _)
          this._addLayer(_[B], B, !0);
      },
      onAdd: function(d) {
        this._initLayout(), this._update(), this._map = d, d.on("zoomend", this._checkDisabledLayers, this);
        for (var _ = 0; _ < this._layers.length; _++)
          this._layers[_].layer.on("add remove", this._onLayerChange, this);
        return this._container;
      },
      addTo: function(d) {
        return oi.prototype.addTo.call(this, d), this._expandIfNotCollapsed();
      },
      onRemove: function() {
        this._map.off("zoomend", this._checkDisabledLayers, this);
        for (var d = 0; d < this._layers.length; d++)
          this._layers[d].layer.off("add remove", this._onLayerChange, this);
      },
      // @method addBaseLayer(layer: Layer, name: String): this
      // Adds a base layer (radio button entry) with the given name to the control.
      addBaseLayer: function(d, _) {
        return this._addLayer(d, _), this._map ? this._update() : this;
      },
      // @method addOverlay(layer: Layer, name: String): this
      // Adds an overlay (checkbox entry) with the given name to the control.
      addOverlay: function(d, _) {
        return this._addLayer(d, _, !0), this._map ? this._update() : this;
      },
      // @method removeLayer(layer: Layer): this
      // Remove the given layer from the control.
      removeLayer: function(d) {
        d.off("add remove", this._onLayerChange, this);
        var _ = this._getLayer(f(d));
        return _ && this._layers.splice(this._layers.indexOf(_), 1), this._map ? this._update() : this;
      },
      // @method expand(): this
      // Expand the control container if collapsed.
      expand: function() {
        pe(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
        var d = this._map.getSize().y - (this._container.offsetTop + 50);
        return d < this._section.clientHeight ? (pe(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = d + "px") : Ne(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this;
      },
      // @method collapse(): this
      // Collapse the control container if expanded.
      collapse: function() {
        return Ne(this._container, "leaflet-control-layers-expanded"), this;
      },
      _initLayout: function() {
        var d = "leaflet-control-layers", _ = this._container = Me("div", d), C = this.options.collapsed;
        _.setAttribute("aria-haspopup", !0), wn(_), hr(_);
        var B = this._section = Me("section", d + "-list");
        C && (this._map.on("click", this.collapse, this), de(_, {
          mouseenter: this._expandSafely,
          mouseleave: this.collapse
        }, this));
        var q = this._layersLink = Me("a", d + "-toggle", _);
        q.href = "#", q.title = "Layers", q.setAttribute("role", "button"), de(q, {
          keydown: function(Q) {
            Q.keyCode === 13 && this._expandSafely();
          },
          // Certain screen readers intercept the key event and instead send a click event
          click: function(Q) {
            He(Q), this._expandSafely();
          }
        }, this), C || this.expand(), this._baseLayersList = Me("div", d + "-base", B), this._separator = Me("div", d + "-separator", B), this._overlaysList = Me("div", d + "-overlays", B), _.appendChild(B);
      },
      _getLayer: function(d) {
        for (var _ = 0; _ < this._layers.length; _++)
          if (this._layers[_] && f(this._layers[_].layer) === d)
            return this._layers[_];
      },
      _addLayer: function(d, _, C) {
        this._map && d.on("add remove", this._onLayerChange, this), this._layers.push({
          layer: d,
          name: _,
          overlay: C
        }), this.options.sortLayers && this._layers.sort(h(function(B, q) {
          return this.options.sortFunction(B.layer, q.layer, B.name, q.name);
        }, this)), this.options.autoZIndex && d.setZIndex && (this._lastZIndex++, d.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();
      },
      _update: function() {
        if (!this._container)
          return this;
        qe(this._baseLayersList), qe(this._overlaysList), this._layerControlInputs = [];
        var d, _, C, B, q = 0;
        for (C = 0; C < this._layers.length; C++)
          B = this._layers[C], this._addItem(B), _ = _ || B.overlay, d = d || !B.overlay, q += B.overlay ? 0 : 1;
        return this.options.hideSingleBase && (d = d && q > 1, this._baseLayersList.style.display = d ? "" : "none"), this._separator.style.display = _ && d ? "" : "none", this;
      },
      _onLayerChange: function(d) {
        this._handlingClick || this._update();
        var _ = this._getLayer(f(d.target)), C = _.overlay ? d.type === "add" ? "overlayadd" : "overlayremove" : d.type === "add" ? "baselayerchange" : null;
        C && this._map.fire(C, _);
      },
      // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
      _createRadioElement: function(d, _) {
        var C = '<input type="radio" class="leaflet-control-layers-selector" name="' + d + '"' + (_ ? ' checked="checked"' : "") + "/>", B = document.createElement("div");
        return B.innerHTML = C, B.firstChild;
      },
      _addItem: function(d) {
        var _ = document.createElement("label"), C = this._map.hasLayer(d.layer), B;
        d.overlay ? (B = document.createElement("input"), B.type = "checkbox", B.className = "leaflet-control-layers-selector", B.defaultChecked = C) : B = this._createRadioElement("leaflet-base-layers_" + f(this), C), this._layerControlInputs.push(B), B.layerId = f(d.layer), de(B, "click", this._onInputClick, this);
        var q = document.createElement("span");
        q.innerHTML = " " + d.name;
        var Q = document.createElement("span");
        _.appendChild(Q), Q.appendChild(B), Q.appendChild(q);
        var dt = d.overlay ? this._overlaysList : this._baseLayersList;
        return dt.appendChild(_), this._checkDisabledLayers(), _;
      },
      _onInputClick: function() {
        if (!this._preventClick) {
          var d = this._layerControlInputs, _, C, B = [], q = [];
          this._handlingClick = !0;
          for (var Q = d.length - 1; Q >= 0; Q--)
            _ = d[Q], C = this._getLayer(_.layerId).layer, _.checked ? B.push(C) : _.checked || q.push(C);
          for (Q = 0; Q < q.length; Q++)
            this._map.hasLayer(q[Q]) && this._map.removeLayer(q[Q]);
          for (Q = 0; Q < B.length; Q++)
            this._map.hasLayer(B[Q]) || this._map.addLayer(B[Q]);
          this._handlingClick = !1, this._refocusOnMap();
        }
      },
      _checkDisabledLayers: function() {
        for (var d = this._layerControlInputs, _, C, B = this._map.getZoom(), q = d.length - 1; q >= 0; q--)
          _ = d[q], C = this._getLayer(_.layerId).layer, _.disabled = C.options.minZoom !== void 0 && B < C.options.minZoom || C.options.maxZoom !== void 0 && B > C.options.maxZoom;
      },
      _expandIfNotCollapsed: function() {
        return this._map && !this.options.collapsed && this.expand(), this;
      },
      _expandSafely: function() {
        var d = this._section;
        this._preventClick = !0, de(d, "click", He), this.expand();
        var _ = this;
        setTimeout(function() {
          Fe(d, "click", He), _._preventClick = !1;
        });
      }
    }), Fr = function(d, _, C) {
      return new Cr(d, _, C);
    }, fr = oi.extend({
      // @section
      // @aka Control.Zoom options
      options: {
        position: "topleft",
        // @option zoomInText: String = '<span aria-hidden="true">+</span>'
        // The text set on the 'zoom in' button.
        zoomInText: '<span aria-hidden="true">+</span>',
        // @option zoomInTitle: String = 'Zoom in'
        // The title set on the 'zoom in' button.
        zoomInTitle: "Zoom in",
        // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
        // The text set on the 'zoom out' button.
        zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
        // @option zoomOutTitle: String = 'Zoom out'
        // The title set on the 'zoom out' button.
        zoomOutTitle: "Zoom out"
      },
      onAdd: function(d) {
        var _ = "leaflet-control-zoom", C = Me("div", _ + " leaflet-bar"), B = this.options;
        return this._zoomInButton = this._createButton(
          B.zoomInText,
          B.zoomInTitle,
          _ + "-in",
          C,
          this._zoomIn
        ), this._zoomOutButton = this._createButton(
          B.zoomOutText,
          B.zoomOutTitle,
          _ + "-out",
          C,
          this._zoomOut
        ), this._updateDisabled(), d.on("zoomend zoomlevelschange", this._updateDisabled, this), C;
      },
      onRemove: function(d) {
        d.off("zoomend zoomlevelschange", this._updateDisabled, this);
      },
      disable: function() {
        return this._disabled = !0, this._updateDisabled(), this;
      },
      enable: function() {
        return this._disabled = !1, this._updateDisabled(), this;
      },
      _zoomIn: function(d) {
        !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (d.shiftKey ? 3 : 1));
      },
      _zoomOut: function(d) {
        !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (d.shiftKey ? 3 : 1));
      },
      _createButton: function(d, _, C, B, q) {
        var Q = Me("a", C, B);
        return Q.innerHTML = d, Q.href = "#", Q.title = _, Q.setAttribute("role", "button"), Q.setAttribute("aria-label", _), wn(Q), de(Q, "click", Ni), de(Q, "click", q, this), de(Q, "click", this._refocusOnMap, this), Q;
      },
      _updateDisabled: function() {
        var d = this._map, _ = "leaflet-disabled";
        Ne(this._zoomInButton, _), Ne(this._zoomOutButton, _), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), (this._disabled || d._zoom === d.getMinZoom()) && (pe(this._zoomOutButton, _), this._zoomOutButton.setAttribute("aria-disabled", "true")), (this._disabled || d._zoom === d.getMaxZoom()) && (pe(this._zoomInButton, _), this._zoomInButton.setAttribute("aria-disabled", "true"));
      }
    });
    Ee.mergeOptions({
      zoomControl: !0
    }), Ee.addInitHook(function() {
      this.options.zoomControl && (this.zoomControl = new fr(), this.addControl(this.zoomControl));
    });
    var b = function(d) {
      return new fr(d);
    }, T = oi.extend({
      // @section
      // @aka Control.Scale options
      options: {
        position: "bottomleft",
        // @option maxWidth: Number = 100
        // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
        maxWidth: 100,
        // @option metric: Boolean = True
        // Whether to show the metric scale line (m/km).
        metric: !0,
        // @option imperial: Boolean = True
        // Whether to show the imperial scale line (mi/ft).
        imperial: !0
        // @option updateWhenIdle: Boolean = false
        // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
      },
      onAdd: function(d) {
        var _ = "leaflet-control-scale", C = Me("div", _), B = this.options;
        return this._addScales(B, _ + "-line", C), d.on(B.updateWhenIdle ? "moveend" : "move", this._update, this), d.whenReady(this._update, this), C;
      },
      onRemove: function(d) {
        d.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
      },
      _addScales: function(d, _, C) {
        d.metric && (this._mScale = Me("div", _, C)), d.imperial && (this._iScale = Me("div", _, C));
      },
      _update: function() {
        var d = this._map, _ = d.getSize().y / 2, C = d.distance(
          d.containerPointToLatLng([0, _]),
          d.containerPointToLatLng([this.options.maxWidth, _])
        );
        this._updateScales(C);
      },
      _updateScales: function(d) {
        this.options.metric && d && this._updateMetric(d), this.options.imperial && d && this._updateImperial(d);
      },
      _updateMetric: function(d) {
        var _ = this._getRoundNum(d), C = _ < 1e3 ? _ + " m" : _ / 1e3 + " km";
        this._updateScale(this._mScale, C, _ / d);
      },
      _updateImperial: function(d) {
        var _ = d * 3.2808399, C, B, q;
        _ > 5280 ? (C = _ / 5280, B = this._getRoundNum(C), this._updateScale(this._iScale, B + " mi", B / C)) : (q = this._getRoundNum(_), this._updateScale(this._iScale, q + " ft", q / _));
      },
      _updateScale: function(d, _, C) {
        d.style.width = Math.round(this.options.maxWidth * C) + "px", d.innerHTML = _;
      },
      _getRoundNum: function(d) {
        var _ = Math.pow(10, (Math.floor(d) + "").length - 1), C = d / _;
        return C = C >= 10 ? 10 : C >= 5 ? 5 : C >= 3 ? 3 : C >= 2 ? 2 : 1, _ * C;
      }
    }), z = function(d) {
      return new T(d);
    }, W = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>', U = oi.extend({
      // @section
      // @aka Control.Attribution options
      options: {
        position: "bottomright",
        // @option prefix: String|false = 'Leaflet'
        // The HTML text shown before the attributions. Pass `false` to disable.
        prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (ae.inlineSvg ? W + " " : "") + "Leaflet</a>"
      },
      initialize: function(d) {
        x(this, d), this._attributions = {};
      },
      onAdd: function(d) {
        d.attributionControl = this, this._container = Me("div", "leaflet-control-attribution"), wn(this._container);
        for (var _ in d._layers)
          d._layers[_].getAttribution && this.addAttribution(d._layers[_].getAttribution());
        return this._update(), d.on("layeradd", this._addAttribution, this), this._container;
      },
      onRemove: function(d) {
        d.off("layeradd", this._addAttribution, this);
      },
      _addAttribution: function(d) {
        d.layer.getAttribution && (this.addAttribution(d.layer.getAttribution()), d.layer.once("remove", function() {
          this.removeAttribution(d.layer.getAttribution());
        }, this));
      },
      // @method setPrefix(prefix: String|false): this
      // The HTML text shown before the attributions. Pass `false` to disable.
      setPrefix: function(d) {
        return this.options.prefix = d, this._update(), this;
      },
      // @method addAttribution(text: String): this
      // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
      addAttribution: function(d) {
        return d ? (this._attributions[d] || (this._attributions[d] = 0), this._attributions[d]++, this._update(), this) : this;
      },
      // @method removeAttribution(text: String): this
      // Removes an attribution text.
      removeAttribution: function(d) {
        return d ? (this._attributions[d] && (this._attributions[d]--, this._update()), this) : this;
      },
      _update: function() {
        if (this._map) {
          var d = [];
          for (var _ in this._attributions)
            this._attributions[_] && d.push(_);
          var C = [];
          this.options.prefix && C.push(this.options.prefix), d.length && C.push(d.join(", ")), this._container.innerHTML = C.join(' <span aria-hidden="true">|</span> ');
        }
      }
    });
    Ee.mergeOptions({
      attributionControl: !0
    }), Ee.addInitHook(function() {
      this.options.attributionControl && new U().addTo(this);
    });
    var X = function(d) {
      return new U(d);
    };
    oi.Layers = Cr, oi.Zoom = fr, oi.Scale = T, oi.Attribution = U, Zi.layers = Fr, Zi.zoom = b, Zi.scale = z, Zi.attribution = X;
    var K = kt.extend({
      initialize: function(d) {
        this._map = d;
      },
      // @method enable(): this
      // Enables the handler
      enable: function() {
        return this._enabled ? this : (this._enabled = !0, this.addHooks(), this);
      },
      // @method disable(): this
      // Disables the handler
      disable: function() {
        return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
      },
      // @method enabled(): Boolean
      // Returns `true` if the handler is enabled
      enabled: function() {
        return !!this._enabled;
      }
      // @section Extension methods
      // Classes inheriting from `Handler` must implement the two following methods:
      // @method addHooks()
      // Called when the handler is enabled, should add event hooks.
      // @method removeHooks()
      // Called when the handler is disabled, should remove the event hooks added previously.
    });
    K.addTo = function(d, _) {
      return d.addHandler(_, this), this;
    };
    var ut = { Events: Mt }, lt = ae.touch ? "touchstart mousedown" : "mousedown", _t = G.extend({
      options: {
        // @section
        // @aka Draggable options
        // @option clickTolerance: Number = 3
        // The max number of pixels a user can shift the mouse pointer during a click
        // for it to be considered a valid click (as opposed to a mouse drag).
        clickTolerance: 3
      },
      // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
      // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
      initialize: function(d, _, C, B) {
        x(this, B), this._element = d, this._dragStartTarget = _ || d, this._preventOutline = C;
      },
      // @method enable()
      // Enables the dragging ability
      enable: function() {
        this._enabled || (de(this._dragStartTarget, lt, this._onDown, this), this._enabled = !0);
      },
      // @method disable()
      // Disables the dragging ability
      disable: function() {
        this._enabled && (_t._dragging === this && this.finishDrag(!0), Fe(this._dragStartTarget, lt, this._onDown, this), this._enabled = !1, this._moved = !1);
      },
      _onDown: function(d) {
        if (this._enabled && (this._moved = !1, !nr(this._element, "leaflet-zoom-anim"))) {
          if (d.touches && d.touches.length !== 1) {
            _t._dragging === this && this.finishDrag();
            return;
          }
          if (!(_t._dragging || d.shiftKey || d.which !== 1 && d.button !== 1 && !d.touches) && (_t._dragging = this, this._preventOutline && bn(this._element), yn(), mn(), !this._moving)) {
            this.fire("down");
            var _ = d.touches ? d.touches[0] : d, C = ar(this._element);
            this._startPoint = new Y(_.clientX, _.clientY), this._startPos = fi(this._element), this._parentScale = or(C);
            var B = d.type === "mousedown";
            de(document, B ? "mousemove" : "touchmove", this._onMove, this), de(document, B ? "mouseup" : "touchend touchcancel", this._onUp, this);
          }
        }
      },
      _onMove: function(d) {
        if (this._enabled) {
          if (d.touches && d.touches.length > 1) {
            this._moved = !0;
            return;
          }
          var _ = d.touches && d.touches.length === 1 ? d.touches[0] : d, C = new Y(_.clientX, _.clientY)._subtract(this._startPoint);
          !C.x && !C.y || Math.abs(C.x) + Math.abs(C.y) < this.options.clickTolerance || (C.x /= this._parentScale.x, C.y /= this._parentScale.y, He(d), this._moved || (this.fire("dragstart"), this._moved = !0, pe(document.body, "leaflet-dragging"), this._lastTarget = d.target || d.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), pe(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(C), this._moving = !0, this._lastEvent = d, this._updatePosition());
        }
      },
      _updatePosition: function() {
        var d = { originalEvent: this._lastEvent };
        this.fire("predrag", d), Ie(this._element, this._newPos), this.fire("drag", d);
      },
      _onUp: function() {
        this._enabled && this.finishDrag();
      },
      finishDrag: function(d) {
        Ne(document.body, "leaflet-dragging"), this._lastTarget && (Ne(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), Fe(document, "mousemove touchmove", this._onMove, this), Fe(document, "mouseup touchend touchcancel", this._onUp, this), rr(), _n();
        var _ = this._moved && this._moving;
        this._moving = !1, _t._dragging = !1, _ && this.fire("dragend", {
          noInertia: d,
          distance: this._newPos.distanceTo(this._startPos)
        });
      }
    });
    function Lt(d, _, C) {
      var B, q = [1, 4, 2, 8], Q, dt, Dt, Tt, Wt, ie, le, Ce;
      for (Q = 0, ie = d.length; Q < ie; Q++)
        d[Q]._code = me(d[Q], _);
      for (Dt = 0; Dt < 4; Dt++) {
        for (le = q[Dt], B = [], Q = 0, ie = d.length, dt = ie - 1; Q < ie; dt = Q++)
          Tt = d[Q], Wt = d[dt], Tt._code & le ? Wt._code & le || (Ce = Ci(Wt, Tt, le, _, C), Ce._code = me(Ce, _), B.push(Ce)) : (Wt._code & le && (Ce = Ci(Wt, Tt, le, _, C), Ce._code = me(Ce, _), B.push(Ce)), B.push(Tt));
        d = B;
      }
      return d;
    }
    function Bt(d, _) {
      var C, B, q, Q, dt, Dt, Tt, Wt, ie;
      if (!d || d.length === 0)
        throw new Error("latlngs not passed");
      ei(d) || (console.warn("latlngs are not flat! Only the first ring will be used"), d = d[0]);
      var le = zt([0, 0]), Ce = St(d), ri = Ce.getNorthWest().distanceTo(Ce.getSouthWest()) * Ce.getNorthEast().distanceTo(Ce.getNorthWest());
      ri < 1700 && (le = Pt(d));
      var Ye = d.length, Ai = [];
      for (C = 0; C < Ye; C++) {
        var hi = zt(d[C]);
        Ai.push(_.project(zt([hi.lat - le.lat, hi.lng - le.lng])));
      }
      for (Dt = Tt = Wt = 0, C = 0, B = Ye - 1; C < Ye; B = C++)
        q = Ai[C], Q = Ai[B], dt = q.y * Q.x - Q.y * q.x, Tt += (q.x + Q.x) * dt, Wt += (q.y + Q.y) * dt, Dt += dt * 3;
      Dt === 0 ? ie = Ai[0] : ie = [Tt / Dt, Wt / Dt];
      var Qn = _.unproject(rt(ie));
      return zt([Qn.lat + le.lat, Qn.lng + le.lng]);
    }
    function Pt(d) {
      for (var _ = 0, C = 0, B = 0, q = 0; q < d.length; q++) {
        var Q = zt(d[q]);
        _ += Q.lat, C += Q.lng, B++;
      }
      return zt([_ / B, C / B]);
    }
    var Vt = {
      __proto__: null,
      clipPolygon: Lt,
      polygonCenter: Bt,
      centroid: Pt
    };
    function se(d, _) {
      if (!_ || !d.length)
        return d.slice();
      var C = _ * _;
      return d = wi(d, C), d = Ue(d, C), d;
    }
    function De(d, _, C) {
      return Math.sqrt(Oi(d, _, C, !0));
    }
    function ge(d, _, C) {
      return Oi(d, _, C);
    }
    function Ue(d, _) {
      var C = d.length, B = typeof Uint8Array < "u" ? Uint8Array : Array, q = new B(C);
      q[0] = q[C - 1] = 1, Be(d, q, _, 0, C - 1);
      var Q, dt = [];
      for (Q = 0; Q < C; Q++)
        q[Q] && dt.push(d[Q]);
      return dt;
    }
    function Be(d, _, C, B, q) {
      var Q = 0, dt, Dt, Tt;
      for (Dt = B + 1; Dt <= q - 1; Dt++)
        Tt = Oi(d[Dt], d[B], d[q], !0), Tt > Q && (dt = Dt, Q = Tt);
      Q > C && (_[dt] = 1, Be(d, _, C, B, dt), Be(d, _, C, dt, q));
    }
    function wi(d, _) {
      for (var C = [d[0]], B = 1, q = 0, Q = d.length; B < Q; B++)
        Oe(d[B], d[q]) > _ && (C.push(d[B]), q = B);
      return q < Q - 1 && C.push(d[Q - 1]), C;
    }
    var gi;
    function ye(d, _, C, B, q) {
      var Q = B ? gi : me(d, C), dt = me(_, C), Dt, Tt, Wt;
      for (gi = dt; ; ) {
        if (!(Q | dt))
          return [d, _];
        if (Q & dt)
          return !1;
        Dt = Q || dt, Tt = Ci(d, _, Dt, C, q), Wt = me(Tt, C), Dt === Q ? (d = Tt, Q = Wt) : (_ = Tt, dt = Wt);
      }
    }
    function Ci(d, _, C, B, q) {
      var Q = _.x - d.x, dt = _.y - d.y, Dt = B.min, Tt = B.max, Wt, ie;
      return C & 8 ? (Wt = d.x + Q * (Tt.y - d.y) / dt, ie = Tt.y) : C & 4 ? (Wt = d.x + Q * (Dt.y - d.y) / dt, ie = Dt.y) : C & 2 ? (Wt = Tt.x, ie = d.y + dt * (Tt.x - d.x) / Q) : C & 1 && (Wt = Dt.x, ie = d.y + dt * (Dt.x - d.x) / Q), new Y(Wt, ie, q);
    }
    function me(d, _) {
      var C = 0;
      return d.x < _.min.x ? C |= 1 : d.x > _.max.x && (C |= 2), d.y < _.min.y ? C |= 4 : d.y > _.max.y && (C |= 8), C;
    }
    function Oe(d, _) {
      var C = _.x - d.x, B = _.y - d.y;
      return C * C + B * B;
    }
    function Oi(d, _, C, B) {
      var q = _.x, Q = _.y, dt = C.x - q, Dt = C.y - Q, Tt = dt * dt + Dt * Dt, Wt;
      return Tt > 0 && (Wt = ((d.x - q) * dt + (d.y - Q) * Dt) / Tt, Wt > 1 ? (q = C.x, Q = C.y) : Wt > 0 && (q += dt * Wt, Q += Dt * Wt)), dt = d.x - q, Dt = d.y - Q, B ? dt * dt + Dt * Dt : new Y(q, Q);
    }
    function ei(d) {
      return !N(d[0]) || typeof d[0][0] != "object" && typeof d[0][0] < "u";
    }
    function vi(d) {
      return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), ei(d);
    }
    function tn(d, _) {
      var C, B, q, Q, dt, Dt, Tt, Wt;
      if (!d || d.length === 0)
        throw new Error("latlngs not passed");
      ei(d) || (console.warn("latlngs are not flat! Only the first ring will be used"), d = d[0]);
      var ie = zt([0, 0]), le = St(d), Ce = le.getNorthWest().distanceTo(le.getSouthWest()) * le.getNorthEast().distanceTo(le.getNorthWest());
      Ce < 1700 && (ie = Pt(d));
      var ri = d.length, Ye = [];
      for (C = 0; C < ri; C++) {
        var Ai = zt(d[C]);
        Ye.push(_.project(zt([Ai.lat - ie.lat, Ai.lng - ie.lng])));
      }
      for (C = 0, B = 0; C < ri - 1; C++)
        B += Ye[C].distanceTo(Ye[C + 1]) / 2;
      if (B === 0)
        Wt = Ye[0];
      else
        for (C = 0, Q = 0; C < ri - 1; C++)
          if (dt = Ye[C], Dt = Ye[C + 1], q = dt.distanceTo(Dt), Q += q, Q > B) {
            Tt = (Q - B) / q, Wt = [
              Dt.x - Tt * (Dt.x - dt.x),
              Dt.y - Tt * (Dt.y - dt.y)
            ];
            break;
          }
      var hi = _.unproject(rt(Wt));
      return zt([hi.lat + ie.lat, hi.lng + ie.lng]);
    }
    var Di = {
      __proto__: null,
      simplify: se,
      pointToSegmentDistance: De,
      closestPointOnSegment: ge,
      clipSegment: ye,
      _getEdgeIntersection: Ci,
      _getBitCode: me,
      _sqClosestPointOnSegment: Oi,
      isFlat: ei,
      _flat: vi,
      polylineCenter: tn
    }, Mi = {
      project: function(d) {
        return new Y(d.lng, d.lat);
      },
      unproject: function(d) {
        return new Ft(d.y, d.x);
      },
      bounds: new ht([-180, -90], [180, 90])
    }, Ei = {
      R: 6378137,
      R_MINOR: 6356752314245179e-9,
      bounds: new ht([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
      project: function(d) {
        var _ = Math.PI / 180, C = this.R, B = d.lat * _, q = this.R_MINOR / C, Q = Math.sqrt(1 - q * q), dt = Q * Math.sin(B), Dt = Math.tan(Math.PI / 4 - B / 2) / Math.pow((1 - dt) / (1 + dt), Q / 2);
        return B = -C * Math.log(Math.max(Dt, 1e-10)), new Y(d.lng * _ * C, B);
      },
      unproject: function(d) {
        for (var _ = 180 / Math.PI, C = this.R, B = this.R_MINOR / C, q = Math.sqrt(1 - B * B), Q = Math.exp(-d.y / C), dt = Math.PI / 2 - 2 * Math.atan(Q), Dt = 0, Tt = 0.1, Wt; Dt < 15 && Math.abs(Tt) > 1e-7; Dt++)
          Wt = q * Math.sin(dt), Wt = Math.pow((1 - Wt) / (1 + Wt), q / 2), Tt = Math.PI / 2 - 2 * Math.atan(Q * Wt) - dt, dt += Tt;
        return new Ft(dt * _, d.x * _ / C);
      }
    }, si = {
      __proto__: null,
      LonLat: Mi,
      Mercator: Ei,
      SphericalMercator: at
    }, pr = l({}, J, {
      code: "EPSG:3395",
      projection: Ei,
      transformation: function() {
        var d = 0.5 / (Math.PI * Ei.R);
        return wt(d, 0.5, -d, 0.5);
      }()
    }), Pi = l({}, J, {
      code: "EPSG:4326",
      projection: Mi,
      transformation: wt(1 / 180, 1, -1 / 180, 0.5)
    }), Ii = l({}, Zt, {
      projection: Mi,
      transformation: wt(1, 0, -1, 0),
      scale: function(d) {
        return Math.pow(2, d);
      },
      zoom: function(d) {
        return Math.log(d) / Math.LN2;
      },
      distance: function(d, _) {
        var C = _.lng - d.lng, B = _.lat - d.lat;
        return Math.sqrt(C * C + B * B);
      },
      infinite: !0
    });
    Zt.Earth = J, Zt.EPSG3395 = pr, Zt.EPSG3857 = Et, Zt.EPSG900913 = qt, Zt.EPSG4326 = Pi, Zt.Simple = Ii;
    var mi = G.extend({
      // Classes extending `L.Layer` will inherit the following options:
      options: {
        // @option pane: String = 'overlayPane'
        // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
        pane: "overlayPane",
        // @option attribution: String = null
        // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
        attribution: null,
        bubblingMouseEvents: !0
      },
      /* @section
       * Classes extending `L.Layer` will inherit the following methods:
       *
       * @method addTo(map: Map|LayerGroup): this
       * Adds the layer to the given map or layer group.
       */
      addTo: function(d) {
        return d.addLayer(this), this;
      },
      // @method remove: this
      // Removes the layer from the map it is currently active on.
      remove: function() {
        return this.removeFrom(this._map || this._mapToAdd);
      },
      // @method removeFrom(map: Map): this
      // Removes the layer from the given map
      //
      // @alternative
      // @method removeFrom(group: LayerGroup): this
      // Removes the layer from the given `LayerGroup`
      removeFrom: function(d) {
        return d && d.removeLayer(this), this;
      },
      // @method getPane(name? : String): HTMLElement
      // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
      getPane: function(d) {
        return this._map.getPane(d ? this.options[d] || d : this.options.pane);
      },
      addInteractiveTarget: function(d) {
        return this._map._targets[f(d)] = this, this;
      },
      removeInteractiveTarget: function(d) {
        return delete this._map._targets[f(d)], this;
      },
      // @method getAttribution: String
      // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
      getAttribution: function() {
        return this.options.attribution;
      },
      _layerAdd: function(d) {
        var _ = d.target;
        if (_.hasLayer(this)) {
          if (this._map = _, this._zoomAnimated = _._zoomAnimated, this.getEvents) {
            var C = this.getEvents();
            _.on(C, this), this.once("remove", function() {
              _.off(C, this);
            }, this);
          }
          this.onAdd(_), this.fire("add"), _.fire("layeradd", { layer: this });
        }
      }
    });
    Ee.include({
      // @method addLayer(layer: Layer): this
      // Adds the given layer to the map
      addLayer: function(d) {
        if (!d._layerAdd)
          throw new Error("The provided object is not a Layer.");
        var _ = f(d);
        return this._layers[_] ? this : (this._layers[_] = d, d._mapToAdd = this, d.beforeAdd && d.beforeAdd(this), this.whenReady(d._layerAdd, d), this);
      },
      // @method removeLayer(layer: Layer): this
      // Removes the given layer from the map.
      removeLayer: function(d) {
        var _ = f(d);
        return this._layers[_] ? (this._loaded && d.onRemove(this), delete this._layers[_], this._loaded && (this.fire("layerremove", { layer: d }), d.fire("remove")), d._map = d._mapToAdd = null, this) : this;
      },
      // @method hasLayer(layer: Layer): Boolean
      // Returns `true` if the given layer is currently added to the map
      hasLayer: function(d) {
        return f(d) in this._layers;
      },
      /* @method eachLayer(fn: Function, context?: Object): this
       * Iterates over the layers of the map, optionally specifying context of the iterator function.
       * ```
       * map.eachLayer(function(layer){
       *     layer.bindPopup('Hello');
       * });
       * ```
       */
      eachLayer: function(d, _) {
        for (var C in this._layers)
          d.call(_, this._layers[C]);
        return this;
      },
      _addLayers: function(d) {
        d = d ? N(d) ? d : [d] : [];
        for (var _ = 0, C = d.length; _ < C; _++)
          this.addLayer(d[_]);
      },
      _addZoomLimit: function(d) {
        (!isNaN(d.options.maxZoom) || !isNaN(d.options.minZoom)) && (this._zoomBoundLayers[f(d)] = d, this._updateZoomLevels());
      },
      _removeZoomLimit: function(d) {
        var _ = f(d);
        this._zoomBoundLayers[_] && (delete this._zoomBoundLayers[_], this._updateZoomLevels());
      },
      _updateZoomLevels: function() {
        var d = 1 / 0, _ = -1 / 0, C = this._getZoomSpan();
        for (var B in this._zoomBoundLayers) {
          var q = this._zoomBoundLayers[B].options;
          d = q.minZoom === void 0 ? d : Math.min(d, q.minZoom), _ = q.maxZoom === void 0 ? _ : Math.max(_, q.maxZoom);
        }
        this._layersMaxZoom = _ === -1 / 0 ? void 0 : _, this._layersMinZoom = d === 1 / 0 ? void 0 : d, C !== this._getZoomSpan() && this.fire("zoomlevelschange"), this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
      }
    });
    var en = mi.extend({
      initialize: function(d, _) {
        x(this, _), this._layers = {};
        var C, B;
        if (d)
          for (C = 0, B = d.length; C < B; C++)
            this.addLayer(d[C]);
      },
      // @method addLayer(layer: Layer): this
      // Adds the given layer to the group.
      addLayer: function(d) {
        var _ = this.getLayerId(d);
        return this._layers[_] = d, this._map && this._map.addLayer(d), this;
      },
      // @method removeLayer(layer: Layer): this
      // Removes the given layer from the group.
      // @alternative
      // @method removeLayer(id: Number): this
      // Removes the layer with the given internal ID from the group.
      removeLayer: function(d) {
        var _ = d in this._layers ? d : this.getLayerId(d);
        return this._map && this._layers[_] && this._map.removeLayer(this._layers[_]), delete this._layers[_], this;
      },
      // @method hasLayer(layer: Layer): Boolean
      // Returns `true` if the given layer is currently added to the group.
      // @alternative
      // @method hasLayer(id: Number): Boolean
      // Returns `true` if the given internal ID is currently added to the group.
      hasLayer: function(d) {
        var _ = typeof d == "number" ? d : this.getLayerId(d);
        return _ in this._layers;
      },
      // @method clearLayers(): this
      // Removes all the layers from the group.
      clearLayers: function() {
        return this.eachLayer(this.removeLayer, this);
      },
      // @method invoke(methodName: String, …): this
      // Calls `methodName` on every layer contained in this group, passing any
      // additional parameters. Has no effect if the layers contained do not
      // implement `methodName`.
      invoke: function(d) {
        var _ = Array.prototype.slice.call(arguments, 1), C, B;
        for (C in this._layers)
          B = this._layers[C], B[d] && B[d].apply(B, _);
        return this;
      },
      onAdd: function(d) {
        this.eachLayer(d.addLayer, d);
      },
      onRemove: function(d) {
        this.eachLayer(d.removeLayer, d);
      },
      // @method eachLayer(fn: Function, context?: Object): this
      // Iterates over the layers of the group, optionally specifying context of the iterator function.
      // ```js
      // group.eachLayer(function (layer) {
      // 	layer.bindPopup('Hello');
      // });
      // ```
      eachLayer: function(d, _) {
        for (var C in this._layers)
          d.call(_, this._layers[C]);
        return this;
      },
      // @method getLayer(id: Number): Layer
      // Returns the layer with the given internal ID.
      getLayer: function(d) {
        return this._layers[d];
      },
      // @method getLayers(): Layer[]
      // Returns an array of all the layers added to the group.
      getLayers: function() {
        var d = [];
        return this.eachLayer(d.push, d), d;
      },
      // @method setZIndex(zIndex: Number): this
      // Calls `setZIndex` on every layer contained in this group, passing the z-index.
      setZIndex: function(d) {
        return this.invoke("setZIndex", d);
      },
      // @method getLayerId(layer: Layer): Number
      // Returns the internal ID for a layer
      getLayerId: function(d) {
        return f(d);
      }
    }), Lr = function(d, _) {
      return new en(d, _);
    }, be = en.extend({
      addLayer: function(d) {
        return this.hasLayer(d) ? this : (d.addEventParent(this), en.prototype.addLayer.call(this, d), this.fire("layeradd", { layer: d }));
      },
      removeLayer: function(d) {
        return this.hasLayer(d) ? (d in this._layers && (d = this._layers[d]), d.removeEventParent(this), en.prototype.removeLayer.call(this, d), this.fire("layerremove", { layer: d })) : this;
      },
      // @method setStyle(style: Path options): this
      // Sets the given path options to each layer of the group that has a `setStyle` method.
      setStyle: function(d) {
        return this.invoke("setStyle", d);
      },
      // @method bringToFront(): this
      // Brings the layer group to the top of all other layers
      bringToFront: function() {
        return this.invoke("bringToFront");
      },
      // @method bringToBack(): this
      // Brings the layer group to the back of all other layers
      bringToBack: function() {
        return this.invoke("bringToBack");
      },
      // @method getBounds(): LatLngBounds
      // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
      getBounds: function() {
        var d = new yt();
        for (var _ in this._layers) {
          var C = this._layers[_];
          d.extend(C.getBounds ? C.getBounds() : C.getLatLng());
        }
        return d;
      }
    }), Xn = function(d, _) {
      return new be(d, _);
    }, Xe = kt.extend({
      /* @section
       * @aka Icon options
       *
       * @option iconUrl: String = null
       * **(required)** The URL to the icon image (absolute or relative to your script path).
       *
       * @option iconRetinaUrl: String = null
       * The URL to a retina sized version of the icon image (absolute or relative to your
       * script path). Used for Retina screen devices.
       *
       * @option iconSize: Point = null
       * Size of the icon image in pixels.
       *
       * @option iconAnchor: Point = null
       * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
       * will be aligned so that this point is at the marker's geographical location. Centered
       * by default if size is specified, also can be set in CSS with negative margins.
       *
       * @option popupAnchor: Point = [0, 0]
       * The coordinates of the point from which popups will "open", relative to the icon anchor.
       *
       * @option tooltipAnchor: Point = [0, 0]
       * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
       *
       * @option shadowUrl: String = null
       * The URL to the icon shadow image. If not specified, no shadow image will be created.
       *
       * @option shadowRetinaUrl: String = null
       *
       * @option shadowSize: Point = null
       * Size of the shadow image in pixels.
       *
       * @option shadowAnchor: Point = null
       * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
       * as iconAnchor if not specified).
       *
       * @option className: String = ''
       * A custom class name to assign to both icon and shadow images. Empty by default.
       */
      options: {
        popupAnchor: [0, 0],
        tooltipAnchor: [0, 0],
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the tiles.
        // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: !1
      },
      initialize: function(d) {
        x(this, d);
      },
      // @method createIcon(oldIcon?: HTMLElement): HTMLElement
      // Called internally when the icon has to be shown, returns a `<img>` HTML element
      // styled according to the options.
      createIcon: function(d) {
        return this._createIcon("icon", d);
      },
      // @method createShadow(oldIcon?: HTMLElement): HTMLElement
      // As `createIcon`, but for the shadow beneath it.
      createShadow: function(d) {
        return this._createIcon("shadow", d);
      },
      _createIcon: function(d, _) {
        var C = this._getIconUrl(d);
        if (!C) {
          if (d === "icon")
            throw new Error("iconUrl not set in Icon options (see the docs).");
          return null;
        }
        var B = this._createImg(C, _ && _.tagName === "IMG" ? _ : null);
        return this._setIconStyles(B, d), (this.options.crossOrigin || this.options.crossOrigin === "") && (B.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), B;
      },
      _setIconStyles: function(d, _) {
        var C = this.options, B = C[_ + "Size"];
        typeof B == "number" && (B = [B, B]);
        var q = rt(B), Q = rt(_ === "shadow" && C.shadowAnchor || C.iconAnchor || q && q.divideBy(2, !0));
        d.className = "leaflet-marker-" + _ + " " + (C.className || ""), Q && (d.style.marginLeft = -Q.x + "px", d.style.marginTop = -Q.y + "px"), q && (d.style.width = q.x + "px", d.style.height = q.y + "px");
      },
      _createImg: function(d, _) {
        return _ = _ || document.createElement("img"), _.src = d, _;
      },
      _getIconUrl: function(d) {
        return ae.retina && this.options[d + "RetinaUrl"] || this.options[d + "Url"];
      }
    });
    function nn(d) {
      return new Xe(d);
    }
    var Mn = Xe.extend({
      options: {
        iconUrl: "marker-icon.png",
        iconRetinaUrl: "marker-icon-2x.png",
        shadowUrl: "marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28],
        shadowSize: [41, 41]
      },
      _getIconUrl: function(d) {
        return typeof Mn.imagePath != "string" && (Mn.imagePath = this._detectIconPath()), (this.options.imagePath || Mn.imagePath) + Xe.prototype._getIconUrl.call(this, d);
      },
      _stripUrl: function(d) {
        var _ = function(C, B, q) {
          var Q = B.exec(C);
          return Q && Q[q];
        };
        return d = _(d, /^url\((['"])?(.+)\1\)$/, 2), d && _(d, /^(.*)marker-icon\.png$/, 1);
      },
      _detectIconPath: function() {
        var d = Me("div", "leaflet-default-icon-path", document.body), _ = $i(d, "background-image") || $i(d, "backgroundImage");
        if (document.body.removeChild(d), _ = this._stripUrl(_), _)
          return _;
        var C = document.querySelector('link[href$="leaflet.css"]');
        return C ? C.href.substring(0, C.href.length - 11 - 1) : "";
      }
    }), Dr = K.extend({
      initialize: function(d) {
        this._marker = d;
      },
      addHooks: function() {
        var d = this._marker._icon;
        this._draggable || (this._draggable = new _t(d, d, !0)), this._draggable.on({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).enable(), pe(d, "leaflet-marker-draggable");
      },
      removeHooks: function() {
        this._draggable.off({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).disable(), this._marker._icon && Ne(this._marker._icon, "leaflet-marker-draggable");
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      _adjustPan: function(d) {
        var _ = this._marker, C = _._map, B = this._marker.options.autoPanSpeed, q = this._marker.options.autoPanPadding, Q = fi(_._icon), dt = C.getPixelBounds(), Dt = C.getPixelOrigin(), Tt = bt(
          dt.min._subtract(Dt).add(q),
          dt.max._subtract(Dt).subtract(q)
        );
        if (!Tt.contains(Q)) {
          var Wt = rt(
            (Math.max(Tt.max.x, Q.x) - Tt.max.x) / (dt.max.x - Tt.max.x) - (Math.min(Tt.min.x, Q.x) - Tt.min.x) / (dt.min.x - Tt.min.x),
            (Math.max(Tt.max.y, Q.y) - Tt.max.y) / (dt.max.y - Tt.max.y) - (Math.min(Tt.min.y, Q.y) - Tt.min.y) / (dt.min.y - Tt.min.y)
          ).multiplyBy(B);
          C.panBy(Wt, { animate: !1 }), this._draggable._newPos._add(Wt), this._draggable._startPos._add(Wt), Ie(_._icon, this._draggable._newPos), this._onDrag(d), this._panRequest = pt(this._adjustPan.bind(this, d));
        }
      },
      _onDragStart: function() {
        this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart");
      },
      _onPreDrag: function(d) {
        this._marker.options.autoPan && (ct(this._panRequest), this._panRequest = pt(this._adjustPan.bind(this, d)));
      },
      _onDrag: function(d) {
        var _ = this._marker, C = _._shadow, B = fi(_._icon), q = _._map.layerPointToLatLng(B);
        C && Ie(C, B), _._latlng = q, d.latlng = q, d.oldLatLng = this._oldLatLng, _.fire("move", d).fire("drag", d);
      },
      _onDragEnd: function(d) {
        ct(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", d);
      }
    }), En = mi.extend({
      // @section
      // @aka Marker options
      options: {
        // @option icon: Icon = *
        // Icon instance to use for rendering the marker.
        // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
        // If not specified, a common instance of `L.Icon.Default` is used.
        icon: new Mn(),
        // Option inherited from "Interactive layer" abstract class
        interactive: !0,
        // @option keyboard: Boolean = true
        // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
        keyboard: !0,
        // @option title: String = ''
        // Text for the browser tooltip that appear on marker hover (no tooltip by default).
        // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
        title: "",
        // @option alt: String = 'Marker'
        // Text for the `alt` attribute of the icon image.
        // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
        alt: "Marker",
        // @option zIndexOffset: Number = 0
        // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
        zIndexOffset: 0,
        // @option opacity: Number = 1.0
        // The opacity of the marker.
        opacity: 1,
        // @option riseOnHover: Boolean = false
        // If `true`, the marker will get on top of others when you hover the mouse over it.
        riseOnHover: !1,
        // @option riseOffset: Number = 250
        // The z-index offset used for the `riseOnHover` feature.
        riseOffset: 250,
        // @option pane: String = 'markerPane'
        // `Map pane` where the markers icon will be added.
        pane: "markerPane",
        // @option shadowPane: String = 'shadowPane'
        // `Map pane` where the markers shadow will be added.
        shadowPane: "shadowPane",
        // @option bubblingMouseEvents: Boolean = false
        // When `true`, a mouse event on this marker will trigger the same event on the map
        // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
        bubblingMouseEvents: !1,
        // @option autoPanOnFocus: Boolean = true
        // When `true`, the map will pan whenever the marker is focused (via
        // e.g. pressing `tab` on the keyboard) to ensure the marker is
        // visible within the map's bounds
        autoPanOnFocus: !0,
        // @section Draggable marker options
        // @option draggable: Boolean = false
        // Whether the marker is draggable with mouse/touch or not.
        draggable: !1,
        // @option autoPan: Boolean = false
        // Whether to pan the map when dragging this marker near its edge or not.
        autoPan: !1,
        // @option autoPanPadding: Point = Point(50, 50)
        // Distance (in pixels to the left/right and to the top/bottom) of the
        // map edge to start panning the map.
        autoPanPadding: [50, 50],
        // @option autoPanSpeed: Number = 10
        // Number of pixels the map should pan by.
        autoPanSpeed: 10
      },
      /* @section
       *
       * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
       */
      initialize: function(d, _) {
        x(this, _), this._latlng = zt(d);
      },
      onAdd: function(d) {
        this._zoomAnimated = this._zoomAnimated && d.options.markerZoomAnimation, this._zoomAnimated && d.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update();
      },
      onRemove: function(d) {
        this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && d.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow();
      },
      getEvents: function() {
        return {
          zoom: this.update,
          viewreset: this.update
        };
      },
      // @method getLatLng: LatLng
      // Returns the current geographical position of the marker.
      getLatLng: function() {
        return this._latlng;
      },
      // @method setLatLng(latlng: LatLng): this
      // Changes the marker position to the given point.
      setLatLng: function(d) {
        var _ = this._latlng;
        return this._latlng = zt(d), this.update(), this.fire("move", { oldLatLng: _, latlng: this._latlng });
      },
      // @method setZIndexOffset(offset: Number): this
      // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
      setZIndexOffset: function(d) {
        return this.options.zIndexOffset = d, this.update();
      },
      // @method getIcon: Icon
      // Returns the current icon used by the marker
      getIcon: function() {
        return this.options.icon;
      },
      // @method setIcon(icon: Icon): this
      // Changes the marker icon.
      setIcon: function(d) {
        return this.options.icon = d, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;
      },
      getElement: function() {
        return this._icon;
      },
      update: function() {
        if (this._icon && this._map) {
          var d = this._map.latLngToLayerPoint(this._latlng).round();
          this._setPos(d);
        }
        return this;
      },
      _initIcon: function() {
        var d = this.options, _ = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), C = d.icon.createIcon(this._icon), B = !1;
        C !== this._icon && (this._icon && this._removeIcon(), B = !0, d.title && (C.title = d.title), C.tagName === "IMG" && (C.alt = d.alt || "")), pe(C, _), d.keyboard && (C.tabIndex = "0", C.setAttribute("role", "button")), this._icon = C, d.riseOnHover && this.on({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        }), this.options.autoPanOnFocus && de(C, "focus", this._panOnFocus, this);
        var q = d.icon.createShadow(this._shadow), Q = !1;
        q !== this._shadow && (this._removeShadow(), Q = !0), q && (pe(q, _), q.alt = ""), this._shadow = q, d.opacity < 1 && this._updateOpacity(), B && this.getPane().appendChild(this._icon), this._initInteraction(), q && Q && this.getPane(d.shadowPane).appendChild(this._shadow);
      },
      _removeIcon: function() {
        this.options.riseOnHover && this.off({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        }), this.options.autoPanOnFocus && Fe(this._icon, "focus", this._panOnFocus, this), ke(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;
      },
      _removeShadow: function() {
        this._shadow && ke(this._shadow), this._shadow = null;
      },
      _setPos: function(d) {
        this._icon && Ie(this._icon, d), this._shadow && Ie(this._shadow, d), this._zIndex = d.y + this.options.zIndexOffset, this._resetZIndex();
      },
      _updateZIndex: function(d) {
        this._icon && (this._icon.style.zIndex = this._zIndex + d);
      },
      _animateZoom: function(d) {
        var _ = this._map._latLngToNewLayerPoint(this._latlng, d.zoom, d.center).round();
        this._setPos(_);
      },
      _initInteraction: function() {
        if (this.options.interactive && (pe(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), Dr)) {
          var d = this.options.draggable;
          this.dragging && (d = this.dragging.enabled(), this.dragging.disable()), this.dragging = new Dr(this), d && this.dragging.enable();
        }
      },
      // @method setOpacity(opacity: Number): this
      // Changes the opacity of the marker.
      setOpacity: function(d) {
        return this.options.opacity = d, this._map && this._updateOpacity(), this;
      },
      _updateOpacity: function() {
        var d = this.options.opacity;
        this._icon && ni(this._icon, d), this._shadow && ni(this._shadow, d);
      },
      _bringToFront: function() {
        this._updateZIndex(this.options.riseOffset);
      },
      _resetZIndex: function() {
        this._updateZIndex(0);
      },
      _panOnFocus: function() {
        var d = this._map;
        if (d) {
          var _ = this.options.icon.options, C = _.iconSize ? rt(_.iconSize) : rt(0, 0), B = _.iconAnchor ? rt(_.iconAnchor) : rt(0, 0);
          d.panInside(this._latlng, {
            paddingTopLeft: B,
            paddingBottomRight: C.subtract(B)
          });
        }
      },
      _getPopupAnchor: function() {
        return this.options.icon.options.popupAnchor;
      },
      _getTooltipAnchor: function() {
        return this.options.icon.options.tooltipAnchor;
      }
    });
    function Xi(d, _) {
      return new En(d, _);
    }
    var Si = mi.extend({
      // @section
      // @aka Path options
      options: {
        // @option stroke: Boolean = true
        // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
        stroke: !0,
        // @option color: String = '#3388ff'
        // Stroke color
        color: "#3388ff",
        // @option weight: Number = 3
        // Stroke width in pixels
        weight: 3,
        // @option opacity: Number = 1.0
        // Stroke opacity
        opacity: 1,
        // @option lineCap: String= 'round'
        // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
        lineCap: "round",
        // @option lineJoin: String = 'round'
        // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
        lineJoin: "round",
        // @option dashArray: String = null
        // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
        dashArray: null,
        // @option dashOffset: String = null
        // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
        dashOffset: null,
        // @option fill: Boolean = depends
        // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
        fill: !1,
        // @option fillColor: String = *
        // Fill color. Defaults to the value of the [`color`](#path-color) option
        fillColor: null,
        // @option fillOpacity: Number = 0.2
        // Fill opacity.
        fillOpacity: 0.2,
        // @option fillRule: String = 'evenodd'
        // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
        fillRule: "evenodd",
        // className: '',
        // Option inherited from "Interactive layer" abstract class
        interactive: !0,
        // @option bubblingMouseEvents: Boolean = true
        // When `true`, a mouse event on this path will trigger the same event on the map
        // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
        bubblingMouseEvents: !0
      },
      beforeAdd: function(d) {
        this._renderer = d.getRenderer(this);
      },
      onAdd: function() {
        this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
      },
      onRemove: function() {
        this._renderer._removePath(this);
      },
      // @method redraw(): this
      // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
      redraw: function() {
        return this._map && this._renderer._updatePath(this), this;
      },
      // @method setStyle(style: Path options): this
      // Changes the appearance of a Path based on the options in the `Path options` object.
      setStyle: function(d) {
        return x(this, d), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && d && Object.prototype.hasOwnProperty.call(d, "weight") && this._updateBounds()), this;
      },
      // @method bringToFront(): this
      // Brings the layer to the top of all path layers.
      bringToFront: function() {
        return this._renderer && this._renderer._bringToFront(this), this;
      },
      // @method bringToBack(): this
      // Brings the layer to the bottom of all path layers.
      bringToBack: function() {
        return this._renderer && this._renderer._bringToBack(this), this;
      },
      getElement: function() {
        return this._path;
      },
      _reset: function() {
        this._project(), this._update();
      },
      _clickTolerance: function() {
        return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
      }
    }), _i = Si.extend({
      // @section
      // @aka CircleMarker options
      options: {
        fill: !0,
        // @option radius: Number = 10
        // Radius of the circle marker, in pixels
        radius: 10
      },
      initialize: function(d, _) {
        x(this, _), this._latlng = zt(d), this._radius = this.options.radius;
      },
      // @method setLatLng(latLng: LatLng): this
      // Sets the position of a circle marker to a new location.
      setLatLng: function(d) {
        var _ = this._latlng;
        return this._latlng = zt(d), this.redraw(), this.fire("move", { oldLatLng: _, latlng: this._latlng });
      },
      // @method getLatLng(): LatLng
      // Returns the current geographical position of the circle marker
      getLatLng: function() {
        return this._latlng;
      },
      // @method setRadius(radius: Number): this
      // Sets the radius of a circle marker. Units are in pixels.
      setRadius: function(d) {
        return this.options.radius = this._radius = d, this.redraw();
      },
      // @method getRadius(): Number
      // Returns the current radius of the circle
      getRadius: function() {
        return this._radius;
      },
      setStyle: function(d) {
        var _ = d && d.radius || this._radius;
        return Si.prototype.setStyle.call(this, d), this.setRadius(_), this;
      },
      _project: function() {
        this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
      },
      _updateBounds: function() {
        var d = this._radius, _ = this._radiusY || d, C = this._clickTolerance(), B = [d + C, _ + C];
        this._pxBounds = new ht(this._point.subtract(B), this._point.add(B));
      },
      _update: function() {
        this._map && this._updatePath();
      },
      _updatePath: function() {
        this._renderer._updateCircle(this);
      },
      _empty: function() {
        return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(d) {
        return d.distanceTo(this._point) <= this._radius + this._clickTolerance();
      }
    });
    function Mr(d, _) {
      return new _i(d, _);
    }
    var Yi = _i.extend({
      initialize: function(d, _, C) {
        if (typeof _ == "number" && (_ = l({}, C, { radius: _ })), x(this, _), this._latlng = zt(d), isNaN(this.options.radius))
          throw new Error("Circle radius cannot be NaN");
        this._mRadius = this.options.radius;
      },
      // @method setRadius(radius: Number): this
      // Sets the radius of a circle. Units are in meters.
      setRadius: function(d) {
        return this._mRadius = d, this.redraw();
      },
      // @method getRadius(): Number
      // Returns the current radius of a circle. Units are in meters.
      getRadius: function() {
        return this._mRadius;
      },
      // @method getBounds(): LatLngBounds
      // Returns the `LatLngBounds` of the path.
      getBounds: function() {
        var d = [this._radius, this._radiusY || this._radius];
        return new yt(
          this._map.layerPointToLatLng(this._point.subtract(d)),
          this._map.layerPointToLatLng(this._point.add(d))
        );
      },
      setStyle: Si.prototype.setStyle,
      _project: function() {
        var d = this._latlng.lng, _ = this._latlng.lat, C = this._map, B = C.options.crs;
        if (B.distance === J.distance) {
          var q = Math.PI / 180, Q = this._mRadius / J.R / q, dt = C.project([_ + Q, d]), Dt = C.project([_ - Q, d]), Tt = dt.add(Dt).divideBy(2), Wt = C.unproject(Tt).lat, ie = Math.acos((Math.cos(Q * q) - Math.sin(_ * q) * Math.sin(Wt * q)) / (Math.cos(_ * q) * Math.cos(Wt * q))) / q;
          (isNaN(ie) || ie === 0) && (ie = Q / Math.cos(Math.PI / 180 * _)), this._point = Tt.subtract(C.getPixelOrigin()), this._radius = isNaN(ie) ? 0 : Tt.x - C.project([Wt, d - ie]).x, this._radiusY = Tt.y - dt.y;
        } else {
          var le = B.unproject(B.project(this._latlng).subtract([this._mRadius, 0]));
          this._point = C.latLngToLayerPoint(this._latlng), this._radius = this._point.x - C.latLngToLayerPoint(le).x;
        }
        this._updateBounds();
      }
    });
    function Yn(d, _, C) {
      return new Yi(d, _, C);
    }
    var li = Si.extend({
      // @section
      // @aka Polyline options
      options: {
        // @option smoothFactor: Number = 1.0
        // How much to simplify the polyline on each zoom level. More means
        // better performance and smoother look, and less means more accurate representation.
        smoothFactor: 1,
        // @option noClip: Boolean = false
        // Disable polyline clipping.
        noClip: !1
      },
      initialize: function(d, _) {
        x(this, _), this._setLatLngs(d);
      },
      // @method getLatLngs(): LatLng[]
      // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
      getLatLngs: function() {
        return this._latlngs;
      },
      // @method setLatLngs(latlngs: LatLng[]): this
      // Replaces all the points in the polyline with the given array of geographical points.
      setLatLngs: function(d) {
        return this._setLatLngs(d), this.redraw();
      },
      // @method isEmpty(): Boolean
      // Returns `true` if the Polyline has no LatLngs.
      isEmpty: function() {
        return !this._latlngs.length;
      },
      // @method closestLayerPoint(p: Point): Point
      // Returns the point closest to `p` on the Polyline.
      closestLayerPoint: function(d) {
        for (var _ = 1 / 0, C = null, B = Oi, q, Q, dt = 0, Dt = this._parts.length; dt < Dt; dt++)
          for (var Tt = this._parts[dt], Wt = 1, ie = Tt.length; Wt < ie; Wt++) {
            q = Tt[Wt - 1], Q = Tt[Wt];
            var le = B(d, q, Q, !0);
            le < _ && (_ = le, C = B(d, q, Q));
          }
        return C && (C.distance = Math.sqrt(_)), C;
      },
      // @method getCenter(): LatLng
      // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
      getCenter: function() {
        if (!this._map)
          throw new Error("Must add layer to map before using getCenter()");
        return tn(this._defaultShape(), this._map.options.crs);
      },
      // @method getBounds(): LatLngBounds
      // Returns the `LatLngBounds` of the path.
      getBounds: function() {
        return this._bounds;
      },
      // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
      // Adds a given point to the polyline. By default, adds to the first ring of
      // the polyline in case of a multi-polyline, but can be overridden by passing
      // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
      addLatLng: function(d, _) {
        return _ = _ || this._defaultShape(), d = zt(d), _.push(d), this._bounds.extend(d), this.redraw();
      },
      _setLatLngs: function(d) {
        this._bounds = new yt(), this._latlngs = this._convertLatLngs(d);
      },
      _defaultShape: function() {
        return ei(this._latlngs) ? this._latlngs : this._latlngs[0];
      },
      // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
      _convertLatLngs: function(d) {
        for (var _ = [], C = ei(d), B = 0, q = d.length; B < q; B++)
          C ? (_[B] = zt(d[B]), this._bounds.extend(_[B])) : _[B] = this._convertLatLngs(d[B]);
        return _;
      },
      _project: function() {
        var d = new ht();
        this._rings = [], this._projectLatlngs(this._latlngs, this._rings, d), this._bounds.isValid() && d.isValid() && (this._rawPxBounds = d, this._updateBounds());
      },
      _updateBounds: function() {
        var d = this._clickTolerance(), _ = new Y(d, d);
        this._rawPxBounds && (this._pxBounds = new ht([
          this._rawPxBounds.min.subtract(_),
          this._rawPxBounds.max.add(_)
        ]));
      },
      // recursively turns latlngs into a set of rings with projected coordinates
      _projectLatlngs: function(d, _, C) {
        var B = d[0] instanceof Ft, q = d.length, Q, dt;
        if (B) {
          for (dt = [], Q = 0; Q < q; Q++)
            dt[Q] = this._map.latLngToLayerPoint(d[Q]), C.extend(dt[Q]);
          _.push(dt);
        } else
          for (Q = 0; Q < q; Q++)
            this._projectLatlngs(d[Q], _, C);
      },
      // clip polyline by renderer bounds so that we have less to render for performance
      _clipPoints: function() {
        var d = this._renderer._bounds;
        if (this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(d))) {
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          var _ = this._parts, C, B, q, Q, dt, Dt, Tt;
          for (C = 0, q = 0, Q = this._rings.length; C < Q; C++)
            for (Tt = this._rings[C], B = 0, dt = Tt.length; B < dt - 1; B++)
              Dt = ye(Tt[B], Tt[B + 1], d, B, !0), Dt && (_[q] = _[q] || [], _[q].push(Dt[0]), (Dt[1] !== Tt[B + 1] || B === dt - 2) && (_[q].push(Dt[1]), q++));
        }
      },
      // simplify each clipped part of the polyline for performance
      _simplifyPoints: function() {
        for (var d = this._parts, _ = this.options.smoothFactor, C = 0, B = d.length; C < B; C++)
          d[C] = se(d[C], _);
      },
      _update: function() {
        this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
      },
      _updatePath: function() {
        this._renderer._updatePoly(this);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(d, _) {
        var C, B, q, Q, dt, Dt, Tt = this._clickTolerance();
        if (!this._pxBounds || !this._pxBounds.contains(d))
          return !1;
        for (C = 0, Q = this._parts.length; C < Q; C++)
          for (Dt = this._parts[C], B = 0, dt = Dt.length, q = dt - 1; B < dt; q = B++)
            if (!(!_ && B === 0) && De(d, Dt[q], Dt[B]) <= Tt)
              return !0;
        return !1;
      }
    });
    function gr(d, _) {
      return new li(d, _);
    }
    li._flat = vi;
    var rn = li.extend({
      options: {
        fill: !0
      },
      isEmpty: function() {
        return !this._latlngs.length || !this._latlngs[0].length;
      },
      // @method getCenter(): LatLng
      // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
      getCenter: function() {
        if (!this._map)
          throw new Error("Must add layer to map before using getCenter()");
        return Bt(this._defaultShape(), this._map.options.crs);
      },
      _convertLatLngs: function(d) {
        var _ = li.prototype._convertLatLngs.call(this, d), C = _.length;
        return C >= 2 && _[0] instanceof Ft && _[0].equals(_[C - 1]) && _.pop(), _;
      },
      _setLatLngs: function(d) {
        li.prototype._setLatLngs.call(this, d), ei(this._latlngs) && (this._latlngs = [this._latlngs]);
      },
      _defaultShape: function() {
        return ei(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
      },
      _clipPoints: function() {
        var d = this._renderer._bounds, _ = this.options.weight, C = new Y(_, _);
        if (d = new ht(d.min.subtract(C), d.max.add(C)), this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(d))) {
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          for (var B = 0, q = this._rings.length, Q; B < q; B++)
            Q = Lt(this._rings[B], d, !0), Q.length && this._parts.push(Q);
        }
      },
      _updatePath: function() {
        this._renderer._updatePoly(this, !0);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(d) {
        var _ = !1, C, B, q, Q, dt, Dt, Tt, Wt;
        if (!this._pxBounds || !this._pxBounds.contains(d))
          return !1;
        for (Q = 0, Tt = this._parts.length; Q < Tt; Q++)
          for (C = this._parts[Q], dt = 0, Wt = C.length, Dt = Wt - 1; dt < Wt; Dt = dt++)
            B = C[dt], q = C[Dt], B.y > d.y != q.y > d.y && d.x < (q.x - B.x) * (d.y - B.y) / (q.y - B.y) + B.x && (_ = !_);
        return _ || li.prototype._containsPoint.call(this, d, !0);
      }
    });
    function Jn(d, _) {
      return new rn(d, _);
    }
    var yi = be.extend({
      /* @section
       * @aka GeoJSON options
       *
       * @option pointToLayer: Function = *
       * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
       * called when data is added, passing the GeoJSON point feature and its `LatLng`.
       * The default is to spawn a default `Marker`:
       * ```js
       * function(geoJsonPoint, latlng) {
       * 	return L.marker(latlng);
       * }
       * ```
       *
       * @option style: Function = *
       * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
       * called internally when data is added.
       * The default value is to not override any defaults:
       * ```js
       * function (geoJsonFeature) {
       * 	return {}
       * }
       * ```
       *
       * @option onEachFeature: Function = *
       * A `Function` that will be called once for each created `Feature`, after it has
       * been created and styled. Useful for attaching events and popups to features.
       * The default is to do nothing with the newly created layers:
       * ```js
       * function (feature, layer) {}
       * ```
       *
       * @option filter: Function = *
       * A `Function` that will be used to decide whether to include a feature or not.
       * The default is to include all features:
       * ```js
       * function (geoJsonFeature) {
       * 	return true;
       * }
       * ```
       * Note: dynamically changing the `filter` option will have effect only on newly
       * added data. It will _not_ re-evaluate already included features.
       *
       * @option coordsToLatLng: Function = *
       * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
       * The default is the `coordsToLatLng` static method.
       *
       * @option markersInheritOptions: Boolean = false
       * Whether default Markers for "Point" type Features inherit from group options.
       */
      initialize: function(d, _) {
        x(this, _), this._layers = {}, d && this.addData(d);
      },
      // @method addData( <GeoJSON> data ): this
      // Adds a GeoJSON object to the layer.
      addData: function(d) {
        var _ = N(d) ? d : d.features, C, B, q;
        if (_) {
          for (C = 0, B = _.length; C < B; C++)
            q = _[C], (q.geometries || q.geometry || q.features || q.coordinates) && this.addData(q);
          return this;
        }
        var Q = this.options;
        if (Q.filter && !Q.filter(d))
          return this;
        var dt = an(d, Q);
        return dt ? (dt.feature = At(d), dt.defaultOptions = dt.options, this.resetStyle(dt), Q.onEachFeature && Q.onEachFeature(d, dt), this.addLayer(dt)) : this;
      },
      // @method resetStyle( <Path> layer? ): this
      // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
      // If `layer` is omitted, the style of all features in the current layer is reset.
      resetStyle: function(d) {
        return d === void 0 ? this.eachLayer(this.resetStyle, this) : (d.options = l({}, d.defaultOptions), this._setLayerStyle(d, this.options.style), this);
      },
      // @method setStyle( <Function> style ): this
      // Changes styles of GeoJSON vector layers with the given style function.
      setStyle: function(d) {
        return this.eachLayer(function(_) {
          this._setLayerStyle(_, d);
        }, this);
      },
      _setLayerStyle: function(d, _) {
        d.setStyle && (typeof _ == "function" && (_ = _(d.feature)), d.setStyle(_));
      }
    });
    function an(d, _) {
      var C = d.type === "Feature" ? d.geometry : d, B = C ? C.coordinates : null, q = [], Q = _ && _.pointToLayer, dt = _ && _.coordsToLatLng || Pn, Dt, Tt, Wt, ie;
      if (!B && !C)
        return null;
      switch (C.type) {
        case "Point":
          return Dt = dt(B), Er(Q, d, Dt, _);
        case "MultiPoint":
          for (Wt = 0, ie = B.length; Wt < ie; Wt++)
            Dt = dt(B[Wt]), q.push(Er(Q, d, Dt, _));
          return new be(q);
        case "LineString":
        case "MultiLineString":
          return Tt = Sn(B, C.type === "LineString" ? 0 : 1, dt), new li(Tt, _);
        case "Polygon":
        case "MultiPolygon":
          return Tt = Sn(B, C.type === "Polygon" ? 1 : 2, dt), new rn(Tt, _);
        case "GeometryCollection":
          for (Wt = 0, ie = C.geometries.length; Wt < ie; Wt++) {
            var le = an({
              geometry: C.geometries[Wt],
              type: "Feature",
              properties: d.properties
            }, _);
            le && q.push(le);
          }
          return new be(q);
        case "FeatureCollection":
          for (Wt = 0, ie = C.features.length; Wt < ie; Wt++) {
            var Ce = an(C.features[Wt], _);
            Ce && q.push(Ce);
          }
          return new be(q);
        default:
          throw new Error("Invalid GeoJSON object.");
      }
    }
    function Er(d, _, C, B) {
      return d ? d(_, C) : new En(C, B && B.markersInheritOptions && B);
    }
    function Pn(d) {
      return new Ft(d[1], d[0], d[2]);
    }
    function Sn(d, _, C) {
      for (var B = [], q = 0, Q = d.length, dt; q < Q; q++)
        dt = _ ? Sn(d[q], _ - 1, C) : (C || Pn)(d[q]), B.push(dt);
      return B;
    }
    function ot(d, _) {
      return d = zt(d), d.alt !== void 0 ? [y(d.lng, _), y(d.lat, _), y(d.alt, _)] : [y(d.lng, _), y(d.lat, _)];
    }
    function vt(d, _, C, B) {
      for (var q = [], Q = 0, dt = d.length; Q < dt; Q++)
        q.push(_ ? vt(d[Q], ei(d[Q]) ? 0 : _ - 1, C, B) : ot(d[Q], B));
      return !_ && C && q.length > 0 && q.push(q[0].slice()), q;
    }
    function Ct(d, _) {
      return d.feature ? l({}, d.feature, { geometry: _ }) : At(_);
    }
    function At(d) {
      return d.type === "Feature" || d.type === "FeatureCollection" ? d : {
        type: "Feature",
        properties: {},
        geometry: d
      };
    }
    var It = {
      toGeoJSON: function(d) {
        return Ct(this, {
          type: "Point",
          coordinates: ot(this.getLatLng(), d)
        });
      }
    };
    En.include(It), Yi.include(It), _i.include(It), li.include({
      toGeoJSON: function(d) {
        var _ = !ei(this._latlngs), C = vt(this._latlngs, _ ? 1 : 0, !1, d);
        return Ct(this, {
          type: (_ ? "Multi" : "") + "LineString",
          coordinates: C
        });
      }
    }), rn.include({
      toGeoJSON: function(d) {
        var _ = !ei(this._latlngs), C = _ && !ei(this._latlngs[0]), B = vt(this._latlngs, C ? 2 : _ ? 1 : 0, !0, d);
        return _ || (B = [B]), Ct(this, {
          type: (C ? "Multi" : "") + "Polygon",
          coordinates: B
        });
      }
    }), en.include({
      toMultiPoint: function(d) {
        var _ = [];
        return this.eachLayer(function(C) {
          _.push(C.toGeoJSON(d).geometry.coordinates);
        }), Ct(this, {
          type: "MultiPoint",
          coordinates: _
        });
      },
      // @method toGeoJSON(precision?: Number|false): Object
      // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
      // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
      toGeoJSON: function(d) {
        var _ = this.feature && this.feature.geometry && this.feature.geometry.type;
        if (_ === "MultiPoint")
          return this.toMultiPoint(d);
        var C = _ === "GeometryCollection", B = [];
        return this.eachLayer(function(q) {
          if (q.toGeoJSON) {
            var Q = q.toGeoJSON(d);
            if (C)
              B.push(Q.geometry);
            else {
              var dt = At(Q);
              dt.type === "FeatureCollection" ? B.push.apply(B, dt.features) : B.push(dt);
            }
          }
        }), C ? Ct(this, {
          geometries: B,
          type: "GeometryCollection"
        }) : {
          type: "FeatureCollection",
          features: B
        };
      }
    });
    function Kt(d, _) {
      return new yi(d, _);
    }
    var te = Kt, ne = mi.extend({
      // @section
      // @aka ImageOverlay options
      options: {
        // @option opacity: Number = 1.0
        // The opacity of the image overlay.
        opacity: 1,
        // @option alt: String = ''
        // Text for the `alt` attribute of the image (useful for accessibility).
        alt: "",
        // @option interactive: Boolean = false
        // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
        interactive: !1,
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the image.
        // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: !1,
        // @option errorOverlayUrl: String = ''
        // URL to the overlay image to show in place of the overlay that failed to load.
        errorOverlayUrl: "",
        // @option zIndex: Number = 1
        // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
        zIndex: 1,
        // @option className: String = ''
        // A custom class name to assign to the image. Empty by default.
        className: ""
      },
      initialize: function(d, _, C) {
        this._url = d, this._bounds = St(_), x(this, C);
      },
      onAdd: function() {
        this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (pe(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();
      },
      onRemove: function() {
        ke(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
      },
      // @method setOpacity(opacity: Number): this
      // Sets the opacity of the overlay.
      setOpacity: function(d) {
        return this.options.opacity = d, this._image && this._updateOpacity(), this;
      },
      setStyle: function(d) {
        return d.opacity && this.setOpacity(d.opacity), this;
      },
      // @method bringToFront(): this
      // Brings the layer to the top of all overlays.
      bringToFront: function() {
        return this._map && ci(this._image), this;
      },
      // @method bringToBack(): this
      // Brings the layer to the bottom of all overlays.
      bringToBack: function() {
        return this._map && Li(this._image), this;
      },
      // @method setUrl(url: String): this
      // Changes the URL of the image.
      setUrl: function(d) {
        return this._url = d, this._image && (this._image.src = d), this;
      },
      // @method setBounds(bounds: LatLngBounds): this
      // Update the bounds that this ImageOverlay covers
      setBounds: function(d) {
        return this._bounds = St(d), this._map && this._reset(), this;
      },
      getEvents: function() {
        var d = {
          zoom: this._reset,
          viewreset: this._reset
        };
        return this._zoomAnimated && (d.zoomanim = this._animateZoom), d;
      },
      // @method setZIndex(value: Number): this
      // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
      setZIndex: function(d) {
        return this.options.zIndex = d, this._updateZIndex(), this;
      },
      // @method getBounds(): LatLngBounds
      // Get the bounds that this ImageOverlay covers
      getBounds: function() {
        return this._bounds;
      },
      // @method getElement(): HTMLElement
      // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
      // used by this overlay.
      getElement: function() {
        return this._image;
      },
      _initImage: function() {
        var d = this._url.tagName === "IMG", _ = this._image = d ? this._url : Me("img");
        if (pe(_, "leaflet-image-layer"), this._zoomAnimated && pe(_, "leaflet-zoom-animated"), this.options.className && pe(_, this.options.className), _.onselectstart = g, _.onmousemove = g, _.onload = h(this.fire, this, "load"), _.onerror = h(this._overlayOnError, this, "error"), (this.options.crossOrigin || this.options.crossOrigin === "") && (_.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), d) {
          this._url = _.src;
          return;
        }
        _.src = this._url, _.alt = this.options.alt;
      },
      _animateZoom: function(d) {
        var _ = this._map.getZoomScale(d.zoom), C = this._map._latLngBoundsToNewLayerBounds(this._bounds, d.zoom, d.center).min;
        Ge(this._image, C, _);
      },
      _reset: function() {
        var d = this._image, _ = new ht(
          this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
          this._map.latLngToLayerPoint(this._bounds.getSouthEast())
        ), C = _.getSize();
        Ie(d, _.min), d.style.width = C.x + "px", d.style.height = C.y + "px";
      },
      _updateOpacity: function() {
        ni(this._image, this.options.opacity);
      },
      _updateZIndex: function() {
        this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex);
      },
      _overlayOnError: function() {
        this.fire("error");
        var d = this.options.errorOverlayUrl;
        d && this._url !== d && (this._url = d, this._image.src = d);
      },
      // @method getCenter(): LatLng
      // Returns the center of the ImageOverlay.
      getCenter: function() {
        return this._bounds.getCenter();
      }
    }), ee = function(d, _, C) {
      return new ne(d, _, C);
    }, _e = ne.extend({
      // @section
      // @aka VideoOverlay options
      options: {
        // @option autoplay: Boolean = true
        // Whether the video starts playing automatically when loaded.
        // On some browsers autoplay will only work with `muted: true`
        autoplay: !0,
        // @option loop: Boolean = true
        // Whether the video will loop back to the beginning when played.
        loop: !0,
        // @option keepAspectRatio: Boolean = true
        // Whether the video will save aspect ratio after the projection.
        // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
        keepAspectRatio: !0,
        // @option muted: Boolean = false
        // Whether the video starts on mute when loaded.
        muted: !1,
        // @option playsInline: Boolean = true
        // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
        playsInline: !0
      },
      _initImage: function() {
        var d = this._url.tagName === "VIDEO", _ = this._image = d ? this._url : Me("video");
        if (pe(_, "leaflet-image-layer"), this._zoomAnimated && pe(_, "leaflet-zoom-animated"), this.options.className && pe(_, this.options.className), _.onselectstart = g, _.onmousemove = g, _.onloadeddata = h(this.fire, this, "load"), d) {
          for (var C = _.getElementsByTagName("source"), B = [], q = 0; q < C.length; q++)
            B.push(C[q].src);
          this._url = C.length > 0 ? B : [_.src];
          return;
        }
        N(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(_.style, "objectFit") && (_.style.objectFit = "fill"), _.autoplay = !!this.options.autoplay, _.loop = !!this.options.loop, _.muted = !!this.options.muted, _.playsInline = !!this.options.playsInline;
        for (var Q = 0; Q < this._url.length; Q++) {
          var dt = Me("source");
          dt.src = this._url[Q], _.appendChild(dt);
        }
      }
      // @method getElement(): HTMLVideoElement
      // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
      // used by this overlay.
    });
    function oe(d, _, C) {
      return new _e(d, _, C);
    }
    var ue = ne.extend({
      _initImage: function() {
        var d = this._image = this._url;
        pe(d, "leaflet-image-layer"), this._zoomAnimated && pe(d, "leaflet-zoom-animated"), this.options.className && pe(d, this.options.className), d.onselectstart = g, d.onmousemove = g;
      }
      // @method getElement(): SVGElement
      // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
      // used by this overlay.
    });
    function xe(d, _, C) {
      return new ue(d, _, C);
    }
    var re = mi.extend({
      // @section
      // @aka DivOverlay options
      options: {
        // @option interactive: Boolean = false
        // If true, the popup/tooltip will listen to the mouse events.
        interactive: !1,
        // @option offset: Point = Point(0, 0)
        // The offset of the overlay position.
        offset: [0, 0],
        // @option className: String = ''
        // A custom CSS class name to assign to the overlay.
        className: "",
        // @option pane: String = undefined
        // `Map pane` where the overlay will be added.
        pane: void 0,
        // @option content: String|HTMLElement|Function = ''
        // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
        // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
        content: ""
      },
      initialize: function(d, _) {
        d && (d instanceof Ft || N(d)) ? (this._latlng = zt(d), x(this, _)) : (x(this, d), this._source = _), this.options.content && (this._content = this.options.content);
      },
      // @method openOn(map: Map): this
      // Adds the overlay to the map.
      // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
      openOn: function(d) {
        return d = arguments.length ? d : this._source._map, d.hasLayer(this) || d.addLayer(this), this;
      },
      // @method close(): this
      // Closes the overlay.
      // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
      // and `layer.closePopup()`/`.closeTooltip()`.
      close: function() {
        return this._map && this._map.removeLayer(this), this;
      },
      // @method toggle(layer?: Layer): this
      // Opens or closes the overlay bound to layer depending on its current state.
      // Argument may be omitted only for overlay bound to layer.
      // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
      toggle: function(d) {
        return this._map ? this.close() : (arguments.length ? this._source = d : d = this._source, this._prepareOpen(), this.openOn(d._map)), this;
      },
      onAdd: function(d) {
        this._zoomAnimated = d._zoomAnimated, this._container || this._initLayout(), d._fadeAnimated && ni(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), d._fadeAnimated && ni(this._container, 1), this.bringToFront(), this.options.interactive && (pe(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
      },
      onRemove: function(d) {
        d._fadeAnimated ? (ni(this._container, 0), this._removeTimeout = setTimeout(h(ke, void 0, this._container), 200)) : ke(this._container), this.options.interactive && (Ne(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
      },
      // @namespace DivOverlay
      // @method getLatLng: LatLng
      // Returns the geographical point of the overlay.
      getLatLng: function() {
        return this._latlng;
      },
      // @method setLatLng(latlng: LatLng): this
      // Sets the geographical point where the overlay will open.
      setLatLng: function(d) {
        return this._latlng = zt(d), this._map && (this._updatePosition(), this._adjustPan()), this;
      },
      // @method getContent: String|HTMLElement
      // Returns the content of the overlay.
      getContent: function() {
        return this._content;
      },
      // @method setContent(htmlContent: String|HTMLElement|Function): this
      // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
      // The function should return a `String` or `HTMLElement` to be used in the overlay.
      setContent: function(d) {
        return this._content = d, this.update(), this;
      },
      // @method getElement: String|HTMLElement
      // Returns the HTML container of the overlay.
      getElement: function() {
        return this._container;
      },
      // @method update: null
      // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
      update: function() {
        this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
      },
      getEvents: function() {
        var d = {
          zoom: this._updatePosition,
          viewreset: this._updatePosition
        };
        return this._zoomAnimated && (d.zoomanim = this._animateZoom), d;
      },
      // @method isOpen: Boolean
      // Returns `true` when the overlay is visible on the map.
      isOpen: function() {
        return !!this._map && this._map.hasLayer(this);
      },
      // @method bringToFront: this
      // Brings this overlay in front of other overlays (in the same map pane).
      bringToFront: function() {
        return this._map && ci(this._container), this;
      },
      // @method bringToBack: this
      // Brings this overlay to the back of other overlays (in the same map pane).
      bringToBack: function() {
        return this._map && Li(this._container), this;
      },
      // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
      _prepareOpen: function(d) {
        var _ = this._source;
        if (!_._map)
          return !1;
        if (_ instanceof be) {
          _ = null;
          var C = this._source._layers;
          for (var B in C)
            if (C[B]._map) {
              _ = C[B];
              break;
            }
          if (!_)
            return !1;
          this._source = _;
        }
        if (!d)
          if (_.getCenter)
            d = _.getCenter();
          else if (_.getLatLng)
            d = _.getLatLng();
          else if (_.getBounds)
            d = _.getBounds().getCenter();
          else
            throw new Error("Unable to get source layer LatLng.");
        return this.setLatLng(d), this._map && this.update(), !0;
      },
      _updateContent: function() {
        if (this._content) {
          var d = this._contentNode, _ = typeof this._content == "function" ? this._content(this._source || this) : this._content;
          if (typeof _ == "string")
            d.innerHTML = _;
          else {
            for (; d.hasChildNodes(); )
              d.removeChild(d.firstChild);
            d.appendChild(_);
          }
          this.fire("contentupdate");
        }
      },
      _updatePosition: function() {
        if (this._map) {
          var d = this._map.latLngToLayerPoint(this._latlng), _ = rt(this.options.offset), C = this._getAnchor();
          this._zoomAnimated ? Ie(this._container, d.add(C)) : _ = _.add(d).add(C);
          var B = this._containerBottom = -_.y, q = this._containerLeft = -Math.round(this._containerWidth / 2) + _.x;
          this._container.style.bottom = B + "px", this._container.style.left = q + "px";
        }
      },
      _getAnchor: function() {
        return [0, 0];
      }
    });
    Ee.include({
      _initOverlay: function(d, _, C, B) {
        var q = _;
        return q instanceof d || (q = new d(B).setContent(_)), C && q.setLatLng(C), q;
      }
    }), mi.include({
      _initOverlay: function(d, _, C, B) {
        var q = C;
        return q instanceof d ? (x(q, B), q._source = this) : (q = _ && !B ? _ : new d(B, this), q.setContent(C)), q;
      }
    });
    var Ae = re.extend({
      // @section
      // @aka Popup options
      options: {
        // @option pane: String = 'popupPane'
        // `Map pane` where the popup will be added.
        pane: "popupPane",
        // @option offset: Point = Point(0, 7)
        // The offset of the popup position.
        offset: [0, 7],
        // @option maxWidth: Number = 300
        // Max width of the popup, in pixels.
        maxWidth: 300,
        // @option minWidth: Number = 50
        // Min width of the popup, in pixels.
        minWidth: 50,
        // @option maxHeight: Number = null
        // If set, creates a scrollable container of the given height
        // inside a popup if its content exceeds it.
        // The scrollable container can be styled using the
        // `leaflet-popup-scrolled` CSS class selector.
        maxHeight: null,
        // @option autoPan: Boolean = true
        // Set it to `false` if you don't want the map to do panning animation
        // to fit the opened popup.
        autoPan: !0,
        // @option autoPanPaddingTopLeft: Point = null
        // The margin between the popup and the top left corner of the map
        // view after autopanning was performed.
        autoPanPaddingTopLeft: null,
        // @option autoPanPaddingBottomRight: Point = null
        // The margin between the popup and the bottom right corner of the map
        // view after autopanning was performed.
        autoPanPaddingBottomRight: null,
        // @option autoPanPadding: Point = Point(5, 5)
        // Equivalent of setting both top left and bottom right autopan padding to the same value.
        autoPanPadding: [5, 5],
        // @option keepInView: Boolean = false
        // Set it to `true` if you want to prevent users from panning the popup
        // off of the screen while it is open.
        keepInView: !1,
        // @option closeButton: Boolean = true
        // Controls the presence of a close button in the popup.
        closeButton: !0,
        // @option autoClose: Boolean = true
        // Set it to `false` if you want to override the default behavior of
        // the popup closing when another popup is opened.
        autoClose: !0,
        // @option closeOnEscapeKey: Boolean = true
        // Set it to `false` if you want to override the default behavior of
        // the ESC key for closing of the popup.
        closeOnEscapeKey: !0,
        // @option closeOnClick: Boolean = *
        // Set it if you want to override the default behavior of the popup closing when user clicks
        // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
        // @option className: String = ''
        // A custom CSS class name to assign to the popup.
        className: ""
      },
      // @namespace Popup
      // @method openOn(map: Map): this
      // Alternative to `map.openPopup(popup)`.
      // Adds the popup to the map and closes the previous one.
      openOn: function(d) {
        return d = arguments.length ? d : this._source._map, !d.hasLayer(this) && d._popup && d._popup.options.autoClose && d.removeLayer(d._popup), d._popup = this, re.prototype.openOn.call(this, d);
      },
      onAdd: function(d) {
        re.prototype.onAdd.call(this, d), d.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof Si || this._source.on("preclick", Vi));
      },
      onRemove: function(d) {
        re.prototype.onRemove.call(this, d), d.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof Si || this._source.off("preclick", Vi));
      },
      getEvents: function() {
        var d = re.prototype.getEvents.call(this);
        return (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (d.preclick = this.close), this.options.keepInView && (d.moveend = this._adjustPan), d;
      },
      _initLayout: function() {
        var d = "leaflet-popup", _ = this._container = Me(
          "div",
          d + " " + (this.options.className || "") + " leaflet-zoom-animated"
        ), C = this._wrapper = Me("div", d + "-content-wrapper", _);
        if (this._contentNode = Me("div", d + "-content", C), wn(_), hr(this._contentNode), de(_, "contextmenu", Vi), this._tipContainer = Me("div", d + "-tip-container", _), this._tip = Me("div", d + "-tip", this._tipContainer), this.options.closeButton) {
          var B = this._closeButton = Me("a", d + "-close-button", _);
          B.setAttribute("role", "button"), B.setAttribute("aria-label", "Close popup"), B.href = "#close", B.innerHTML = '<span aria-hidden="true">&#215;</span>', de(B, "click", function(q) {
            He(q), this.close();
          }, this);
        }
      },
      _updateLayout: function() {
        var d = this._contentNode, _ = d.style;
        _.width = "", _.whiteSpace = "nowrap";
        var C = d.offsetWidth;
        C = Math.min(C, this.options.maxWidth), C = Math.max(C, this.options.minWidth), _.width = C + 1 + "px", _.whiteSpace = "", _.height = "";
        var B = d.offsetHeight, q = this.options.maxHeight, Q = "leaflet-popup-scrolled";
        q && B > q ? (_.height = q + "px", pe(d, Q)) : Ne(d, Q), this._containerWidth = this._container.offsetWidth;
      },
      _animateZoom: function(d) {
        var _ = this._map._latLngToNewLayerPoint(this._latlng, d.zoom, d.center), C = this._getAnchor();
        Ie(this._container, _.add(C));
      },
      _adjustPan: function() {
        if (this.options.autoPan) {
          if (this._map._panAnim && this._map._panAnim.stop(), this._autopanning) {
            this._autopanning = !1;
            return;
          }
          var d = this._map, _ = parseInt($i(this._container, "marginBottom"), 10) || 0, C = this._container.offsetHeight + _, B = this._containerWidth, q = new Y(this._containerLeft, -C - this._containerBottom);
          q._add(fi(this._container));
          var Q = d.layerPointToContainerPoint(q), dt = rt(this.options.autoPanPadding), Dt = rt(this.options.autoPanPaddingTopLeft || dt), Tt = rt(this.options.autoPanPaddingBottomRight || dt), Wt = d.getSize(), ie = 0, le = 0;
          Q.x + B + Tt.x > Wt.x && (ie = Q.x + B - Wt.x + Tt.x), Q.x - ie - Dt.x < 0 && (ie = Q.x - Dt.x), Q.y + C + Tt.y > Wt.y && (le = Q.y + C - Wt.y + Tt.y), Q.y - le - Dt.y < 0 && (le = Q.y - Dt.y), (ie || le) && (this.options.keepInView && (this._autopanning = !0), d.fire("autopanstart").panBy([ie, le]));
        }
      },
      _getAnchor: function() {
        return rt(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
      }
    }), ii = function(d, _) {
      return new Ae(d, _);
    };
    Ee.mergeOptions({
      closePopupOnClick: !0
    }), Ee.include({
      // @method openPopup(popup: Popup): this
      // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
      // @alternative
      // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
      // Creates a popup with the specified content and options and opens it in the given point on a map.
      openPopup: function(d, _, C) {
        return this._initOverlay(Ae, d, _, C).openOn(this), this;
      },
      // @method closePopup(popup?: Popup): this
      // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
      closePopup: function(d) {
        return d = arguments.length ? d : this._popup, d && d.close(), this;
      }
    }), mi.include({
      // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
      // Binds a popup to the layer with the passed `content` and sets up the
      // necessary event listeners. If a `Function` is passed it will receive
      // the layer as the first argument and should return a `String` or `HTMLElement`.
      bindPopup: function(d, _) {
        return this._popup = this._initOverlay(Ae, this._popup, d, _), this._popupHandlersAdded || (this.on({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        }), this._popupHandlersAdded = !0), this;
      },
      // @method unbindPopup(): this
      // Removes the popup previously bound with `bindPopup`.
      unbindPopup: function() {
        return this._popup && (this.off({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        }), this._popupHandlersAdded = !1, this._popup = null), this;
      },
      // @method openPopup(latlng?: LatLng): this
      // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
      openPopup: function(d) {
        return this._popup && (this instanceof be || (this._popup._source = this), this._popup._prepareOpen(d || this._latlng) && this._popup.openOn(this._map)), this;
      },
      // @method closePopup(): this
      // Closes the popup bound to this layer if it is open.
      closePopup: function() {
        return this._popup && this._popup.close(), this;
      },
      // @method togglePopup(): this
      // Opens or closes the popup bound to this layer depending on its current state.
      togglePopup: function() {
        return this._popup && this._popup.toggle(this), this;
      },
      // @method isPopupOpen(): boolean
      // Returns `true` if the popup bound to this layer is currently open.
      isPopupOpen: function() {
        return this._popup ? this._popup.isOpen() : !1;
      },
      // @method setPopupContent(content: String|HTMLElement|Popup): this
      // Sets the content of the popup bound to this layer.
      setPopupContent: function(d) {
        return this._popup && this._popup.setContent(d), this;
      },
      // @method getPopup(): Popup
      // Returns the popup bound to this layer.
      getPopup: function() {
        return this._popup;
      },
      _openPopup: function(d) {
        if (!(!this._popup || !this._map)) {
          Ni(d);
          var _ = d.layer || d.target;
          if (this._popup._source === _ && !(_ instanceof Si)) {
            this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(d.latlng);
            return;
          }
          this._popup._source = _, this.openPopup(d.latlng);
        }
      },
      _movePopup: function(d) {
        this._popup.setLatLng(d.latlng);
      },
      _onKeyPress: function(d) {
        d.originalEvent.keyCode === 13 && this._openPopup(d);
      }
    });
    var ze = re.extend({
      // @section
      // @aka Tooltip options
      options: {
        // @option pane: String = 'tooltipPane'
        // `Map pane` where the tooltip will be added.
        pane: "tooltipPane",
        // @option offset: Point = Point(0, 0)
        // Optional offset of the tooltip position.
        offset: [0, 0],
        // @option direction: String = 'auto'
        // Direction where to open the tooltip. Possible values are: `right`, `left`,
        // `top`, `bottom`, `center`, `auto`.
        // `auto` will dynamically switch between `right` and `left` according to the tooltip
        // position on the map.
        direction: "auto",
        // @option permanent: Boolean = false
        // Whether to open the tooltip permanently or only on mouseover.
        permanent: !1,
        // @option sticky: Boolean = false
        // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
        sticky: !1,
        // @option opacity: Number = 0.9
        // Tooltip container opacity.
        opacity: 0.9
      },
      onAdd: function(d) {
        re.prototype.onAdd.call(this, d), this.setOpacity(this.options.opacity), d.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, !0));
      },
      onRemove: function(d) {
        re.prototype.onRemove.call(this, d), d.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, !0));
      },
      getEvents: function() {
        var d = re.prototype.getEvents.call(this);
        return this.options.permanent || (d.preclick = this.close), d;
      },
      _initLayout: function() {
        var d = "leaflet-tooltip", _ = d + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
        this._contentNode = this._container = Me("div", _), this._container.setAttribute("role", "tooltip"), this._container.setAttribute("id", "leaflet-tooltip-" + f(this));
      },
      _updateLayout: function() {
      },
      _adjustPan: function() {
      },
      _setPosition: function(d) {
        var _, C, B = this._map, q = this._container, Q = B.latLngToContainerPoint(B.getCenter()), dt = B.layerPointToContainerPoint(d), Dt = this.options.direction, Tt = q.offsetWidth, Wt = q.offsetHeight, ie = rt(this.options.offset), le = this._getAnchor();
        Dt === "top" ? (_ = Tt / 2, C = Wt) : Dt === "bottom" ? (_ = Tt / 2, C = 0) : Dt === "center" ? (_ = Tt / 2, C = Wt / 2) : Dt === "right" ? (_ = 0, C = Wt / 2) : Dt === "left" ? (_ = Tt, C = Wt / 2) : dt.x < Q.x ? (Dt = "right", _ = 0, C = Wt / 2) : (Dt = "left", _ = Tt + (ie.x + le.x) * 2, C = Wt / 2), d = d.subtract(rt(_, C, !0)).add(ie).add(le), Ne(q, "leaflet-tooltip-right"), Ne(q, "leaflet-tooltip-left"), Ne(q, "leaflet-tooltip-top"), Ne(q, "leaflet-tooltip-bottom"), pe(q, "leaflet-tooltip-" + Dt), Ie(q, d);
      },
      _updatePosition: function() {
        var d = this._map.latLngToLayerPoint(this._latlng);
        this._setPosition(d);
      },
      setOpacity: function(d) {
        this.options.opacity = d, this._container && ni(this._container, d);
      },
      _animateZoom: function(d) {
        var _ = this._map._latLngToNewLayerPoint(this._latlng, d.zoom, d.center);
        this._setPosition(_);
      },
      _getAnchor: function() {
        return rt(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
      }
    }), ui = function(d, _) {
      return new ze(d, _);
    };
    Ee.include({
      // @method openTooltip(tooltip: Tooltip): this
      // Opens the specified tooltip.
      // @alternative
      // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
      // Creates a tooltip with the specified content and options and open it.
      openTooltip: function(d, _, C) {
        return this._initOverlay(ze, d, _, C).openOn(this), this;
      },
      // @method closeTooltip(tooltip: Tooltip): this
      // Closes the tooltip given as parameter.
      closeTooltip: function(d) {
        return d.close(), this;
      }
    }), mi.include({
      // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
      // Binds a tooltip to the layer with the passed `content` and sets up the
      // necessary event listeners. If a `Function` is passed it will receive
      // the layer as the first argument and should return a `String` or `HTMLElement`.
      bindTooltip: function(d, _) {
        return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(ze, this._tooltip, d, _), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;
      },
      // @method unbindTooltip(): this
      // Removes the tooltip previously bound with `bindTooltip`.
      unbindTooltip: function() {
        return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this;
      },
      _initTooltipInteractions: function(d) {
        if (!(!d && this._tooltipHandlersAdded)) {
          var _ = d ? "off" : "on", C = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
          this._tooltip.options.permanent ? C.add = this._openTooltip : (C.mouseover = this._openTooltip, C.mouseout = this.closeTooltip, C.click = this._openTooltip, this._map ? this._addFocusListeners() : C.add = this._addFocusListeners), this._tooltip.options.sticky && (C.mousemove = this._moveTooltip), this[_](C), this._tooltipHandlersAdded = !d;
        }
      },
      // @method openTooltip(latlng?: LatLng): this
      // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
      openTooltip: function(d) {
        return this._tooltip && (this instanceof be || (this._tooltip._source = this), this._tooltip._prepareOpen(d) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), this;
      },
      // @method closeTooltip(): this
      // Closes the tooltip bound to this layer if it is open.
      closeTooltip: function() {
        if (this._tooltip)
          return this._tooltip.close();
      },
      // @method toggleTooltip(): this
      // Opens or closes the tooltip bound to this layer depending on its current state.
      toggleTooltip: function() {
        return this._tooltip && this._tooltip.toggle(this), this;
      },
      // @method isTooltipOpen(): boolean
      // Returns `true` if the tooltip bound to this layer is currently open.
      isTooltipOpen: function() {
        return this._tooltip.isOpen();
      },
      // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
      // Sets the content of the tooltip bound to this layer.
      setTooltipContent: function(d) {
        return this._tooltip && this._tooltip.setContent(d), this;
      },
      // @method getTooltip(): Tooltip
      // Returns the tooltip bound to this layer.
      getTooltip: function() {
        return this._tooltip;
      },
      _addFocusListeners: function() {
        this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
      },
      _addFocusListenersOnLayer: function(d) {
        var _ = typeof d.getElement == "function" && d.getElement();
        _ && (de(_, "focus", function() {
          this._tooltip._source = d, this.openTooltip();
        }, this), de(_, "blur", this.closeTooltip, this));
      },
      _setAriaDescribedByOnLayer: function(d) {
        var _ = typeof d.getElement == "function" && d.getElement();
        _ && _.setAttribute("aria-describedby", this._tooltip._container.id);
      },
      _openTooltip: function(d) {
        if (!(!this._tooltip || !this._map)) {
          if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
            this._openOnceFlag = !0;
            var _ = this;
            this._map.once("moveend", function() {
              _._openOnceFlag = !1, _._openTooltip(d);
            });
            return;
          }
          this._tooltip._source = d.layer || d.target, this.openTooltip(this._tooltip.options.sticky ? d.latlng : void 0);
        }
      },
      _moveTooltip: function(d) {
        var _ = d.latlng, C, B;
        this._tooltip.options.sticky && d.originalEvent && (C = this._map.mouseEventToContainerPoint(d.originalEvent), B = this._map.containerPointToLayerPoint(C), _ = this._map.layerPointToLatLng(B)), this._tooltip.setLatLng(_);
      }
    });
    var bi = Xe.extend({
      options: {
        // @section
        // @aka DivIcon options
        iconSize: [12, 12],
        // also can be set through CSS
        // iconAnchor: (Point),
        // popupAnchor: (Point),
        // @option html: String|HTMLElement = ''
        // Custom HTML code to put inside the div element, empty by default. Alternatively,
        // an instance of `HTMLElement`.
        html: !1,
        // @option bgPos: Point = [0, 0]
        // Optional relative position of the background, in pixels
        bgPos: null,
        className: "leaflet-div-icon"
      },
      createIcon: function(d) {
        var _ = d && d.tagName === "DIV" ? d : document.createElement("div"), C = this.options;
        if (C.html instanceof Element ? (qe(_), _.appendChild(C.html)) : _.innerHTML = C.html !== !1 ? C.html : "", C.bgPos) {
          var B = rt(C.bgPos);
          _.style.backgroundPosition = -B.x + "px " + -B.y + "px";
        }
        return this._setIconStyles(_, "icon"), _;
      },
      createShadow: function() {
        return null;
      }
    });
    function on(d) {
      return new bi(d);
    }
    Xe.Default = Mn;
    var Re = mi.extend({
      // @section
      // @aka GridLayer options
      options: {
        // @option tileSize: Number|Point = 256
        // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
        tileSize: 256,
        // @option opacity: Number = 1.0
        // Opacity of the tiles. Can be used in the `createTile()` function.
        opacity: 1,
        // @option updateWhenIdle: Boolean = (depends)
        // Load new tiles only when panning ends.
        // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
        // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
        // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
        updateWhenIdle: ae.mobile,
        // @option updateWhenZooming: Boolean = true
        // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
        updateWhenZooming: !0,
        // @option updateInterval: Number = 200
        // Tiles will not update more than once every `updateInterval` milliseconds when panning.
        updateInterval: 200,
        // @option zIndex: Number = 1
        // The explicit zIndex of the tile layer.
        zIndex: 1,
        // @option bounds: LatLngBounds = undefined
        // If set, tiles will only be loaded inside the set `LatLngBounds`.
        bounds: null,
        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom: 0,
        // @option maxZoom: Number = undefined
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom: void 0,
        // @option maxNativeZoom: Number = undefined
        // Maximum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
        // from `maxNativeZoom` level and auto-scaled.
        maxNativeZoom: void 0,
        // @option minNativeZoom: Number = undefined
        // Minimum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
        // from `minNativeZoom` level and auto-scaled.
        minNativeZoom: void 0,
        // @option noWrap: Boolean = false
        // Whether the layer is wrapped around the antimeridian. If `true`, the
        // GridLayer will only be displayed once at low zoom levels. Has no
        // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
        // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
        // tiles outside the CRS limits.
        noWrap: !1,
        // @option pane: String = 'tilePane'
        // `Map pane` where the grid layer will be added.
        pane: "tilePane",
        // @option className: String = ''
        // A custom class name to assign to the tile layer. Empty by default.
        className: "",
        // @option keepBuffer: Number = 2
        // When panning the map, keep this many rows and columns of tiles before unloading them.
        keepBuffer: 2
      },
      initialize: function(d) {
        x(this, d);
      },
      onAdd: function() {
        this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
      },
      beforeAdd: function(d) {
        d._addZoomLimit(this);
      },
      onRemove: function(d) {
        this._removeAllTiles(), ke(this._container), d._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;
      },
      // @method bringToFront: this
      // Brings the tile layer to the top of all tile layers.
      bringToFront: function() {
        return this._map && (ci(this._container), this._setAutoZIndex(Math.max)), this;
      },
      // @method bringToBack: this
      // Brings the tile layer to the bottom of all tile layers.
      bringToBack: function() {
        return this._map && (Li(this._container), this._setAutoZIndex(Math.min)), this;
      },
      // @method getContainer: HTMLElement
      // Returns the HTML element that contains the tiles for this layer.
      getContainer: function() {
        return this._container;
      },
      // @method setOpacity(opacity: Number): this
      // Changes the [opacity](#gridlayer-opacity) of the grid layer.
      setOpacity: function(d) {
        return this.options.opacity = d, this._updateOpacity(), this;
      },
      // @method setZIndex(zIndex: Number): this
      // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
      setZIndex: function(d) {
        return this.options.zIndex = d, this._updateZIndex(), this;
      },
      // @method isLoading: Boolean
      // Returns `true` if any tile in the grid layer has not finished loading.
      isLoading: function() {
        return this._loading;
      },
      // @method redraw: this
      // Causes the layer to clear all the tiles and request them again.
      redraw: function() {
        if (this._map) {
          this._removeAllTiles();
          var d = this._clampZoom(this._map.getZoom());
          d !== this._tileZoom && (this._tileZoom = d, this._updateLevels()), this._update();
        }
        return this;
      },
      getEvents: function() {
        var d = {
          viewprereset: this._invalidateAll,
          viewreset: this._resetView,
          zoom: this._resetView,
          moveend: this._onMoveEnd
        };
        return this.options.updateWhenIdle || (this._onMove || (this._onMove = v(this._onMoveEnd, this.options.updateInterval, this)), d.move = this._onMove), this._zoomAnimated && (d.zoomanim = this._animateZoom), d;
      },
      // @section Extension methods
      // Layers extending `GridLayer` shall reimplement the following method.
      // @method createTile(coords: Object, done?: Function): HTMLElement
      // Called only internally, must be overridden by classes extending `GridLayer`.
      // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
      // is specified, it must be called when the tile has finished loading and drawing.
      createTile: function() {
        return document.createElement("div");
      },
      // @section
      // @method getTileSize: Point
      // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
      getTileSize: function() {
        var d = this.options.tileSize;
        return d instanceof Y ? d : new Y(d, d);
      },
      _updateZIndex: function() {
        this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex);
      },
      _setAutoZIndex: function(d) {
        for (var _ = this.getPane().children, C = -d(-1 / 0, 1 / 0), B = 0, q = _.length, Q; B < q; B++)
          Q = _[B].style.zIndex, _[B] !== this._container && Q && (C = d(C, +Q));
        isFinite(C) && (this.options.zIndex = C + d(-1, 1), this._updateZIndex());
      },
      _updateOpacity: function() {
        if (this._map && !ae.ielt9) {
          ni(this._container, this.options.opacity);
          var d = +/* @__PURE__ */ new Date(), _ = !1, C = !1;
          for (var B in this._tiles) {
            var q = this._tiles[B];
            if (!(!q.current || !q.loaded)) {
              var Q = Math.min(1, (d - q.loaded) / 200);
              ni(q.el, Q), Q < 1 ? _ = !0 : (q.active ? C = !0 : this._onOpaqueTile(q), q.active = !0);
            }
          }
          C && !this._noPrune && this._pruneTiles(), _ && (ct(this._fadeFrame), this._fadeFrame = pt(this._updateOpacity, this));
        }
      },
      _onOpaqueTile: g,
      _initContainer: function() {
        this._container || (this._container = Me("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
      },
      _updateLevels: function() {
        var d = this._tileZoom, _ = this.options.maxZoom;
        if (d !== void 0) {
          for (var C in this._levels)
            C = Number(C), this._levels[C].el.children.length || C === d ? (this._levels[C].el.style.zIndex = _ - Math.abs(d - C), this._onUpdateLevel(C)) : (ke(this._levels[C].el), this._removeTilesAtZoom(C), this._onRemoveLevel(C), delete this._levels[C]);
          var B = this._levels[d], q = this._map;
          return B || (B = this._levels[d] = {}, B.el = Me("div", "leaflet-tile-container leaflet-zoom-animated", this._container), B.el.style.zIndex = _, B.origin = q.project(q.unproject(q.getPixelOrigin()), d).round(), B.zoom = d, this._setZoomTransform(B, q.getCenter(), q.getZoom()), g(B.el.offsetWidth), this._onCreateLevel(B)), this._level = B, B;
        }
      },
      _onUpdateLevel: g,
      _onRemoveLevel: g,
      _onCreateLevel: g,
      _pruneTiles: function() {
        if (this._map) {
          var d, _, C = this._map.getZoom();
          if (C > this.options.maxZoom || C < this.options.minZoom) {
            this._removeAllTiles();
            return;
          }
          for (d in this._tiles)
            _ = this._tiles[d], _.retain = _.current;
          for (d in this._tiles)
            if (_ = this._tiles[d], _.current && !_.active) {
              var B = _.coords;
              this._retainParent(B.x, B.y, B.z, B.z - 5) || this._retainChildren(B.x, B.y, B.z, B.z + 2);
            }
          for (d in this._tiles)
            this._tiles[d].retain || this._removeTile(d);
        }
      },
      _removeTilesAtZoom: function(d) {
        for (var _ in this._tiles)
          this._tiles[_].coords.z === d && this._removeTile(_);
      },
      _removeAllTiles: function() {
        for (var d in this._tiles)
          this._removeTile(d);
      },
      _invalidateAll: function() {
        for (var d in this._levels)
          ke(this._levels[d].el), this._onRemoveLevel(Number(d)), delete this._levels[d];
        this._removeAllTiles(), this._tileZoom = void 0;
      },
      _retainParent: function(d, _, C, B) {
        var q = Math.floor(d / 2), Q = Math.floor(_ / 2), dt = C - 1, Dt = new Y(+q, +Q);
        Dt.z = +dt;
        var Tt = this._tileCoordsToKey(Dt), Wt = this._tiles[Tt];
        return Wt && Wt.active ? (Wt.retain = !0, !0) : (Wt && Wt.loaded && (Wt.retain = !0), dt > B ? this._retainParent(q, Q, dt, B) : !1);
      },
      _retainChildren: function(d, _, C, B) {
        for (var q = 2 * d; q < 2 * d + 2; q++)
          for (var Q = 2 * _; Q < 2 * _ + 2; Q++) {
            var dt = new Y(q, Q);
            dt.z = C + 1;
            var Dt = this._tileCoordsToKey(dt), Tt = this._tiles[Dt];
            if (Tt && Tt.active) {
              Tt.retain = !0;
              continue;
            } else
              Tt && Tt.loaded && (Tt.retain = !0);
            C + 1 < B && this._retainChildren(q, Q, C + 1, B);
          }
      },
      _resetView: function(d) {
        var _ = d && (d.pinch || d.flyTo);
        this._setView(this._map.getCenter(), this._map.getZoom(), _, _);
      },
      _animateZoom: function(d) {
        this._setView(d.center, d.zoom, !0, d.noUpdate);
      },
      _clampZoom: function(d) {
        var _ = this.options;
        return _.minNativeZoom !== void 0 && d < _.minNativeZoom ? _.minNativeZoom : _.maxNativeZoom !== void 0 && _.maxNativeZoom < d ? _.maxNativeZoom : d;
      },
      _setView: function(d, _, C, B) {
        var q = Math.round(_);
        this.options.maxZoom !== void 0 && q > this.options.maxZoom || this.options.minZoom !== void 0 && q < this.options.minZoom ? q = void 0 : q = this._clampZoom(q);
        var Q = this.options.updateWhenZooming && q !== this._tileZoom;
        (!B || Q) && (this._tileZoom = q, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), q !== void 0 && this._update(d), C || this._pruneTiles(), this._noPrune = !!C), this._setZoomTransforms(d, _);
      },
      _setZoomTransforms: function(d, _) {
        for (var C in this._levels)
          this._setZoomTransform(this._levels[C], d, _);
      },
      _setZoomTransform: function(d, _, C) {
        var B = this._map.getZoomScale(C, d.zoom), q = d.origin.multiplyBy(B).subtract(this._map._getNewPixelOrigin(_, C)).round();
        ae.any3d ? Ge(d.el, q, B) : Ie(d.el, q);
      },
      _resetGrid: function() {
        var d = this._map, _ = d.options.crs, C = this._tileSize = this.getTileSize(), B = this._tileZoom, q = this._map.getPixelWorldBounds(this._tileZoom);
        q && (this._globalTileRange = this._pxBoundsToTileRange(q)), this._wrapX = _.wrapLng && !this.options.noWrap && [
          Math.floor(d.project([0, _.wrapLng[0]], B).x / C.x),
          Math.ceil(d.project([0, _.wrapLng[1]], B).x / C.y)
        ], this._wrapY = _.wrapLat && !this.options.noWrap && [
          Math.floor(d.project([_.wrapLat[0], 0], B).y / C.x),
          Math.ceil(d.project([_.wrapLat[1], 0], B).y / C.y)
        ];
      },
      _onMoveEnd: function() {
        !this._map || this._map._animatingZoom || this._update();
      },
      _getTiledPixelBounds: function(d) {
        var _ = this._map, C = _._animatingZoom ? Math.max(_._animateToZoom, _.getZoom()) : _.getZoom(), B = _.getZoomScale(C, this._tileZoom), q = _.project(d, this._tileZoom).floor(), Q = _.getSize().divideBy(B * 2);
        return new ht(q.subtract(Q), q.add(Q));
      },
      // Private method to load tiles in the grid's active zoom level according to map bounds
      _update: function(d) {
        var _ = this._map;
        if (_) {
          var C = this._clampZoom(_.getZoom());
          if (d === void 0 && (d = _.getCenter()), this._tileZoom !== void 0) {
            var B = this._getTiledPixelBounds(d), q = this._pxBoundsToTileRange(B), Q = q.getCenter(), dt = [], Dt = this.options.keepBuffer, Tt = new ht(
              q.getBottomLeft().subtract([Dt, -Dt]),
              q.getTopRight().add([Dt, -Dt])
            );
            if (!(isFinite(q.min.x) && isFinite(q.min.y) && isFinite(q.max.x) && isFinite(q.max.y)))
              throw new Error("Attempted to load an infinite number of tiles");
            for (var Wt in this._tiles) {
              var ie = this._tiles[Wt].coords;
              (ie.z !== this._tileZoom || !Tt.contains(new Y(ie.x, ie.y))) && (this._tiles[Wt].current = !1);
            }
            if (Math.abs(C - this._tileZoom) > 1) {
              this._setView(d, C);
              return;
            }
            for (var le = q.min.y; le <= q.max.y; le++)
              for (var Ce = q.min.x; Ce <= q.max.x; Ce++) {
                var ri = new Y(Ce, le);
                if (ri.z = this._tileZoom, !!this._isValidTile(ri)) {
                  var Ye = this._tiles[this._tileCoordsToKey(ri)];
                  Ye ? Ye.current = !0 : dt.push(ri);
                }
              }
            if (dt.sort(function(hi, Qn) {
              return hi.distanceTo(Q) - Qn.distanceTo(Q);
            }), dt.length !== 0) {
              this._loading || (this._loading = !0, this.fire("loading"));
              var Ai = document.createDocumentFragment();
              for (Ce = 0; Ce < dt.length; Ce++)
                this._addTile(dt[Ce], Ai);
              this._level.el.appendChild(Ai);
            }
          }
        }
      },
      _isValidTile: function(d) {
        var _ = this._map.options.crs;
        if (!_.infinite) {
          var C = this._globalTileRange;
          if (!_.wrapLng && (d.x < C.min.x || d.x > C.max.x) || !_.wrapLat && (d.y < C.min.y || d.y > C.max.y))
            return !1;
        }
        if (!this.options.bounds)
          return !0;
        var B = this._tileCoordsToBounds(d);
        return St(this.options.bounds).overlaps(B);
      },
      _keyToBounds: function(d) {
        return this._tileCoordsToBounds(this._keyToTileCoords(d));
      },
      _tileCoordsToNwSe: function(d) {
        var _ = this._map, C = this.getTileSize(), B = d.scaleBy(C), q = B.add(C), Q = _.unproject(B, d.z), dt = _.unproject(q, d.z);
        return [Q, dt];
      },
      // converts tile coordinates to its geographical bounds
      _tileCoordsToBounds: function(d) {
        var _ = this._tileCoordsToNwSe(d), C = new yt(_[0], _[1]);
        return this.options.noWrap || (C = this._map.wrapLatLngBounds(C)), C;
      },
      // converts tile coordinates to key for the tile cache
      _tileCoordsToKey: function(d) {
        return d.x + ":" + d.y + ":" + d.z;
      },
      // converts tile cache key to coordinates
      _keyToTileCoords: function(d) {
        var _ = d.split(":"), C = new Y(+_[0], +_[1]);
        return C.z = +_[2], C;
      },
      _removeTile: function(d) {
        var _ = this._tiles[d];
        _ && (ke(_.el), delete this._tiles[d], this.fire("tileunload", {
          tile: _.el,
          coords: this._keyToTileCoords(d)
        }));
      },
      _initTile: function(d) {
        pe(d, "leaflet-tile");
        var _ = this.getTileSize();
        d.style.width = _.x + "px", d.style.height = _.y + "px", d.onselectstart = g, d.onmousemove = g, ae.ielt9 && this.options.opacity < 1 && ni(d, this.options.opacity);
      },
      _addTile: function(d, _) {
        var C = this._getTilePos(d), B = this._tileCoordsToKey(d), q = this.createTile(this._wrapCoords(d), h(this._tileReady, this, d));
        this._initTile(q), this.createTile.length < 2 && pt(h(this._tileReady, this, d, null, q)), Ie(q, C), this._tiles[B] = {
          el: q,
          coords: d,
          current: !0
        }, _.appendChild(q), this.fire("tileloadstart", {
          tile: q,
          coords: d
        });
      },
      _tileReady: function(d, _, C) {
        _ && this.fire("tileerror", {
          error: _,
          tile: C,
          coords: d
        });
        var B = this._tileCoordsToKey(d);
        C = this._tiles[B], C && (C.loaded = +/* @__PURE__ */ new Date(), this._map._fadeAnimated ? (ni(C.el, 0), ct(this._fadeFrame), this._fadeFrame = pt(this._updateOpacity, this)) : (C.active = !0, this._pruneTiles()), _ || (pe(C.el, "leaflet-tile-loaded"), this.fire("tileload", {
          tile: C.el,
          coords: d
        })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), ae.ielt9 || !this._map._fadeAnimated ? pt(this._pruneTiles, this) : setTimeout(h(this._pruneTiles, this), 250)));
      },
      _getTilePos: function(d) {
        return d.scaleBy(this.getTileSize()).subtract(this._level.origin);
      },
      _wrapCoords: function(d) {
        var _ = new Y(
          this._wrapX ? m(d.x, this._wrapX) : d.x,
          this._wrapY ? m(d.y, this._wrapY) : d.y
        );
        return _.z = d.z, _;
      },
      _pxBoundsToTileRange: function(d) {
        var _ = this.getTileSize();
        return new ht(
          d.min.unscaleBy(_).floor(),
          d.max.unscaleBy(_).ceil().subtract([1, 1])
        );
      },
      _noTilesToLoad: function() {
        for (var d in this._tiles)
          if (!this._tiles[d].loaded)
            return !1;
        return !0;
      }
    });
    function Jr(d) {
      return new Re(d);
    }
    var Kn = Re.extend({
      // @section
      // @aka TileLayer options
      options: {
        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom: 0,
        // @option maxZoom: Number = 18
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom: 18,
        // @option subdomains: String|String[] = 'abc'
        // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
        subdomains: "abc",
        // @option errorTileUrl: String = ''
        // URL to the tile image to show in place of the tile that failed to load.
        errorTileUrl: "",
        // @option zoomOffset: Number = 0
        // The zoom number used in tile URLs will be offset with this value.
        zoomOffset: 0,
        // @option tms: Boolean = false
        // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
        tms: !1,
        // @option zoomReverse: Boolean = false
        // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
        zoomReverse: !1,
        // @option detectRetina: Boolean = false
        // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
        detectRetina: !1,
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the tiles.
        // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: !1,
        // @option referrerPolicy: Boolean|String = false
        // Whether the referrerPolicy attribute will be added to the tiles.
        // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
        // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
        // (e.g. to validate an API token).
        // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
        referrerPolicy: !1
      },
      initialize: function(d, _) {
        this._url = d, _ = x(this, _), _.detectRetina && ae.retina && _.maxZoom > 0 ? (_.tileSize = Math.floor(_.tileSize / 2), _.zoomReverse ? (_.zoomOffset--, _.minZoom = Math.min(_.maxZoom, _.minZoom + 1)) : (_.zoomOffset++, _.maxZoom = Math.max(_.minZoom, _.maxZoom - 1)), _.minZoom = Math.max(0, _.minZoom)) : _.zoomReverse ? _.minZoom = Math.min(_.maxZoom, _.minZoom) : _.maxZoom = Math.max(_.minZoom, _.maxZoom), typeof _.subdomains == "string" && (_.subdomains = _.subdomains.split("")), this.on("tileunload", this._onTileRemove);
      },
      // @method setUrl(url: String, noRedraw?: Boolean): this
      // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
      // If the URL does not change, the layer will not be redrawn unless
      // the noRedraw parameter is set to false.
      setUrl: function(d, _) {
        return this._url === d && _ === void 0 && (_ = !0), this._url = d, _ || this.redraw(), this;
      },
      // @method createTile(coords: Object, done?: Function): HTMLElement
      // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
      // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
      // callback is called when the tile has been loaded.
      createTile: function(d, _) {
        var C = document.createElement("img");
        return de(C, "load", h(this._tileOnLoad, this, _, C)), de(C, "error", h(this._tileOnError, this, _, C)), (this.options.crossOrigin || this.options.crossOrigin === "") && (C.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), typeof this.options.referrerPolicy == "string" && (C.referrerPolicy = this.options.referrerPolicy), C.alt = "", C.src = this.getTileUrl(d), C;
      },
      // @section Extension methods
      // @uninheritable
      // Layers extending `TileLayer` might reimplement the following method.
      // @method getTileUrl(coords: Object): String
      // Called only internally, returns the URL for a tile given its coordinates.
      // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
      getTileUrl: function(d) {
        var _ = {
          r: ae.retina ? "@2x" : "",
          s: this._getSubdomain(d),
          x: d.x,
          y: d.y,
          z: this._getZoomForUrl()
        };
        if (this._map && !this._map.options.crs.infinite) {
          var C = this._globalTileRange.max.y - d.y;
          this.options.tms && (_.y = C), _["-y"] = C;
        }
        return k(this._url, l(_, this.options));
      },
      _tileOnLoad: function(d, _) {
        ae.ielt9 ? setTimeout(h(d, this, null, _), 0) : d(null, _);
      },
      _tileOnError: function(d, _, C) {
        var B = this.options.errorTileUrl;
        B && _.getAttribute("src") !== B && (_.src = B), d(C, _);
      },
      _onTileRemove: function(d) {
        d.tile.onload = null;
      },
      _getZoomForUrl: function() {
        var d = this._tileZoom, _ = this.options.maxZoom, C = this.options.zoomReverse, B = this.options.zoomOffset;
        return C && (d = _ - d), d + B;
      },
      _getSubdomain: function(d) {
        var _ = Math.abs(d.x + d.y) % this.options.subdomains.length;
        return this.options.subdomains[_];
      },
      // stops loading all tiles in the background layer
      _abortLoading: function() {
        var d, _;
        for (d in this._tiles)
          if (this._tiles[d].coords.z !== this._tileZoom && (_ = this._tiles[d].el, _.onload = g, _.onerror = g, !_.complete)) {
            _.src = R;
            var C = this._tiles[d].coords;
            ke(_), delete this._tiles[d], this.fire("tileabort", {
              tile: _,
              coords: C
            });
          }
      },
      _removeTile: function(d) {
        var _ = this._tiles[d];
        if (_)
          return _.el.setAttribute("src", R), Re.prototype._removeTile.call(this, d);
      },
      _tileReady: function(d, _, C) {
        if (!(!this._map || C && C.getAttribute("src") === R))
          return Re.prototype._tileReady.call(this, d, _, C);
      }
    });
    function Nr(d, _) {
      return new Kn(d, _);
    }
    var Or = Kn.extend({
      // @section
      // @aka TileLayer.WMS options
      // If any custom options not documented here are used, they will be sent to the
      // WMS server as extra parameters in each request URL. This can be useful for
      // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
      defaultWmsParams: {
        service: "WMS",
        request: "GetMap",
        // @option layers: String = ''
        // **(required)** Comma-separated list of WMS layers to show.
        layers: "",
        // @option styles: String = ''
        // Comma-separated list of WMS styles.
        styles: "",
        // @option format: String = 'image/jpeg'
        // WMS image format (use `'image/png'` for layers with transparency).
        format: "image/jpeg",
        // @option transparent: Boolean = false
        // If `true`, the WMS service will return images with transparency.
        transparent: !1,
        // @option version: String = '1.1.1'
        // Version of the WMS service to use
        version: "1.1.1"
      },
      options: {
        // @option crs: CRS = null
        // Coordinate Reference System to use for the WMS requests, defaults to
        // map CRS. Don't change this if you're not sure what it means.
        crs: null,
        // @option uppercase: Boolean = false
        // If `true`, WMS request parameter keys will be uppercase.
        uppercase: !1
      },
      initialize: function(d, _) {
        this._url = d;
        var C = l({}, this.defaultWmsParams);
        for (var B in _)
          B in this.options || (C[B] = _[B]);
        _ = x(this, _);
        var q = _.detectRetina && ae.retina ? 2 : 1, Q = this.getTileSize();
        C.width = Q.x * q, C.height = Q.y * q, this.wmsParams = C;
      },
      onAdd: function(d) {
        this._crs = this.options.crs || d.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
        var _ = this._wmsVersion >= 1.3 ? "crs" : "srs";
        this.wmsParams[_] = this._crs.code, Kn.prototype.onAdd.call(this, d);
      },
      getTileUrl: function(d) {
        var _ = this._tileCoordsToNwSe(d), C = this._crs, B = bt(C.project(_[0]), C.project(_[1])), q = B.min, Q = B.max, dt = (this._wmsVersion >= 1.3 && this._crs === Pi ? [q.y, q.x, Q.y, Q.x] : [q.x, q.y, Q.x, Q.y]).join(","), Dt = Kn.prototype.getTileUrl.call(this, d);
        return Dt + D(this.wmsParams, Dt, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + dt;
      },
      // @method setParams(params: Object, noRedraw?: Boolean): this
      // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
      setParams: function(d, _) {
        return l(this.wmsParams, d), _ || this.redraw(), this;
      }
    });
    function Kr(d, _) {
      return new Or(d, _);
    }
    Kn.WMS = Or, Nr.wms = Kr;
    var Ji = mi.extend({
      // @section
      // @aka Renderer options
      options: {
        // @option padding: Number = 0.1
        // How much to extend the clip area around the map view (relative to its size)
        // e.g. 0.1 would be 10% of map view in each direction
        padding: 0.1
      },
      initialize: function(d) {
        x(this, d), f(this), this._layers = this._layers || {};
      },
      onAdd: function() {
        this._container || (this._initContainer(), pe(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
      },
      onRemove: function() {
        this.off("update", this._updatePaths, this), this._destroyContainer();
      },
      getEvents: function() {
        var d = {
          viewreset: this._reset,
          zoom: this._onZoom,
          moveend: this._update,
          zoomend: this._onZoomEnd
        };
        return this._zoomAnimated && (d.zoomanim = this._onAnimZoom), d;
      },
      _onAnimZoom: function(d) {
        this._updateTransform(d.center, d.zoom);
      },
      _onZoom: function() {
        this._updateTransform(this._map.getCenter(), this._map.getZoom());
      },
      _updateTransform: function(d, _) {
        var C = this._map.getZoomScale(_, this._zoom), B = this._map.getSize().multiplyBy(0.5 + this.options.padding), q = this._map.project(this._center, _), Q = B.multiplyBy(-C).add(q).subtract(this._map._getNewPixelOrigin(d, _));
        ae.any3d ? Ge(this._container, Q, C) : Ie(this._container, Q);
      },
      _reset: function() {
        this._update(), this._updateTransform(this._center, this._zoom);
        for (var d in this._layers)
          this._layers[d]._reset();
      },
      _onZoomEnd: function() {
        for (var d in this._layers)
          this._layers[d]._project();
      },
      _updatePaths: function() {
        for (var d in this._layers)
          this._layers[d]._update();
      },
      _update: function() {
        var d = this.options.padding, _ = this._map.getSize(), C = this._map.containerPointToLayerPoint(_.multiplyBy(-d)).round();
        this._bounds = new ht(C, C.add(_.multiplyBy(1 + d * 2)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
      }
    }), Ir = Ji.extend({
      // @section
      // @aka Canvas options
      options: {
        // @option tolerance: Number = 0
        // How much to extend the click tolerance around a path/object on the map.
        tolerance: 0
      },
      getEvents: function() {
        var d = Ji.prototype.getEvents.call(this);
        return d.viewprereset = this._onViewPreReset, d;
      },
      _onViewPreReset: function() {
        this._postponeUpdatePaths = !0;
      },
      onAdd: function() {
        Ji.prototype.onAdd.call(this), this._draw();
      },
      _initContainer: function() {
        var d = this._container = document.createElement("canvas");
        de(d, "mousemove", this._onMouseMove, this), de(d, "click dblclick mousedown mouseup contextmenu", this._onClick, this), de(d, "mouseout", this._handleMouseOut, this), d._leaflet_disable_events = !0, this._ctx = d.getContext("2d");
      },
      _destroyContainer: function() {
        ct(this._redrawRequest), delete this._ctx, ke(this._container), Fe(this._container), delete this._container;
      },
      _updatePaths: function() {
        if (!this._postponeUpdatePaths) {
          var d;
          this._redrawBounds = null;
          for (var _ in this._layers)
            d = this._layers[_], d._update();
          this._redraw();
        }
      },
      _update: function() {
        if (!(this._map._animatingZoom && this._bounds)) {
          Ji.prototype._update.call(this);
          var d = this._bounds, _ = this._container, C = d.getSize(), B = ae.retina ? 2 : 1;
          Ie(_, d.min), _.width = B * C.x, _.height = B * C.y, _.style.width = C.x + "px", _.style.height = C.y + "px", ae.retina && this._ctx.scale(2, 2), this._ctx.translate(-d.min.x, -d.min.y), this.fire("update");
        }
      },
      _reset: function() {
        Ji.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths());
      },
      _initPath: function(d) {
        this._updateDashArray(d), this._layers[f(d)] = d;
        var _ = d._order = {
          layer: d,
          prev: this._drawLast,
          next: null
        };
        this._drawLast && (this._drawLast.next = _), this._drawLast = _, this._drawFirst = this._drawFirst || this._drawLast;
      },
      _addPath: function(d) {
        this._requestRedraw(d);
      },
      _removePath: function(d) {
        var _ = d._order, C = _.next, B = _.prev;
        C ? C.prev = B : this._drawLast = B, B ? B.next = C : this._drawFirst = C, delete d._order, delete this._layers[f(d)], this._requestRedraw(d);
      },
      _updatePath: function(d) {
        this._extendRedrawBounds(d), d._project(), d._update(), this._requestRedraw(d);
      },
      _updateStyle: function(d) {
        this._updateDashArray(d), this._requestRedraw(d);
      },
      _updateDashArray: function(d) {
        if (typeof d.options.dashArray == "string") {
          var _ = d.options.dashArray.split(/[, ]+/), C = [], B, q;
          for (q = 0; q < _.length; q++) {
            if (B = Number(_[q]), isNaN(B))
              return;
            C.push(B);
          }
          d.options._dashArray = C;
        } else
          d.options._dashArray = d.options.dashArray;
      },
      _requestRedraw: function(d) {
        this._map && (this._extendRedrawBounds(d), this._redrawRequest = this._redrawRequest || pt(this._redraw, this));
      },
      _extendRedrawBounds: function(d) {
        if (d._pxBounds) {
          var _ = (d.options.weight || 0) + 1;
          this._redrawBounds = this._redrawBounds || new ht(), this._redrawBounds.extend(d._pxBounds.min.subtract([_, _])), this._redrawBounds.extend(d._pxBounds.max.add([_, _]));
        }
      },
      _redraw: function() {
        this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
      },
      _clear: function() {
        var d = this._redrawBounds;
        if (d) {
          var _ = d.getSize();
          this._ctx.clearRect(d.min.x, d.min.y, _.x, _.y);
        } else
          this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore();
      },
      _draw: function() {
        var d, _ = this._redrawBounds;
        if (this._ctx.save(), _) {
          var C = _.getSize();
          this._ctx.beginPath(), this._ctx.rect(_.min.x, _.min.y, C.x, C.y), this._ctx.clip();
        }
        this._drawing = !0;
        for (var B = this._drawFirst; B; B = B.next)
          d = B.layer, (!_ || d._pxBounds && d._pxBounds.intersects(_)) && d._updatePath();
        this._drawing = !1, this._ctx.restore();
      },
      _updatePoly: function(d, _) {
        if (this._drawing) {
          var C, B, q, Q, dt = d._parts, Dt = dt.length, Tt = this._ctx;
          if (Dt) {
            for (Tt.beginPath(), C = 0; C < Dt; C++) {
              for (B = 0, q = dt[C].length; B < q; B++)
                Q = dt[C][B], Tt[B ? "lineTo" : "moveTo"](Q.x, Q.y);
              _ && Tt.closePath();
            }
            this._fillStroke(Tt, d);
          }
        }
      },
      _updateCircle: function(d) {
        if (!(!this._drawing || d._empty())) {
          var _ = d._point, C = this._ctx, B = Math.max(Math.round(d._radius), 1), q = (Math.max(Math.round(d._radiusY), 1) || B) / B;
          q !== 1 && (C.save(), C.scale(1, q)), C.beginPath(), C.arc(_.x, _.y / q, B, 0, Math.PI * 2, !1), q !== 1 && C.restore(), this._fillStroke(C, d);
        }
      },
      _fillStroke: function(d, _) {
        var C = _.options;
        C.fill && (d.globalAlpha = C.fillOpacity, d.fillStyle = C.fillColor || C.color, d.fill(C.fillRule || "evenodd")), C.stroke && C.weight !== 0 && (d.setLineDash && d.setLineDash(_.options && _.options._dashArray || []), d.globalAlpha = C.opacity, d.lineWidth = C.weight, d.strokeStyle = C.color, d.lineCap = C.lineCap, d.lineJoin = C.lineJoin, d.stroke());
      },
      // Canvas obviously doesn't have mouse events for individual drawn objects,
      // so we emulate that by calculating what's under the mouse on mousemove/click manually
      _onClick: function(d) {
        for (var _ = this._map.mouseEventToLayerPoint(d), C, B, q = this._drawFirst; q; q = q.next)
          C = q.layer, C.options.interactive && C._containsPoint(_) && (!(d.type === "click" || d.type === "preclick") || !this._map._draggableMoved(C)) && (B = C);
        this._fireEvent(B ? [B] : !1, d);
      },
      _onMouseMove: function(d) {
        if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
          var _ = this._map.mouseEventToLayerPoint(d);
          this._handleMouseHover(d, _);
        }
      },
      _handleMouseOut: function(d) {
        var _ = this._hoveredLayer;
        _ && (Ne(this._container, "leaflet-interactive"), this._fireEvent([_], d, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1);
      },
      _handleMouseHover: function(d, _) {
        if (!this._mouseHoverThrottled) {
          for (var C, B, q = this._drawFirst; q; q = q.next)
            C = q.layer, C.options.interactive && C._containsPoint(_) && (B = C);
          B !== this._hoveredLayer && (this._handleMouseOut(d), B && (pe(this._container, "leaflet-interactive"), this._fireEvent([B], d, "mouseover"), this._hoveredLayer = B)), this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, d), this._mouseHoverThrottled = !0, setTimeout(h(function() {
            this._mouseHoverThrottled = !1;
          }, this), 32);
        }
      },
      _fireEvent: function(d, _, C) {
        this._map._fireDOMEvent(_, C || _.type, d);
      },
      _bringToFront: function(d) {
        var _ = d._order;
        if (_) {
          var C = _.next, B = _.prev;
          if (C)
            C.prev = B;
          else
            return;
          B ? B.next = C : C && (this._drawFirst = C), _.prev = this._drawLast, this._drawLast.next = _, _.next = null, this._drawLast = _, this._requestRedraw(d);
        }
      },
      _bringToBack: function(d) {
        var _ = d._order;
        if (_) {
          var C = _.next, B = _.prev;
          if (B)
            B.next = C;
          else
            return;
          C ? C.prev = B : B && (this._drawLast = B), _.prev = null, _.next = this._drawFirst, this._drawFirst.prev = _, this._drawFirst = _, this._requestRedraw(d);
        }
      }
    });
    function Br(d) {
      return ae.canvas ? new Ir(d) : null;
    }
    var vr = function() {
      try {
        return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(d) {
          return document.createElement("<lvml:" + d + ' class="lvml">');
        };
      } catch {
      }
      return function(d) {
        return document.createElement("<" + d + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
      };
    }(), Qr = {
      _initContainer: function() {
        this._container = Me("div", "leaflet-vml-container");
      },
      _update: function() {
        this._map._animatingZoom || (Ji.prototype._update.call(this), this.fire("update"));
      },
      _initPath: function(d) {
        var _ = d._container = vr("shape");
        pe(_, "leaflet-vml-shape " + (this.options.className || "")), _.coordsize = "1 1", d._path = vr("path"), _.appendChild(d._path), this._updateStyle(d), this._layers[f(d)] = d;
      },
      _addPath: function(d) {
        var _ = d._container;
        this._container.appendChild(_), d.options.interactive && d.addInteractiveTarget(_);
      },
      _removePath: function(d) {
        var _ = d._container;
        ke(_), d.removeInteractiveTarget(_), delete this._layers[f(d)];
      },
      _updateStyle: function(d) {
        var _ = d._stroke, C = d._fill, B = d.options, q = d._container;
        q.stroked = !!B.stroke, q.filled = !!B.fill, B.stroke ? (_ || (_ = d._stroke = vr("stroke")), q.appendChild(_), _.weight = B.weight + "px", _.color = B.color, _.opacity = B.opacity, B.dashArray ? _.dashStyle = N(B.dashArray) ? B.dashArray.join(" ") : B.dashArray.replace(/( *, *)/g, " ") : _.dashStyle = "", _.endcap = B.lineCap.replace("butt", "flat"), _.joinstyle = B.lineJoin) : _ && (q.removeChild(_), d._stroke = null), B.fill ? (C || (C = d._fill = vr("fill")), q.appendChild(C), C.color = B.fillColor || B.color, C.opacity = B.fillOpacity) : C && (q.removeChild(C), d._fill = null);
      },
      _updateCircle: function(d) {
        var _ = d._point.round(), C = Math.round(d._radius), B = Math.round(d._radiusY || C);
        this._setPath(d, d._empty() ? "M0 0" : "AL " + _.x + "," + _.y + " " + C + "," + B + " 0," + 65535 * 360);
      },
      _setPath: function(d, _) {
        d._path.v = _;
      },
      _bringToFront: function(d) {
        ci(d._container);
      },
      _bringToBack: function(d) {
        Li(d._container);
      }
    }, Pr = ae.vml ? vr : Jt, mr = Ji.extend({
      _initContainer: function() {
        this._container = Pr("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = Pr("g"), this._container.appendChild(this._rootGroup);
      },
      _destroyContainer: function() {
        ke(this._container), Fe(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;
      },
      _update: function() {
        if (!(this._map._animatingZoom && this._bounds)) {
          Ji.prototype._update.call(this);
          var d = this._bounds, _ = d.getSize(), C = this._container;
          (!this._svgSize || !this._svgSize.equals(_)) && (this._svgSize = _, C.setAttribute("width", _.x), C.setAttribute("height", _.y)), Ie(C, d.min), C.setAttribute("viewBox", [d.min.x, d.min.y, _.x, _.y].join(" ")), this.fire("update");
        }
      },
      // methods below are called by vector layers implementations
      _initPath: function(d) {
        var _ = d._path = Pr("path");
        d.options.className && pe(_, d.options.className), d.options.interactive && pe(_, "leaflet-interactive"), this._updateStyle(d), this._layers[f(d)] = d;
      },
      _addPath: function(d) {
        this._rootGroup || this._initContainer(), this._rootGroup.appendChild(d._path), d.addInteractiveTarget(d._path);
      },
      _removePath: function(d) {
        ke(d._path), d.removeInteractiveTarget(d._path), delete this._layers[f(d)];
      },
      _updatePath: function(d) {
        d._project(), d._update();
      },
      _updateStyle: function(d) {
        var _ = d._path, C = d.options;
        _ && (C.stroke ? (_.setAttribute("stroke", C.color), _.setAttribute("stroke-opacity", C.opacity), _.setAttribute("stroke-width", C.weight), _.setAttribute("stroke-linecap", C.lineCap), _.setAttribute("stroke-linejoin", C.lineJoin), C.dashArray ? _.setAttribute("stroke-dasharray", C.dashArray) : _.removeAttribute("stroke-dasharray"), C.dashOffset ? _.setAttribute("stroke-dashoffset", C.dashOffset) : _.removeAttribute("stroke-dashoffset")) : _.setAttribute("stroke", "none"), C.fill ? (_.setAttribute("fill", C.fillColor || C.color), _.setAttribute("fill-opacity", C.fillOpacity), _.setAttribute("fill-rule", C.fillRule || "evenodd")) : _.setAttribute("fill", "none"));
      },
      _updatePoly: function(d, _) {
        this._setPath(d, Gt(d._parts, _));
      },
      _updateCircle: function(d) {
        var _ = d._point, C = Math.max(Math.round(d._radius), 1), B = Math.max(Math.round(d._radiusY), 1) || C, q = "a" + C + "," + B + " 0 1,0 ", Q = d._empty() ? "M0 0" : "M" + (_.x - C) + "," + _.y + q + C * 2 + ",0 " + q + -C * 2 + ",0 ";
        this._setPath(d, Q);
      },
      _setPath: function(d, _) {
        d._path.setAttribute("d", _);
      },
      // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
      _bringToFront: function(d) {
        ci(d._path);
      },
      _bringToBack: function(d) {
        Li(d._path);
      }
    });
    ae.vml && mr.include(Qr);
    function zr(d) {
      return ae.svg || ae.vml ? new mr(d) : null;
    }
    Ee.include({
      // @namespace Map; @method getRenderer(layer: Path): Renderer
      // Returns the instance of `Renderer` that should be used to render the given
      // `Path`. It will ensure that the `renderer` options of the map and paths
      // are respected, and that the renderers do exist on the map.
      getRenderer: function(d) {
        var _ = d.options.renderer || this._getPaneRenderer(d.options.pane) || this.options.renderer || this._renderer;
        return _ || (_ = this._renderer = this._createRenderer()), this.hasLayer(_) || this.addLayer(_), _;
      },
      _getPaneRenderer: function(d) {
        if (d === "overlayPane" || d === void 0)
          return !1;
        var _ = this._paneRenderers[d];
        return _ === void 0 && (_ = this._createRenderer({ pane: d }), this._paneRenderers[d] = _), _;
      },
      _createRenderer: function(d) {
        return this.options.preferCanvas && Br(d) || zr(d);
      }
    });
    var Rr = rn.extend({
      initialize: function(d, _) {
        rn.prototype.initialize.call(this, this._boundsToLatLngs(d), _);
      },
      // @method setBounds(latLngBounds: LatLngBounds): this
      // Redraws the rectangle with the passed bounds.
      setBounds: function(d) {
        return this.setLatLngs(this._boundsToLatLngs(d));
      },
      _boundsToLatLngs: function(d) {
        return d = St(d), [
          d.getSouthWest(),
          d.getNorthWest(),
          d.getNorthEast(),
          d.getSouthEast()
        ];
      }
    });
    function $r(d, _) {
      return new Rr(d, _);
    }
    mr.create = Pr, mr.pointsToPath = Gt, yi.geometryToLayer = an, yi.coordsToLatLng = Pn, yi.coordsToLatLngs = Sn, yi.latLngToCoords = ot, yi.latLngsToCoords = vt, yi.getFeature = Ct, yi.asFeature = At, Ee.mergeOptions({
      // @option boxZoom: Boolean = true
      // Whether the map can be zoomed to a rectangular area specified by
      // dragging the mouse while pressing the shift key.
      boxZoom: !0
    });
    var Hr = K.extend({
      initialize: function(d) {
        this._map = d, this._container = d._container, this._pane = d._panes.overlayPane, this._resetStateTimeout = 0, d.on("unload", this._destroy, this);
      },
      addHooks: function() {
        de(this._container, "mousedown", this._onMouseDown, this);
      },
      removeHooks: function() {
        Fe(this._container, "mousedown", this._onMouseDown, this);
      },
      moved: function() {
        return this._moved;
      },
      _destroy: function() {
        ke(this._pane), delete this._pane;
      },
      _resetState: function() {
        this._resetStateTimeout = 0, this._moved = !1;
      },
      _clearDeferredResetState: function() {
        this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
      },
      _onMouseDown: function(d) {
        if (!d.shiftKey || d.which !== 1 && d.button !== 1)
          return !1;
        this._clearDeferredResetState(), this._resetState(), mn(), yn(), this._startPoint = this._map.mouseEventToContainerPoint(d), de(document, {
          contextmenu: Ni,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseMove: function(d) {
        this._moved || (this._moved = !0, this._box = Me("div", "leaflet-zoom-box", this._container), pe(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(d);
        var _ = new ht(this._point, this._startPoint), C = _.getSize();
        Ie(this._box, _.min), this._box.style.width = C.x + "px", this._box.style.height = C.y + "px";
      },
      _finish: function() {
        this._moved && (ke(this._box), Ne(this._container, "leaflet-crosshair")), _n(), rr(), Fe(document, {
          contextmenu: Ni,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseUp: function(d) {
        if (!(d.which !== 1 && d.button !== 1) && (this._finish(), !!this._moved)) {
          this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(h(this._resetState, this), 0);
          var _ = new yt(
            this._map.containerPointToLatLng(this._startPoint),
            this._map.containerPointToLatLng(this._point)
          );
          this._map.fitBounds(_).fire("boxzoomend", { boxZoomBounds: _ });
        }
      },
      _onKeyDown: function(d) {
        d.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
      }
    });
    Ee.addInitHook("addHandler", "boxZoom", Hr), Ee.mergeOptions({
      // @option doubleClickZoom: Boolean|String = true
      // Whether the map can be zoomed in by double clicking on it and
      // zoomed out by double clicking while holding shift. If passed
      // `'center'`, double-click zoom will zoom to the center of the
      //  view regardless of where the mouse was.
      doubleClickZoom: !0
    });
    var Wr = K.extend({
      addHooks: function() {
        this._map.on("dblclick", this._onDoubleClick, this);
      },
      removeHooks: function() {
        this._map.off("dblclick", this._onDoubleClick, this);
      },
      _onDoubleClick: function(d) {
        var _ = this._map, C = _.getZoom(), B = _.options.zoomDelta, q = d.originalEvent.shiftKey ? C - B : C + B;
        _.options.doubleClickZoom === "center" ? _.setZoom(q) : _.setZoomAround(d.containerPoint, q);
      }
    });
    Ee.addInitHook("addHandler", "doubleClickZoom", Wr), Ee.mergeOptions({
      // @option dragging: Boolean = true
      // Whether the map is draggable with mouse/touch or not.
      dragging: !0,
      // @section Panning Inertia Options
      // @option inertia: Boolean = *
      // If enabled, panning of the map will have an inertia effect where
      // the map builds momentum while dragging and continues moving in
      // the same direction for some time. Feels especially nice on touch
      // devices. Enabled by default.
      inertia: !0,
      // @option inertiaDeceleration: Number = 3000
      // The rate with which the inertial movement slows down, in pixels/second².
      inertiaDeceleration: 3400,
      // px/s^2
      // @option inertiaMaxSpeed: Number = Infinity
      // Max speed of the inertial movement, in pixels/second.
      inertiaMaxSpeed: 1 / 0,
      // px/s
      // @option easeLinearity: Number = 0.2
      easeLinearity: 0.2,
      // TODO refactor, move to CRS
      // @option worldCopyJump: Boolean = false
      // With this option enabled, the map tracks when you pan to another "copy"
      // of the world and seamlessly jumps to the original one so that all overlays
      // like markers and vector layers are still visible.
      worldCopyJump: !1,
      // @option maxBoundsViscosity: Number = 0.0
      // If `maxBounds` is set, this option will control how solid the bounds
      // are when dragging the map around. The default value of `0.0` allows the
      // user to drag outside the bounds at normal speed, higher values will
      // slow down map dragging outside bounds, and `1.0` makes the bounds fully
      // solid, preventing the user from dragging outside the bounds.
      maxBoundsViscosity: 0
    });
    var jr = K.extend({
      addHooks: function() {
        if (!this._draggable) {
          var d = this._map;
          this._draggable = new _t(d._mapPane, d._container), this._draggable.on({
            dragstart: this._onDragStart,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this), this._draggable.on("predrag", this._onPreDragLimit, this), d.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), d.on("zoomend", this._onZoomEnd, this), d.whenReady(this._onZoomEnd, this));
        }
        pe(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [];
      },
      removeHooks: function() {
        Ne(this._map._container, "leaflet-grab"), Ne(this._map._container, "leaflet-touch-drag"), this._draggable.disable();
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      moving: function() {
        return this._draggable && this._draggable._moving;
      },
      _onDragStart: function() {
        var d = this._map;
        if (d._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
          var _ = St(this._map.options.maxBounds);
          this._offsetLimit = bt(
            this._map.latLngToContainerPoint(_.getNorthWest()).multiplyBy(-1),
            this._map.latLngToContainerPoint(_.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
          ), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
        } else
          this._offsetLimit = null;
        d.fire("movestart").fire("dragstart"), d.options.inertia && (this._positions = [], this._times = []);
      },
      _onDrag: function(d) {
        if (this._map.options.inertia) {
          var _ = this._lastTime = +/* @__PURE__ */ new Date(), C = this._lastPos = this._draggable._absPos || this._draggable._newPos;
          this._positions.push(C), this._times.push(_), this._prunePositions(_);
        }
        this._map.fire("move", d).fire("drag", d);
      },
      _prunePositions: function(d) {
        for (; this._positions.length > 1 && d - this._times[0] > 50; )
          this._positions.shift(), this._times.shift();
      },
      _onZoomEnd: function() {
        var d = this._map.getSize().divideBy(2), _ = this._map.latLngToLayerPoint([0, 0]);
        this._initialWorldOffset = _.subtract(d).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
      },
      _viscousLimit: function(d, _) {
        return d - (d - _) * this._viscosity;
      },
      _onPreDragLimit: function() {
        if (!(!this._viscosity || !this._offsetLimit)) {
          var d = this._draggable._newPos.subtract(this._draggable._startPos), _ = this._offsetLimit;
          d.x < _.min.x && (d.x = this._viscousLimit(d.x, _.min.x)), d.y < _.min.y && (d.y = this._viscousLimit(d.y, _.min.y)), d.x > _.max.x && (d.x = this._viscousLimit(d.x, _.max.x)), d.y > _.max.y && (d.y = this._viscousLimit(d.y, _.max.y)), this._draggable._newPos = this._draggable._startPos.add(d);
        }
      },
      _onPreDragWrap: function() {
        var d = this._worldWidth, _ = Math.round(d / 2), C = this._initialWorldOffset, B = this._draggable._newPos.x, q = (B - _ + C) % d + _ - C, Q = (B + _ + C) % d - _ - C, dt = Math.abs(q + C) < Math.abs(Q + C) ? q : Q;
        this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = dt;
      },
      _onDragEnd: function(d) {
        var _ = this._map, C = _.options, B = !C.inertia || d.noInertia || this._times.length < 2;
        if (_.fire("dragend", d), B)
          _.fire("moveend");
        else {
          this._prunePositions(+/* @__PURE__ */ new Date());
          var q = this._lastPos.subtract(this._positions[0]), Q = (this._lastTime - this._times[0]) / 1e3, dt = C.easeLinearity, Dt = q.multiplyBy(dt / Q), Tt = Dt.distanceTo([0, 0]), Wt = Math.min(C.inertiaMaxSpeed, Tt), ie = Dt.multiplyBy(Wt / Tt), le = Wt / (C.inertiaDeceleration * dt), Ce = ie.multiplyBy(-le / 2).round();
          !Ce.x && !Ce.y ? _.fire("moveend") : (Ce = _._limitOffset(Ce, _.options.maxBounds), pt(function() {
            _.panBy(Ce, {
              duration: le,
              easeLinearity: dt,
              noMoveStart: !0,
              animate: !0
            });
          }));
        }
      }
    });
    Ee.addInitHook("addHandler", "dragging", jr), Ee.mergeOptions({
      // @option keyboard: Boolean = true
      // Makes the map focusable and allows users to navigate the map with keyboard
      // arrows and `+`/`-` keys.
      keyboard: !0,
      // @option keyboardPanDelta: Number = 80
      // Amount of pixels to pan when pressing an arrow key.
      keyboardPanDelta: 80
    });
    var qr = K.extend({
      keyCodes: {
        left: [37],
        right: [39],
        down: [40],
        up: [38],
        zoomIn: [187, 107, 61, 171],
        zoomOut: [189, 109, 54, 173]
      },
      initialize: function(d) {
        this._map = d, this._setPanDelta(d.options.keyboardPanDelta), this._setZoomDelta(d.options.zoomDelta);
      },
      addHooks: function() {
        var d = this._map._container;
        d.tabIndex <= 0 && (d.tabIndex = "0"), de(d, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this), this._map.on({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      removeHooks: function() {
        this._removeHooks(), Fe(this._map._container, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this), this._map.off({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      _onMouseDown: function() {
        if (!this._focused) {
          var d = document.body, _ = document.documentElement, C = d.scrollTop || _.scrollTop, B = d.scrollLeft || _.scrollLeft;
          this._map._container.focus(), window.scrollTo(B, C);
        }
      },
      _onFocus: function() {
        this._focused = !0, this._map.fire("focus");
      },
      _onBlur: function() {
        this._focused = !1, this._map.fire("blur");
      },
      _setPanDelta: function(d) {
        var _ = this._panKeys = {}, C = this.keyCodes, B, q;
        for (B = 0, q = C.left.length; B < q; B++)
          _[C.left[B]] = [-1 * d, 0];
        for (B = 0, q = C.right.length; B < q; B++)
          _[C.right[B]] = [d, 0];
        for (B = 0, q = C.down.length; B < q; B++)
          _[C.down[B]] = [0, d];
        for (B = 0, q = C.up.length; B < q; B++)
          _[C.up[B]] = [0, -1 * d];
      },
      _setZoomDelta: function(d) {
        var _ = this._zoomKeys = {}, C = this.keyCodes, B, q;
        for (B = 0, q = C.zoomIn.length; B < q; B++)
          _[C.zoomIn[B]] = d;
        for (B = 0, q = C.zoomOut.length; B < q; B++)
          _[C.zoomOut[B]] = -d;
      },
      _addHooks: function() {
        de(document, "keydown", this._onKeyDown, this);
      },
      _removeHooks: function() {
        Fe(document, "keydown", this._onKeyDown, this);
      },
      _onKeyDown: function(d) {
        if (!(d.altKey || d.ctrlKey || d.metaKey)) {
          var _ = d.keyCode, C = this._map, B;
          if (_ in this._panKeys) {
            if (!C._panAnim || !C._panAnim._inProgress)
              if (B = this._panKeys[_], d.shiftKey && (B = rt(B).multiplyBy(3)), C.options.maxBounds && (B = C._limitOffset(rt(B), C.options.maxBounds)), C.options.worldCopyJump) {
                var q = C.wrapLatLng(C.unproject(C.project(C.getCenter()).add(B)));
                C.panTo(q);
              } else
                C.panBy(B);
          } else if (_ in this._zoomKeys)
            C.setZoom(C.getZoom() + (d.shiftKey ? 3 : 1) * this._zoomKeys[_]);
          else if (_ === 27 && C._popup && C._popup.options.closeOnEscapeKey)
            C.closePopup();
          else
            return;
          Ni(d);
        }
      }
    });
    Ee.addInitHook("addHandler", "keyboard", qr), Ee.mergeOptions({
      // @section Mouse wheel options
      // @option scrollWheelZoom: Boolean|String = true
      // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
      // it will zoom to the center of the view regardless of where the mouse was.
      scrollWheelZoom: !0,
      // @option wheelDebounceTime: Number = 40
      // Limits the rate at which a wheel can fire (in milliseconds). By default
      // user can't zoom via wheel more often than once per 40 ms.
      wheelDebounceTime: 40,
      // @option wheelPxPerZoomLevel: Number = 60
      // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
      // mean a change of one full zoom level. Smaller values will make wheel-zooming
      // faster (and vice versa).
      wheelPxPerZoomLevel: 60
    });
    var Gr = K.extend({
      addHooks: function() {
        de(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
      },
      removeHooks: function() {
        Fe(this._map._container, "wheel", this._onWheelScroll, this);
      },
      _onWheelScroll: function(d) {
        var _ = cr(d), C = this._map.options.wheelDebounceTime;
        this._delta += _, this._lastMousePos = this._map.mouseEventToContainerPoint(d), this._startTime || (this._startTime = +/* @__PURE__ */ new Date());
        var B = Math.max(C - (+/* @__PURE__ */ new Date() - this._startTime), 0);
        clearTimeout(this._timer), this._timer = setTimeout(h(this._performZoom, this), B), Ni(d);
      },
      _performZoom: function() {
        var d = this._map, _ = d.getZoom(), C = this._map.options.zoomSnap || 0;
        d._stop();
        var B = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), q = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(B)))) / Math.LN2, Q = C ? Math.ceil(q / C) * C : q, dt = d._limitZoom(_ + (this._delta > 0 ? Q : -Q)) - _;
        this._delta = 0, this._startTime = null, dt && (d.options.scrollWheelZoom === "center" ? d.setZoom(_ + dt) : d.setZoomAround(this._lastMousePos, _ + dt));
      }
    });
    Ee.addInitHook("addHandler", "scrollWheelZoom", Gr);
    var ta = 600;
    Ee.mergeOptions({
      // @section Touch interaction options
      // @option tapHold: Boolean
      // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
      tapHold: ae.touchNative && ae.safari && ae.mobile,
      // @option tapTolerance: Number = 15
      // The max number of pixels a user can shift his finger during touch
      // for it to be considered a valid tap.
      tapTolerance: 15
    });
    var Ur = K.extend({
      addHooks: function() {
        de(this._map._container, "touchstart", this._onDown, this);
      },
      removeHooks: function() {
        Fe(this._map._container, "touchstart", this._onDown, this);
      },
      _onDown: function(d) {
        if (clearTimeout(this._holdTimeout), d.touches.length === 1) {
          var _ = d.touches[0];
          this._startPos = this._newPos = new Y(_.clientX, _.clientY), this._holdTimeout = setTimeout(h(function() {
            this._cancel(), this._isTapValid() && (de(document, "touchend", He), de(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", _));
          }, this), ta), de(document, "touchend touchcancel contextmenu", this._cancel, this), de(document, "touchmove", this._onMove, this);
        }
      },
      _cancelClickPrevent: function d() {
        Fe(document, "touchend", He), Fe(document, "touchend touchcancel", d);
      },
      _cancel: function() {
        clearTimeout(this._holdTimeout), Fe(document, "touchend touchcancel contextmenu", this._cancel, this), Fe(document, "touchmove", this._onMove, this);
      },
      _onMove: function(d) {
        var _ = d.touches[0];
        this._newPos = new Y(_.clientX, _.clientY);
      },
      _isTapValid: function() {
        return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
      },
      _simulateEvent: function(d, _) {
        var C = new MouseEvent(d, {
          bubbles: !0,
          cancelable: !0,
          view: window,
          // detail: 1,
          screenX: _.screenX,
          screenY: _.screenY,
          clientX: _.clientX,
          clientY: _.clientY
          // button: 2,
          // buttons: 2
        });
        C._simulated = !0, _.target.dispatchEvent(C);
      }
    });
    Ee.addInitHook("addHandler", "tapHold", Ur), Ee.mergeOptions({
      // @section Touch interaction options
      // @option touchZoom: Boolean|String = *
      // Whether the map can be zoomed by touch-dragging with two fingers. If
      // passed `'center'`, it will zoom to the center of the view regardless of
      // where the touch events (fingers) were. Enabled for touch-capable web
      // browsers.
      touchZoom: ae.touch,
      // @option bounceAtZoomLimits: Boolean = true
      // Set it to false if you don't want the map to zoom beyond min/max zoom
      // and then bounce back when pinch-zooming.
      bounceAtZoomLimits: !0
    });
    var Vr = K.extend({
      addHooks: function() {
        pe(this._map._container, "leaflet-touch-zoom"), de(this._map._container, "touchstart", this._onTouchStart, this);
      },
      removeHooks: function() {
        Ne(this._map._container, "leaflet-touch-zoom"), Fe(this._map._container, "touchstart", this._onTouchStart, this);
      },
      _onTouchStart: function(d) {
        var _ = this._map;
        if (!(!d.touches || d.touches.length !== 2 || _._animatingZoom || this._zooming)) {
          var C = _.mouseEventToContainerPoint(d.touches[0]), B = _.mouseEventToContainerPoint(d.touches[1]);
          this._centerPoint = _.getSize()._divideBy(2), this._startLatLng = _.containerPointToLatLng(this._centerPoint), _.options.touchZoom !== "center" && (this._pinchStartLatLng = _.containerPointToLatLng(C.add(B)._divideBy(2))), this._startDist = C.distanceTo(B), this._startZoom = _.getZoom(), this._moved = !1, this._zooming = !0, _._stop(), de(document, "touchmove", this._onTouchMove, this), de(document, "touchend touchcancel", this._onTouchEnd, this), He(d);
        }
      },
      _onTouchMove: function(d) {
        if (!(!d.touches || d.touches.length !== 2 || !this._zooming)) {
          var _ = this._map, C = _.mouseEventToContainerPoint(d.touches[0]), B = _.mouseEventToContainerPoint(d.touches[1]), q = C.distanceTo(B) / this._startDist;
          if (this._zoom = _.getScaleZoom(q, this._startZoom), !_.options.bounceAtZoomLimits && (this._zoom < _.getMinZoom() && q < 1 || this._zoom > _.getMaxZoom() && q > 1) && (this._zoom = _._limitZoom(this._zoom)), _.options.touchZoom === "center") {
            if (this._center = this._startLatLng, q === 1)
              return;
          } else {
            var Q = C._add(B)._divideBy(2)._subtract(this._centerPoint);
            if (q === 1 && Q.x === 0 && Q.y === 0)
              return;
            this._center = _.unproject(_.project(this._pinchStartLatLng, this._zoom).subtract(Q), this._zoom);
          }
          this._moved || (_._moveStart(!0, !1), this._moved = !0), ct(this._animRequest);
          var dt = h(_._move, _, this._center, this._zoom, { pinch: !0, round: !1 }, void 0);
          this._animRequest = pt(dt, this, !0), He(d);
        }
      },
      _onTouchEnd: function() {
        if (!this._moved || !this._zooming) {
          this._zooming = !1;
          return;
        }
        this._zooming = !1, ct(this._animRequest), Fe(document, "touchmove", this._onTouchMove, this), Fe(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom));
      }
    });
    Ee.addInitHook("addHandler", "touchZoom", Vr), Ee.BoxZoom = Hr, Ee.DoubleClickZoom = Wr, Ee.Drag = jr, Ee.Keyboard = qr, Ee.ScrollWheelZoom = Gr, Ee.TapHold = Ur, Ee.TouchZoom = Vr, r.Bounds = ht, r.Browser = ae, r.CRS = Zt, r.Canvas = Ir, r.Circle = Yi, r.CircleMarker = _i, r.Class = kt, r.Control = oi, r.DivIcon = bi, r.DivOverlay = re, r.DomEvent = Tr, r.DomUtil = yr, r.Draggable = _t, r.Evented = G, r.FeatureGroup = be, r.GeoJSON = yi, r.GridLayer = Re, r.Handler = K, r.Icon = Xe, r.ImageOverlay = ne, r.LatLng = Ft, r.LatLngBounds = yt, r.Layer = mi, r.LayerGroup = en, r.LineUtil = Di, r.Map = Ee, r.Marker = En, r.Mixin = ut, r.Path = Si, r.Point = Y, r.PolyUtil = Vt, r.Polygon = rn, r.Polyline = li, r.Popup = Ae, r.PosAnimation = wr, r.Projection = si, r.Rectangle = Rr, r.Renderer = Ji, r.SVG = mr, r.SVGOverlay = ue, r.TileLayer = Kn, r.Tooltip = ze, r.Transformation = gt, r.Util = Nt, r.VideoOverlay = _e, r.bind = h, r.bounds = bt, r.canvas = Br, r.circle = Yn, r.circleMarker = Mr, r.control = Zi, r.divIcon = on, r.extend = l, r.featureGroup = Xn, r.geoJSON = Kt, r.geoJson = te, r.gridLayer = Jr, r.icon = nn, r.imageOverlay = ee, r.latLng = zt, r.latLngBounds = St, r.layerGroup = Lr, r.map = Dn, r.marker = Xi, r.point = rt, r.polygon = Jn, r.polyline = gr, r.popup = ii, r.rectangle = $r, r.setOptions = x, r.stamp = f, r.svg = zr, r.svgOverlay = xe, r.tileLayer = Nr, r.tooltip = ui, r.transformation = wt, r.version = o, r.videoOverlay = oe;
    var ea = window.L;
    r.noConflict = function() {
      return window.L = ea, this;
    }, window.L = r;
  });
})(leafletSrc, leafletSrc.exports);
var leafletSrcExports = leafletSrc.exports;
leafletSrcExports.TileLayer.WMTS = leafletSrcExports.TileLayer.extend({
  /** Default params for WMTS */
  defaultWmtsParams: {
    service: "WMTS",
    request: "GetTile",
    version: "1.0.0",
    layer: "",
    style: "",
    tilematrixset: "",
    format: "image/jpeg"
  },
  options: {
    // @option crs: CRS = null
    // Coordinate Reference System to use for the WMS requests, defaults to
    // map CRS. Don't change this if you're not sure what it means.
    crs: null,
    // @option uppercase: Boolean = false
    // If `true`, WMS request parameter keys will be uppercase.
    uppercase: !1
  },
  /**
   * Initialize plugin
   * @param {String} url Url to WMTS server
   * @param {Object} options List options
   */
  initialize(e, n) {
    this._url = e;
    const r = {};
    Object.keys(n).forEach((h) => r[h.toLowerCase()] = n[h]);
    const l = leafletSrcExports.extend({}, this.defaultWmtsParams), u = r.tileSize || this.options.tileSize;
    r.detectRetina && leafletSrcExports.Browser.retina ? (l.width = u * 2, l.height = u * 2) : (l.width = u, l.height = u);
    for (const h in r)
      l.hasOwnProperty(h) && h !== "matrixIds" && (l[h] = r[h]);
    this.wmtsParams = l, this.matrixIds = n.matrixIds || this.getDefaultMatrix(), leafletSrcExports.setOptions(this, n);
  },
  /**
   * Set tile to map
   * @param {Leaflet.Map} map Leaflet map
   */
  onAdd(e) {
    this._crs = this.options.crs || e.options.crs, leafletSrcExports.TileLayer.prototype.onAdd.call(this, e);
  },
  /**
   * Generate URL for tile pieces
   * @param {Leaflet.Point} coords Position tile
   * @param {Number} coords.x Position X
   * @param {Number} coords.y Position Y
   * @param {Number} coords.z Position Z
   * @return {String} URL
   */
  getTileUrl(e) {
    const n = this.options.tileSize, r = e.multiplyBy(n);
    r.x += 1, r.y -= 1;
    const o = r.add(new leafletSrcExports.Point(n, n)), l = this._tileZoom, u = this._crs.project(this._map.unproject(o, l)), h = this._crs.project(this._map.unproject(r, l)), c = u.x - h.x, f = this.matrixIds[l].identifier, v = `${this.wmtsParams.tilematrixset}:${f}`, m = this.matrixIds[l].topLeftCorner.lng, g = this.matrixIds[l].topLeftCorner.lat;
    Math.floor((h.x - m) / c), -Math.floor((h.y - g) / c);
    const y = leafletSrcExports.Util.template(this._url, {
      s: this._getSubdomain(e)
    });
    return `${y}${leafletSrcExports.Util.getParamString(this.wmtsParams, y)}&tilematrix=${v}&tilerow=${e.y}&tilecol=${e.x}`;
  },
  /**
   * Set params
   * @param {Object} params Params
   * @param {Boolean} noRedraw needed redraw map
   */
  setParams(e, n) {
    return leafletSrcExports.extend(this.wmtsParams, e), n || this.redraw(), this;
  },
  /**
   * Generate default matrix
   * @description The matrix3857 represents the projection
   * for in the IGN WMTS for the google coordinates.
   */
  getDefaultMatrix() {
    const e = new Array(22);
    for (let n = 0; n < 22; n++)
      e[n] = {
        identifier: String(n),
        topLeftCorner: new leafletSrcExports.LatLng(200375083428e-4, -200375083428e-4)
      };
    return e;
  }
});
var jquery = { exports: {} };
/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
(function(e) {
  (function(n, r) {
    e.exports = n.document ? r(n, !0) : function(o) {
      if (!o.document)
        throw new Error("jQuery requires a window with a document");
      return r(o);
    };
  })(typeof window < "u" ? window : commonjsGlobal, function(n, r) {
    var o = [], l = Object.getPrototypeOf, u = o.slice, h = o.flat ? function(b) {
      return o.flat.call(b);
    } : function(b) {
      return o.concat.apply([], b);
    }, c = o.push, f = o.indexOf, v = {}, m = v.toString, g = v.hasOwnProperty, y = g.toString, w = y.call(Object), E = {}, x = function(T) {
      return typeof T == "function" && typeof T.nodeType != "number" && typeof T.item != "function";
    }, D = function(T) {
      return T != null && T === T.window;
    }, F = n.document, k = {
      type: !0,
      src: !0,
      nonce: !0,
      noModule: !0
    };
    function N(b, T, z) {
      z = z || F;
      var W, U, X = z.createElement("script");
      if (X.text = b, T)
        for (W in k)
          U = T[W] || T.getAttribute && T.getAttribute(W), U && X.setAttribute(W, U);
      z.head.appendChild(X).parentNode.removeChild(X);
    }
    function H(b) {
      return b == null ? b + "" : typeof b == "object" || typeof b == "function" ? v[m.call(b)] || "object" : typeof b;
    }
    var R = "3.7.1", j = /HTML$/i, S = function(b, T) {
      return new S.fn.init(b, T);
    };
    S.fn = S.prototype = {
      // The current version of jQuery being used
      jquery: R,
      constructor: S,
      // The default length of a jQuery object is 0
      length: 0,
      toArray: function() {
        return u.call(this);
      },
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function(b) {
        return b == null ? u.call(this) : b < 0 ? this[b + this.length] : this[b];
      },
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function(b) {
        var T = S.merge(this.constructor(), b);
        return T.prevObject = this, T;
      },
      // Execute a callback for every element in the matched set.
      each: function(b) {
        return S.each(this, b);
      },
      map: function(b) {
        return this.pushStack(S.map(this, function(T, z) {
          return b.call(T, z, T);
        }));
      },
      slice: function() {
        return this.pushStack(u.apply(this, arguments));
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      even: function() {
        return this.pushStack(S.grep(this, function(b, T) {
          return (T + 1) % 2;
        }));
      },
      odd: function() {
        return this.pushStack(S.grep(this, function(b, T) {
          return T % 2;
        }));
      },
      eq: function(b) {
        var T = this.length, z = +b + (b < 0 ? T : 0);
        return this.pushStack(z >= 0 && z < T ? [this[z]] : []);
      },
      end: function() {
        return this.prevObject || this.constructor();
      },
      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push: c,
      sort: o.sort,
      splice: o.splice
    }, S.extend = S.fn.extend = function() {
      var b, T, z, W, U, X, K = arguments[0] || {}, ut = 1, lt = arguments.length, _t = !1;
      for (typeof K == "boolean" && (_t = K, K = arguments[ut] || {}, ut++), typeof K != "object" && !x(K) && (K = {}), ut === lt && (K = this, ut--); ut < lt; ut++)
        if ((b = arguments[ut]) != null)
          for (T in b)
            W = b[T], !(T === "__proto__" || K === W) && (_t && W && (S.isPlainObject(W) || (U = Array.isArray(W))) ? (z = K[T], U && !Array.isArray(z) ? X = [] : !U && !S.isPlainObject(z) ? X = {} : X = z, U = !1, K[T] = S.extend(_t, X, W)) : W !== void 0 && (K[T] = W));
      return K;
    }, S.extend({
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (R + Math.random()).replace(/\D/g, ""),
      // Assume jQuery is ready without the ready module
      isReady: !0,
      error: function(b) {
        throw new Error(b);
      },
      noop: function() {
      },
      isPlainObject: function(b) {
        var T, z;
        return !b || m.call(b) !== "[object Object]" ? !1 : (T = l(b), T ? (z = g.call(T, "constructor") && T.constructor, typeof z == "function" && y.call(z) === w) : !0);
      },
      isEmptyObject: function(b) {
        var T;
        for (T in b)
          return !1;
        return !0;
      },
      // Evaluates a script in a provided context; falls back to the global one
      // if not specified.
      globalEval: function(b, T, z) {
        N(b, { nonce: T && T.nonce }, z);
      },
      each: function(b, T) {
        var z, W = 0;
        if (tt(b))
          for (z = b.length; W < z && T.call(b[W], W, b[W]) !== !1; W++)
            ;
        else
          for (W in b)
            if (T.call(b[W], W, b[W]) === !1)
              break;
        return b;
      },
      // Retrieve the text value of an array of DOM nodes
      text: function(b) {
        var T, z = "", W = 0, U = b.nodeType;
        if (!U)
          for (; T = b[W++]; )
            z += S.text(T);
        return U === 1 || U === 11 ? b.textContent : U === 9 ? b.documentElement.textContent : U === 3 || U === 4 ? b.nodeValue : z;
      },
      // results is for internal usage only
      makeArray: function(b, T) {
        var z = T || [];
        return b != null && (tt(Object(b)) ? S.merge(
          z,
          typeof b == "string" ? [b] : b
        ) : c.call(z, b)), z;
      },
      inArray: function(b, T, z) {
        return T == null ? -1 : f.call(T, b, z);
      },
      isXMLDoc: function(b) {
        var T = b && b.namespaceURI, z = b && (b.ownerDocument || b).documentElement;
        return !j.test(T || z && z.nodeName || "HTML");
      },
      // Support: Android <=4.0 only, PhantomJS 1 only
      // push.apply(_, arraylike) throws on ancient WebKit
      merge: function(b, T) {
        for (var z = +T.length, W = 0, U = b.length; W < z; W++)
          b[U++] = T[W];
        return b.length = U, b;
      },
      grep: function(b, T, z) {
        for (var W, U = [], X = 0, K = b.length, ut = !z; X < K; X++)
          W = !T(b[X], X), W !== ut && U.push(b[X]);
        return U;
      },
      // arg is for internal usage only
      map: function(b, T, z) {
        var W, U, X = 0, K = [];
        if (tt(b))
          for (W = b.length; X < W; X++)
            U = T(b[X], X, z), U != null && K.push(U);
        else
          for (X in b)
            U = T(b[X], X, z), U != null && K.push(U);
        return h(K);
      },
      // A global GUID counter for objects
      guid: 1,
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support: E
    }), typeof Symbol == "function" && (S.fn[Symbol.iterator] = o[Symbol.iterator]), S.each(
      "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
      function(b, T) {
        v["[object " + T + "]"] = T.toLowerCase();
      }
    );
    function tt(b) {
      var T = !!b && "length" in b && b.length, z = H(b);
      return x(b) || D(b) ? !1 : z === "array" || T === 0 || typeof T == "number" && T > 0 && T - 1 in b;
    }
    function nt(b, T) {
      return b.nodeName && b.nodeName.toLowerCase() === T.toLowerCase();
    }
    var ft = o.pop, pt = o.sort, ct = o.splice, Nt = "[\\x20\\t\\r\\n\\f]", kt = new RegExp(
      "^" + Nt + "+|((?:^|[^\\\\])(?:\\\\.)*)" + Nt + "+$",
      "g"
    );
    S.contains = function(b, T) {
      var z = T && T.parentNode;
      return b === z || !!(z && z.nodeType === 1 && // Support: IE 9 - 11+
      // IE doesn't have `contains` on SVG.
      (b.contains ? b.contains(z) : b.compareDocumentPosition && b.compareDocumentPosition(z) & 16));
    };
    var Rt = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
    function Mt(b, T) {
      return T ? b === "\0" ? "�" : b.slice(0, -1) + "\\" + b.charCodeAt(b.length - 1).toString(16) + " " : "\\" + b;
    }
    S.escapeSelector = function(b) {
      return (b + "").replace(Rt, Mt);
    };
    var G = F, Y = c;
    (function() {
      var b, T, z, W, U, X = Y, K, ut, lt, _t, Lt, Bt = S.expando, Pt = 0, Vt = 0, se = Xn(), De = Xn(), ge = Xn(), Ue = Xn(), Be = function(ot, vt) {
        return ot === vt && (U = !0), 0;
      }, wi = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", gi = "(?:\\\\[\\da-fA-F]{1,6}" + Nt + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", ye = "\\[" + Nt + "*(" + gi + ")(?:" + Nt + // Operator (capture 2)
      "*([*^$|!~]?=)" + Nt + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
      `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + gi + "))|)" + Nt + "*\\]", Ci = ":(" + gi + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + ye + ")*)|.*)\\)|)", me = new RegExp(Nt + "+", "g"), Oe = new RegExp("^" + Nt + "*," + Nt + "*"), Oi = new RegExp("^" + Nt + "*([>+~]|" + Nt + ")" + Nt + "*"), ei = new RegExp(Nt + "|>"), vi = new RegExp(Ci), tn = new RegExp("^" + gi + "$"), Di = {
        ID: new RegExp("^#(" + gi + ")"),
        CLASS: new RegExp("^\\.(" + gi + ")"),
        TAG: new RegExp("^(" + gi + "|[*])"),
        ATTR: new RegExp("^" + ye),
        PSEUDO: new RegExp("^" + Ci),
        CHILD: new RegExp(
          "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + Nt + "*(even|odd|(([+-]|)(\\d*)n|)" + Nt + "*(?:([+-]|)" + Nt + "*(\\d+)|))" + Nt + "*\\)|)",
          "i"
        ),
        bool: new RegExp("^(?:" + wi + ")$", "i"),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        needsContext: new RegExp("^" + Nt + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + Nt + "*((?:-\\d)?\\d*)" + Nt + "*\\)|)(?=[^-]|$)", "i")
      }, Mi = /^(?:input|select|textarea|button)$/i, Ei = /^h\d$/i, si = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, pr = /[+~]/, Pi = new RegExp("\\\\[\\da-fA-F]{1,6}" + Nt + "?|\\\\([^\\r\\n\\f])", "g"), Ii = function(ot, vt) {
        var Ct = "0x" + ot.slice(1) - 65536;
        return vt || (Ct < 0 ? String.fromCharCode(Ct + 65536) : String.fromCharCode(Ct >> 10 | 55296, Ct & 1023 | 56320));
      }, mi = function() {
        _i();
      }, en = li(
        function(ot) {
          return ot.disabled === !0 && nt(ot, "fieldset");
        },
        { dir: "parentNode", next: "legend" }
      );
      function Lr() {
        try {
          return K.activeElement;
        } catch {
        }
      }
      try {
        X.apply(
          o = u.call(G.childNodes),
          G.childNodes
        ), o[G.childNodes.length].nodeType;
      } catch {
        X = {
          apply: function(vt, Ct) {
            Y.apply(vt, u.call(Ct));
          },
          call: function(vt) {
            Y.apply(vt, u.call(arguments, 1));
          }
        };
      }
      function be(ot, vt, Ct, At) {
        var It, Kt, te, ne, ee, _e, oe, ue = vt && vt.ownerDocument, xe = vt ? vt.nodeType : 9;
        if (Ct = Ct || [], typeof ot != "string" || !ot || xe !== 1 && xe !== 9 && xe !== 11)
          return Ct;
        if (!At && (_i(vt), vt = vt || K, lt)) {
          if (xe !== 11 && (ee = si.exec(ot)))
            if (It = ee[1]) {
              if (xe === 9)
                if (te = vt.getElementById(It)) {
                  if (te.id === It)
                    return X.call(Ct, te), Ct;
                } else
                  return Ct;
              else if (ue && (te = ue.getElementById(It)) && be.contains(vt, te) && te.id === It)
                return X.call(Ct, te), Ct;
            } else {
              if (ee[2])
                return X.apply(Ct, vt.getElementsByTagName(ot)), Ct;
              if ((It = ee[3]) && vt.getElementsByClassName)
                return X.apply(Ct, vt.getElementsByClassName(It)), Ct;
            }
          if (!Ue[ot + " "] && (!_t || !_t.test(ot))) {
            if (oe = ot, ue = vt, xe === 1 && (ei.test(ot) || Oi.test(ot))) {
              for (ue = pr.test(ot) && Si(vt.parentNode) || vt, (ue != vt || !E.scope) && ((ne = vt.getAttribute("id")) ? ne = S.escapeSelector(ne) : vt.setAttribute("id", ne = Bt)), _e = Yi(ot), Kt = _e.length; Kt--; )
                _e[Kt] = (ne ? "#" + ne : ":scope") + " " + Yn(_e[Kt]);
              oe = _e.join(",");
            }
            try {
              return X.apply(
                Ct,
                ue.querySelectorAll(oe)
              ), Ct;
            } catch {
              Ue(ot, !0);
            } finally {
              ne === Bt && vt.removeAttribute("id");
            }
          }
        }
        return Sn(ot.replace(kt, "$1"), vt, Ct, At);
      }
      function Xn() {
        var ot = [];
        function vt(Ct, At) {
          return ot.push(Ct + " ") > T.cacheLength && delete vt[ot.shift()], vt[Ct + " "] = At;
        }
        return vt;
      }
      function Xe(ot) {
        return ot[Bt] = !0, ot;
      }
      function nn(ot) {
        var vt = K.createElement("fieldset");
        try {
          return !!ot(vt);
        } catch {
          return !1;
        } finally {
          vt.parentNode && vt.parentNode.removeChild(vt), vt = null;
        }
      }
      function Mn(ot) {
        return function(vt) {
          return nt(vt, "input") && vt.type === ot;
        };
      }
      function Dr(ot) {
        return function(vt) {
          return (nt(vt, "input") || nt(vt, "button")) && vt.type === ot;
        };
      }
      function En(ot) {
        return function(vt) {
          return "form" in vt ? vt.parentNode && vt.disabled === !1 ? "label" in vt ? "label" in vt.parentNode ? vt.parentNode.disabled === ot : vt.disabled === ot : vt.isDisabled === ot || // Where there is no isDisabled, check manually
          vt.isDisabled !== !ot && en(vt) === ot : vt.disabled === ot : "label" in vt ? vt.disabled === ot : !1;
        };
      }
      function Xi(ot) {
        return Xe(function(vt) {
          return vt = +vt, Xe(function(Ct, At) {
            for (var It, Kt = ot([], Ct.length, vt), te = Kt.length; te--; )
              Ct[It = Kt[te]] && (Ct[It] = !(At[It] = Ct[It]));
          });
        });
      }
      function Si(ot) {
        return ot && typeof ot.getElementsByTagName < "u" && ot;
      }
      function _i(ot) {
        var vt, Ct = ot ? ot.ownerDocument || ot : G;
        return Ct == K || Ct.nodeType !== 9 || !Ct.documentElement || (K = Ct, ut = K.documentElement, lt = !S.isXMLDoc(K), Lt = ut.matches || ut.webkitMatchesSelector || ut.msMatchesSelector, ut.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        G != K && (vt = K.defaultView) && vt.top !== vt && vt.addEventListener("unload", mi), E.getById = nn(function(At) {
          return ut.appendChild(At).id = S.expando, !K.getElementsByName || !K.getElementsByName(S.expando).length;
        }), E.disconnectedMatch = nn(function(At) {
          return Lt.call(At, "*");
        }), E.scope = nn(function() {
          return K.querySelectorAll(":scope");
        }), E.cssHas = nn(function() {
          try {
            return K.querySelector(":has(*,:jqfake)"), !1;
          } catch {
            return !0;
          }
        }), E.getById ? (T.filter.ID = function(At) {
          var It = At.replace(Pi, Ii);
          return function(Kt) {
            return Kt.getAttribute("id") === It;
          };
        }, T.find.ID = function(At, It) {
          if (typeof It.getElementById < "u" && lt) {
            var Kt = It.getElementById(At);
            return Kt ? [Kt] : [];
          }
        }) : (T.filter.ID = function(At) {
          var It = At.replace(Pi, Ii);
          return function(Kt) {
            var te = typeof Kt.getAttributeNode < "u" && Kt.getAttributeNode("id");
            return te && te.value === It;
          };
        }, T.find.ID = function(At, It) {
          if (typeof It.getElementById < "u" && lt) {
            var Kt, te, ne, ee = It.getElementById(At);
            if (ee) {
              if (Kt = ee.getAttributeNode("id"), Kt && Kt.value === At)
                return [ee];
              for (ne = It.getElementsByName(At), te = 0; ee = ne[te++]; )
                if (Kt = ee.getAttributeNode("id"), Kt && Kt.value === At)
                  return [ee];
            }
            return [];
          }
        }), T.find.TAG = function(At, It) {
          return typeof It.getElementsByTagName < "u" ? It.getElementsByTagName(At) : It.querySelectorAll(At);
        }, T.find.CLASS = function(At, It) {
          if (typeof It.getElementsByClassName < "u" && lt)
            return It.getElementsByClassName(At);
        }, _t = [], nn(function(At) {
          var It;
          ut.appendChild(At).innerHTML = "<a id='" + Bt + "' href='' disabled='disabled'></a><select id='" + Bt + "-\r\\' disabled='disabled'><option selected=''></option></select>", At.querySelectorAll("[selected]").length || _t.push("\\[" + Nt + "*(?:value|" + wi + ")"), At.querySelectorAll("[id~=" + Bt + "-]").length || _t.push("~="), At.querySelectorAll("a#" + Bt + "+*").length || _t.push(".#.+[+~]"), At.querySelectorAll(":checked").length || _t.push(":checked"), It = K.createElement("input"), It.setAttribute("type", "hidden"), At.appendChild(It).setAttribute("name", "D"), ut.appendChild(At).disabled = !0, At.querySelectorAll(":disabled").length !== 2 && _t.push(":enabled", ":disabled"), It = K.createElement("input"), It.setAttribute("name", ""), At.appendChild(It), At.querySelectorAll("[name='']").length || _t.push("\\[" + Nt + "*name" + Nt + "*=" + Nt + `*(?:''|"")`);
        }), E.cssHas || _t.push(":has"), _t = _t.length && new RegExp(_t.join("|")), Be = function(At, It) {
          if (At === It)
            return U = !0, 0;
          var Kt = !At.compareDocumentPosition - !It.compareDocumentPosition;
          return Kt || (Kt = (At.ownerDocument || At) == (It.ownerDocument || It) ? At.compareDocumentPosition(It) : (
            // Otherwise we know they are disconnected
            1
          ), Kt & 1 || !E.sortDetached && It.compareDocumentPosition(At) === Kt ? At === K || At.ownerDocument == G && be.contains(G, At) ? -1 : It === K || It.ownerDocument == G && be.contains(G, It) ? 1 : W ? f.call(W, At) - f.call(W, It) : 0 : Kt & 4 ? -1 : 1);
        }), K;
      }
      be.matches = function(ot, vt) {
        return be(ot, null, null, vt);
      }, be.matchesSelector = function(ot, vt) {
        if (_i(ot), lt && !Ue[vt + " "] && (!_t || !_t.test(vt)))
          try {
            var Ct = Lt.call(ot, vt);
            if (Ct || E.disconnectedMatch || // As well, disconnected nodes are said to be in a document
            // fragment in IE 9
            ot.document && ot.document.nodeType !== 11)
              return Ct;
          } catch {
            Ue(vt, !0);
          }
        return be(vt, K, null, [ot]).length > 0;
      }, be.contains = function(ot, vt) {
        return (ot.ownerDocument || ot) != K && _i(ot), S.contains(ot, vt);
      }, be.attr = function(ot, vt) {
        (ot.ownerDocument || ot) != K && _i(ot);
        var Ct = T.attrHandle[vt.toLowerCase()], At = Ct && g.call(T.attrHandle, vt.toLowerCase()) ? Ct(ot, vt, !lt) : void 0;
        return At !== void 0 ? At : ot.getAttribute(vt);
      }, be.error = function(ot) {
        throw new Error("Syntax error, unrecognized expression: " + ot);
      }, S.uniqueSort = function(ot) {
        var vt, Ct = [], At = 0, It = 0;
        if (U = !E.sortStable, W = !E.sortStable && u.call(ot, 0), pt.call(ot, Be), U) {
          for (; vt = ot[It++]; )
            vt === ot[It] && (At = Ct.push(It));
          for (; At--; )
            ct.call(ot, Ct[At], 1);
        }
        return W = null, ot;
      }, S.fn.uniqueSort = function() {
        return this.pushStack(S.uniqueSort(u.apply(this)));
      }, T = S.expr = {
        // Can be adjusted by the user
        cacheLength: 50,
        createPseudo: Xe,
        match: Di,
        attrHandle: {},
        find: {},
        relative: {
          ">": { dir: "parentNode", first: !0 },
          " ": { dir: "parentNode" },
          "+": { dir: "previousSibling", first: !0 },
          "~": { dir: "previousSibling" }
        },
        preFilter: {
          ATTR: function(ot) {
            return ot[1] = ot[1].replace(Pi, Ii), ot[3] = (ot[3] || ot[4] || ot[5] || "").replace(Pi, Ii), ot[2] === "~=" && (ot[3] = " " + ot[3] + " "), ot.slice(0, 4);
          },
          CHILD: function(ot) {
            return ot[1] = ot[1].toLowerCase(), ot[1].slice(0, 3) === "nth" ? (ot[3] || be.error(ot[0]), ot[4] = +(ot[4] ? ot[5] + (ot[6] || 1) : 2 * (ot[3] === "even" || ot[3] === "odd")), ot[5] = +(ot[7] + ot[8] || ot[3] === "odd")) : ot[3] && be.error(ot[0]), ot;
          },
          PSEUDO: function(ot) {
            var vt, Ct = !ot[6] && ot[2];
            return Di.CHILD.test(ot[0]) ? null : (ot[3] ? ot[2] = ot[4] || ot[5] || "" : Ct && vi.test(Ct) && // Get excess from tokenize (recursively)
            (vt = Yi(Ct, !0)) && // advance to the next closing parenthesis
            (vt = Ct.indexOf(")", Ct.length - vt) - Ct.length) && (ot[0] = ot[0].slice(0, vt), ot[2] = Ct.slice(0, vt)), ot.slice(0, 3));
          }
        },
        filter: {
          TAG: function(ot) {
            var vt = ot.replace(Pi, Ii).toLowerCase();
            return ot === "*" ? function() {
              return !0;
            } : function(Ct) {
              return nt(Ct, vt);
            };
          },
          CLASS: function(ot) {
            var vt = se[ot + " "];
            return vt || (vt = new RegExp("(^|" + Nt + ")" + ot + "(" + Nt + "|$)")) && se(ot, function(Ct) {
              return vt.test(
                typeof Ct.className == "string" && Ct.className || typeof Ct.getAttribute < "u" && Ct.getAttribute("class") || ""
              );
            });
          },
          ATTR: function(ot, vt, Ct) {
            return function(At) {
              var It = be.attr(At, ot);
              return It == null ? vt === "!=" : vt ? (It += "", vt === "=" ? It === Ct : vt === "!=" ? It !== Ct : vt === "^=" ? Ct && It.indexOf(Ct) === 0 : vt === "*=" ? Ct && It.indexOf(Ct) > -1 : vt === "$=" ? Ct && It.slice(-Ct.length) === Ct : vt === "~=" ? (" " + It.replace(me, " ") + " ").indexOf(Ct) > -1 : vt === "|=" ? It === Ct || It.slice(0, Ct.length + 1) === Ct + "-" : !1) : !0;
            };
          },
          CHILD: function(ot, vt, Ct, At, It) {
            var Kt = ot.slice(0, 3) !== "nth", te = ot.slice(-4) !== "last", ne = vt === "of-type";
            return At === 1 && It === 0 ? (
              // Shortcut for :nth-*(n)
              function(ee) {
                return !!ee.parentNode;
              }
            ) : function(ee, _e, oe) {
              var ue, xe, re, Ae, ii, ze = Kt !== te ? "nextSibling" : "previousSibling", ui = ee.parentNode, bi = ne && ee.nodeName.toLowerCase(), on = !oe && !ne, Re = !1;
              if (ui) {
                if (Kt) {
                  for (; ze; ) {
                    for (re = ee; re = re[ze]; )
                      if (ne ? nt(re, bi) : re.nodeType === 1)
                        return !1;
                    ii = ze = ot === "only" && !ii && "nextSibling";
                  }
                  return !0;
                }
                if (ii = [te ? ui.firstChild : ui.lastChild], te && on) {
                  for (xe = ui[Bt] || (ui[Bt] = {}), ue = xe[ot] || [], Ae = ue[0] === Pt && ue[1], Re = Ae && ue[2], re = Ae && ui.childNodes[Ae]; re = ++Ae && re && re[ze] || // Fallback to seeking `elem` from the start
                  (Re = Ae = 0) || ii.pop(); )
                    if (re.nodeType === 1 && ++Re && re === ee) {
                      xe[ot] = [Pt, Ae, Re];
                      break;
                    }
                } else if (on && (xe = ee[Bt] || (ee[Bt] = {}), ue = xe[ot] || [], Ae = ue[0] === Pt && ue[1], Re = Ae), Re === !1)
                  for (; (re = ++Ae && re && re[ze] || (Re = Ae = 0) || ii.pop()) && !((ne ? nt(re, bi) : re.nodeType === 1) && ++Re && (on && (xe = re[Bt] || (re[Bt] = {}), xe[ot] = [Pt, Re]), re === ee)); )
                    ;
                return Re -= It, Re === At || Re % At === 0 && Re / At >= 0;
              }
            };
          },
          PSEUDO: function(ot, vt) {
            var Ct, At = T.pseudos[ot] || T.setFilters[ot.toLowerCase()] || be.error("unsupported pseudo: " + ot);
            return At[Bt] ? At(vt) : At.length > 1 ? (Ct = [ot, ot, "", vt], T.setFilters.hasOwnProperty(ot.toLowerCase()) ? Xe(function(It, Kt) {
              for (var te, ne = At(It, vt), ee = ne.length; ee--; )
                te = f.call(It, ne[ee]), It[te] = !(Kt[te] = ne[ee]);
            }) : function(It) {
              return At(It, 0, Ct);
            }) : At;
          }
        },
        pseudos: {
          // Potentially complex pseudos
          not: Xe(function(ot) {
            var vt = [], Ct = [], At = Pn(ot.replace(kt, "$1"));
            return At[Bt] ? Xe(function(It, Kt, te, ne) {
              for (var ee, _e = At(It, null, ne, []), oe = It.length; oe--; )
                (ee = _e[oe]) && (It[oe] = !(Kt[oe] = ee));
            }) : function(It, Kt, te) {
              return vt[0] = It, At(vt, null, te, Ct), vt[0] = null, !Ct.pop();
            };
          }),
          has: Xe(function(ot) {
            return function(vt) {
              return be(ot, vt).length > 0;
            };
          }),
          contains: Xe(function(ot) {
            return ot = ot.replace(Pi, Ii), function(vt) {
              return (vt.textContent || S.text(vt)).indexOf(ot) > -1;
            };
          }),
          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // https://www.w3.org/TR/selectors/#lang-pseudo
          lang: Xe(function(ot) {
            return tn.test(ot || "") || be.error("unsupported lang: " + ot), ot = ot.replace(Pi, Ii).toLowerCase(), function(vt) {
              var Ct;
              do
                if (Ct = lt ? vt.lang : vt.getAttribute("xml:lang") || vt.getAttribute("lang"))
                  return Ct = Ct.toLowerCase(), Ct === ot || Ct.indexOf(ot + "-") === 0;
              while ((vt = vt.parentNode) && vt.nodeType === 1);
              return !1;
            };
          }),
          // Miscellaneous
          target: function(ot) {
            var vt = n.location && n.location.hash;
            return vt && vt.slice(1) === ot.id;
          },
          root: function(ot) {
            return ot === ut;
          },
          focus: function(ot) {
            return ot === Lr() && K.hasFocus() && !!(ot.type || ot.href || ~ot.tabIndex);
          },
          // Boolean properties
          enabled: En(!1),
          disabled: En(!0),
          checked: function(ot) {
            return nt(ot, "input") && !!ot.checked || nt(ot, "option") && !!ot.selected;
          },
          selected: function(ot) {
            return ot.parentNode && ot.parentNode.selectedIndex, ot.selected === !0;
          },
          // Contents
          empty: function(ot) {
            for (ot = ot.firstChild; ot; ot = ot.nextSibling)
              if (ot.nodeType < 6)
                return !1;
            return !0;
          },
          parent: function(ot) {
            return !T.pseudos.empty(ot);
          },
          // Element/input types
          header: function(ot) {
            return Ei.test(ot.nodeName);
          },
          input: function(ot) {
            return Mi.test(ot.nodeName);
          },
          button: function(ot) {
            return nt(ot, "input") && ot.type === "button" || nt(ot, "button");
          },
          text: function(ot) {
            var vt;
            return nt(ot, "input") && ot.type === "text" && // Support: IE <10 only
            // New HTML5 attribute values (e.g., "search") appear
            // with elem.type === "text"
            ((vt = ot.getAttribute("type")) == null || vt.toLowerCase() === "text");
          },
          // Position-in-collection
          first: Xi(function() {
            return [0];
          }),
          last: Xi(function(ot, vt) {
            return [vt - 1];
          }),
          eq: Xi(function(ot, vt, Ct) {
            return [Ct < 0 ? Ct + vt : Ct];
          }),
          even: Xi(function(ot, vt) {
            for (var Ct = 0; Ct < vt; Ct += 2)
              ot.push(Ct);
            return ot;
          }),
          odd: Xi(function(ot, vt) {
            for (var Ct = 1; Ct < vt; Ct += 2)
              ot.push(Ct);
            return ot;
          }),
          lt: Xi(function(ot, vt, Ct) {
            var At;
            for (Ct < 0 ? At = Ct + vt : Ct > vt ? At = vt : At = Ct; --At >= 0; )
              ot.push(At);
            return ot;
          }),
          gt: Xi(function(ot, vt, Ct) {
            for (var At = Ct < 0 ? Ct + vt : Ct; ++At < vt; )
              ot.push(At);
            return ot;
          })
        }
      }, T.pseudos.nth = T.pseudos.eq;
      for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 })
        T.pseudos[b] = Mn(b);
      for (b in { submit: !0, reset: !0 })
        T.pseudos[b] = Dr(b);
      function Mr() {
      }
      Mr.prototype = T.filters = T.pseudos, T.setFilters = new Mr();
      function Yi(ot, vt) {
        var Ct, At, It, Kt, te, ne, ee, _e = De[ot + " "];
        if (_e)
          return vt ? 0 : _e.slice(0);
        for (te = ot, ne = [], ee = T.preFilter; te; ) {
          (!Ct || (At = Oe.exec(te))) && (At && (te = te.slice(At[0].length) || te), ne.push(It = [])), Ct = !1, (At = Oi.exec(te)) && (Ct = At.shift(), It.push({
            value: Ct,
            // Cast descendant combinators to space
            type: At[0].replace(kt, " ")
          }), te = te.slice(Ct.length));
          for (Kt in T.filter)
            (At = Di[Kt].exec(te)) && (!ee[Kt] || (At = ee[Kt](At))) && (Ct = At.shift(), It.push({
              value: Ct,
              type: Kt,
              matches: At
            }), te = te.slice(Ct.length));
          if (!Ct)
            break;
        }
        return vt ? te.length : te ? be.error(ot) : (
          // Cache the tokens
          De(ot, ne).slice(0)
        );
      }
      function Yn(ot) {
        for (var vt = 0, Ct = ot.length, At = ""; vt < Ct; vt++)
          At += ot[vt].value;
        return At;
      }
      function li(ot, vt, Ct) {
        var At = vt.dir, It = vt.next, Kt = It || At, te = Ct && Kt === "parentNode", ne = Vt++;
        return vt.first ? (
          // Check against closest ancestor/preceding element
          function(ee, _e, oe) {
            for (; ee = ee[At]; )
              if (ee.nodeType === 1 || te)
                return ot(ee, _e, oe);
            return !1;
          }
        ) : (
          // Check against all ancestor/preceding elements
          function(ee, _e, oe) {
            var ue, xe, re = [Pt, ne];
            if (oe) {
              for (; ee = ee[At]; )
                if ((ee.nodeType === 1 || te) && ot(ee, _e, oe))
                  return !0;
            } else
              for (; ee = ee[At]; )
                if (ee.nodeType === 1 || te)
                  if (xe = ee[Bt] || (ee[Bt] = {}), It && nt(ee, It))
                    ee = ee[At] || ee;
                  else {
                    if ((ue = xe[Kt]) && ue[0] === Pt && ue[1] === ne)
                      return re[2] = ue[2];
                    if (xe[Kt] = re, re[2] = ot(ee, _e, oe))
                      return !0;
                  }
            return !1;
          }
        );
      }
      function gr(ot) {
        return ot.length > 1 ? function(vt, Ct, At) {
          for (var It = ot.length; It--; )
            if (!ot[It](vt, Ct, At))
              return !1;
          return !0;
        } : ot[0];
      }
      function rn(ot, vt, Ct) {
        for (var At = 0, It = vt.length; At < It; At++)
          be(ot, vt[At], Ct);
        return Ct;
      }
      function Jn(ot, vt, Ct, At, It) {
        for (var Kt, te = [], ne = 0, ee = ot.length, _e = vt != null; ne < ee; ne++)
          (Kt = ot[ne]) && (!Ct || Ct(Kt, At, It)) && (te.push(Kt), _e && vt.push(ne));
        return te;
      }
      function yi(ot, vt, Ct, At, It, Kt) {
        return At && !At[Bt] && (At = yi(At)), It && !It[Bt] && (It = yi(It, Kt)), Xe(function(te, ne, ee, _e) {
          var oe, ue, xe, re, Ae = [], ii = [], ze = ne.length, ui = te || rn(
            vt || "*",
            ee.nodeType ? [ee] : ee,
            []
          ), bi = ot && (te || !vt) ? Jn(ui, Ae, ot, ee, _e) : ui;
          if (Ct ? (re = It || (te ? ot : ze || At) ? (
            // ...intermediate processing is necessary
            []
          ) : (
            // ...otherwise use results directly
            ne
          ), Ct(bi, re, ee, _e)) : re = bi, At)
            for (oe = Jn(re, ii), At(oe, [], ee, _e), ue = oe.length; ue--; )
              (xe = oe[ue]) && (re[ii[ue]] = !(bi[ii[ue]] = xe));
          if (te) {
            if (It || ot) {
              if (It) {
                for (oe = [], ue = re.length; ue--; )
                  (xe = re[ue]) && oe.push(bi[ue] = xe);
                It(null, re = [], oe, _e);
              }
              for (ue = re.length; ue--; )
                (xe = re[ue]) && (oe = It ? f.call(te, xe) : Ae[ue]) > -1 && (te[oe] = !(ne[oe] = xe));
            }
          } else
            re = Jn(
              re === ne ? re.splice(ze, re.length) : re
            ), It ? It(null, ne, re, _e) : X.apply(ne, re);
        });
      }
      function an(ot) {
        for (var vt, Ct, At, It = ot.length, Kt = T.relative[ot[0].type], te = Kt || T.relative[" "], ne = Kt ? 1 : 0, ee = li(function(ue) {
          return ue === vt;
        }, te, !0), _e = li(function(ue) {
          return f.call(vt, ue) > -1;
        }, te, !0), oe = [function(ue, xe, re) {
          var Ae = !Kt && (re || xe != z) || ((vt = xe).nodeType ? ee(ue, xe, re) : _e(ue, xe, re));
          return vt = null, Ae;
        }]; ne < It; ne++)
          if (Ct = T.relative[ot[ne].type])
            oe = [li(gr(oe), Ct)];
          else {
            if (Ct = T.filter[ot[ne].type].apply(null, ot[ne].matches), Ct[Bt]) {
              for (At = ++ne; At < It && !T.relative[ot[At].type]; At++)
                ;
              return yi(
                ne > 1 && gr(oe),
                ne > 1 && Yn(
                  // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                  ot.slice(0, ne - 1).concat({ value: ot[ne - 2].type === " " ? "*" : "" })
                ).replace(kt, "$1"),
                Ct,
                ne < At && an(ot.slice(ne, At)),
                At < It && an(ot = ot.slice(At)),
                At < It && Yn(ot)
              );
            }
            oe.push(Ct);
          }
        return gr(oe);
      }
      function Er(ot, vt) {
        var Ct = vt.length > 0, At = ot.length > 0, It = function(Kt, te, ne, ee, _e) {
          var oe, ue, xe, re = 0, Ae = "0", ii = Kt && [], ze = [], ui = z, bi = Kt || At && T.find.TAG("*", _e), on = Pt += ui == null ? 1 : Math.random() || 0.1, Re = bi.length;
          for (_e && (z = te == K || te || _e); Ae !== Re && (oe = bi[Ae]) != null; Ae++) {
            if (At && oe) {
              for (ue = 0, !te && oe.ownerDocument != K && (_i(oe), ne = !lt); xe = ot[ue++]; )
                if (xe(oe, te || K, ne)) {
                  X.call(ee, oe);
                  break;
                }
              _e && (Pt = on);
            }
            Ct && ((oe = !xe && oe) && re--, Kt && ii.push(oe));
          }
          if (re += Ae, Ct && Ae !== re) {
            for (ue = 0; xe = vt[ue++]; )
              xe(ii, ze, te, ne);
            if (Kt) {
              if (re > 0)
                for (; Ae--; )
                  ii[Ae] || ze[Ae] || (ze[Ae] = ft.call(ee));
              ze = Jn(ze);
            }
            X.apply(ee, ze), _e && !Kt && ze.length > 0 && re + vt.length > 1 && S.uniqueSort(ee);
          }
          return _e && (Pt = on, z = ui), ii;
        };
        return Ct ? Xe(It) : It;
      }
      function Pn(ot, vt) {
        var Ct, At = [], It = [], Kt = ge[ot + " "];
        if (!Kt) {
          for (vt || (vt = Yi(ot)), Ct = vt.length; Ct--; )
            Kt = an(vt[Ct]), Kt[Bt] ? At.push(Kt) : It.push(Kt);
          Kt = ge(
            ot,
            Er(It, At)
          ), Kt.selector = ot;
        }
        return Kt;
      }
      function Sn(ot, vt, Ct, At) {
        var It, Kt, te, ne, ee, _e = typeof ot == "function" && ot, oe = !At && Yi(ot = _e.selector || ot);
        if (Ct = Ct || [], oe.length === 1) {
          if (Kt = oe[0] = oe[0].slice(0), Kt.length > 2 && (te = Kt[0]).type === "ID" && vt.nodeType === 9 && lt && T.relative[Kt[1].type]) {
            if (vt = (T.find.ID(
              te.matches[0].replace(Pi, Ii),
              vt
            ) || [])[0], vt)
              _e && (vt = vt.parentNode);
            else
              return Ct;
            ot = ot.slice(Kt.shift().value.length);
          }
          for (It = Di.needsContext.test(ot) ? 0 : Kt.length; It-- && (te = Kt[It], !T.relative[ne = te.type]); )
            if ((ee = T.find[ne]) && (At = ee(
              te.matches[0].replace(Pi, Ii),
              pr.test(Kt[0].type) && Si(vt.parentNode) || vt
            ))) {
              if (Kt.splice(It, 1), ot = At.length && Yn(Kt), !ot)
                return X.apply(Ct, At), Ct;
              break;
            }
        }
        return (_e || Pn(ot, oe))(
          At,
          vt,
          !lt,
          Ct,
          !vt || pr.test(ot) && Si(vt.parentNode) || vt
        ), Ct;
      }
      E.sortStable = Bt.split("").sort(Be).join("") === Bt, _i(), E.sortDetached = nn(function(ot) {
        return ot.compareDocumentPosition(K.createElement("fieldset")) & 1;
      }), S.find = be, S.expr[":"] = S.expr.pseudos, S.unique = S.uniqueSort, be.compile = Pn, be.select = Sn, be.setDocument = _i, be.tokenize = Yi, be.escape = S.escapeSelector, be.getText = S.text, be.isXML = S.isXMLDoc, be.selectors = S.expr, be.support = S.support, be.uniqueSort = S.uniqueSort;
    })();
    var it = function(b, T, z) {
      for (var W = [], U = z !== void 0; (b = b[T]) && b.nodeType !== 9; )
        if (b.nodeType === 1) {
          if (U && S(b).is(z))
            break;
          W.push(b);
        }
      return W;
    }, rt = function(b, T) {
      for (var z = []; b; b = b.nextSibling)
        b.nodeType === 1 && b !== T && z.push(b);
      return z;
    }, ht = S.expr.match.needsContext, bt = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function yt(b, T, z) {
      return x(T) ? S.grep(b, function(W, U) {
        return !!T.call(W, U, W) !== z;
      }) : T.nodeType ? S.grep(b, function(W) {
        return W === T !== z;
      }) : typeof T != "string" ? S.grep(b, function(W) {
        return f.call(T, W) > -1 !== z;
      }) : S.filter(T, b, z);
    }
    S.filter = function(b, T, z) {
      var W = T[0];
      return z && (b = ":not(" + b + ")"), T.length === 1 && W.nodeType === 1 ? S.find.matchesSelector(W, b) ? [W] : [] : S.find.matches(b, S.grep(T, function(U) {
        return U.nodeType === 1;
      }));
    }, S.fn.extend({
      find: function(b) {
        var T, z, W = this.length, U = this;
        if (typeof b != "string")
          return this.pushStack(S(b).filter(function() {
            for (T = 0; T < W; T++)
              if (S.contains(U[T], this))
                return !0;
          }));
        for (z = this.pushStack([]), T = 0; T < W; T++)
          S.find(b, U[T], z);
        return W > 1 ? S.uniqueSort(z) : z;
      },
      filter: function(b) {
        return this.pushStack(yt(this, b || [], !1));
      },
      not: function(b) {
        return this.pushStack(yt(this, b || [], !0));
      },
      is: function(b) {
        return !!yt(
          this,
          // If this is a positional/relative selector, check membership in the returned set
          // so $("p:first").is("p:last") won't return true for a doc with two "p".
          typeof b == "string" && ht.test(b) ? S(b) : b || [],
          !1
        ).length;
      }
    });
    var St, Ft = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, zt = S.fn.init = function(b, T, z) {
      var W, U;
      if (!b)
        return this;
      if (z = z || St, typeof b == "string")
        if (b[0] === "<" && b[b.length - 1] === ">" && b.length >= 3 ? W = [null, b, null] : W = Ft.exec(b), W && (W[1] || !T))
          if (W[1]) {
            if (T = T instanceof S ? T[0] : T, S.merge(this, S.parseHTML(
              W[1],
              T && T.nodeType ? T.ownerDocument || T : F,
              !0
            )), bt.test(W[1]) && S.isPlainObject(T))
              for (W in T)
                x(this[W]) ? this[W](T[W]) : this.attr(W, T[W]);
            return this;
          } else
            return U = F.getElementById(W[2]), U && (this[0] = U, this.length = 1), this;
        else
          return !T || T.jquery ? (T || z).find(b) : this.constructor(T).find(b);
      else {
        if (b.nodeType)
          return this[0] = b, this.length = 1, this;
        if (x(b))
          return z.ready !== void 0 ? z.ready(b) : (
            // Execute immediately if ready is not present
            b(S)
          );
      }
      return S.makeArray(b, this);
    };
    zt.prototype = S.fn, St = S(F);
    var Zt = /^(?:parents|prev(?:Until|All))/, J = {
      children: !0,
      contents: !0,
      next: !0,
      prev: !0
    };
    S.fn.extend({
      has: function(b) {
        var T = S(b, this), z = T.length;
        return this.filter(function() {
          for (var W = 0; W < z; W++)
            if (S.contains(this, T[W]))
              return !0;
        });
      },
      closest: function(b, T) {
        var z, W = 0, U = this.length, X = [], K = typeof b != "string" && S(b);
        if (!ht.test(b)) {
          for (; W < U; W++)
            for (z = this[W]; z && z !== T; z = z.parentNode)
              if (z.nodeType < 11 && (K ? K.index(z) > -1 : (
                // Don't pass non-elements to jQuery#find
                z.nodeType === 1 && S.find.matchesSelector(z, b)
              ))) {
                X.push(z);
                break;
              }
        }
        return this.pushStack(X.length > 1 ? S.uniqueSort(X) : X);
      },
      // Determine the position of an element within the set
      index: function(b) {
        return b ? typeof b == "string" ? f.call(S(b), this[0]) : f.call(
          this,
          // If it receives a jQuery object, the first element is used
          b.jquery ? b[0] : b
        ) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      },
      add: function(b, T) {
        return this.pushStack(
          S.uniqueSort(
            S.merge(this.get(), S(b, T))
          )
        );
      },
      addBack: function(b) {
        return this.add(
          b == null ? this.prevObject : this.prevObject.filter(b)
        );
      }
    });
    function et(b, T) {
      for (; (b = b[T]) && b.nodeType !== 1; )
        ;
      return b;
    }
    S.each({
      parent: function(b) {
        var T = b.parentNode;
        return T && T.nodeType !== 11 ? T : null;
      },
      parents: function(b) {
        return it(b, "parentNode");
      },
      parentsUntil: function(b, T, z) {
        return it(b, "parentNode", z);
      },
      next: function(b) {
        return et(b, "nextSibling");
      },
      prev: function(b) {
        return et(b, "previousSibling");
      },
      nextAll: function(b) {
        return it(b, "nextSibling");
      },
      prevAll: function(b) {
        return it(b, "previousSibling");
      },
      nextUntil: function(b, T, z) {
        return it(b, "nextSibling", z);
      },
      prevUntil: function(b, T, z) {
        return it(b, "previousSibling", z);
      },
      siblings: function(b) {
        return rt((b.parentNode || {}).firstChild, b);
      },
      children: function(b) {
        return rt(b.firstChild);
      },
      contents: function(b) {
        return b.contentDocument != null && // Support: IE 11+
        // <object> elements with no `data` attribute has an object
        // `contentDocument` with a `null` prototype.
        l(b.contentDocument) ? b.contentDocument : (nt(b, "template") && (b = b.content || b), S.merge([], b.childNodes));
      }
    }, function(b, T) {
      S.fn[b] = function(z, W) {
        var U = S.map(this, T, z);
        return b.slice(-5) !== "Until" && (W = z), W && typeof W == "string" && (U = S.filter(W, U)), this.length > 1 && (J[b] || S.uniqueSort(U), Zt.test(b) && U.reverse()), this.pushStack(U);
      };
    });
    var at = /[^\x20\t\r\n\f]+/g;
    function gt(b) {
      var T = {};
      return S.each(b.match(at) || [], function(z, W) {
        T[W] = !0;
      }), T;
    }
    S.Callbacks = function(b) {
      b = typeof b == "string" ? gt(b) : S.extend({}, b);
      var T, z, W, U, X = [], K = [], ut = -1, lt = function() {
        for (U = U || b.once, W = T = !0; K.length; ut = -1)
          for (z = K.shift(); ++ut < X.length; )
            X[ut].apply(z[0], z[1]) === !1 && b.stopOnFalse && (ut = X.length, z = !1);
        b.memory || (z = !1), T = !1, U && (z ? X = [] : X = "");
      }, _t = {
        // Add a callback or a collection of callbacks to the list
        add: function() {
          return X && (z && !T && (ut = X.length - 1, K.push(z)), function Lt(Bt) {
            S.each(Bt, function(Pt, Vt) {
              x(Vt) ? (!b.unique || !_t.has(Vt)) && X.push(Vt) : Vt && Vt.length && H(Vt) !== "string" && Lt(Vt);
            });
          }(arguments), z && !T && lt()), this;
        },
        // Remove a callback from the list
        remove: function() {
          return S.each(arguments, function(Lt, Bt) {
            for (var Pt; (Pt = S.inArray(Bt, X, Pt)) > -1; )
              X.splice(Pt, 1), Pt <= ut && ut--;
          }), this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function(Lt) {
          return Lt ? S.inArray(Lt, X) > -1 : X.length > 0;
        },
        // Remove all callbacks from the list
        empty: function() {
          return X && (X = []), this;
        },
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function() {
          return U = K = [], X = z = "", this;
        },
        disabled: function() {
          return !X;
        },
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function() {
          return U = K = [], !z && !T && (X = z = ""), this;
        },
        locked: function() {
          return !!U;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function(Lt, Bt) {
          return U || (Bt = Bt || [], Bt = [Lt, Bt.slice ? Bt.slice() : Bt], K.push(Bt), T || lt()), this;
        },
        // Call all the callbacks with the given arguments
        fire: function() {
          return _t.fireWith(this, arguments), this;
        },
        // To know if the callbacks have already been called at least once
        fired: function() {
          return !!W;
        }
      };
      return _t;
    };
    function wt(b) {
      return b;
    }
    function Et(b) {
      throw b;
    }
    function qt(b, T, z, W) {
      var U;
      try {
        b && x(U = b.promise) ? U.call(b).done(T).fail(z) : b && x(U = b.then) ? U.call(b, T, z) : T.apply(void 0, [b].slice(W));
      } catch (X) {
        z.apply(void 0, [X]);
      }
    }
    S.extend({
      Deferred: function(b) {
        var T = [
          // action, add listener, callbacks,
          // ... .then handlers, argument index, [final state]
          [
            "notify",
            "progress",
            S.Callbacks("memory"),
            S.Callbacks("memory"),
            2
          ],
          [
            "resolve",
            "done",
            S.Callbacks("once memory"),
            S.Callbacks("once memory"),
            0,
            "resolved"
          ],
          [
            "reject",
            "fail",
            S.Callbacks("once memory"),
            S.Callbacks("once memory"),
            1,
            "rejected"
          ]
        ], z = "pending", W = {
          state: function() {
            return z;
          },
          always: function() {
            return U.done(arguments).fail(arguments), this;
          },
          catch: function(X) {
            return W.then(null, X);
          },
          // Keep pipe for back-compat
          pipe: function() {
            var X = arguments;
            return S.Deferred(function(K) {
              S.each(T, function(ut, lt) {
                var _t = x(X[lt[4]]) && X[lt[4]];
                U[lt[1]](function() {
                  var Lt = _t && _t.apply(this, arguments);
                  Lt && x(Lt.promise) ? Lt.promise().progress(K.notify).done(K.resolve).fail(K.reject) : K[lt[0] + "With"](
                    this,
                    _t ? [Lt] : arguments
                  );
                });
              }), X = null;
            }).promise();
          },
          then: function(X, K, ut) {
            var lt = 0;
            function _t(Lt, Bt, Pt, Vt) {
              return function() {
                var se = this, De = arguments, ge = function() {
                  var Be, wi;
                  if (!(Lt < lt)) {
                    if (Be = Pt.apply(se, De), Be === Bt.promise())
                      throw new TypeError("Thenable self-resolution");
                    wi = Be && // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    (typeof Be == "object" || typeof Be == "function") && Be.then, x(wi) ? Vt ? wi.call(
                      Be,
                      _t(lt, Bt, wt, Vt),
                      _t(lt, Bt, Et, Vt)
                    ) : (lt++, wi.call(
                      Be,
                      _t(lt, Bt, wt, Vt),
                      _t(lt, Bt, Et, Vt),
                      _t(
                        lt,
                        Bt,
                        wt,
                        Bt.notifyWith
                      )
                    )) : (Pt !== wt && (se = void 0, De = [Be]), (Vt || Bt.resolveWith)(se, De));
                  }
                }, Ue = Vt ? ge : function() {
                  try {
                    ge();
                  } catch (Be) {
                    S.Deferred.exceptionHook && S.Deferred.exceptionHook(
                      Be,
                      Ue.error
                    ), Lt + 1 >= lt && (Pt !== Et && (se = void 0, De = [Be]), Bt.rejectWith(se, De));
                  }
                };
                Lt ? Ue() : (S.Deferred.getErrorHook ? Ue.error = S.Deferred.getErrorHook() : S.Deferred.getStackHook && (Ue.error = S.Deferred.getStackHook()), n.setTimeout(Ue));
              };
            }
            return S.Deferred(function(Lt) {
              T[0][3].add(
                _t(
                  0,
                  Lt,
                  x(ut) ? ut : wt,
                  Lt.notifyWith
                )
              ), T[1][3].add(
                _t(
                  0,
                  Lt,
                  x(X) ? X : wt
                )
              ), T[2][3].add(
                _t(
                  0,
                  Lt,
                  x(K) ? K : Et
                )
              );
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function(X) {
            return X != null ? S.extend(X, W) : W;
          }
        }, U = {};
        return S.each(T, function(X, K) {
          var ut = K[2], lt = K[5];
          W[K[1]] = ut.add, lt && ut.add(
            function() {
              z = lt;
            },
            // rejected_callbacks.disable
            // fulfilled_callbacks.disable
            T[3 - X][2].disable,
            // rejected_handlers.disable
            // fulfilled_handlers.disable
            T[3 - X][3].disable,
            // progress_callbacks.lock
            T[0][2].lock,
            // progress_handlers.lock
            T[0][3].lock
          ), ut.add(K[3].fire), U[K[0]] = function() {
            return U[K[0] + "With"](this === U ? void 0 : this, arguments), this;
          }, U[K[0] + "With"] = ut.fireWith;
        }), W.promise(U), b && b.call(U, U), U;
      },
      // Deferred helper
      when: function(b) {
        var T = arguments.length, z = T, W = Array(z), U = u.call(arguments), X = S.Deferred(), K = function(ut) {
          return function(lt) {
            W[ut] = this, U[ut] = arguments.length > 1 ? u.call(arguments) : lt, --T || X.resolveWith(W, U);
          };
        };
        if (T <= 1 && (qt(
          b,
          X.done(K(z)).resolve,
          X.reject,
          !T
        ), X.state() === "pending" || x(U[z] && U[z].then)))
          return X.then();
        for (; z--; )
          qt(U[z], K(z), X.reject);
        return X.promise();
      }
    });
    var Jt = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    S.Deferred.exceptionHook = function(b, T) {
      n.console && n.console.warn && b && Jt.test(b.name) && n.console.warn(
        "jQuery.Deferred exception: " + b.message,
        b.stack,
        T
      );
    }, S.readyException = function(b) {
      n.setTimeout(function() {
        throw b;
      });
    };
    var Gt = S.Deferred();
    S.fn.ready = function(b) {
      return Gt.then(b).catch(function(T) {
        S.readyException(T);
      }), this;
    }, S.extend({
      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: !1,
      // A counter to track how many items to wait for before
      // the ready event fires. See trac-6781
      readyWait: 1,
      // Handle when the DOM is ready
      ready: function(b) {
        (b === !0 ? --S.readyWait : S.isReady) || (S.isReady = !0, !(b !== !0 && --S.readyWait > 0) && Gt.resolveWith(F, [S]));
      }
    }), S.ready.then = Gt.then;
    function Yt() {
      F.removeEventListener("DOMContentLoaded", Yt), n.removeEventListener("load", Yt), S.ready();
    }
    F.readyState === "complete" || F.readyState !== "loading" && !F.documentElement.doScroll ? n.setTimeout(S.ready) : (F.addEventListener("DOMContentLoaded", Yt), n.addEventListener("load", Yt));
    var he = function(b, T, z, W, U, X, K) {
      var ut = 0, lt = b.length, _t = z == null;
      if (H(z) === "object") {
        U = !0;
        for (ut in z)
          he(b, T, ut, z[ut], !0, X, K);
      } else if (W !== void 0 && (U = !0, x(W) || (K = !0), _t && (K ? (T.call(b, W), T = null) : (_t = T, T = function(Lt, Bt, Pt) {
        return _t.call(S(Lt), Pt);
      })), T))
        for (; ut < lt; ut++)
          T(
            b[ut],
            z,
            K ? W : W.call(b[ut], ut, T(b[ut], z))
          );
      return U ? b : _t ? T.call(b) : lt ? T(b[0], z) : X;
    }, Pe = /^-ms-/, ce = /-([a-z])/g;
    function di(b, T) {
      return T.toUpperCase();
    }
    function fe(b) {
      return b.replace(Pe, "ms-").replace(ce, di);
    }
    var st = function(b) {
      return b.nodeType === 1 || b.nodeType === 9 || !+b.nodeType;
    };
    function xt() {
      this.expando = S.expando + xt.uid++;
    }
    xt.uid = 1, xt.prototype = {
      cache: function(b) {
        var T = b[this.expando];
        return T || (T = {}, st(b) && (b.nodeType ? b[this.expando] = T : Object.defineProperty(b, this.expando, {
          value: T,
          configurable: !0
        }))), T;
      },
      set: function(b, T, z) {
        var W, U = this.cache(b);
        if (typeof T == "string")
          U[fe(T)] = z;
        else
          for (W in T)
            U[fe(W)] = T[W];
        return U;
      },
      get: function(b, T) {
        return T === void 0 ? this.cache(b) : (
          // Always use camelCase key (gh-2257)
          b[this.expando] && b[this.expando][fe(T)]
        );
      },
      access: function(b, T, z) {
        return T === void 0 || T && typeof T == "string" && z === void 0 ? this.get(b, T) : (this.set(b, T, z), z !== void 0 ? z : T);
      },
      remove: function(b, T) {
        var z, W = b[this.expando];
        if (W !== void 0) {
          if (T !== void 0)
            for (Array.isArray(T) ? T = T.map(fe) : (T = fe(T), T = T in W ? [T] : T.match(at) || []), z = T.length; z--; )
              delete W[T[z]];
          (T === void 0 || S.isEmptyObject(W)) && (b.nodeType ? b[this.expando] = void 0 : delete b[this.expando]);
        }
      },
      hasData: function(b) {
        var T = b[this.expando];
        return T !== void 0 && !S.isEmptyObject(T);
      }
    };
    var mt = new xt(), Ot = new xt(), jt = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Ht = /[A-Z]/g;
    function $t(b) {
      return b === "true" ? !0 : b === "false" ? !1 : b === "null" ? null : b === +b + "" ? +b : jt.test(b) ? JSON.parse(b) : b;
    }
    function Xt(b, T, z) {
      var W;
      if (z === void 0 && b.nodeType === 1)
        if (W = "data-" + T.replace(Ht, "-$&").toLowerCase(), z = b.getAttribute(W), typeof z == "string") {
          try {
            z = $t(z);
          } catch {
          }
          Ot.set(b, T, z);
        } else
          z = void 0;
      return z;
    }
    S.extend({
      hasData: function(b) {
        return Ot.hasData(b) || mt.hasData(b);
      },
      data: function(b, T, z) {
        return Ot.access(b, T, z);
      },
      removeData: function(b, T) {
        Ot.remove(b, T);
      },
      // TODO: Now that all calls to _data and _removeData have been replaced
      // with direct calls to dataPriv methods, these can be deprecated.
      _data: function(b, T, z) {
        return mt.access(b, T, z);
      },
      _removeData: function(b, T) {
        mt.remove(b, T);
      }
    }), S.fn.extend({
      data: function(b, T) {
        var z, W, U, X = this[0], K = X && X.attributes;
        if (b === void 0) {
          if (this.length && (U = Ot.get(X), X.nodeType === 1 && !mt.get(X, "hasDataAttrs"))) {
            for (z = K.length; z--; )
              K[z] && (W = K[z].name, W.indexOf("data-") === 0 && (W = fe(W.slice(5)), Xt(X, W, U[W])));
            mt.set(X, "hasDataAttrs", !0);
          }
          return U;
        }
        return typeof b == "object" ? this.each(function() {
          Ot.set(this, b);
        }) : he(this, function(ut) {
          var lt;
          if (X && ut === void 0)
            return lt = Ot.get(X, b), lt !== void 0 || (lt = Xt(X, b), lt !== void 0) ? lt : void 0;
          this.each(function() {
            Ot.set(this, b, ut);
          });
        }, null, T, arguments.length > 1, null, !0);
      },
      removeData: function(b) {
        return this.each(function() {
          Ot.remove(this, b);
        });
      }
    }), S.extend({
      queue: function(b, T, z) {
        var W;
        if (b)
          return T = (T || "fx") + "queue", W = mt.get(b, T), z && (!W || Array.isArray(z) ? W = mt.access(b, T, S.makeArray(z)) : W.push(z)), W || [];
      },
      dequeue: function(b, T) {
        T = T || "fx";
        var z = S.queue(b, T), W = z.length, U = z.shift(), X = S._queueHooks(b, T), K = function() {
          S.dequeue(b, T);
        };
        U === "inprogress" && (U = z.shift(), W--), U && (T === "fx" && z.unshift("inprogress"), delete X.stop, U.call(b, K, X)), !W && X && X.empty.fire();
      },
      // Not public - generate a queueHooks object, or return the current one
      _queueHooks: function(b, T) {
        var z = T + "queueHooks";
        return mt.get(b, z) || mt.access(b, z, {
          empty: S.Callbacks("once memory").add(function() {
            mt.remove(b, [T + "queue", z]);
          })
        });
      }
    }), S.fn.extend({
      queue: function(b, T) {
        var z = 2;
        return typeof b != "string" && (T = b, b = "fx", z--), arguments.length < z ? S.queue(this[0], b) : T === void 0 ? this : this.each(function() {
          var W = S.queue(this, b, T);
          S._queueHooks(this, b), b === "fx" && W[0] !== "inprogress" && S.dequeue(this, b);
        });
      },
      dequeue: function(b) {
        return this.each(function() {
          S.dequeue(this, b);
        });
      },
      clearQueue: function(b) {
        return this.queue(b || "fx", []);
      },
      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function(b, T) {
        var z, W = 1, U = S.Deferred(), X = this, K = this.length, ut = function() {
          --W || U.resolveWith(X, [X]);
        };
        for (typeof b != "string" && (T = b, b = void 0), b = b || "fx"; K--; )
          z = mt.get(X[K], b + "queueHooks"), z && z.empty && (W++, z.empty.add(ut));
        return ut(), U.promise(T);
      }
    });
    var Qt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, Ut = new RegExp("^(?:([+-])=|)(" + Qt + ")([a-z%]*)$", "i"), ve = ["Top", "Right", "Bottom", "Left"], we = F.documentElement, Te = function(b) {
      return S.contains(b.ownerDocument, b);
    }, Ve = { composed: !0 };
    we.getRootNode && (Te = function(b) {
      return S.contains(b.ownerDocument, b) || b.getRootNode(Ve) === b.ownerDocument;
    });
    var Le = function(b, T) {
      return b = T || b, b.style.display === "none" || b.style.display === "" && // Otherwise, check computed style
      // Support: Firefox <=43 - 45
      // Disconnected elements can have computed display: none, so first confirm that elem is
      // in the document.
      Te(b) && S.css(b, "display") === "none";
    };
    function Ke(b, T, z, W) {
      var U, X, K = 20, ut = W ? function() {
        return W.cur();
      } : function() {
        return S.css(b, T, "");
      }, lt = ut(), _t = z && z[3] || (S.cssNumber[T] ? "" : "px"), Lt = b.nodeType && (S.cssNumber[T] || _t !== "px" && +lt) && Ut.exec(S.css(b, T));
      if (Lt && Lt[3] !== _t) {
        for (lt = lt / 2, _t = _t || Lt[3], Lt = +lt || 1; K--; )
          S.style(b, T, Lt + _t), (1 - X) * (1 - (X = ut() / lt || 0.5)) <= 0 && (K = 0), Lt = Lt / X;
        Lt = Lt * 2, S.style(b, T, Lt + _t), z = z || [];
      }
      return z && (Lt = +Lt || +lt || 0, U = z[1] ? Lt + (z[1] + 1) * z[2] : +z[2], W && (W.unit = _t, W.start = Lt, W.end = U)), U;
    }
    var Qe = {};
    function Ti(b) {
      var T, z = b.ownerDocument, W = b.nodeName, U = Qe[W];
      return U || (T = z.body.appendChild(z.createElement(W)), U = S.css(T, "display"), T.parentNode.removeChild(T), U === "none" && (U = "block"), Qe[W] = U, U);
    }
    function ai(b, T) {
      for (var z, W, U = [], X = 0, K = b.length; X < K; X++)
        W = b[X], W.style && (z = W.style.display, T ? (z === "none" && (U[X] = mt.get(W, "display") || null, U[X] || (W.style.display = "")), W.style.display === "" && Le(W) && (U[X] = Ti(W))) : z !== "none" && (U[X] = "none", mt.set(W, "display", z)));
      for (X = 0; X < K; X++)
        U[X] != null && (b[X].style.display = U[X]);
      return b;
    }
    S.fn.extend({
      show: function() {
        return ai(this, !0);
      },
      hide: function() {
        return ai(this);
      },
      toggle: function(b) {
        return typeof b == "boolean" ? b ? this.show() : this.hide() : this.each(function() {
          Le(this) ? S(this).show() : S(this).hide();
        });
      }
    });
    var Bi = /^(?:checkbox|radio)$/i, In = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, Bn = /^$|^module$|\/(?:java|ecma)script/i;
    (function() {
      var b = F.createDocumentFragment(), T = b.appendChild(F.createElement("div")), z = F.createElement("input");
      z.setAttribute("type", "radio"), z.setAttribute("checked", "checked"), z.setAttribute("name", "t"), T.appendChild(z), E.checkClone = T.cloneNode(!0).cloneNode(!0).lastChild.checked, T.innerHTML = "<textarea>x</textarea>", E.noCloneChecked = !!T.cloneNode(!0).lastChild.defaultValue, T.innerHTML = "<option></option>", E.option = !!T.lastChild;
    })();
    var $e = {
      // XHTML parsers do not magically insert elements in the
      // same way that tag soup parsers do. So we cannot shorten
      // this by omitting <tbody> or other required elements.
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
    $e.tbody = $e.tfoot = $e.colgroup = $e.caption = $e.thead, $e.th = $e.td, E.option || ($e.optgroup = $e.option = [1, "<select multiple='multiple'>", "</select>"]);
    function Ze(b, T) {
      var z;
      return typeof b.getElementsByTagName < "u" ? z = b.getElementsByTagName(T || "*") : typeof b.querySelectorAll < "u" ? z = b.querySelectorAll(T || "*") : z = [], T === void 0 || T && nt(b, T) ? S.merge([b], z) : z;
    }
    function sn(b, T) {
      for (var z = 0, W = b.length; z < W; z++)
        mt.set(
          b[z],
          "globalEval",
          !T || mt.get(T[z], "globalEval")
        );
    }
    var $n = /<|&#?\w+;/;
    function Ki(b, T, z, W, U) {
      for (var X, K, ut, lt, _t, Lt, Bt = T.createDocumentFragment(), Pt = [], Vt = 0, se = b.length; Vt < se; Vt++)
        if (X = b[Vt], X || X === 0)
          if (H(X) === "object")
            S.merge(Pt, X.nodeType ? [X] : X);
          else if (!$n.test(X))
            Pt.push(T.createTextNode(X));
          else {
            for (K = K || Bt.appendChild(T.createElement("div")), ut = (In.exec(X) || ["", ""])[1].toLowerCase(), lt = $e[ut] || $e._default, K.innerHTML = lt[1] + S.htmlPrefilter(X) + lt[2], Lt = lt[0]; Lt--; )
              K = K.lastChild;
            S.merge(Pt, K.childNodes), K = Bt.firstChild, K.textContent = "";
          }
      for (Bt.textContent = "", Vt = 0; X = Pt[Vt++]; ) {
        if (W && S.inArray(X, W) > -1) {
          U && U.push(X);
          continue;
        }
        if (_t = Te(X), K = Ze(Bt.appendChild(X), "script"), _t && sn(K), z)
          for (Lt = 0; X = K[Lt++]; )
            Bn.test(X.type || "") && z.push(X);
      }
      return Bt;
    }
    var zn = /^([^.]*)(?:\.(.+)|)/;
    function zi() {
      return !0;
    }
    function Ri() {
      return !1;
    }
    function un(b, T, z, W, U, X) {
      var K, ut;
      if (typeof T == "object") {
        typeof z != "string" && (W = W || z, z = void 0);
        for (ut in T)
          un(b, ut, z, W, T[ut], X);
        return b;
      }
      if (W == null && U == null ? (U = z, W = z = void 0) : U == null && (typeof z == "string" ? (U = W, W = void 0) : (U = W, W = z, z = void 0)), U === !1)
        U = Ri;
      else if (!U)
        return b;
      return X === 1 && (K = U, U = function(lt) {
        return S().off(lt), K.apply(this, arguments);
      }, U.guid = K.guid || (K.guid = S.guid++)), b.each(function() {
        S.event.add(this, T, U, W, z);
      });
    }
    S.event = {
      global: {},
      add: function(b, T, z, W, U) {
        var X, K, ut, lt, _t, Lt, Bt, Pt, Vt, se, De, ge = mt.get(b);
        if (st(b))
          for (z.handler && (X = z, z = X.handler, U = X.selector), U && S.find.matchesSelector(we, U), z.guid || (z.guid = S.guid++), (lt = ge.events) || (lt = ge.events = /* @__PURE__ */ Object.create(null)), (K = ge.handle) || (K = ge.handle = function(Ue) {
            return typeof S < "u" && S.event.triggered !== Ue.type ? S.event.dispatch.apply(b, arguments) : void 0;
          }), T = (T || "").match(at) || [""], _t = T.length; _t--; )
            ut = zn.exec(T[_t]) || [], Vt = De = ut[1], se = (ut[2] || "").split(".").sort(), Vt && (Bt = S.event.special[Vt] || {}, Vt = (U ? Bt.delegateType : Bt.bindType) || Vt, Bt = S.event.special[Vt] || {}, Lt = S.extend({
              type: Vt,
              origType: De,
              data: W,
              handler: z,
              guid: z.guid,
              selector: U,
              needsContext: U && S.expr.match.needsContext.test(U),
              namespace: se.join(".")
            }, X), (Pt = lt[Vt]) || (Pt = lt[Vt] = [], Pt.delegateCount = 0, (!Bt.setup || Bt.setup.call(b, W, se, K) === !1) && b.addEventListener && b.addEventListener(Vt, K)), Bt.add && (Bt.add.call(b, Lt), Lt.handler.guid || (Lt.handler.guid = z.guid)), U ? Pt.splice(Pt.delegateCount++, 0, Lt) : Pt.push(Lt), S.event.global[Vt] = !0);
      },
      // Detach an event or set of events from an element
      remove: function(b, T, z, W, U) {
        var X, K, ut, lt, _t, Lt, Bt, Pt, Vt, se, De, ge = mt.hasData(b) && mt.get(b);
        if (!(!ge || !(lt = ge.events))) {
          for (T = (T || "").match(at) || [""], _t = T.length; _t--; ) {
            if (ut = zn.exec(T[_t]) || [], Vt = De = ut[1], se = (ut[2] || "").split(".").sort(), !Vt) {
              for (Vt in lt)
                S.event.remove(b, Vt + T[_t], z, W, !0);
              continue;
            }
            for (Bt = S.event.special[Vt] || {}, Vt = (W ? Bt.delegateType : Bt.bindType) || Vt, Pt = lt[Vt] || [], ut = ut[2] && new RegExp("(^|\\.)" + se.join("\\.(?:.*\\.|)") + "(\\.|$)"), K = X = Pt.length; X--; )
              Lt = Pt[X], (U || De === Lt.origType) && (!z || z.guid === Lt.guid) && (!ut || ut.test(Lt.namespace)) && (!W || W === Lt.selector || W === "**" && Lt.selector) && (Pt.splice(X, 1), Lt.selector && Pt.delegateCount--, Bt.remove && Bt.remove.call(b, Lt));
            K && !Pt.length && ((!Bt.teardown || Bt.teardown.call(b, se, ge.handle) === !1) && S.removeEvent(b, Vt, ge.handle), delete lt[Vt]);
          }
          S.isEmptyObject(lt) && mt.remove(b, "handle events");
        }
      },
      dispatch: function(b) {
        var T, z, W, U, X, K, ut = new Array(arguments.length), lt = S.event.fix(b), _t = (mt.get(this, "events") || /* @__PURE__ */ Object.create(null))[lt.type] || [], Lt = S.event.special[lt.type] || {};
        for (ut[0] = lt, T = 1; T < arguments.length; T++)
          ut[T] = arguments[T];
        if (lt.delegateTarget = this, !(Lt.preDispatch && Lt.preDispatch.call(this, lt) === !1)) {
          for (K = S.event.handlers.call(this, lt, _t), T = 0; (U = K[T++]) && !lt.isPropagationStopped(); )
            for (lt.currentTarget = U.elem, z = 0; (X = U.handlers[z++]) && !lt.isImmediatePropagationStopped(); )
              (!lt.rnamespace || X.namespace === !1 || lt.rnamespace.test(X.namespace)) && (lt.handleObj = X, lt.data = X.data, W = ((S.event.special[X.origType] || {}).handle || X.handler).apply(U.elem, ut), W !== void 0 && (lt.result = W) === !1 && (lt.preventDefault(), lt.stopPropagation()));
          return Lt.postDispatch && Lt.postDispatch.call(this, lt), lt.result;
        }
      },
      handlers: function(b, T) {
        var z, W, U, X, K, ut = [], lt = T.delegateCount, _t = b.target;
        if (lt && // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        _t.nodeType && // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !(b.type === "click" && b.button >= 1)) {
          for (; _t !== this; _t = _t.parentNode || this)
            if (_t.nodeType === 1 && !(b.type === "click" && _t.disabled === !0)) {
              for (X = [], K = {}, z = 0; z < lt; z++)
                W = T[z], U = W.selector + " ", K[U] === void 0 && (K[U] = W.needsContext ? S(U, this).index(_t) > -1 : S.find(U, this, null, [_t]).length), K[U] && X.push(W);
              X.length && ut.push({ elem: _t, handlers: X });
            }
        }
        return _t = this, lt < T.length && ut.push({ elem: _t, handlers: T.slice(lt) }), ut;
      },
      addProp: function(b, T) {
        Object.defineProperty(S.Event.prototype, b, {
          enumerable: !0,
          configurable: !0,
          get: x(T) ? function() {
            if (this.originalEvent)
              return T(this.originalEvent);
          } : function() {
            if (this.originalEvent)
              return this.originalEvent[b];
          },
          set: function(z) {
            Object.defineProperty(this, b, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: z
            });
          }
        });
      },
      fix: function(b) {
        return b[S.expando] ? b : new S.Event(b);
      },
      special: {
        load: {
          // Prevent triggered image.load events from bubbling to window.load
          noBubble: !0
        },
        click: {
          // Utilize native event to ensure correct state for checkable inputs
          setup: function(b) {
            var T = this || b;
            return Bi.test(T.type) && T.click && nt(T, "input") && Je(T, "click", !0), !1;
          },
          trigger: function(b) {
            var T = this || b;
            return Bi.test(T.type) && T.click && nt(T, "input") && Je(T, "click"), !0;
          },
          // For cross-browser consistency, suppress native .click() on links
          // Also prevent it if we're currently inside a leveraged native-event stack
          _default: function(b) {
            var T = b.target;
            return Bi.test(T.type) && T.click && nt(T, "input") && mt.get(T, "click") || nt(T, "a");
          }
        },
        beforeunload: {
          postDispatch: function(b) {
            b.result !== void 0 && b.originalEvent && (b.originalEvent.returnValue = b.result);
          }
        }
      }
    };
    function Je(b, T, z) {
      if (!z) {
        mt.get(b, T) === void 0 && S.event.add(b, T, zi);
        return;
      }
      mt.set(b, T, !1), S.event.add(b, T, {
        namespace: !1,
        handler: function(W) {
          var U, X = mt.get(this, T);
          if (W.isTrigger & 1 && this[T]) {
            if (X)
              (S.event.special[T] || {}).delegateType && W.stopPropagation();
            else if (X = u.call(arguments), mt.set(this, T, X), this[T](), U = mt.get(this, T), mt.set(this, T, !1), X !== U)
              return W.stopImmediatePropagation(), W.preventDefault(), U;
          } else
            X && (mt.set(this, T, S.event.trigger(
              X[0],
              X.slice(1),
              this
            )), W.stopPropagation(), W.isImmediatePropagationStopped = zi);
        }
      });
    }
    S.removeEvent = function(b, T, z) {
      b.removeEventListener && b.removeEventListener(T, z);
    }, S.Event = function(b, T) {
      if (!(this instanceof S.Event))
        return new S.Event(b, T);
      b && b.type ? (this.originalEvent = b, this.type = b.type, this.isDefaultPrevented = b.defaultPrevented || b.defaultPrevented === void 0 && // Support: Android <=2.3 only
      b.returnValue === !1 ? zi : Ri, this.target = b.target && b.target.nodeType === 3 ? b.target.parentNode : b.target, this.currentTarget = b.currentTarget, this.relatedTarget = b.relatedTarget) : this.type = b, T && S.extend(this, T), this.timeStamp = b && b.timeStamp || Date.now(), this[S.expando] = !0;
    }, S.Event.prototype = {
      constructor: S.Event,
      isDefaultPrevented: Ri,
      isPropagationStopped: Ri,
      isImmediatePropagationStopped: Ri,
      isSimulated: !1,
      preventDefault: function() {
        var b = this.originalEvent;
        this.isDefaultPrevented = zi, b && !this.isSimulated && b.preventDefault();
      },
      stopPropagation: function() {
        var b = this.originalEvent;
        this.isPropagationStopped = zi, b && !this.isSimulated && b.stopPropagation();
      },
      stopImmediatePropagation: function() {
        var b = this.originalEvent;
        this.isImmediatePropagationStopped = zi, b && !this.isSimulated && b.stopImmediatePropagation(), this.stopPropagation();
      }
    }, S.each({
      altKey: !0,
      bubbles: !0,
      cancelable: !0,
      changedTouches: !0,
      ctrlKey: !0,
      detail: !0,
      eventPhase: !0,
      metaKey: !0,
      pageX: !0,
      pageY: !0,
      shiftKey: !0,
      view: !0,
      char: !0,
      code: !0,
      charCode: !0,
      key: !0,
      keyCode: !0,
      button: !0,
      buttons: !0,
      clientX: !0,
      clientY: !0,
      offsetX: !0,
      offsetY: !0,
      pointerId: !0,
      pointerType: !0,
      screenX: !0,
      screenY: !0,
      targetTouches: !0,
      toElement: !0,
      touches: !0,
      which: !0
    }, S.event.addProp), S.each({ focus: "focusin", blur: "focusout" }, function(b, T) {
      function z(W) {
        if (F.documentMode) {
          var U = mt.get(this, "handle"), X = S.event.fix(W);
          X.type = W.type === "focusin" ? "focus" : "blur", X.isSimulated = !0, U(W), X.target === X.currentTarget && U(X);
        } else
          S.event.simulate(
            T,
            W.target,
            S.event.fix(W)
          );
      }
      S.event.special[b] = {
        // Utilize native event if possible so blur/focus sequence is correct
        setup: function() {
          var W;
          if (Je(this, b, !0), F.documentMode)
            W = mt.get(this, T), W || this.addEventListener(T, z), mt.set(this, T, (W || 0) + 1);
          else
            return !1;
        },
        trigger: function() {
          return Je(this, b), !0;
        },
        teardown: function() {
          var W;
          if (F.documentMode)
            W = mt.get(this, T) - 1, W ? mt.set(this, T, W) : (this.removeEventListener(T, z), mt.remove(this, T));
          else
            return !1;
        },
        // Suppress native focus or blur if we're currently inside
        // a leveraged native-event stack
        _default: function(W) {
          return mt.get(W.target, b);
        },
        delegateType: T
      }, S.event.special[T] = {
        setup: function() {
          var W = this.ownerDocument || this.document || this, U = F.documentMode ? this : W, X = mt.get(U, T);
          X || (F.documentMode ? this.addEventListener(T, z) : W.addEventListener(b, z, !0)), mt.set(U, T, (X || 0) + 1);
        },
        teardown: function() {
          var W = this.ownerDocument || this.document || this, U = F.documentMode ? this : W, X = mt.get(U, T) - 1;
          X ? mt.set(U, T, X) : (F.documentMode ? this.removeEventListener(T, z) : W.removeEventListener(b, z, !0), mt.remove(U, T));
        }
      };
    }), S.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function(b, T) {
      S.event.special[b] = {
        delegateType: T,
        bindType: T,
        handle: function(z) {
          var W, U = this, X = z.relatedTarget, K = z.handleObj;
          return (!X || X !== U && !S.contains(U, X)) && (z.type = K.origType, W = K.handler.apply(this, arguments), z.type = T), W;
        }
      };
    }), S.fn.extend({
      on: function(b, T, z, W) {
        return un(this, b, T, z, W);
      },
      one: function(b, T, z, W) {
        return un(this, b, T, z, W, 1);
      },
      off: function(b, T, z) {
        var W, U;
        if (b && b.preventDefault && b.handleObj)
          return W = b.handleObj, S(b.delegateTarget).off(
            W.namespace ? W.origType + "." + W.namespace : W.origType,
            W.selector,
            W.handler
          ), this;
        if (typeof b == "object") {
          for (U in b)
            this.off(U, T, b[U]);
          return this;
        }
        return (T === !1 || typeof T == "function") && (z = T, T = void 0), z === !1 && (z = Ri), this.each(function() {
          S.event.remove(this, b, z, T);
        });
      }
    });
    var ae = /<script|<style|<link/i, Rn = /checked\s*(?:[^=]|=\s*.checked.)/i, Hn = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
    function hn(b, T) {
      return nt(b, "table") && nt(T.nodeType !== 11 ? T : T.firstChild, "tr") && S(b).children("tbody")[0] || b;
    }
    function Wn(b) {
      return b.type = (b.getAttribute("type") !== null) + "/" + b.type, b;
    }
    function dn(b) {
      return (b.type || "").slice(0, 5) === "true/" ? b.type = b.type.slice(5) : b.removeAttribute("type"), b;
    }
    function cn(b, T) {
      var z, W, U, X, K, ut, lt;
      if (T.nodeType === 1) {
        if (mt.hasData(b) && (X = mt.get(b), lt = X.events, lt)) {
          mt.remove(T, "handle events");
          for (U in lt)
            for (z = 0, W = lt[U].length; z < W; z++)
              S.event.add(T, U, lt[U][z]);
        }
        Ot.hasData(b) && (K = Ot.access(b), ut = S.extend({}, K), Ot.set(T, ut));
      }
    }
    function Hi(b, T) {
      var z = T.nodeName.toLowerCase();
      z === "input" && Bi.test(b.type) ? T.checked = b.checked : (z === "input" || z === "textarea") && (T.defaultValue = b.defaultValue);
    }
    function Fi(b, T, z, W) {
      T = h(T);
      var U, X, K, ut, lt, _t, Lt = 0, Bt = b.length, Pt = Bt - 1, Vt = T[0], se = x(Vt);
      if (se || Bt > 1 && typeof Vt == "string" && !E.checkClone && Rn.test(Vt))
        return b.each(function(De) {
          var ge = b.eq(De);
          se && (T[0] = Vt.call(this, De, ge.html())), Fi(ge, T, z, W);
        });
      if (Bt && (U = Ki(T, b[0].ownerDocument, !1, b, W), X = U.firstChild, U.childNodes.length === 1 && (U = X), X || W)) {
        for (K = S.map(Ze(U, "script"), Wn), ut = K.length; Lt < Bt; Lt++)
          lt = U, Lt !== Pt && (lt = S.clone(lt, !0, !0), ut && S.merge(K, Ze(lt, "script"))), z.call(b[Lt], lt, Lt);
        if (ut)
          for (_t = K[K.length - 1].ownerDocument, S.map(K, dn), Lt = 0; Lt < ut; Lt++)
            lt = K[Lt], Bn.test(lt.type || "") && !mt.access(lt, "globalEval") && S.contains(_t, lt) && (lt.src && (lt.type || "").toLowerCase() !== "module" ? S._evalUrl && !lt.noModule && S._evalUrl(lt.src, {
              nonce: lt.nonce || lt.getAttribute("nonce")
            }, _t) : N(lt.textContent.replace(Hn, ""), lt, _t));
      }
      return b;
    }
    function jn(b, T, z) {
      for (var W, U = T ? S.filter(T, b) : b, X = 0; (W = U[X]) != null; X++)
        !z && W.nodeType === 1 && S.cleanData(Ze(W)), W.parentNode && (z && Te(W) && sn(Ze(W, "script")), W.parentNode.removeChild(W));
      return b;
    }
    S.extend({
      htmlPrefilter: function(b) {
        return b;
      },
      clone: function(b, T, z) {
        var W, U, X, K, ut = b.cloneNode(!0), lt = Te(b);
        if (!E.noCloneChecked && (b.nodeType === 1 || b.nodeType === 11) && !S.isXMLDoc(b))
          for (K = Ze(ut), X = Ze(b), W = 0, U = X.length; W < U; W++)
            Hi(X[W], K[W]);
        if (T)
          if (z)
            for (X = X || Ze(b), K = K || Ze(ut), W = 0, U = X.length; W < U; W++)
              cn(X[W], K[W]);
          else
            cn(b, ut);
        return K = Ze(ut, "script"), K.length > 0 && sn(K, !lt && Ze(b, "script")), ut;
      },
      cleanData: function(b) {
        for (var T, z, W, U = S.event.special, X = 0; (z = b[X]) !== void 0; X++)
          if (st(z)) {
            if (T = z[mt.expando]) {
              if (T.events)
                for (W in T.events)
                  U[W] ? S.event.remove(z, W) : S.removeEvent(z, W, T.handle);
              z[mt.expando] = void 0;
            }
            z[Ot.expando] && (z[Ot.expando] = void 0);
          }
      }
    }), S.fn.extend({
      detach: function(b) {
        return jn(this, b, !0);
      },
      remove: function(b) {
        return jn(this, b);
      },
      text: function(b) {
        return he(this, function(T) {
          return T === void 0 ? S.text(this) : this.empty().each(function() {
            (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) && (this.textContent = T);
          });
        }, null, b, arguments.length);
      },
      append: function() {
        return Fi(this, arguments, function(b) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var T = hn(this, b);
            T.appendChild(b);
          }
        });
      },
      prepend: function() {
        return Fi(this, arguments, function(b) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var T = hn(this, b);
            T.insertBefore(b, T.firstChild);
          }
        });
      },
      before: function() {
        return Fi(this, arguments, function(b) {
          this.parentNode && this.parentNode.insertBefore(b, this);
        });
      },
      after: function() {
        return Fi(this, arguments, function(b) {
          this.parentNode && this.parentNode.insertBefore(b, this.nextSibling);
        });
      },
      empty: function() {
        for (var b, T = 0; (b = this[T]) != null; T++)
          b.nodeType === 1 && (S.cleanData(Ze(b, !1)), b.textContent = "");
        return this;
      },
      clone: function(b, T) {
        return b = b ?? !1, T = T ?? b, this.map(function() {
          return S.clone(this, b, T);
        });
      },
      html: function(b) {
        return he(this, function(T) {
          var z = this[0] || {}, W = 0, U = this.length;
          if (T === void 0 && z.nodeType === 1)
            return z.innerHTML;
          if (typeof T == "string" && !ae.test(T) && !$e[(In.exec(T) || ["", ""])[1].toLowerCase()]) {
            T = S.htmlPrefilter(T);
            try {
              for (; W < U; W++)
                z = this[W] || {}, z.nodeType === 1 && (S.cleanData(Ze(z, !1)), z.innerHTML = T);
              z = 0;
            } catch {
            }
          }
          z && this.empty().append(T);
        }, null, b, arguments.length);
      },
      replaceWith: function() {
        var b = [];
        return Fi(this, arguments, function(T) {
          var z = this.parentNode;
          S.inArray(this, b) < 0 && (S.cleanData(Ze(this)), z && z.replaceChild(T, this));
        }, b);
      }
    }), S.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function(b, T) {
      S.fn[b] = function(z) {
        for (var W, U = [], X = S(z), K = X.length - 1, ut = 0; ut <= K; ut++)
          W = ut === K ? this : this.clone(!0), S(X[ut])[T](W), c.apply(U, W.get());
        return this.pushStack(U);
      };
    });
    var fn = new RegExp("^(" + Qt + ")(?!px)[a-z%]+$", "i"), pn = /^--/, Qi = function(b) {
      var T = b.ownerDocument.defaultView;
      return (!T || !T.opener) && (T = n), T.getComputedStyle(b);
    }, gn = function(b, T, z) {
      var W, U, X = {};
      for (U in T)
        X[U] = b.style[U], b.style[U] = T[U];
      W = z.call(b);
      for (U in T)
        b.style[U] = X[U];
      return W;
    }, er = new RegExp(ve.join("|"), "i");
    (function() {
      function b() {
        if (_t) {
          lt.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", _t.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", we.appendChild(lt).appendChild(_t);
          var Lt = n.getComputedStyle(_t);
          z = Lt.top !== "1%", ut = T(Lt.marginLeft) === 12, _t.style.right = "60%", X = T(Lt.right) === 36, W = T(Lt.width) === 36, _t.style.position = "absolute", U = T(_t.offsetWidth / 3) === 12, we.removeChild(lt), _t = null;
        }
      }
      function T(Lt) {
        return Math.round(parseFloat(Lt));
      }
      var z, W, U, X, K, ut, lt = F.createElement("div"), _t = F.createElement("div");
      _t.style && (_t.style.backgroundClip = "content-box", _t.cloneNode(!0).style.backgroundClip = "", E.clearCloneStyle = _t.style.backgroundClip === "content-box", S.extend(E, {
        boxSizingReliable: function() {
          return b(), W;
        },
        pixelBoxStyles: function() {
          return b(), X;
        },
        pixelPosition: function() {
          return b(), z;
        },
        reliableMarginLeft: function() {
          return b(), ut;
        },
        scrollboxSize: function() {
          return b(), U;
        },
        // Support: IE 9 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Behavior in IE 9 is more subtle than in newer versions & it passes
        // some versions of this test; make sure not to make it pass there!
        //
        // Support: Firefox 70+
        // Only Firefox includes border widths
        // in computed dimensions. (gh-4529)
        reliableTrDimensions: function() {
          var Lt, Bt, Pt, Vt;
          return K == null && (Lt = F.createElement("table"), Bt = F.createElement("tr"), Pt = F.createElement("div"), Lt.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", Bt.style.cssText = "box-sizing:content-box;border:1px solid", Bt.style.height = "1px", Pt.style.height = "9px", Pt.style.display = "block", we.appendChild(Lt).appendChild(Bt).appendChild(Pt), Vt = n.getComputedStyle(Bt), K = parseInt(Vt.height, 10) + parseInt(Vt.borderTopWidth, 10) + parseInt(Vt.borderBottomWidth, 10) === Bt.offsetHeight, we.removeChild(Lt)), K;
        }
      }));
    })();
    function ti(b, T, z) {
      var W, U, X, K, ut = pn.test(T), lt = b.style;
      return z = z || Qi(b), z && (K = z.getPropertyValue(T) || z[T], ut && K && (K = K.replace(kt, "$1") || void 0), K === "" && !Te(b) && (K = S.style(b, T)), !E.pixelBoxStyles() && fn.test(K) && er.test(T) && (W = lt.width, U = lt.minWidth, X = lt.maxWidth, lt.minWidth = lt.maxWidth = lt.width = K, K = z.width, lt.width = W, lt.minWidth = U, lt.maxWidth = X)), K !== void 0 ? (
        // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        K + ""
      ) : K;
    }
    function Se(b, T) {
      return {
        get: function() {
          if (b()) {
            delete this.get;
            return;
          }
          return (this.get = T).apply(this, arguments);
        }
      };
    }
    var je = ["Webkit", "Moz", "ms"], qn = F.createElement("div").style, ji = {};
    function qi(b) {
      for (var T = b[0].toUpperCase() + b.slice(1), z = je.length; z--; )
        if (b = je[z] + T, b in qn)
          return b;
    }
    function Gi(b) {
      var T = S.cssProps[b] || ji[b];
      return T || (b in qn ? b : ji[b] = qi(b) || b);
    }
    var vn = /^(none|table(?!-c[ea]).+)/, _r = { position: "absolute", visibility: "hidden", display: "block" }, ir = {
      letterSpacing: "0",
      fontWeight: "400"
    };
    function $i(b, T, z) {
      var W = Ut.exec(T);
      return W ? (
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, W[2] - (z || 0)) + (W[3] || "px")
      ) : T;
    }
    function Me(b, T, z, W, U, X) {
      var K = T === "width" ? 1 : 0, ut = 0, lt = 0, _t = 0;
      if (z === (W ? "border" : "content"))
        return 0;
      for (; K < 4; K += 2)
        z === "margin" && (_t += S.css(b, z + ve[K], !0, U)), W ? (z === "content" && (lt -= S.css(b, "padding" + ve[K], !0, U)), z !== "margin" && (lt -= S.css(b, "border" + ve[K] + "Width", !0, U))) : (lt += S.css(b, "padding" + ve[K], !0, U), z !== "padding" ? lt += S.css(b, "border" + ve[K] + "Width", !0, U) : ut += S.css(b, "border" + ve[K] + "Width", !0, U));
      return !W && X >= 0 && (lt += Math.max(0, Math.ceil(
        b["offset" + T[0].toUpperCase() + T.slice(1)] - X - lt - ut - 0.5
        // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
        // Use an explicit zero to avoid NaN (gh-3964)
      )) || 0), lt + _t;
    }
    function ke(b, T, z) {
      var W = Qi(b), U = !E.boxSizingReliable() || z, X = U && S.css(b, "boxSizing", !1, W) === "border-box", K = X, ut = ti(b, T, W), lt = "offset" + T[0].toUpperCase() + T.slice(1);
      if (fn.test(ut)) {
        if (!z)
          return ut;
        ut = "auto";
      }
      return (!E.boxSizingReliable() && X || // Support: IE 10 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Interestingly, in some cases IE 9 doesn't suffer from this issue.
      !E.reliableTrDimensions() && nt(b, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
      // This happens for inline elements with no explicit setting (gh-3571)
      ut === "auto" || // Support: Android <=4.1 - 4.3 only
      // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
      !parseFloat(ut) && S.css(b, "display", !1, W) === "inline") && // Make sure the element is visible & connected
      b.getClientRects().length && (X = S.css(b, "boxSizing", !1, W) === "border-box", K = lt in b, K && (ut = b[lt])), ut = parseFloat(ut) || 0, ut + Me(
        b,
        T,
        z || (X ? "border" : "content"),
        K,
        W,
        // Provide the current computed size to request scroll gutter calculation (gh-3589)
        ut
      ) + "px";
    }
    S.extend({
      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
        opacity: {
          get: function(b, T) {
            if (T) {
              var z = ti(b, "opacity");
              return z === "" ? "1" : z;
            }
          }
        }
      },
      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageSlice: !0,
        columnCount: !0,
        flexGrow: !0,
        flexShrink: !0,
        fontWeight: !0,
        gridArea: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnStart: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowStart: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        scale: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        // SVG-related
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0
      },
      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {},
      // Get and set the style property on a DOM Node
      style: function(b, T, z, W) {
        if (!(!b || b.nodeType === 3 || b.nodeType === 8 || !b.style)) {
          var U, X, K, ut = fe(T), lt = pn.test(T), _t = b.style;
          if (lt || (T = Gi(ut)), K = S.cssHooks[T] || S.cssHooks[ut], z !== void 0) {
            if (X = typeof z, X === "string" && (U = Ut.exec(z)) && U[1] && (z = Ke(b, T, U), X = "number"), z == null || z !== z)
              return;
            X === "number" && !lt && (z += U && U[3] || (S.cssNumber[ut] ? "" : "px")), !E.clearCloneStyle && z === "" && T.indexOf("background") === 0 && (_t[T] = "inherit"), (!K || !("set" in K) || (z = K.set(b, z, W)) !== void 0) && (lt ? _t.setProperty(T, z) : _t[T] = z);
          } else
            return K && "get" in K && (U = K.get(b, !1, W)) !== void 0 ? U : _t[T];
        }
      },
      css: function(b, T, z, W) {
        var U, X, K, ut = fe(T), lt = pn.test(T);
        return lt || (T = Gi(ut)), K = S.cssHooks[T] || S.cssHooks[ut], K && "get" in K && (U = K.get(b, !0, z)), U === void 0 && (U = ti(b, T, W)), U === "normal" && T in ir && (U = ir[T]), z === "" || z ? (X = parseFloat(U), z === !0 || isFinite(X) ? X || 0 : U) : U;
      }
    }), S.each(["height", "width"], function(b, T) {
      S.cssHooks[T] = {
        get: function(z, W, U) {
          if (W)
            return vn.test(S.css(z, "display")) && // Support: Safari 8+
            // Table columns in Safari have non-zero offsetWidth & zero
            // getBoundingClientRect().width unless display is changed.
            // Support: IE <=11 only
            // Running getBoundingClientRect on a disconnected node
            // in IE throws an error.
            (!z.getClientRects().length || !z.getBoundingClientRect().width) ? gn(z, _r, function() {
              return ke(z, T, U);
            }) : ke(z, T, U);
        },
        set: function(z, W, U) {
          var X, K = Qi(z), ut = !E.scrollboxSize() && K.position === "absolute", lt = ut || U, _t = lt && S.css(z, "boxSizing", !1, K) === "border-box", Lt = U ? Me(
            z,
            T,
            U,
            _t,
            K
          ) : 0;
          return _t && ut && (Lt -= Math.ceil(
            z["offset" + T[0].toUpperCase() + T.slice(1)] - parseFloat(K[T]) - Me(z, T, "border", !1, K) - 0.5
          )), Lt && (X = Ut.exec(W)) && (X[3] || "px") !== "px" && (z.style[T] = W, W = S.css(z, T)), $i(z, W, Lt);
        }
      };
    }), S.cssHooks.marginLeft = Se(
      E.reliableMarginLeft,
      function(b, T) {
        if (T)
          return (parseFloat(ti(b, "marginLeft")) || b.getBoundingClientRect().left - gn(b, { marginLeft: 0 }, function() {
            return b.getBoundingClientRect().left;
          })) + "px";
      }
    ), S.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function(b, T) {
      S.cssHooks[b + T] = {
        expand: function(z) {
          for (var W = 0, U = {}, X = typeof z == "string" ? z.split(" ") : [z]; W < 4; W++)
            U[b + ve[W] + T] = X[W] || X[W - 2] || X[0];
          return U;
        }
      }, b !== "margin" && (S.cssHooks[b + T].set = $i);
    }), S.fn.extend({
      css: function(b, T) {
        return he(this, function(z, W, U) {
          var X, K, ut = {}, lt = 0;
          if (Array.isArray(W)) {
            for (X = Qi(z), K = W.length; lt < K; lt++)
              ut[W[lt]] = S.css(z, W[lt], !1, X);
            return ut;
          }
          return U !== void 0 ? S.style(z, W, U) : S.css(z, W);
        }, b, T, arguments.length > 1);
      }
    });
    function qe(b, T, z, W, U) {
      return new qe.prototype.init(b, T, z, W, U);
    }
    S.Tween = qe, qe.prototype = {
      constructor: qe,
      init: function(b, T, z, W, U, X) {
        this.elem = b, this.prop = z, this.easing = U || S.easing._default, this.options = T, this.start = this.now = this.cur(), this.end = W, this.unit = X || (S.cssNumber[z] ? "" : "px");
      },
      cur: function() {
        var b = qe.propHooks[this.prop];
        return b && b.get ? b.get(this) : qe.propHooks._default.get(this);
      },
      run: function(b) {
        var T, z = qe.propHooks[this.prop];
        return this.options.duration ? this.pos = T = S.easing[this.easing](
          b,
          this.options.duration * b,
          0,
          1,
          this.options.duration
        ) : this.pos = T = b, this.now = (this.end - this.start) * T + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), z && z.set ? z.set(this) : qe.propHooks._default.set(this), this;
      }
    }, qe.prototype.init.prototype = qe.prototype, qe.propHooks = {
      _default: {
        get: function(b) {
          var T;
          return b.elem.nodeType !== 1 || b.elem[b.prop] != null && b.elem.style[b.prop] == null ? b.elem[b.prop] : (T = S.css(b.elem, b.prop, ""), !T || T === "auto" ? 0 : T);
        },
        set: function(b) {
          S.fx.step[b.prop] ? S.fx.step[b.prop](b) : b.elem.nodeType === 1 && (S.cssHooks[b.prop] || b.elem.style[Gi(b.prop)] != null) ? S.style(b.elem, b.prop, b.now + b.unit) : b.elem[b.prop] = b.now;
        }
      }
    }, qe.propHooks.scrollTop = qe.propHooks.scrollLeft = {
      set: function(b) {
        b.elem.nodeType && b.elem.parentNode && (b.elem[b.prop] = b.now);
      }
    }, S.easing = {
      linear: function(b) {
        return b;
      },
      swing: function(b) {
        return 0.5 - Math.cos(b * Math.PI) / 2;
      },
      _default: "swing"
    }, S.fx = qe.prototype.init, S.fx.step = {};
    var ci, Li, nr = /^(?:toggle|show|hide)$/, pe = /queueHooks$/;
    function Ne() {
      Li && (F.hidden === !1 && n.requestAnimationFrame ? n.requestAnimationFrame(Ne) : n.setTimeout(Ne, S.fx.interval), S.fx.tick());
    }
    function Gn() {
      return n.setTimeout(function() {
        ci = void 0;
      }), ci = Date.now();
    }
    function Ui(b, T) {
      var z, W = 0, U = { height: b };
      for (T = T ? 1 : 0; W < 4; W += 2 - T)
        z = ve[W], U["margin" + z] = U["padding" + z] = b;
      return T && (U.opacity = U.width = b), U;
    }
    function ni(b, T, z) {
      for (var W, U = (Ge.tweeners[T] || []).concat(Ge.tweeners["*"]), X = 0, K = U.length; X < K; X++)
        if (W = U[X].call(z, T, b))
          return W;
    }
    function Ar(b, T, z) {
      var W, U, X, K, ut, lt, _t, Lt, Bt = "width" in T || "height" in T, Pt = this, Vt = {}, se = b.style, De = b.nodeType && Le(b), ge = mt.get(b, "fxshow");
      z.queue || (K = S._queueHooks(b, "fx"), K.unqueued == null && (K.unqueued = 0, ut = K.empty.fire, K.empty.fire = function() {
        K.unqueued || ut();
      }), K.unqueued++, Pt.always(function() {
        Pt.always(function() {
          K.unqueued--, S.queue(b, "fx").length || K.empty.fire();
        });
      }));
      for (W in T)
        if (U = T[W], nr.test(U)) {
          if (delete T[W], X = X || U === "toggle", U === (De ? "hide" : "show"))
            if (U === "show" && ge && ge[W] !== void 0)
              De = !0;
            else
              continue;
          Vt[W] = ge && ge[W] || S.style(b, W);
        }
      if (lt = !S.isEmptyObject(T), !(!lt && S.isEmptyObject(Vt))) {
        Bt && b.nodeType === 1 && (z.overflow = [se.overflow, se.overflowX, se.overflowY], _t = ge && ge.display, _t == null && (_t = mt.get(b, "display")), Lt = S.css(b, "display"), Lt === "none" && (_t ? Lt = _t : (ai([b], !0), _t = b.style.display || _t, Lt = S.css(b, "display"), ai([b]))), (Lt === "inline" || Lt === "inline-block" && _t != null) && S.css(b, "float") === "none" && (lt || (Pt.done(function() {
          se.display = _t;
        }), _t == null && (Lt = se.display, _t = Lt === "none" ? "" : Lt)), se.display = "inline-block")), z.overflow && (se.overflow = "hidden", Pt.always(function() {
          se.overflow = z.overflow[0], se.overflowX = z.overflow[1], se.overflowY = z.overflow[2];
        })), lt = !1;
        for (W in Vt)
          lt || (ge ? "hidden" in ge && (De = ge.hidden) : ge = mt.access(b, "fxshow", { display: _t }), X && (ge.hidden = !De), De && ai([b], !0), Pt.done(function() {
            De || ai([b]), mt.remove(b, "fxshow");
            for (W in Vt)
              S.style(b, W, Vt[W]);
          })), lt = ni(De ? ge[W] : 0, W, Pt), W in ge || (ge[W] = lt.start, De && (lt.end = lt.start, lt.start = 0));
      }
    }
    function Un(b, T) {
      var z, W, U, X, K;
      for (z in b)
        if (W = fe(z), U = T[W], X = b[z], Array.isArray(X) && (U = X[1], X = b[z] = X[0]), z !== W && (b[W] = X, delete b[z]), K = S.cssHooks[W], K && "expand" in K) {
          X = K.expand(X), delete b[W];
          for (z in X)
            z in b || (b[z] = X[z], T[z] = U);
        } else
          T[W] = U;
    }
    function Ge(b, T, z) {
      var W, U, X = 0, K = Ge.prefilters.length, ut = S.Deferred().always(function() {
        delete lt.elem;
      }), lt = function() {
        if (U)
          return !1;
        for (var Bt = ci || Gn(), Pt = Math.max(0, _t.startTime + _t.duration - Bt), Vt = Pt / _t.duration || 0, se = 1 - Vt, De = 0, ge = _t.tweens.length; De < ge; De++)
          _t.tweens[De].run(se);
        return ut.notifyWith(b, [_t, se, Pt]), se < 1 && ge ? Pt : (ge || ut.notifyWith(b, [_t, 1, 0]), ut.resolveWith(b, [_t]), !1);
      }, _t = ut.promise({
        elem: b,
        props: S.extend({}, T),
        opts: S.extend(!0, {
          specialEasing: {},
          easing: S.easing._default
        }, z),
        originalProperties: T,
        originalOptions: z,
        startTime: ci || Gn(),
        duration: z.duration,
        tweens: [],
        createTween: function(Bt, Pt) {
          var Vt = S.Tween(
            b,
            _t.opts,
            Bt,
            Pt,
            _t.opts.specialEasing[Bt] || _t.opts.easing
          );
          return _t.tweens.push(Vt), Vt;
        },
        stop: function(Bt) {
          var Pt = 0, Vt = Bt ? _t.tweens.length : 0;
          if (U)
            return this;
          for (U = !0; Pt < Vt; Pt++)
            _t.tweens[Pt].run(1);
          return Bt ? (ut.notifyWith(b, [_t, 1, 0]), ut.resolveWith(b, [_t, Bt])) : ut.rejectWith(b, [_t, Bt]), this;
        }
      }), Lt = _t.props;
      for (Un(Lt, _t.opts.specialEasing); X < K; X++)
        if (W = Ge.prefilters[X].call(_t, b, Lt, _t.opts), W)
          return x(W.stop) && (S._queueHooks(_t.elem, _t.opts.queue).stop = W.stop.bind(W)), W;
      return S.map(Lt, ni, _t), x(_t.opts.start) && _t.opts.start.call(b, _t), _t.progress(_t.opts.progress).done(_t.opts.done, _t.opts.complete).fail(_t.opts.fail).always(_t.opts.always), S.fx.timer(
        S.extend(lt, {
          elem: b,
          anim: _t,
          queue: _t.opts.queue
        })
      ), _t;
    }
    S.Animation = S.extend(Ge, {
      tweeners: {
        "*": [function(b, T) {
          var z = this.createTween(b, T);
          return Ke(z.elem, b, Ut.exec(T), z), z;
        }]
      },
      tweener: function(b, T) {
        x(b) ? (T = b, b = ["*"]) : b = b.match(at);
        for (var z, W = 0, U = b.length; W < U; W++)
          z = b[W], Ge.tweeners[z] = Ge.tweeners[z] || [], Ge.tweeners[z].unshift(T);
      },
      prefilters: [Ar],
      prefilter: function(b, T) {
        T ? Ge.prefilters.unshift(b) : Ge.prefilters.push(b);
      }
    }), S.speed = function(b, T, z) {
      var W = b && typeof b == "object" ? S.extend({}, b) : {
        complete: z || !z && T || x(b) && b,
        duration: b,
        easing: z && T || T && !x(T) && T
      };
      return S.fx.off ? W.duration = 0 : typeof W.duration != "number" && (W.duration in S.fx.speeds ? W.duration = S.fx.speeds[W.duration] : W.duration = S.fx.speeds._default), (W.queue == null || W.queue === !0) && (W.queue = "fx"), W.old = W.complete, W.complete = function() {
        x(W.old) && W.old.call(this), W.queue && S.dequeue(this, W.queue);
      }, W;
    }, S.fn.extend({
      fadeTo: function(b, T, z, W) {
        return this.filter(Le).css("opacity", 0).show().end().animate({ opacity: T }, b, z, W);
      },
      animate: function(b, T, z, W) {
        var U = S.isEmptyObject(b), X = S.speed(T, z, W), K = function() {
          var ut = Ge(this, S.extend({}, b), X);
          (U || mt.get(this, "finish")) && ut.stop(!0);
        };
        return K.finish = K, U || X.queue === !1 ? this.each(K) : this.queue(X.queue, K);
      },
      stop: function(b, T, z) {
        var W = function(U) {
          var X = U.stop;
          delete U.stop, X(z);
        };
        return typeof b != "string" && (z = T, T = b, b = void 0), T && this.queue(b || "fx", []), this.each(function() {
          var U = !0, X = b != null && b + "queueHooks", K = S.timers, ut = mt.get(this);
          if (X)
            ut[X] && ut[X].stop && W(ut[X]);
          else
            for (X in ut)
              ut[X] && ut[X].stop && pe.test(X) && W(ut[X]);
          for (X = K.length; X--; )
            K[X].elem === this && (b == null || K[X].queue === b) && (K[X].anim.stop(z), U = !1, K.splice(X, 1));
          (U || !z) && S.dequeue(this, b);
        });
      },
      finish: function(b) {
        return b !== !1 && (b = b || "fx"), this.each(function() {
          var T, z = mt.get(this), W = z[b + "queue"], U = z[b + "queueHooks"], X = S.timers, K = W ? W.length : 0;
          for (z.finish = !0, S.queue(this, b, []), U && U.stop && U.stop.call(this, !0), T = X.length; T--; )
            X[T].elem === this && X[T].queue === b && (X[T].anim.stop(!0), X.splice(T, 1));
          for (T = 0; T < K; T++)
            W[T] && W[T].finish && W[T].finish.call(this);
          delete z.finish;
        });
      }
    }), S.each(["toggle", "show", "hide"], function(b, T) {
      var z = S.fn[T];
      S.fn[T] = function(W, U, X) {
        return W == null || typeof W == "boolean" ? z.apply(this, arguments) : this.animate(Ui(T, !0), W, U, X);
      };
    }), S.each({
      slideDown: Ui("show"),
      slideUp: Ui("hide"),
      slideToggle: Ui("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" }
    }, function(b, T) {
      S.fn[b] = function(z, W, U) {
        return this.animate(T, z, W, U);
      };
    }), S.timers = [], S.fx.tick = function() {
      var b, T = 0, z = S.timers;
      for (ci = Date.now(); T < z.length; T++)
        b = z[T], !b() && z[T] === b && z.splice(T--, 1);
      z.length || S.fx.stop(), ci = void 0;
    }, S.fx.timer = function(b) {
      S.timers.push(b), S.fx.start();
    }, S.fx.interval = 13, S.fx.start = function() {
      Li || (Li = !0, Ne());
    }, S.fx.stop = function() {
      Li = null;
    }, S.fx.speeds = {
      slow: 600,
      fast: 200,
      // Default speed
      _default: 400
    }, S.fn.delay = function(b, T) {
      return b = S.fx && S.fx.speeds[b] || b, T = T || "fx", this.queue(T, function(z, W) {
        var U = n.setTimeout(z, b);
        W.stop = function() {
          n.clearTimeout(U);
        };
      });
    }, function() {
      var b = F.createElement("input"), T = F.createElement("select"), z = T.appendChild(F.createElement("option"));
      b.type = "checkbox", E.checkOn = b.value !== "", E.optSelected = z.selected, b = F.createElement("input"), b.value = "t", b.type = "radio", E.radioValue = b.value === "t";
    }();
    var Ie, fi = S.expr.attrHandle;
    S.fn.extend({
      attr: function(b, T) {
        return he(this, S.attr, b, T, arguments.length > 1);
      },
      removeAttr: function(b) {
        return this.each(function() {
          S.removeAttr(this, b);
        });
      }
    }), S.extend({
      attr: function(b, T, z) {
        var W, U, X = b.nodeType;
        if (!(X === 3 || X === 8 || X === 2)) {
          if (typeof b.getAttribute > "u")
            return S.prop(b, T, z);
          if ((X !== 1 || !S.isXMLDoc(b)) && (U = S.attrHooks[T.toLowerCase()] || (S.expr.match.bool.test(T) ? Ie : void 0)), z !== void 0) {
            if (z === null) {
              S.removeAttr(b, T);
              return;
            }
            return U && "set" in U && (W = U.set(b, z, T)) !== void 0 ? W : (b.setAttribute(T, z + ""), z);
          }
          return U && "get" in U && (W = U.get(b, T)) !== null ? W : (W = S.find.attr(b, T), W ?? void 0);
        }
      },
      attrHooks: {
        type: {
          set: function(b, T) {
            if (!E.radioValue && T === "radio" && nt(b, "input")) {
              var z = b.value;
              return b.setAttribute("type", T), z && (b.value = z), T;
            }
          }
        }
      },
      removeAttr: function(b, T) {
        var z, W = 0, U = T && T.match(at);
        if (U && b.nodeType === 1)
          for (; z = U[W++]; )
            b.removeAttribute(z);
      }
    }), Ie = {
      set: function(b, T, z) {
        return T === !1 ? S.removeAttr(b, z) : b.setAttribute(z, z), z;
      }
    }, S.each(S.expr.match.bool.source.match(/\w+/g), function(b, T) {
      var z = fi[T] || S.find.attr;
      fi[T] = function(W, U, X) {
        var K, ut, lt = U.toLowerCase();
        return X || (ut = fi[lt], fi[lt] = K, K = z(W, U, X) != null ? lt : null, fi[lt] = ut), K;
      };
    });
    var mn = /^(?:input|select|textarea|button)$/i, _n = /^(?:a|area)$/i;
    S.fn.extend({
      prop: function(b, T) {
        return he(this, S.prop, b, T, arguments.length > 1);
      },
      removeProp: function(b) {
        return this.each(function() {
          delete this[S.propFix[b] || b];
        });
      }
    }), S.extend({
      prop: function(b, T, z) {
        var W, U, X = b.nodeType;
        if (!(X === 3 || X === 8 || X === 2))
          return (X !== 1 || !S.isXMLDoc(b)) && (T = S.propFix[T] || T, U = S.propHooks[T]), z !== void 0 ? U && "set" in U && (W = U.set(b, z, T)) !== void 0 ? W : b[T] = z : U && "get" in U && (W = U.get(b, T)) !== null ? W : b[T];
      },
      propHooks: {
        tabIndex: {
          get: function(b) {
            var T = S.find.attr(b, "tabindex");
            return T ? parseInt(T, 10) : mn.test(b.nodeName) || _n.test(b.nodeName) && b.href ? 0 : -1;
          }
        }
      },
      propFix: {
        for: "htmlFor",
        class: "className"
      }
    }), E.optSelected || (S.propHooks.selected = {
      get: function(b) {
        var T = b.parentNode;
        return T && T.parentNode && T.parentNode.selectedIndex, null;
      },
      set: function(b) {
        var T = b.parentNode;
        T && (T.selectedIndex, T.parentNode && T.parentNode.selectedIndex);
      }
    }), S.each([
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable"
    ], function() {
      S.propFix[this.toLowerCase()] = this;
    });
    function ki(b) {
      var T = b.match(at) || [];
      return T.join(" ");
    }
    function pi(b) {
      return b.getAttribute && b.getAttribute("class") || "";
    }
    function yn(b) {
      return Array.isArray(b) ? b : typeof b == "string" ? b.match(at) || [] : [];
    }
    S.fn.extend({
      addClass: function(b) {
        var T, z, W, U, X, K;
        return x(b) ? this.each(function(ut) {
          S(this).addClass(b.call(this, ut, pi(this)));
        }) : (T = yn(b), T.length ? this.each(function() {
          if (W = pi(this), z = this.nodeType === 1 && " " + ki(W) + " ", z) {
            for (X = 0; X < T.length; X++)
              U = T[X], z.indexOf(" " + U + " ") < 0 && (z += U + " ");
            K = ki(z), W !== K && this.setAttribute("class", K);
          }
        }) : this);
      },
      removeClass: function(b) {
        var T, z, W, U, X, K;
        return x(b) ? this.each(function(ut) {
          S(this).removeClass(b.call(this, ut, pi(this)));
        }) : arguments.length ? (T = yn(b), T.length ? this.each(function() {
          if (W = pi(this), z = this.nodeType === 1 && " " + ki(W) + " ", z) {
            for (X = 0; X < T.length; X++)
              for (U = T[X]; z.indexOf(" " + U + " ") > -1; )
                z = z.replace(" " + U + " ", " ");
            K = ki(z), W !== K && this.setAttribute("class", K);
          }
        }) : this) : this.attr("class", "");
      },
      toggleClass: function(b, T) {
        var z, W, U, X, K = typeof b, ut = K === "string" || Array.isArray(b);
        return x(b) ? this.each(function(lt) {
          S(this).toggleClass(
            b.call(this, lt, pi(this), T),
            T
          );
        }) : typeof T == "boolean" && ut ? T ? this.addClass(b) : this.removeClass(b) : (z = yn(b), this.each(function() {
          if (ut)
            for (X = S(this), U = 0; U < z.length; U++)
              W = z[U], X.hasClass(W) ? X.removeClass(W) : X.addClass(W);
          else
            (b === void 0 || K === "boolean") && (W = pi(this), W && mt.set(this, "__className__", W), this.setAttribute && this.setAttribute(
              "class",
              W || b === !1 ? "" : mt.get(this, "__className__") || ""
            ));
        }));
      },
      hasClass: function(b) {
        var T, z, W = 0;
        for (T = " " + b + " "; z = this[W++]; )
          if (z.nodeType === 1 && (" " + ki(pi(z)) + " ").indexOf(T) > -1)
            return !0;
        return !1;
      }
    });
    var rr = /\r/g;
    S.fn.extend({
      val: function(b) {
        var T, z, W, U = this[0];
        return arguments.length ? (W = x(b), this.each(function(X) {
          var K;
          this.nodeType === 1 && (W ? K = b.call(this, X, S(this).val()) : K = b, K == null ? K = "" : typeof K == "number" ? K += "" : Array.isArray(K) && (K = S.map(K, function(ut) {
            return ut == null ? "" : ut + "";
          })), T = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()], (!T || !("set" in T) || T.set(this, K, "value") === void 0) && (this.value = K));
        })) : U ? (T = S.valHooks[U.type] || S.valHooks[U.nodeName.toLowerCase()], T && "get" in T && (z = T.get(U, "value")) !== void 0 ? z : (z = U.value, typeof z == "string" ? z.replace(rr, "") : z ?? "")) : void 0;
      }
    }), S.extend({
      valHooks: {
        option: {
          get: function(b) {
            var T = S.find.attr(b, "value");
            return T ?? // Support: IE <=10 - 11 only
            // option.text throws exceptions (trac-14686, trac-14858)
            // Strip and collapse whitespace
            // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
            ki(S.text(b));
          }
        },
        select: {
          get: function(b) {
            var T, z, W, U = b.options, X = b.selectedIndex, K = b.type === "select-one", ut = K ? null : [], lt = K ? X + 1 : U.length;
            for (X < 0 ? W = lt : W = K ? X : 0; W < lt; W++)
              if (z = U[W], (z.selected || W === X) && // Don't return options that are disabled or in a disabled optgroup
              !z.disabled && (!z.parentNode.disabled || !nt(z.parentNode, "optgroup"))) {
                if (T = S(z).val(), K)
                  return T;
                ut.push(T);
              }
            return ut;
          },
          set: function(b, T) {
            for (var z, W, U = b.options, X = S.makeArray(T), K = U.length; K--; )
              W = U[K], (W.selected = S.inArray(S.valHooks.option.get(W), X) > -1) && (z = !0);
            return z || (b.selectedIndex = -1), X;
          }
        }
      }
    }), S.each(["radio", "checkbox"], function() {
      S.valHooks[this] = {
        set: function(b, T) {
          if (Array.isArray(T))
            return b.checked = S.inArray(S(b).val(), T) > -1;
        }
      }, E.checkOn || (S.valHooks[this].get = function(b) {
        return b.getAttribute("value") === null ? "on" : b.value;
      });
    });
    var Wi = n.location, Vn = { guid: Date.now() }, bn = /\?/;
    S.parseXML = function(b) {
      var T, z;
      if (!b || typeof b != "string")
        return null;
      try {
        T = new n.DOMParser().parseFromString(b, "text/xml");
      } catch {
      }
      return z = T && T.getElementsByTagName("parsererror")[0], (!T || z) && S.error("Invalid XML: " + (z ? S.map(z.childNodes, function(W) {
        return W.textContent;
      }).join(`
`) : b)), T;
    };
    var xn = /^(?:focusinfocus|focusoutblur)$/, ar = function(b) {
      b.stopPropagation();
    };
    S.extend(S.event, {
      trigger: function(b, T, z, W) {
        var U, X, K, ut, lt, _t, Lt, Bt, Pt = [z || F], Vt = g.call(b, "type") ? b.type : b, se = g.call(b, "namespace") ? b.namespace.split(".") : [];
        if (X = Bt = K = z = z || F, !(z.nodeType === 3 || z.nodeType === 8) && !xn.test(Vt + S.event.triggered) && (Vt.indexOf(".") > -1 && (se = Vt.split("."), Vt = se.shift(), se.sort()), lt = Vt.indexOf(":") < 0 && "on" + Vt, b = b[S.expando] ? b : new S.Event(Vt, typeof b == "object" && b), b.isTrigger = W ? 2 : 3, b.namespace = se.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\.)" + se.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = z), T = T == null ? [b] : S.makeArray(T, [b]), Lt = S.event.special[Vt] || {}, !(!W && Lt.trigger && Lt.trigger.apply(z, T) === !1))) {
          if (!W && !Lt.noBubble && !D(z)) {
            for (ut = Lt.delegateType || Vt, xn.test(ut + Vt) || (X = X.parentNode); X; X = X.parentNode)
              Pt.push(X), K = X;
            K === (z.ownerDocument || F) && Pt.push(K.defaultView || K.parentWindow || n);
          }
          for (U = 0; (X = Pt[U++]) && !b.isPropagationStopped(); )
            Bt = X, b.type = U > 1 ? ut : Lt.bindType || Vt, _t = (mt.get(X, "events") || /* @__PURE__ */ Object.create(null))[b.type] && mt.get(X, "handle"), _t && _t.apply(X, T), _t = lt && X[lt], _t && _t.apply && st(X) && (b.result = _t.apply(X, T), b.result === !1 && b.preventDefault());
          return b.type = Vt, !W && !b.isDefaultPrevented() && (!Lt._default || Lt._default.apply(Pt.pop(), T) === !1) && st(z) && lt && x(z[Vt]) && !D(z) && (K = z[lt], K && (z[lt] = null), S.event.triggered = Vt, b.isPropagationStopped() && Bt.addEventListener(Vt, ar), z[Vt](), b.isPropagationStopped() && Bt.removeEventListener(Vt, ar), S.event.triggered = void 0, K && (z[lt] = K)), b.result;
        }
      },
      // Piggyback on a donor event to simulate a different one
      // Used only for `focus(in | out)` events
      simulate: function(b, T, z) {
        var W = S.extend(
          new S.Event(),
          z,
          {
            type: b,
            isSimulated: !0
          }
        );
        S.event.trigger(W, null, T);
      }
    }), S.fn.extend({
      trigger: function(b, T) {
        return this.each(function() {
          S.event.trigger(b, T, this);
        });
      },
      triggerHandler: function(b, T) {
        var z = this[0];
        if (z)
          return S.event.trigger(b, T, z, !0);
      }
    });
    var or = /\[\]$/, yr = /\r?\n/g, de = /^(?:submit|button|image|reset|file)$/i, xi = /^(?:input|select|textarea|keygen)/i;
    function Fe(b, T, z, W) {
      var U;
      if (Array.isArray(T))
        S.each(T, function(X, K) {
          z || or.test(b) ? W(b, K) : Fe(
            b + "[" + (typeof K == "object" && K != null ? X : "") + "]",
            K,
            z,
            W
          );
        });
      else if (!z && H(T) === "object")
        for (U in T)
          Fe(b + "[" + U + "]", T[U], z, W);
      else
        W(b, T);
    }
    S.param = function(b, T) {
      var z, W = [], U = function(X, K) {
        var ut = x(K) ? K() : K;
        W[W.length] = encodeURIComponent(X) + "=" + encodeURIComponent(ut ?? "");
      };
      if (b == null)
        return "";
      if (Array.isArray(b) || b.jquery && !S.isPlainObject(b))
        S.each(b, function() {
          U(this.name, this.value);
        });
      else
        for (z in b)
          Fe(z, b[z], T, U);
      return W.join("&");
    }, S.fn.extend({
      serialize: function() {
        return S.param(this.serializeArray());
      },
      serializeArray: function() {
        return this.map(function() {
          var b = S.prop(this, "elements");
          return b ? S.makeArray(b) : this;
        }).filter(function() {
          var b = this.type;
          return this.name && !S(this).is(":disabled") && xi.test(this.nodeName) && !de.test(b) && (this.checked || !Bi.test(b));
        }).map(function(b, T) {
          var z = S(this).val();
          return z == null ? null : Array.isArray(z) ? S.map(z, function(W) {
            return { name: T.name, value: W.replace(yr, `\r
`) };
          }) : { name: T.name, value: z.replace(yr, `\r
`) };
        }).get();
      }
    });
    var br = /%20/g, sr = /#.*$/, lr = /([?&])_=[^&]*/, ur = /^(.*?):[ \t]*([^\r\n]*)$/mg, Vi = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, hr = /^(?:GET|HEAD)$/, wn = /^\/\//, He = {}, Ni = {}, dr = "*/".concat("*"), Zn = F.createElement("a");
    Zn.href = Wi.href;
    function xr(b) {
      return function(T, z) {
        typeof T != "string" && (z = T, T = "*");
        var W, U = 0, X = T.toLowerCase().match(at) || [];
        if (x(z))
          for (; W = X[U++]; )
            W[0] === "+" ? (W = W.slice(1) || "*", (b[W] = b[W] || []).unshift(z)) : (b[W] = b[W] || []).push(z);
      };
    }
    function cr(b, T, z, W) {
      var U = {}, X = b === Ni;
      function K(ut) {
        var lt;
        return U[ut] = !0, S.each(b[ut] || [], function(_t, Lt) {
          var Bt = Lt(T, z, W);
          if (typeof Bt == "string" && !X && !U[Bt])
            return T.dataTypes.unshift(Bt), K(Bt), !1;
          if (X)
            return !(lt = Bt);
        }), lt;
      }
      return K(T.dataTypes[0]) || !U["*"] && K("*");
    }
    function Cn(b, T) {
      var z, W, U = S.ajaxSettings.flatOptions || {};
      for (z in T)
        T[z] !== void 0 && ((U[z] ? b : W || (W = {}))[z] = T[z]);
      return W && S.extend(!0, b, W), b;
    }
    function Tr(b, T, z) {
      for (var W, U, X, K, ut = b.contents, lt = b.dataTypes; lt[0] === "*"; )
        lt.shift(), W === void 0 && (W = b.mimeType || T.getResponseHeader("Content-Type"));
      if (W) {
        for (U in ut)
          if (ut[U] && ut[U].test(W)) {
            lt.unshift(U);
            break;
          }
      }
      if (lt[0] in z)
        X = lt[0];
      else {
        for (U in z) {
          if (!lt[0] || b.converters[U + " " + lt[0]]) {
            X = U;
            break;
          }
          K || (K = U);
        }
        X = X || K;
      }
      if (X)
        return X !== lt[0] && lt.unshift(X), z[X];
    }
    function wr(b, T, z, W) {
      var U, X, K, ut, lt, _t = {}, Lt = b.dataTypes.slice();
      if (Lt[1])
        for (K in b.converters)
          _t[K.toLowerCase()] = b.converters[K];
      for (X = Lt.shift(); X; )
        if (b.responseFields[X] && (z[b.responseFields[X]] = T), !lt && W && b.dataFilter && (T = b.dataFilter(T, b.dataType)), lt = X, X = Lt.shift(), X) {
          if (X === "*")
            X = lt;
          else if (lt !== "*" && lt !== X) {
            if (K = _t[lt + " " + X] || _t["* " + X], !K) {
              for (U in _t)
                if (ut = U.split(" "), ut[1] === X && (K = _t[lt + " " + ut[0]] || _t["* " + ut[0]], K)) {
                  K === !0 ? K = _t[U] : _t[U] !== !0 && (X = ut[0], Lt.unshift(ut[1]));
                  break;
                }
            }
            if (K !== !0)
              if (K && b.throws)
                T = K(T);
              else
                try {
                  T = K(T);
                } catch (Bt) {
                  return {
                    state: "parsererror",
                    error: K ? Bt : "No conversion from " + lt + " to " + X
                  };
                }
          }
        }
      return { state: "success", data: T };
    }
    S.extend({
      // Counter for holding the number of active queries
      active: 0,
      // Last-Modified header cache for next request
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: Wi.href,
        type: "GET",
        isLocal: Vi.test(Wi.protocol),
        global: !0,
        processData: !0,
        async: !0,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */
        accepts: {
          "*": dr,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {
          // Convert anything to text
          "* text": String,
          // Text to html (true = no transformation)
          "text html": !0,
          // Evaluate text as a json expression
          "text json": JSON.parse,
          // Parse text as xml
          "text xml": S.parseXML
        },
        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
          url: !0,
          context: !0
        }
      },
      // Creates a full fledged settings object into target
      // with both ajaxSettings and settings fields.
      // If target is omitted, writes into ajaxSettings.
      ajaxSetup: function(b, T) {
        return T ? (
          // Building a settings object
          Cn(Cn(b, S.ajaxSettings), T)
        ) : (
          // Extending ajaxSettings
          Cn(S.ajaxSettings, b)
        );
      },
      ajaxPrefilter: xr(He),
      ajaxTransport: xr(Ni),
      // Main method
      ajax: function(b, T) {
        typeof b == "object" && (T = b, b = void 0), T = T || {};
        var z, W, U, X, K, ut, lt, _t, Lt, Bt, Pt = S.ajaxSetup({}, T), Vt = Pt.context || Pt, se = Pt.context && (Vt.nodeType || Vt.jquery) ? S(Vt) : S.event, De = S.Deferred(), ge = S.Callbacks("once memory"), Ue = Pt.statusCode || {}, Be = {}, wi = {}, gi = "canceled", ye = {
          readyState: 0,
          // Builds headers hashtable if needed
          getResponseHeader: function(me) {
            var Oe;
            if (lt) {
              if (!X)
                for (X = {}; Oe = ur.exec(U); )
                  X[Oe[1].toLowerCase() + " "] = (X[Oe[1].toLowerCase() + " "] || []).concat(Oe[2]);
              Oe = X[me.toLowerCase() + " "];
            }
            return Oe == null ? null : Oe.join(", ");
          },
          // Raw string
          getAllResponseHeaders: function() {
            return lt ? U : null;
          },
          // Caches the header
          setRequestHeader: function(me, Oe) {
            return lt == null && (me = wi[me.toLowerCase()] = wi[me.toLowerCase()] || me, Be[me] = Oe), this;
          },
          // Overrides response content-type header
          overrideMimeType: function(me) {
            return lt == null && (Pt.mimeType = me), this;
          },
          // Status-dependent callbacks
          statusCode: function(me) {
            var Oe;
            if (me)
              if (lt)
                ye.always(me[ye.status]);
              else
                for (Oe in me)
                  Ue[Oe] = [Ue[Oe], me[Oe]];
            return this;
          },
          // Cancel the request
          abort: function(me) {
            var Oe = me || gi;
            return z && z.abort(Oe), Ci(0, Oe), this;
          }
        };
        if (De.promise(ye), Pt.url = ((b || Pt.url || Wi.href) + "").replace(wn, Wi.protocol + "//"), Pt.type = T.method || T.type || Pt.method || Pt.type, Pt.dataTypes = (Pt.dataType || "*").toLowerCase().match(at) || [""], Pt.crossDomain == null) {
          ut = F.createElement("a");
          try {
            ut.href = Pt.url, ut.href = ut.href, Pt.crossDomain = Zn.protocol + "//" + Zn.host != ut.protocol + "//" + ut.host;
          } catch {
            Pt.crossDomain = !0;
          }
        }
        if (Pt.data && Pt.processData && typeof Pt.data != "string" && (Pt.data = S.param(Pt.data, Pt.traditional)), cr(He, Pt, T, ye), lt)
          return ye;
        _t = S.event && Pt.global, _t && S.active++ === 0 && S.event.trigger("ajaxStart"), Pt.type = Pt.type.toUpperCase(), Pt.hasContent = !hr.test(Pt.type), W = Pt.url.replace(sr, ""), Pt.hasContent ? Pt.data && Pt.processData && (Pt.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && (Pt.data = Pt.data.replace(br, "+")) : (Bt = Pt.url.slice(W.length), Pt.data && (Pt.processData || typeof Pt.data == "string") && (W += (bn.test(W) ? "&" : "?") + Pt.data, delete Pt.data), Pt.cache === !1 && (W = W.replace(lr, "$1"), Bt = (bn.test(W) ? "&" : "?") + "_=" + Vn.guid++ + Bt), Pt.url = W + Bt), Pt.ifModified && (S.lastModified[W] && ye.setRequestHeader("If-Modified-Since", S.lastModified[W]), S.etag[W] && ye.setRequestHeader("If-None-Match", S.etag[W])), (Pt.data && Pt.hasContent && Pt.contentType !== !1 || T.contentType) && ye.setRequestHeader("Content-Type", Pt.contentType), ye.setRequestHeader(
          "Accept",
          Pt.dataTypes[0] && Pt.accepts[Pt.dataTypes[0]] ? Pt.accepts[Pt.dataTypes[0]] + (Pt.dataTypes[0] !== "*" ? ", " + dr + "; q=0.01" : "") : Pt.accepts["*"]
        );
        for (Lt in Pt.headers)
          ye.setRequestHeader(Lt, Pt.headers[Lt]);
        if (Pt.beforeSend && (Pt.beforeSend.call(Vt, ye, Pt) === !1 || lt))
          return ye.abort();
        if (gi = "abort", ge.add(Pt.complete), ye.done(Pt.success), ye.fail(Pt.error), z = cr(Ni, Pt, T, ye), !z)
          Ci(-1, "No Transport");
        else {
          if (ye.readyState = 1, _t && se.trigger("ajaxSend", [ye, Pt]), lt)
            return ye;
          Pt.async && Pt.timeout > 0 && (K = n.setTimeout(function() {
            ye.abort("timeout");
          }, Pt.timeout));
          try {
            lt = !1, z.send(Be, Ci);
          } catch (me) {
            if (lt)
              throw me;
            Ci(-1, me);
          }
        }
        function Ci(me, Oe, Oi, ei) {
          var vi, tn, Di, Mi, Ei, si = Oe;
          lt || (lt = !0, K && n.clearTimeout(K), z = void 0, U = ei || "", ye.readyState = me > 0 ? 4 : 0, vi = me >= 200 && me < 300 || me === 304, Oi && (Mi = Tr(Pt, ye, Oi)), !vi && S.inArray("script", Pt.dataTypes) > -1 && S.inArray("json", Pt.dataTypes) < 0 && (Pt.converters["text script"] = function() {
          }), Mi = wr(Pt, Mi, ye, vi), vi ? (Pt.ifModified && (Ei = ye.getResponseHeader("Last-Modified"), Ei && (S.lastModified[W] = Ei), Ei = ye.getResponseHeader("etag"), Ei && (S.etag[W] = Ei)), me === 204 || Pt.type === "HEAD" ? si = "nocontent" : me === 304 ? si = "notmodified" : (si = Mi.state, tn = Mi.data, Di = Mi.error, vi = !Di)) : (Di = si, (me || !si) && (si = "error", me < 0 && (me = 0))), ye.status = me, ye.statusText = (Oe || si) + "", vi ? De.resolveWith(Vt, [tn, si, ye]) : De.rejectWith(Vt, [ye, si, Di]), ye.statusCode(Ue), Ue = void 0, _t && se.trigger(
            vi ? "ajaxSuccess" : "ajaxError",
            [ye, Pt, vi ? tn : Di]
          ), ge.fireWith(Vt, [ye, si]), _t && (se.trigger("ajaxComplete", [ye, Pt]), --S.active || S.event.trigger("ajaxStop")));
        }
        return ye;
      },
      getJSON: function(b, T, z) {
        return S.get(b, T, z, "json");
      },
      getScript: function(b, T) {
        return S.get(b, void 0, T, "script");
      }
    }), S.each(["get", "post"], function(b, T) {
      S[T] = function(z, W, U, X) {
        return x(W) && (X = X || U, U = W, W = void 0), S.ajax(S.extend({
          url: z,
          type: T,
          dataType: X,
          data: W,
          success: U
        }, S.isPlainObject(z) && z));
      };
    }), S.ajaxPrefilter(function(b) {
      var T;
      for (T in b.headers)
        T.toLowerCase() === "content-type" && (b.contentType = b.headers[T] || "");
    }), S._evalUrl = function(b, T, z) {
      return S.ajax({
        url: b,
        // Make this explicit, since user can override this through ajaxSetup (trac-11264)
        type: "GET",
        dataType: "script",
        cache: !0,
        async: !1,
        global: !1,
        // Only evaluate the response if it is successful (gh-4126)
        // dataFilter is not invoked for failure responses, so using it instead
        // of the default converter is kludgy but it works.
        converters: {
          "text script": function() {
          }
        },
        dataFilter: function(W) {
          S.globalEval(W, T, z);
        }
      });
    }, S.fn.extend({
      wrapAll: function(b) {
        var T;
        return this[0] && (x(b) && (b = b.call(this[0])), T = S(b, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && T.insertBefore(this[0]), T.map(function() {
          for (var z = this; z.firstElementChild; )
            z = z.firstElementChild;
          return z;
        }).append(this)), this;
      },
      wrapInner: function(b) {
        return x(b) ? this.each(function(T) {
          S(this).wrapInner(b.call(this, T));
        }) : this.each(function() {
          var T = S(this), z = T.contents();
          z.length ? z.wrapAll(b) : T.append(b);
        });
      },
      wrap: function(b) {
        var T = x(b);
        return this.each(function(z) {
          S(this).wrapAll(T ? b.call(this, z) : b);
        });
      },
      unwrap: function(b) {
        return this.parent(b).not("body").each(function() {
          S(this).replaceWith(this.childNodes);
        }), this;
      }
    }), S.expr.pseudos.hidden = function(b) {
      return !S.expr.pseudos.visible(b);
    }, S.expr.pseudos.visible = function(b) {
      return !!(b.offsetWidth || b.offsetHeight || b.getClientRects().length);
    }, S.ajaxSettings.xhr = function() {
      try {
        return new n.XMLHttpRequest();
      } catch {
      }
    };
    var Ee = {
      // File protocol always yields status code 0, assume 200
      0: 200,
      // Support: IE <=9 only
      // trac-1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    }, Dn = S.ajaxSettings.xhr();
    E.cors = !!Dn && "withCredentials" in Dn, E.ajax = Dn = !!Dn, S.ajaxTransport(function(b) {
      var T, z;
      if (E.cors || Dn && !b.crossDomain)
        return {
          send: function(W, U) {
            var X, K = b.xhr();
            if (K.open(
              b.type,
              b.url,
              b.async,
              b.username,
              b.password
            ), b.xhrFields)
              for (X in b.xhrFields)
                K[X] = b.xhrFields[X];
            b.mimeType && K.overrideMimeType && K.overrideMimeType(b.mimeType), !b.crossDomain && !W["X-Requested-With"] && (W["X-Requested-With"] = "XMLHttpRequest");
            for (X in W)
              K.setRequestHeader(X, W[X]);
            T = function(ut) {
              return function() {
                T && (T = z = K.onload = K.onerror = K.onabort = K.ontimeout = K.onreadystatechange = null, ut === "abort" ? K.abort() : ut === "error" ? typeof K.status != "number" ? U(0, "error") : U(
                  // File: protocol always yields status 0; see trac-8605, trac-14207
                  K.status,
                  K.statusText
                ) : U(
                  Ee[K.status] || K.status,
                  K.statusText,
                  // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  (K.responseType || "text") !== "text" || typeof K.responseText != "string" ? { binary: K.response } : { text: K.responseText },
                  K.getAllResponseHeaders()
                ));
              };
            }, K.onload = T(), z = K.onerror = K.ontimeout = T("error"), K.onabort !== void 0 ? K.onabort = z : K.onreadystatechange = function() {
              K.readyState === 4 && n.setTimeout(function() {
                T && z();
              });
            }, T = T("abort");
            try {
              K.send(b.hasContent && b.data || null);
            } catch (ut) {
              if (T)
                throw ut;
            }
          },
          abort: function() {
            T && T();
          }
        };
    }), S.ajaxPrefilter(function(b) {
      b.crossDomain && (b.contents.script = !1);
    }), S.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function(b) {
          return S.globalEval(b), b;
        }
      }
    }), S.ajaxPrefilter("script", function(b) {
      b.cache === void 0 && (b.cache = !1), b.crossDomain && (b.type = "GET");
    }), S.ajaxTransport("script", function(b) {
      if (b.crossDomain || b.scriptAttrs) {
        var T, z;
        return {
          send: function(W, U) {
            T = S("<script>").attr(b.scriptAttrs || {}).prop({ charset: b.scriptCharset, src: b.url }).on("load error", z = function(X) {
              T.remove(), z = null, X && U(X.type === "error" ? 404 : 200, X.type);
            }), F.head.appendChild(T[0]);
          },
          abort: function() {
            z && z();
          }
        };
      }
    });
    var oi = [], Zi = /(=)\?(?=&|$)|\?\?/;
    S.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function() {
        var b = oi.pop() || S.expando + "_" + Vn.guid++;
        return this[b] = !0, b;
      }
    }), S.ajaxPrefilter("json jsonp", function(b, T, z) {
      var W, U, X, K = b.jsonp !== !1 && (Zi.test(b.url) ? "url" : typeof b.data == "string" && (b.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && Zi.test(b.data) && "data");
      if (K || b.dataTypes[0] === "jsonp")
        return W = b.jsonpCallback = x(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, K ? b[K] = b[K].replace(Zi, "$1" + W) : b.jsonp !== !1 && (b.url += (bn.test(b.url) ? "&" : "?") + b.jsonp + "=" + W), b.converters["script json"] = function() {
          return X || S.error(W + " was not called"), X[0];
        }, b.dataTypes[0] = "json", U = n[W], n[W] = function() {
          X = arguments;
        }, z.always(function() {
          U === void 0 ? S(n).removeProp(W) : n[W] = U, b[W] && (b.jsonpCallback = T.jsonpCallback, oi.push(W)), X && x(U) && U(X[0]), X = U = void 0;
        }), "script";
    }), E.createHTMLDocument = function() {
      var b = F.implementation.createHTMLDocument("").body;
      return b.innerHTML = "<form></form><form></form>", b.childNodes.length === 2;
    }(), S.parseHTML = function(b, T, z) {
      if (typeof b != "string")
        return [];
      typeof T == "boolean" && (z = T, T = !1);
      var W, U, X;
      return T || (E.createHTMLDocument ? (T = F.implementation.createHTMLDocument(""), W = T.createElement("base"), W.href = F.location.href, T.head.appendChild(W)) : T = F), U = bt.exec(b), X = !z && [], U ? [T.createElement(U[1])] : (U = Ki([b], T, X), X && X.length && S(X).remove(), S.merge([], U.childNodes));
    }, S.fn.load = function(b, T, z) {
      var W, U, X, K = this, ut = b.indexOf(" ");
      return ut > -1 && (W = ki(b.slice(ut)), b = b.slice(0, ut)), x(T) ? (z = T, T = void 0) : T && typeof T == "object" && (U = "POST"), K.length > 0 && S.ajax({
        url: b,
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: U || "GET",
        dataType: "html",
        data: T
      }).done(function(lt) {
        X = arguments, K.html(W ? (
          // If a selector was specified, locate the right elements in a dummy div
          // Exclude scripts to avoid IE 'Permission Denied' errors
          S("<div>").append(S.parseHTML(lt)).find(W)
        ) : (
          // Otherwise use the full result
          lt
        ));
      }).always(z && function(lt, _t) {
        K.each(function() {
          z.apply(this, X || [lt.responseText, _t, lt]);
        });
      }), this;
    }, S.expr.pseudos.animated = function(b) {
      return S.grep(S.timers, function(T) {
        return b === T.elem;
      }).length;
    }, S.offset = {
      setOffset: function(b, T, z) {
        var W, U, X, K, ut, lt, _t, Lt = S.css(b, "position"), Bt = S(b), Pt = {};
        Lt === "static" && (b.style.position = "relative"), ut = Bt.offset(), X = S.css(b, "top"), lt = S.css(b, "left"), _t = (Lt === "absolute" || Lt === "fixed") && (X + lt).indexOf("auto") > -1, _t ? (W = Bt.position(), K = W.top, U = W.left) : (K = parseFloat(X) || 0, U = parseFloat(lt) || 0), x(T) && (T = T.call(b, z, S.extend({}, ut))), T.top != null && (Pt.top = T.top - ut.top + K), T.left != null && (Pt.left = T.left - ut.left + U), "using" in T ? T.using.call(b, Pt) : Bt.css(Pt);
      }
    }, S.fn.extend({
      // offset() relates an element's border box to the document origin
      offset: function(b) {
        if (arguments.length)
          return b === void 0 ? this : this.each(function(U) {
            S.offset.setOffset(this, b, U);
          });
        var T, z, W = this[0];
        if (W)
          return W.getClientRects().length ? (T = W.getBoundingClientRect(), z = W.ownerDocument.defaultView, {
            top: T.top + z.pageYOffset,
            left: T.left + z.pageXOffset
          }) : { top: 0, left: 0 };
      },
      // position() relates an element's margin box to its offset parent's padding box
      // This corresponds to the behavior of CSS absolute positioning
      position: function() {
        if (this[0]) {
          var b, T, z, W = this[0], U = { top: 0, left: 0 };
          if (S.css(W, "position") === "fixed")
            T = W.getBoundingClientRect();
          else {
            for (T = this.offset(), z = W.ownerDocument, b = W.offsetParent || z.documentElement; b && (b === z.body || b === z.documentElement) && S.css(b, "position") === "static"; )
              b = b.parentNode;
            b && b !== W && b.nodeType === 1 && (U = S(b).offset(), U.top += S.css(b, "borderTopWidth", !0), U.left += S.css(b, "borderLeftWidth", !0));
          }
          return {
            top: T.top - U.top - S.css(W, "marginTop", !0),
            left: T.left - U.left - S.css(W, "marginLeft", !0)
          };
        }
      },
      // This method will return documentElement in the following cases:
      // 1) For the element inside the iframe without offsetParent, this method will return
      //    documentElement of the parent window
      // 2) For the hidden or detached element
      // 3) For body or html element, i.e. in case of the html node - it will return itself
      //
      // but those exceptions were never presented as a real life use-cases
      // and might be considered as more preferable results.
      //
      // This logic, however, is not guaranteed and can change at any point in the future
      offsetParent: function() {
        return this.map(function() {
          for (var b = this.offsetParent; b && S.css(b, "position") === "static"; )
            b = b.offsetParent;
          return b || we;
        });
      }
    }), S.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(b, T) {
      var z = T === "pageYOffset";
      S.fn[b] = function(W) {
        return he(this, function(U, X, K) {
          var ut;
          if (D(U) ? ut = U : U.nodeType === 9 && (ut = U.defaultView), K === void 0)
            return ut ? ut[T] : U[X];
          ut ? ut.scrollTo(
            z ? ut.pageXOffset : K,
            z ? K : ut.pageYOffset
          ) : U[X] = K;
        }, b, W, arguments.length);
      };
    }), S.each(["top", "left"], function(b, T) {
      S.cssHooks[T] = Se(
        E.pixelPosition,
        function(z, W) {
          if (W)
            return W = ti(z, T), fn.test(W) ? S(z).position()[T] + "px" : W;
        }
      );
    }), S.each({ Height: "height", Width: "width" }, function(b, T) {
      S.each({
        padding: "inner" + b,
        content: T,
        "": "outer" + b
      }, function(z, W) {
        S.fn[W] = function(U, X) {
          var K = arguments.length && (z || typeof U != "boolean"), ut = z || (U === !0 || X === !0 ? "margin" : "border");
          return he(this, function(lt, _t, Lt) {
            var Bt;
            return D(lt) ? W.indexOf("outer") === 0 ? lt["inner" + b] : lt.document.documentElement["client" + b] : lt.nodeType === 9 ? (Bt = lt.documentElement, Math.max(
              lt.body["scroll" + b],
              Bt["scroll" + b],
              lt.body["offset" + b],
              Bt["offset" + b],
              Bt["client" + b]
            )) : Lt === void 0 ? (
              // Get width or height on the element, requesting but not forcing parseFloat
              S.css(lt, _t, ut)
            ) : (
              // Set width or height on the element
              S.style(lt, _t, Lt, ut)
            );
          }, T, K ? U : void 0, K);
        };
      });
    }), S.each([
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend"
    ], function(b, T) {
      S.fn[T] = function(z) {
        return this.on(T, z);
      };
    }), S.fn.extend({
      bind: function(b, T, z) {
        return this.on(b, null, T, z);
      },
      unbind: function(b, T) {
        return this.off(b, null, T);
      },
      delegate: function(b, T, z, W) {
        return this.on(T, b, z, W);
      },
      undelegate: function(b, T, z) {
        return arguments.length === 1 ? this.off(b, "**") : this.off(T, b || "**", z);
      },
      hover: function(b, T) {
        return this.on("mouseenter", b).on("mouseleave", T || b);
      }
    }), S.each(
      "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
      function(b, T) {
        S.fn[T] = function(z, W) {
          return arguments.length > 0 ? this.on(T, null, z, W) : this.trigger(T);
        };
      }
    );
    var Cr = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
    S.proxy = function(b, T) {
      var z, W, U;
      if (typeof T == "string" && (z = b[T], T = b, b = z), !!x(b))
        return W = u.call(arguments, 2), U = function() {
          return b.apply(T || this, W.concat(u.call(arguments)));
        }, U.guid = b.guid = b.guid || S.guid++, U;
    }, S.holdReady = function(b) {
      b ? S.readyWait++ : S.ready(!0);
    }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = nt, S.isFunction = x, S.isWindow = D, S.camelCase = fe, S.type = H, S.now = Date.now, S.isNumeric = function(b) {
      var T = S.type(b);
      return (T === "number" || T === "string") && // parseFloat NaNs numeric-cast false positives ("")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      !isNaN(b - parseFloat(b));
    }, S.trim = function(b) {
      return b == null ? "" : (b + "").replace(Cr, "$1");
    };
    var Fr = n.jQuery, fr = n.$;
    return S.noConflict = function(b) {
      return n.$ === S && (n.$ = fr), b && n.jQuery === S && (n.jQuery = Fr), S;
    }, typeof r > "u" && (n.jQuery = n.$ = S), S;
  });
})(jquery);
var jqueryExports = jquery.exports;
const $ = /* @__PURE__ */ getDefaultExportFromCjs(jqueryExports);
class FeatureLayer extends Layer {
  constructor(n, r) {
    super(), this._className = "FeatureLayer", this._featureCollection = [], this._selectedFeatures = [], this._featureMap = /* @__PURE__ */ new Map(), this._map = n, this._layerType = LayerType.FEATURE, this._featGroup = new leafletSrcExports.FeatureGroup(), this._layerName = r.layerName;
  }
  _initialize() {
    this._map._map.on("zoomend", () => {
    });
  }
  //清空图层
  removeAll() {
    for (; this._featureCollection.length > 0; ) {
      let n = this._featureCollection.pop();
      defined(n) && n._featureComponents.remove();
    }
  }
  //添加feature对象
  addFeature(n) {
    if (defined(n))
      try {
        if (this._featureCollection.indexOf(n) !== -1)
          return null;
        n._layer = this, this._featureMap.set(n._id, n), this._featureCollection.push(n), n._featureComponents.addTo(this._map._map), n._map = this._map, n._symbol._map = this._map;
      } catch (r) {
        console.log(r, "FeatureLayer:addFeature");
      }
  }
  addEntity(n) {
    if (defined(n)) {
      try {
        if (this._featureCollection.indexOf(n) !== -1)
          return null;
        n._layer = this, this._featureMap.set(n._id, n), this._featureCollection.push(n), n._featureComponents.addTo(this._map._map), n._map = this._map, n._symbol._map = this._map;
      } catch (r) {
        console.log(r, "FeatureLayer:addFeature");
      }
      return this.redraw(), n;
    }
  }
  //移除对象
  removeFeature(n) {
    if (!defined(n))
      return !1;
    const r = this._featureCollection.findIndex((o) => o._id === n._id);
    return r !== -1 && (n._featureComponents.remove(), this._featureMap.delete(n._id), this._featureCollection.splice(r, 1)), !1;
  }
  //图层隐藏
  hide() {
    this._featureCollection.forEach((n) => {
      n._featureComponents.removeFrom(this._map._map);
    }), super.hide();
  }
  //图层显示
  show() {
    this._featureCollection.forEach((n) => {
      n._featureComponents.addTo(this._map._map);
    }), super.show();
  }
  getFeatureByID(n) {
    if (!defined(n))
      return null;
    const r = this._featureCollection.findIndex((o) => o._id === n);
    return r != -1 ? this._featureCollection[r] : null;
  }
  redraw() {
    this._featureCollection.forEach((n) => {
      n.redraw();
    });
  }
  //获取所有对象
  getAllFeatures() {
    return this._featureCollection;
  }
}
class SymbolComponent extends BaseObject {
  constructor(n, r, o = null) {
    super(), this._type = n, this._options = defined(o) ? Clone(o) : null, this._points = r.slice(), this._className = "SymbolComponent";
  }
}
let Symbol$1 = class extends BaseObject {
  constructor(n) {
    super(), this._type = n, this._components = [], this._className = "Symbol", this.minEditPts = 0, this.maxEditPts = 9999, this.canAddDeletePoint = !1, this._map = null, this.controlPoints = [], this._rotate = 0, this._scale = 1, this._options = null;
  }
  _initialize() {
  }
  calculateParts() {
  }
  getControls() {
    return this.controlPoints;
  }
  addCell(n, r, o = null) {
    if (n && r) {
      const l = new SymbolComponent(n, r, o);
      this._components.push(l);
    }
  }
};
class SymbolPolyline extends Symbol$1 {
  constructor() {
    super(FeatureType.Polyline), this.minEditPts = 2, this.maxEditPts = 9999, this.canAddDeletePoint = !0;
  }
  calculateParts() {
    super.calculateParts(), !(this.controlPoints.length < this.minEditPts) && (this._components = [], this.addCell(SymbolCellType.PolyLine, this.controlPoints));
  }
}
class SymbolPolygon extends Symbol$1 {
  constructor() {
    super(FeatureType.Polyline), this.minEditPts = 2, this.maxEditPts = 9999;
  }
  calculateParts() {
    super.calculateParts(), this._components = [], !(this.controlPoints.length < this.minEditPts) && this.addCell(SymbolCellType.Polygon, this.controlPoints);
  }
}
class SymbolPin extends Symbol$1 {
  constructor() {
    super(FeatureType.Pin), this.minEditPts = 1, this.maxEditPts = 1;
  }
  calculateParts() {
    super.calculateParts(), !(this.controlPoints.length < this.minEditPts) && (this._components = [], this.addCell(SymbolCellType.Pin, this.controlPoints));
  }
}
class SymbolRectangle extends Symbol$1 {
  constructor() {
    super(FeatureType.Rectangle), this.minEditPts = 2, this.maxEditPts = 2, this._calculationControls = [];
  }
  calculateParts() {
    if (super.calculateParts(), this.controlPoints.length < this.minEditPts)
      return;
    let n = this.controlPoints.slice();
    if (n.length >= this.minEditPts) {
      var r = n[0], o = n[1];
      let y = new GeoPoint3D((Number(r.getLon()) + Number(o.getLon())) / 2, (Number(r.getLat()) + Number(o.getLat())) / 2);
      r = this.rotatepos(r, y, -0), o = this.rotatepos(o, y, -0);
      var l = Math.min(Number(r.getLon()), Number(o.getLon())), u = Math.max(Number(r.getLon()), Number(o.getLon())), h = Math.min(Number(r.getLat()), Number(o.getLat())), c = Math.max(Number(r.getLat()), Number(o.getLat())), f = new GeoPoint3D(l, c);
      f = this.rotatepos(f, y, this._rotate);
      var v = new GeoPoint3D(u, c);
      v = this.rotatepos(v, y, this._rotate);
      var m = new GeoPoint3D(u, h);
      m = this.rotatepos(m, y, this._rotate);
      var g = new GeoPoint3D(l, h);
      g = this.rotatepos(g, y, this._rotate);
    }
    this._components = [], this._calculationControls = [f, m], this.addCell(SymbolCellType.Polygon, [f, v, m, g]);
  }
  getControls() {
    return this._calculationControls;
  }
  rotatepos(n, r, o) {
    var l = (n.getLon() - r.getLon()) * Math.cos(o / 180 * Math.PI) - (n.getLat() - r.getLat()) * Math.sin(o / 180 * Math.PI) + r.getLon(), u = (n.getLon() - r.getLon()) * Math.sin(o / 180 * Math.PI) + (n.getLat() - r.getLat()) * Math.cos(o / 180 * Math.PI) + r.getLat();
    return new GeoPoint3D(l, u);
  }
}
class SymbolPlotPng extends Symbol$1 {
  constructor() {
    super(FeatureType.PlotPng), this.minEditPts = 1, this.maxEditPts = 1, this._iconlength = 48;
  }
  calculateParts() {
    if (super.calculateParts(), this.controlPoints.length == 1) {
      this._components = [];
      var n = this._map._map.latLngToLayerPoint({ lng: this.controlPoints[0].getLon(), lat: this.controlPoints[0].getLat() }), r = this._map._map.layerPointToLatLng([n.x, n.y - this._iconlength * 0.5]);
      this.addCell(SymbolCellType.Text, [new GeoPoint3D(r.lng, r.lat)]), this.addCell(SymbolCellType.PlotPng, this.controlPoints);
    }
  }
}
class SymbolText extends Symbol$1 {
  constructor() {
    super(FeatureType.Text), this.minEditPts = 1, this.maxEditPts = 1;
  }
  calculateParts() {
    super.calculateParts(), this._components = [], this.addCell(SymbolCellType.Text, this.controlPoints);
  }
}
class SymbolDistanceResult extends Symbol$1 {
  constructor() {
    super(FeatureType.DistanceResult), this._className = "SymbolDistanceResult", this.minEditPts = 2, this.maxEditPts = 999, this.pointStyle = {
      fillColor: "#FFFFFF",
      color: "#FF0000",
      radius: 5,
      weight: 1,
      opacity: 1,
      fillOpacity: 1,
      zIndex: 1e3
    };
  }
  calculateParts() {
    super.calculateParts(), this._components = [];
    var n = [];
    if (!(this.controlPoints.length < 2)) {
      for (var r = this.controlPoints.length, o = 0; o < r; o++) {
        n.push([this.controlPoints[o].getLon(), this.controlPoints[o].getLat()]);
        var l = this._map._map.latLngToLayerPoint({ lng: this.controlPoints[o].getLon(), lat: this.controlPoints[o].getLat() }), u = this._map._map.layerPointToLatLng({ x: l.x + 10, y: l.y });
        if (o == 0)
          this.addCell(SymbolCellType.Text, [new GeoPoint3D(u.lng, u.lat)], { text: "起点" });
        else {
          var h = lineString(n), c = length(h, { units: "kilometers" }), f = "";
          Number(c) < 0 ? f = `${(Number(c) * 1e3).toFixed(2)}米` : f = `${Number(c).toFixed(2)}千米`, this.addCell(SymbolCellType.Text, [new GeoPoint3D(u.lng, u.lat)], { text: f });
        }
        this.addCell(SymbolCellType.circleMark, [this.controlPoints[o]], { style: this.pointStyle });
      }
      this.addCell(SymbolCellType.PolyLine, this.controlPoints);
    }
  }
}
class SymbolAreaResult extends Symbol$1 {
  constructor() {
    super(FeatureType.AreaResult), this.minEditPts = 2, this.maxEditPts = 999;
  }
  calculateParts() {
    super.calculateParts(), this._components = [];
    var n = [];
    if (!(this.controlPoints.length < this.minEditPts)) {
      if (this.controlPoints.length != 2) {
        if (this.controlPoints.length >= this.minEditPts) {
          for (var r = this.controlPoints.length, o = 0; o < r; o++)
            n.push([this.controlPoints[o].getLon(), this.controlPoints[o].getLat()]);
          n.push(n[0]);
          var l = polygon([n]), u = area(l), h = centroid(l), c = "";
          u < 1e3 * 100 ? c = `${Number(u).toFixed(2)}平方米` : c = `${Number(u / 1e3 / 1e3).toFixed(2)}平方公里`, this.addCell(SymbolCellType.Text, [new GeoPoint3D(h.geometry.coordinates[0], h.geometry.coordinates[1])], { text: c });
        }
      }
      this.addCell(SymbolCellType.Polygon, this.controlPoints);
    }
  }
}
class SymbolAngleResult extends Symbol$1 {
  constructor() {
    super(FeatureType.AngleResult), this.minEditPts = 2, this.maxEditPts = 2;
  }
  calculateParts() {
    if (super.calculateParts(), this._components = [], this.controlPoints.length == 2) {
      var n = this._map._map.latLngToLayerPoint({
        lng: this.controlPoints[0].getLon(),
        lat: this.controlPoints[0].getLat()
      }), r = this._map._map.latLngToLayerPoint({
        lng: this.controlPoints[1].getLon(),
        lat: this.controlPoints[1].getLat()
      }), o = Math.sqrt((n.x - r.x) * (n.x - r.x) + (n.y - r.y) * (n.y - r.y)), l = this._map._map.layerPointToLatLng({
        x: n.x,
        y: n.y - o < 50 ? 50 : n.y - o
      }), u = point([this.controlPoints[0].getLon(), this.controlPoints[0].getLat()]), h = point([this.controlPoints[1].getLon(), this.controlPoints[1].getLat()]), c = distance(u, h, { units: "meters" }), f = rhumbBearing(point([this.controlPoints[0].getLon(), this.controlPoints[0].getLat()]), point([this.controlPoints[1].getLon(), this.controlPoints[1].getLat()])), v = point([this.controlPoints[0].getLon(), this.controlPoints[0].getLat()]), m = c / 2;
      defined(m) || (m = 0);
      var g = 0, y = sector(v, m, g, f, { units: "meters", steps: 60 });
      this.addCell(SymbolCellType.PolyLine, [new GeoPoint3D(l.lng, l.lat), this.controlPoints[0], this.controlPoints[1]]);
      var w = getCoords(y), E = [];
      defined(w) && w[0].forEach((D) => {
        E.push(new GeoPoint3D(D[0], D[1]));
      });
      var x = this._map._map.layerPointToLatLng({
        x: (r.x + n.x) / 2,
        y: (r.y + n.y) / 2
      });
      E.splice(E.length - 3, 3), E.splice(0, 1), E.push(new GeoPoint3D(x.lng, x.lat)), this.addCell(SymbolCellType.PolyLine, E), f = f < 0 ? f + 360 : f, this.addCell(SymbolCellType.Text, [E[Math.round(E.length / 2)]], { text: `${Number(f).toFixed(2)}` }), this.addCell(SymbolCellType.Text, [new GeoPoint3D(l.lng, l.lat)], { text: "正北" });
    }
  }
}
class SymbolMultiLines extends Symbol$1 {
  constructor() {
    super(FeatureType.MultiLines), this.minEditPts = 2, this.maxEditPts = 99999;
  }
  calculateParts() {
    if (super.calculateParts(), this._components = [], !(this.controlPoints.length < this.minEditPts))
      for (var n = this.controlPoints.length, r = 0; r < n; r += 2)
        this.addCell(SymbolCellType.PolyLine, [this.controlPoints[r], this.controlPoints[r + 1]]);
  }
}
class SymbolMultiText extends Symbol$1 {
  constructor() {
    super(FeatureType.MultiText), this.minEditPts = 1, this.maxEditPts = 99999;
  }
  calculateParts() {
    super.calculateParts(), this._components = [];
    for (var n = this.controlPoints.length, r = 0; r < n; r++)
      this.addCell(SymbolCellType.Text, [this.controlPoints[r]]);
  }
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(e) {
    for (var n = 1; n < arguments.length; n++) {
      var r = arguments[n];
      for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (e[o] = r[o]);
    }
    return e;
  }, _extends.apply(this, arguments);
}
var DEFAULT_CONFIG = {
  // minimum relative difference between two compared values,
  // used by all comparison functions
  epsilon: 1e-12,
  // type of default matrix output. Choose 'matrix' (default) or 'array'
  matrix: "Matrix",
  // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
  number: "number",
  // number of significant digits in BigNumbers
  precision: 64,
  // predictable output type of functions. When true, output type depends only
  // on the input types. When false (default), output type can vary depending
  // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
  // predictable is false, and returns `NaN` when true.
  predictable: !1,
  // random seed for seeded pseudo random number generation
  // null = randomly seed
  randomSeed: null
};
function isNumber$1(e) {
  return typeof e == "number";
}
function isBigNumber(e) {
  return !e || typeof e != "object" || typeof e.constructor != "function" ? !1 : e.isBigNumber === !0 && typeof e.constructor.prototype == "object" && e.constructor.prototype.isBigNumber === !0 || typeof e.constructor.isDecimal == "function" && e.constructor.isDecimal(e) === !0;
}
function isComplex(e) {
  return e && typeof e == "object" && Object.getPrototypeOf(e).isComplex === !0 || !1;
}
function isFraction(e) {
  return e && typeof e == "object" && Object.getPrototypeOf(e).isFraction === !0 || !1;
}
function isUnit(e) {
  return e && e.constructor.prototype.isUnit === !0 || !1;
}
function isString$1(e) {
  return typeof e == "string";
}
var isArray$1 = Array.isArray;
function isMatrix(e) {
  return e && e.constructor.prototype.isMatrix === !0 || !1;
}
function isCollection(e) {
  return Array.isArray(e) || isMatrix(e);
}
function isDenseMatrix(e) {
  return e && e.isDenseMatrix && e.constructor.prototype.isMatrix === !0 || !1;
}
function isSparseMatrix(e) {
  return e && e.isSparseMatrix && e.constructor.prototype.isMatrix === !0 || !1;
}
function isRange(e) {
  return e && e.constructor.prototype.isRange === !0 || !1;
}
function isIndex(e) {
  return e && e.constructor.prototype.isIndex === !0 || !1;
}
function isBoolean$1(e) {
  return typeof e == "boolean";
}
function isResultSet(e) {
  return e && e.constructor.prototype.isResultSet === !0 || !1;
}
function isHelp(e) {
  return e && e.constructor.prototype.isHelp === !0 || !1;
}
function isFunction$1(e) {
  return typeof e == "function";
}
function isDate$1(e) {
  return e instanceof Date;
}
function isRegExp$1(e) {
  return e instanceof RegExp;
}
function isObject$1(e) {
  return !!(e && typeof e == "object" && e.constructor === Object && !isComplex(e) && !isFraction(e));
}
function isNull(e) {
  return e === null;
}
function isUndefined$1(e) {
  return e === void 0;
}
function isAccessorNode(e) {
  return e && e.isAccessorNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isArrayNode(e) {
  return e && e.isArrayNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isAssignmentNode(e) {
  return e && e.isAssignmentNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isBlockNode(e) {
  return e && e.isBlockNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isConditionalNode(e) {
  return e && e.isConditionalNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isConstantNode(e) {
  return e && e.isConstantNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isFunctionAssignmentNode(e) {
  return e && e.isFunctionAssignmentNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isFunctionNode(e) {
  return e && e.isFunctionNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isIndexNode(e) {
  return e && e.isIndexNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isNode(e) {
  return e && e.isNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isObjectNode(e) {
  return e && e.isObjectNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isOperatorNode(e) {
  return e && e.isOperatorNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isParenthesisNode(e) {
  return e && e.isParenthesisNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isRangeNode(e) {
  return e && e.isRangeNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isRelationalNode(e) {
  return e && e.isRelationalNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isSymbolNode(e) {
  return e && e.isSymbolNode === !0 && e.constructor.prototype.isNode === !0 || !1;
}
function isChain(e) {
  return e && e.constructor.prototype.isChain === !0 || !1;
}
function typeOf(e) {
  var n = typeof e;
  return n === "object" ? e === null ? "null" : isBigNumber(e) ? "BigNumber" : e.constructor && e.constructor.name ? e.constructor.name : "Object" : n;
}
function clone$2(e) {
  var n = typeof e;
  if (n === "number" || n === "string" || n === "boolean" || e === null || e === void 0)
    return e;
  if (typeof e.clone == "function")
    return e.clone();
  if (Array.isArray(e))
    return e.map(function(r) {
      return clone$2(r);
    });
  if (e instanceof Date)
    return new Date(e.valueOf());
  if (isBigNumber(e))
    return e;
  if (isObject$1(e))
    return mapObject(e, clone$2);
  throw new TypeError("Cannot clone: unknown type of value (value: ".concat(e, ")"));
}
function mapObject(e, n) {
  var r = {};
  for (var o in e)
    hasOwnProperty$1(e, o) && (r[o] = n(e[o]));
  return r;
}
function extend$2(e, n) {
  for (var r in n)
    hasOwnProperty$1(n, r) && (e[r] = n[r]);
  return e;
}
function deepStrictEqual(e, n) {
  var r, o, l;
  if (Array.isArray(e)) {
    if (!Array.isArray(n) || e.length !== n.length)
      return !1;
    for (o = 0, l = e.length; o < l; o++)
      if (!deepStrictEqual(e[o], n[o]))
        return !1;
    return !0;
  } else {
    if (typeof e == "function")
      return e === n;
    if (e instanceof Object) {
      if (Array.isArray(n) || !(n instanceof Object))
        return !1;
      for (r in e)
        if (!(r in n) || !deepStrictEqual(e[r], n[r]))
          return !1;
      for (r in n)
        if (!(r in e))
          return !1;
      return !0;
    } else
      return e === n;
  }
}
function hasOwnProperty$1(e, n) {
  return e && Object.hasOwnProperty.call(e, n);
}
function pickShallow(e, n) {
  for (var r = {}, o = 0; o < n.length; o++) {
    var l = n[o], u = e[l];
    u !== void 0 && (r[l] = u);
  }
  return r;
}
var MATRIX_OPTIONS = ["Matrix", "Array"], NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"], config$1 = function(n) {
  if (n)
    throw new Error(`The global config is readonly. 
Please create a mathjs instance if you want to change the default configuration. 
Example:

  import { create, all } from 'mathjs';
  const mathjs = create(all);
  mathjs.config({ number: 'BigNumber' });
`);
  return Object.freeze(DEFAULT_CONFIG);
};
_extends(config$1, DEFAULT_CONFIG, {
  MATRIX_OPTIONS,
  NUMBER_OPTIONS
});
function ok() {
  return !0;
}
function notOk() {
  return !1;
}
function undef() {
}
const NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
function create() {
  function e(st) {
    return typeof st == "object" && st !== null && st.constructor === Object;
  }
  const n = [{
    name: "number",
    test: function(st) {
      return typeof st == "number";
    }
  }, {
    name: "string",
    test: function(st) {
      return typeof st == "string";
    }
  }, {
    name: "boolean",
    test: function(st) {
      return typeof st == "boolean";
    }
  }, {
    name: "Function",
    test: function(st) {
      return typeof st == "function";
    }
  }, {
    name: "Array",
    test: Array.isArray
  }, {
    name: "Date",
    test: function(st) {
      return st instanceof Date;
    }
  }, {
    name: "RegExp",
    test: function(st) {
      return st instanceof RegExp;
    }
  }, {
    name: "Object",
    test: e
  }, {
    name: "null",
    test: function(st) {
      return st === null;
    }
  }, {
    name: "undefined",
    test: function(st) {
      return st === void 0;
    }
  }], r = {
    name: "any",
    test: ok,
    isAny: !0
  };
  let o, l, u = 0, h = {
    createCount: 0
  };
  function c(st) {
    const xt = o.get(st);
    if (xt)
      return xt;
    let mt = 'Unknown type "' + st + '"';
    const Ot = st.toLowerCase();
    let jt;
    for (jt of l)
      if (jt.toLowerCase() === Ot) {
        mt += '. Did you mean "' + jt + '" ?';
        break;
      }
    throw new TypeError(mt);
  }
  function f(st) {
    let xt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
    const mt = xt ? c(xt).index : l.length, Ot = [];
    for (let Ht = 0; Ht < st.length; ++Ht) {
      if (!st[Ht] || typeof st[Ht].name != "string" || typeof st[Ht].test != "function")
        throw new TypeError("Object with properties {name: string, test: function} expected");
      const $t = st[Ht].name;
      if (o.has($t))
        throw new TypeError('Duplicate type name "' + $t + '"');
      Ot.push($t), o.set($t, {
        name: $t,
        test: st[Ht].test,
        isAny: st[Ht].isAny,
        index: mt + Ht,
        conversionsTo: []
        // Newly added type can't have any conversions to it
      });
    }
    const jt = l.slice(mt);
    l = l.slice(0, mt).concat(Ot).concat(jt);
    for (let Ht = mt + Ot.length; Ht < l.length; ++Ht)
      o.get(l[Ht]).index = Ht;
  }
  function v() {
    o = /* @__PURE__ */ new Map(), l = [], u = 0, f([r], !1);
  }
  v(), f(n);
  function m() {
    let st;
    for (st of l)
      o.get(st).conversionsTo = [];
    u = 0;
  }
  function g(st) {
    const xt = l.filter((mt) => {
      const Ot = o.get(mt);
      return !Ot.isAny && Ot.test(st);
    });
    return xt.length ? xt : ["any"];
  }
  function y(st) {
    return st && typeof st == "function" && "_typedFunctionData" in st;
  }
  function w(st, xt, mt) {
    if (!y(st))
      throw new TypeError(NOT_TYPED_FUNCTION);
    const Ot = mt && mt.exact, jt = Array.isArray(xt) ? xt.join(",") : xt, Ht = H(jt), $t = D(Ht);
    if (!Ot || $t in st.signatures) {
      const ve = st._typedFunctionData.signatureMap.get($t);
      if (ve)
        return ve;
    }
    const Xt = Ht.length;
    let Qt;
    if (Ot) {
      Qt = [];
      let ve;
      for (ve in st.signatures)
        Qt.push(st._typedFunctionData.signatureMap.get(ve));
    } else
      Qt = st._typedFunctionData.signatures;
    for (let ve = 0; ve < Xt; ++ve) {
      const we = Ht[ve], Te = [];
      let Ve;
      for (Ve of Qt) {
        const Le = tt(Ve.params, ve);
        if (!(!Le || we.restParam && !Le.restParam)) {
          if (!Le.hasAny) {
            const Ke = N(Le);
            if (we.types.some((Qe) => !Ke.has(Qe.name)))
              continue;
          }
          Te.push(Ve);
        }
      }
      if (Qt = Te, Qt.length === 0)
        break;
    }
    let Ut;
    for (Ut of Qt)
      if (Ut.params.length <= Xt)
        return Ut;
    throw new TypeError("Signature not found (signature: " + (st.name || "unnamed") + "(" + D(Ht, ", ") + "))");
  }
  function E(st, xt, mt) {
    return w(st, xt, mt).implementation;
  }
  function x(st, xt) {
    const mt = c(xt);
    if (mt.test(st))
      return st;
    const Ot = mt.conversionsTo;
    if (Ot.length === 0)
      throw new Error("There are no conversions to " + xt + " defined.");
    for (let jt = 0; jt < Ot.length; jt++)
      if (c(Ot[jt].from).test(st))
        return Ot[jt].convert(st);
    throw new Error("Cannot convert " + st + " to " + xt);
  }
  function D(st) {
    let xt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
    return st.map((mt) => mt.name).join(xt);
  }
  function F(st) {
    const xt = st.indexOf("...") === 0, Ot = (xt ? st.length > 3 ? st.slice(3) : "any" : st).split("|").map((Xt) => c(Xt.trim()));
    let jt = !1, Ht = xt ? "..." : "";
    return {
      types: Ot.map(function(Xt) {
        return jt = Xt.isAny || jt, Ht += Xt.name + "|", {
          name: Xt.name,
          typeIndex: Xt.index,
          test: Xt.test,
          isAny: Xt.isAny,
          conversion: null,
          conversionIndex: -1
        };
      }),
      name: Ht.slice(0, -1),
      // remove trailing '|' from above
      hasAny: jt,
      hasConversion: !1,
      restParam: xt
    };
  }
  function k(st) {
    const xt = st.types.map(($t) => $t.name), mt = G(xt);
    let Ot = st.hasAny, jt = st.name;
    const Ht = mt.map(function($t) {
      const Xt = c($t.from);
      return Ot = Xt.isAny || Ot, jt += "|" + $t.from, {
        name: $t.from,
        typeIndex: Xt.index,
        test: Xt.test,
        isAny: Xt.isAny,
        conversion: $t,
        conversionIndex: $t.index
      };
    });
    return {
      types: st.types.concat(Ht),
      name: jt,
      hasAny: Ot,
      hasConversion: Ht.length > 0,
      restParam: st.restParam
    };
  }
  function N(st) {
    return st.typeSet || (st.typeSet = /* @__PURE__ */ new Set(), st.types.forEach((xt) => st.typeSet.add(xt.name))), st.typeSet;
  }
  function H(st) {
    const xt = [];
    if (typeof st != "string")
      throw new TypeError("Signatures must be strings");
    const mt = st.trim();
    if (mt === "")
      return xt;
    const Ot = mt.split(",");
    for (let jt = 0; jt < Ot.length; ++jt) {
      const Ht = F(Ot[jt].trim());
      if (Ht.restParam && jt !== Ot.length - 1)
        throw new SyntaxError('Unexpected rest parameter "' + Ot[jt] + '": only allowed for the last parameter');
      if (Ht.types.length === 0)
        return null;
      xt.push(Ht);
    }
    return xt;
  }
  function R(st) {
    const xt = et(st);
    return xt ? xt.restParam : !1;
  }
  function j(st) {
    if (!st || st.types.length === 0)
      return ok;
    if (st.types.length === 1)
      return c(st.types[0].name).test;
    if (st.types.length === 2) {
      const xt = c(st.types[0].name).test, mt = c(st.types[1].name).test;
      return function(jt) {
        return xt(jt) || mt(jt);
      };
    } else {
      const xt = st.types.map(function(mt) {
        return c(mt.name).test;
      });
      return function(Ot) {
        for (let jt = 0; jt < xt.length; jt++)
          if (xt[jt](Ot))
            return !0;
        return !1;
      };
    }
  }
  function S(st) {
    let xt, mt, Ot;
    if (R(st)) {
      xt = J(st).map(j);
      const jt = xt.length, Ht = j(et(st)), $t = function(Xt) {
        for (let Qt = jt; Qt < Xt.length; Qt++)
          if (!Ht(Xt[Qt]))
            return !1;
        return !0;
      };
      return function(Qt) {
        for (let Ut = 0; Ut < xt.length; Ut++)
          if (!xt[Ut](Qt[Ut]))
            return !1;
        return $t(Qt) && Qt.length >= jt + 1;
      };
    } else
      return st.length === 0 ? function(Ht) {
        return Ht.length === 0;
      } : st.length === 1 ? (mt = j(st[0]), function(Ht) {
        return mt(Ht[0]) && Ht.length === 1;
      }) : st.length === 2 ? (mt = j(st[0]), Ot = j(st[1]), function(Ht) {
        return mt(Ht[0]) && Ot(Ht[1]) && Ht.length === 2;
      }) : (xt = st.map(j), function(Ht) {
        for (let $t = 0; $t < xt.length; $t++)
          if (!xt[$t](Ht[$t]))
            return !1;
        return Ht.length === xt.length;
      });
  }
  function tt(st, xt) {
    return xt < st.length ? st[xt] : R(st) ? et(st) : null;
  }
  function nt(st, xt) {
    const mt = tt(st, xt);
    return mt ? N(mt) : /* @__PURE__ */ new Set();
  }
  function ft(st) {
    return st.conversion === null || st.conversion === void 0;
  }
  function pt(st, xt) {
    const mt = /* @__PURE__ */ new Set();
    return st.forEach((Ot) => {
      const jt = nt(Ot.params, xt);
      let Ht;
      for (Ht of jt)
        mt.add(Ht);
    }), mt.has("any") ? ["any"] : Array.from(mt);
  }
  function ct(st, xt, mt) {
    let Ot, jt;
    const Ht = st || "unnamed";
    let $t = mt, Xt;
    for (Xt = 0; Xt < xt.length; Xt++) {
      const we = [];
      if ($t.forEach((Te) => {
        const Ve = tt(Te.params, Xt), Le = j(Ve);
        (Xt < Te.params.length || R(Te.params)) && Le(xt[Xt]) && we.push(Te);
      }), we.length === 0) {
        if (jt = pt($t, Xt), jt.length > 0) {
          const Te = g(xt[Xt]);
          return Ot = new TypeError("Unexpected type of argument in function " + Ht + " (expected: " + jt.join(" or ") + ", actual: " + Te.join(" | ") + ", index: " + Xt + ")"), Ot.data = {
            category: "wrongType",
            fn: Ht,
            index: Xt,
            actual: Te,
            expected: jt
          }, Ot;
        }
      } else
        $t = we;
    }
    const Qt = $t.map(function(we) {
      return R(we.params) ? 1 / 0 : we.params.length;
    });
    if (xt.length < Math.min.apply(null, Qt))
      return jt = pt($t, Xt), Ot = new TypeError("Too few arguments in function " + Ht + " (expected: " + jt.join(" or ") + ", index: " + xt.length + ")"), Ot.data = {
        category: "tooFewArgs",
        fn: Ht,
        index: xt.length,
        expected: jt
      }, Ot;
    const Ut = Math.max.apply(null, Qt);
    if (xt.length > Ut)
      return Ot = new TypeError("Too many arguments in function " + Ht + " (expected: " + Ut + ", actual: " + xt.length + ")"), Ot.data = {
        category: "tooManyArgs",
        fn: Ht,
        index: xt.length,
        expectedLength: Ut
      }, Ot;
    const ve = [];
    for (let we = 0; we < xt.length; ++we)
      ve.push(g(xt[we]).join("|"));
    return Ot = new TypeError('Arguments of type "' + ve.join(", ") + '" do not match any of the defined signatures of function ' + Ht + "."), Ot.data = {
      category: "mismatch",
      actual: ve
    }, Ot;
  }
  function Nt(st) {
    let xt = l.length + 1;
    for (let mt = 0; mt < st.types.length; mt++)
      ft(st.types[mt]) && (xt = Math.min(xt, st.types[mt].typeIndex));
    return xt;
  }
  function kt(st) {
    let xt = u + 1;
    for (let mt = 0; mt < st.types.length; mt++)
      ft(st.types[mt]) || (xt = Math.min(xt, st.types[mt].conversionIndex));
    return xt;
  }
  function Rt(st, xt) {
    if (st.hasAny) {
      if (!xt.hasAny)
        return 1;
    } else if (xt.hasAny)
      return -1;
    if (st.restParam) {
      if (!xt.restParam)
        return 1;
    } else if (xt.restParam)
      return -1;
    if (st.hasConversion) {
      if (!xt.hasConversion)
        return 1;
    } else if (xt.hasConversion)
      return -1;
    const mt = Nt(st) - Nt(xt);
    if (mt < 0)
      return -1;
    if (mt > 0)
      return 1;
    const Ot = kt(st) - kt(xt);
    return Ot < 0 ? -1 : Ot > 0 ? 1 : 0;
  }
  function Mt(st, xt) {
    const mt = st.params, Ot = xt.params, jt = et(mt), Ht = et(Ot), $t = R(mt), Xt = R(Ot);
    if ($t && jt.hasAny) {
      if (!Xt || !Ht.hasAny)
        return 1;
    } else if (Xt && Ht.hasAny)
      return -1;
    let Qt = 0, Ut = 0, ve;
    for (ve of mt)
      ve.hasAny && ++Qt, ve.hasConversion && ++Ut;
    let we = 0, Te = 0;
    for (ve of Ot)
      ve.hasAny && ++we, ve.hasConversion && ++Te;
    if (Qt !== we)
      return Qt - we;
    if ($t && jt.hasConversion) {
      if (!Xt || !Ht.hasConversion)
        return 1;
    } else if (Xt && Ht.hasConversion)
      return -1;
    if (Ut !== Te)
      return Ut - Te;
    if ($t) {
      if (!Xt)
        return 1;
    } else if (Xt)
      return -1;
    const Ve = (mt.length - Ot.length) * ($t ? -1 : 1);
    if (Ve !== 0)
      return Ve;
    const Le = [];
    let Ke = 0;
    for (let Ti = 0; Ti < mt.length; ++Ti) {
      const ai = Rt(mt[Ti], Ot[Ti]);
      Le.push(ai), Ke += ai;
    }
    if (Ke !== 0)
      return Ke;
    let Qe;
    for (Qe of Le)
      if (Qe !== 0)
        return Qe;
    return 0;
  }
  function G(st) {
    if (st.length === 0)
      return [];
    const xt = st.map(c);
    st.length > 1 && xt.sort((jt, Ht) => jt.index - Ht.index);
    let mt = xt[0].conversionsTo;
    if (st.length === 1)
      return mt;
    mt = mt.concat([]);
    const Ot = new Set(st);
    for (let jt = 1; jt < xt.length; ++jt) {
      let Ht;
      for (Ht of xt[jt].conversionsTo)
        Ot.has(Ht.from) || (mt.push(Ht), Ot.add(Ht.from));
    }
    return mt;
  }
  function Y(st, xt) {
    let mt = xt;
    if (st.some((jt) => jt.hasConversion)) {
      const jt = R(st), Ht = st.map(it);
      mt = function() {
        const Xt = [], Qt = jt ? arguments.length - 1 : arguments.length;
        for (let Ut = 0; Ut < Qt; Ut++)
          Xt[Ut] = Ht[Ut](arguments[Ut]);
        return jt && (Xt[Qt] = arguments[Qt].map(Ht[Qt])), xt.apply(this, Xt);
      };
    }
    let Ot = mt;
    if (R(st)) {
      const jt = st.length - 1;
      Ot = function() {
        return mt.apply(this, at(arguments, 0, jt).concat([at(arguments, jt)]));
      };
    }
    return Ot;
  }
  function it(st) {
    let xt, mt, Ot, jt;
    const Ht = [], $t = [];
    switch (st.types.forEach(function(Xt) {
      Xt.conversion && (Ht.push(c(Xt.conversion.from).test), $t.push(Xt.conversion.convert));
    }), $t.length) {
      case 0:
        return function(Qt) {
          return Qt;
        };
      case 1:
        return xt = Ht[0], Ot = $t[0], function(Qt) {
          return xt(Qt) ? Ot(Qt) : Qt;
        };
      case 2:
        return xt = Ht[0], mt = Ht[1], Ot = $t[0], jt = $t[1], function(Qt) {
          return xt(Qt) ? Ot(Qt) : mt(Qt) ? jt(Qt) : Qt;
        };
      default:
        return function(Qt) {
          for (let Ut = 0; Ut < $t.length; Ut++)
            if (Ht[Ut](Qt))
              return $t[Ut](Qt);
          return Qt;
        };
    }
  }
  function rt(st) {
    function xt(mt, Ot, jt) {
      if (Ot < mt.length) {
        const Ht = mt[Ot];
        let $t = [];
        if (Ht.restParam) {
          const Xt = Ht.types.filter(ft);
          Xt.length < Ht.types.length && $t.push({
            types: Xt,
            name: "..." + Xt.map((Qt) => Qt.name).join("|"),
            hasAny: Xt.some((Qt) => Qt.isAny),
            hasConversion: !1,
            restParam: !0
          }), $t.push(Ht);
        } else
          $t = Ht.types.map(function(Xt) {
            return {
              types: [Xt],
              name: Xt.name,
              hasAny: Xt.isAny,
              hasConversion: Xt.conversion,
              restParam: !1
            };
          });
        return wt($t, function(Xt) {
          return xt(mt, Ot + 1, jt.concat([Xt]));
        });
      } else
        return [jt];
    }
    return xt(st, 0, []);
  }
  function ht(st, xt) {
    const mt = Math.max(st.length, xt.length);
    for (let Xt = 0; Xt < mt; Xt++) {
      const Qt = nt(st, Xt), Ut = nt(xt, Xt);
      let ve = !1, we;
      for (we of Ut)
        if (Qt.has(we)) {
          ve = !0;
          break;
        }
      if (!ve)
        return !1;
    }
    const Ot = st.length, jt = xt.length, Ht = R(st), $t = R(xt);
    return Ht ? $t ? Ot === jt : jt >= Ot : $t ? Ot >= jt : Ot === jt;
  }
  function bt(st) {
    return st.map((xt) => Yt(xt) ? Jt(xt.referToSelf.callback) : Gt(xt) ? qt(xt.referTo.references, xt.referTo.callback) : xt);
  }
  function yt(st, xt, mt) {
    const Ot = [];
    let jt;
    for (jt of st) {
      let Ht = mt[jt];
      if (typeof Ht != "number")
        throw new TypeError('No definition for referenced signature "' + jt + '"');
      if (Ht = xt[Ht], typeof Ht != "function")
        return !1;
      Ot.push(Ht);
    }
    return Ot;
  }
  function St(st, xt, mt) {
    const Ot = bt(st), jt = new Array(Ot.length).fill(!1);
    let Ht = !0;
    for (; Ht; ) {
      Ht = !1;
      let $t = !0;
      for (let Xt = 0; Xt < Ot.length; ++Xt) {
        if (jt[Xt])
          continue;
        const Qt = Ot[Xt];
        if (Yt(Qt))
          Ot[Xt] = Qt.referToSelf.callback(mt), Ot[Xt].referToSelf = Qt.referToSelf, jt[Xt] = !0, $t = !1;
        else if (Gt(Qt)) {
          const Ut = yt(Qt.referTo.references, Ot, xt);
          Ut ? (Ot[Xt] = Qt.referTo.callback.apply(this, Ut), Ot[Xt].referTo = Qt.referTo, jt[Xt] = !0, $t = !1) : Ht = !0;
        }
      }
      if ($t && Ht)
        throw new SyntaxError("Circular reference detected in resolving typed.referTo");
    }
    return Ot;
  }
  function Ft(st) {
    const xt = /\bthis(\(|\.signatures\b)/;
    Object.keys(st).forEach((mt) => {
      const Ot = st[mt];
      if (xt.test(Ot.toString()))
        throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
    });
  }
  function zt(st, xt) {
    if (h.createCount++, Object.keys(xt).length === 0)
      throw new SyntaxError("No signatures provided");
    h.warnAgainstDeprecatedThis && Ft(xt);
    const mt = [], Ot = [], jt = {}, Ht = [];
    let $t;
    for ($t in xt) {
      if (!Object.prototype.hasOwnProperty.call(xt, $t))
        continue;
      const Se = H($t);
      if (!Se)
        continue;
      mt.forEach(function(qi) {
        if (ht(qi, Se))
          throw new TypeError('Conflicting signatures "' + D(qi) + '" and "' + D(Se) + '".');
      }), mt.push(Se);
      const je = Ot.length;
      Ot.push(xt[$t]);
      const qn = Se.map(k);
      let ji;
      for (ji of rt(qn)) {
        const qi = D(ji);
        Ht.push({
          params: ji,
          name: qi,
          fn: je
        }), ji.every((Gi) => !Gi.hasConversion) && (jt[qi] = je);
      }
    }
    Ht.sort(Mt);
    const Xt = St(Ot, jt, ti);
    let Qt;
    for (Qt in jt)
      Object.prototype.hasOwnProperty.call(jt, Qt) && (jt[Qt] = Xt[jt[Qt]]);
    const Ut = [], ve = /* @__PURE__ */ new Map();
    for (Qt of Ht)
      ve.has(Qt.name) || (Qt.fn = Xt[Qt.fn], Ut.push(Qt), ve.set(Qt.name, Qt));
    const we = Ut[0] && Ut[0].params.length <= 2 && !R(Ut[0].params), Te = Ut[1] && Ut[1].params.length <= 2 && !R(Ut[1].params), Ve = Ut[2] && Ut[2].params.length <= 2 && !R(Ut[2].params), Le = Ut[3] && Ut[3].params.length <= 2 && !R(Ut[3].params), Ke = Ut[4] && Ut[4].params.length <= 2 && !R(Ut[4].params), Qe = Ut[5] && Ut[5].params.length <= 2 && !R(Ut[5].params), Ti = we && Te && Ve && Le && Ke && Qe;
    for (let Se = 0; Se < Ut.length; ++Se)
      Ut[Se].test = S(Ut[Se].params);
    const ai = we ? j(Ut[0].params[0]) : notOk, Bi = Te ? j(Ut[1].params[0]) : notOk, In = Ve ? j(Ut[2].params[0]) : notOk, Bn = Le ? j(Ut[3].params[0]) : notOk, $e = Ke ? j(Ut[4].params[0]) : notOk, Ze = Qe ? j(Ut[5].params[0]) : notOk, sn = we ? j(Ut[0].params[1]) : notOk, $n = Te ? j(Ut[1].params[1]) : notOk, Ki = Ve ? j(Ut[2].params[1]) : notOk, zn = Le ? j(Ut[3].params[1]) : notOk, zi = Ke ? j(Ut[4].params[1]) : notOk, Ri = Qe ? j(Ut[5].params[1]) : notOk;
    for (let Se = 0; Se < Ut.length; ++Se)
      Ut[Se].implementation = Y(Ut[Se].params, Ut[Se].fn);
    const un = we ? Ut[0].implementation : undef, Je = Te ? Ut[1].implementation : undef, ae = Ve ? Ut[2].implementation : undef, Rn = Le ? Ut[3].implementation : undef, Hn = Ke ? Ut[4].implementation : undef, hn = Qe ? Ut[5].implementation : undef, Wn = we ? Ut[0].params.length : -1, dn = Te ? Ut[1].params.length : -1, cn = Ve ? Ut[2].params.length : -1, Hi = Le ? Ut[3].params.length : -1, Fi = Ke ? Ut[4].params.length : -1, jn = Qe ? Ut[5].params.length : -1, fn = Ti ? 6 : 0, pn = Ut.length, Qi = Ut.map((Se) => Se.test), gn = Ut.map((Se) => Se.implementation), er = function() {
      for (let je = fn; je < pn; je++)
        if (Qi[je](arguments))
          return gn[je].apply(this, arguments);
      return h.onMismatch(st, arguments, Ut);
    };
    function ti(Se, je) {
      return arguments.length === Wn && ai(Se) && sn(je) ? un.apply(this, arguments) : arguments.length === dn && Bi(Se) && $n(je) ? Je.apply(this, arguments) : arguments.length === cn && In(Se) && Ki(je) ? ae.apply(this, arguments) : arguments.length === Hi && Bn(Se) && zn(je) ? Rn.apply(this, arguments) : arguments.length === Fi && $e(Se) && zi(je) ? Hn.apply(this, arguments) : arguments.length === jn && Ze(Se) && Ri(je) ? hn.apply(this, arguments) : er.apply(this, arguments);
    }
    try {
      Object.defineProperty(ti, "name", {
        value: st
      });
    } catch {
    }
    return ti.signatures = jt, ti._typedFunctionData = {
      signatures: Ut,
      signatureMap: ve
    }, ti;
  }
  function Zt(st, xt, mt) {
    throw ct(st, xt, mt);
  }
  function J(st) {
    return at(st, 0, st.length - 1);
  }
  function et(st) {
    return st[st.length - 1];
  }
  function at(st, xt, mt) {
    return Array.prototype.slice.call(st, xt, mt);
  }
  function gt(st, xt) {
    for (let mt = 0; mt < st.length; mt++)
      if (xt(st[mt]))
        return st[mt];
  }
  function wt(st, xt) {
    return Array.prototype.concat.apply([], st.map(xt));
  }
  function Et() {
    const st = J(arguments).map((mt) => D(H(mt))), xt = et(arguments);
    if (typeof xt != "function")
      throw new TypeError("Callback function expected as last argument");
    return qt(st, xt);
  }
  function qt(st, xt) {
    return {
      referTo: {
        references: st,
        callback: xt
      }
    };
  }
  function Jt(st) {
    if (typeof st != "function")
      throw new TypeError("Callback function expected as first argument");
    return {
      referToSelf: {
        callback: st
      }
    };
  }
  function Gt(st) {
    return st && typeof st.referTo == "object" && Array.isArray(st.referTo.references) && typeof st.referTo.callback == "function";
  }
  function Yt(st) {
    return st && typeof st.referToSelf == "object" && typeof st.referToSelf.callback == "function";
  }
  function he(st, xt) {
    if (!st)
      return xt;
    if (xt && xt !== st) {
      const mt = new Error("Function names do not match (expected: " + st + ", actual: " + xt + ")");
      throw mt.data = {
        actual: xt,
        expected: st
      }, mt;
    }
    return st;
  }
  function Pe(st) {
    let xt;
    for (const mt in st)
      Object.prototype.hasOwnProperty.call(st, mt) && (y(st[mt]) || typeof st[mt].signature == "string") && (xt = he(xt, st[mt].name));
    return xt;
  }
  function ce(st, xt) {
    let mt;
    for (mt in xt)
      if (Object.prototype.hasOwnProperty.call(xt, mt)) {
        if (mt in st && xt[mt] !== st[mt]) {
          const Ot = new Error('Signature "' + mt + '" is defined twice');
          throw Ot.data = {
            signature: mt,
            sourceFunction: xt[mt],
            destFunction: st[mt]
          }, Ot;
        }
        st[mt] = xt[mt];
      }
  }
  const di = h;
  h = function(st) {
    const xt = typeof st == "string", mt = xt ? 1 : 0;
    let Ot = xt ? st : "";
    const jt = {};
    for (let Ht = mt; Ht < arguments.length; ++Ht) {
      const $t = arguments[Ht];
      let Xt = {}, Qt;
      if (typeof $t == "function" ? (Qt = $t.name, typeof $t.signature == "string" ? Xt[$t.signature] = $t : y($t) && (Xt = $t.signatures)) : e($t) && (Xt = $t, xt || (Qt = Pe($t))), Object.keys(Xt).length === 0) {
        const Ut = new TypeError("Argument to 'typed' at index " + Ht + " is not a (typed) function, nor an object with signatures as keys and functions as values.");
        throw Ut.data = {
          index: Ht,
          argument: $t
        }, Ut;
      }
      xt || (Ot = he(Ot, Qt)), ce(jt, Xt);
    }
    return zt(Ot || "", jt);
  }, h.create = create, h.createCount = di.createCount, h.onMismatch = Zt, h.throwMismatchError = Zt, h.createError = ct, h.clear = v, h.clearConversions = m, h.addTypes = f, h._findType = c, h.referTo = Et, h.referToSelf = Jt, h.convert = x, h.findSignature = w, h.find = E, h.isTypedFunction = y, h.warnAgainstDeprecatedThis = !0, h.addType = function(st, xt) {
    let mt = "any";
    xt !== !1 && o.has("Object") && (mt = "Object"), h.addTypes([st], mt);
  };
  function fe(st) {
    if (!st || typeof st.from != "string" || typeof st.to != "string" || typeof st.convert != "function")
      throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
    if (st.to === st.from)
      throw new SyntaxError('Illegal to define conversion from "' + st.from + '" to itself.');
  }
  return h.addConversion = function(st) {
    fe(st);
    const xt = c(st.to);
    if (xt.conversionsTo.every(function(mt) {
      return mt.from !== st.from;
    }))
      xt.conversionsTo.push({
        from: st.from,
        convert: st.convert,
        index: u++
      });
    else
      throw new Error('There is already a conversion from "' + st.from + '" to "' + xt.name + '"');
  }, h.addConversions = function(st) {
    st.forEach(h.addConversion);
  }, h.removeConversion = function(st) {
    fe(st);
    const xt = c(st.to), mt = gt(xt.conversionsTo, (jt) => jt.from === st.from);
    if (!mt)
      throw new Error("Attempt to remove nonexistent conversion from " + st.from + " to " + st.to);
    if (mt.convert !== st.convert)
      throw new Error("Conversion to remove does not match existing conversion");
    const Ot = xt.conversionsTo.indexOf(mt);
    xt.conversionsTo.splice(Ot, 1);
  }, h.resolve = function(st, xt) {
    if (!y(st))
      throw new TypeError(NOT_TYPED_FUNCTION);
    const mt = st._typedFunctionData.signatures;
    for (let Ot = 0; Ot < mt.length; ++Ot)
      if (mt[Ot].test(xt))
        return mt[Ot];
    return null;
  }, h;
}
const typedFunction = create();
function isInteger$1(e) {
  return typeof e == "boolean" ? !0 : isFinite(e) ? e === Math.round(e) : !1;
}
function formatNumberToBase(e, n, r) {
  var o = {
    2: "0b",
    8: "0o",
    16: "0x"
  }, l = o[n], u = "";
  if (r) {
    if (r < 1)
      throw new Error("size must be in greater than 0");
    if (!isInteger$1(r))
      throw new Error("size must be an integer");
    if (e > 2 ** (r - 1) - 1 || e < -(2 ** (r - 1)))
      throw new Error("Value must be in range [-2^".concat(r - 1, ", 2^").concat(r - 1, "-1]"));
    if (!isInteger$1(e))
      throw new Error("Value must be an integer");
    e < 0 && (e = e + 2 ** r), u = "i".concat(r);
  }
  var h = "";
  return e < 0 && (e = -e, h = "-"), "".concat(h).concat(l).concat(e.toString(n)).concat(u);
}
function format$2(e, n) {
  if (typeof n == "function")
    return n(e);
  if (e === 1 / 0)
    return "Infinity";
  if (e === -1 / 0)
    return "-Infinity";
  if (isNaN(e))
    return "NaN";
  var {
    notation: r,
    precision: o,
    wordSize: l
  } = normalizeFormatOptions(n);
  switch (r) {
    case "fixed":
      return toFixed$1(e, o);
    case "exponential":
      return toExponential$1(e, o);
    case "engineering":
      return toEngineering$1(e, o);
    case "bin":
      return formatNumberToBase(e, 2, l);
    case "oct":
      return formatNumberToBase(e, 8, l);
    case "hex":
      return formatNumberToBase(e, 16, l);
    case "auto":
      return toPrecision(e, o, n).replace(/((\.\d*?)(0+))($|e)/, function() {
        var u = arguments[2], h = arguments[4];
        return u !== "." ? u + h : h;
      });
    default:
      throw new Error('Unknown notation "' + r + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function normalizeFormatOptions(e) {
  var n = "auto", r, o;
  if (e !== void 0)
    if (isNumber$1(e))
      r = e;
    else if (isBigNumber(e))
      r = e.toNumber();
    else if (isObject$1(e))
      e.precision !== void 0 && (r = _toNumberOrThrow(e.precision, () => {
        throw new Error('Option "precision" must be a number or BigNumber');
      })), e.wordSize !== void 0 && (o = _toNumberOrThrow(e.wordSize, () => {
        throw new Error('Option "wordSize" must be a number or BigNumber');
      })), e.notation && (n = e.notation);
    else
      throw new Error("Unsupported type of options, number, BigNumber, or object expected");
  return {
    notation: n,
    precision: r,
    wordSize: o
  };
}
function splitNumber(e) {
  var n = String(e).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!n)
    throw new SyntaxError("Invalid number " + e);
  var r = n[1], o = n[2], l = parseFloat(n[4] || "0"), u = o.indexOf(".");
  l += u !== -1 ? u - 1 : o.length - 1;
  var h = o.replace(".", "").replace(/^0*/, function(c) {
    return l -= c.length, "";
  }).replace(/0*$/, "").split("").map(function(c) {
    return parseInt(c);
  });
  return h.length === 0 && (h.push(0), l++), {
    sign: r,
    coefficients: h,
    exponent: l
  };
}
function toEngineering$1(e, n) {
  if (isNaN(e) || !isFinite(e))
    return String(e);
  var r = splitNumber(e), o = roundDigits(r, n), l = o.exponent, u = o.coefficients, h = l % 3 === 0 ? l : l < 0 ? l - 3 - l % 3 : l - l % 3;
  if (isNumber$1(n))
    for (; n > u.length || l - h + 1 > u.length; )
      u.push(0);
  else
    for (var c = Math.abs(l - h) - (u.length - 1), f = 0; f < c; f++)
      u.push(0);
  for (var v = Math.abs(l - h), m = 1; v > 0; )
    m++, v--;
  var g = u.slice(m).join(""), y = isNumber$1(n) && g.length || g.match(/[1-9]/) ? "." + g : "", w = u.slice(0, m).join("") + y + "e" + (l >= 0 ? "+" : "") + h.toString();
  return o.sign + w;
}
function toFixed$1(e, n) {
  if (isNaN(e) || !isFinite(e))
    return String(e);
  var r = splitNumber(e), o = typeof n == "number" ? roundDigits(r, r.exponent + 1 + n) : r, l = o.coefficients, u = o.exponent + 1, h = u + (n || 0);
  return l.length < h && (l = l.concat(zeros(h - l.length))), u < 0 && (l = zeros(-u + 1).concat(l), u = 1), u < l.length && l.splice(u, 0, u === 0 ? "0." : "."), o.sign + l.join("");
}
function toExponential$1(e, n) {
  if (isNaN(e) || !isFinite(e))
    return String(e);
  var r = splitNumber(e), o = n ? roundDigits(r, n) : r, l = o.coefficients, u = o.exponent;
  l.length < n && (l = l.concat(zeros(n - l.length)));
  var h = l.shift();
  return o.sign + h + (l.length > 0 ? "." + l.join("") : "") + "e" + (u >= 0 ? "+" : "") + u;
}
function toPrecision(e, n, r) {
  if (isNaN(e) || !isFinite(e))
    return String(e);
  var o = _toNumberOrDefault$1(r == null ? void 0 : r.lowerExp, -3), l = _toNumberOrDefault$1(r == null ? void 0 : r.upperExp, 5), u = splitNumber(e), h = n ? roundDigits(u, n) : u;
  if (h.exponent < o || h.exponent >= l)
    return toExponential$1(e, n);
  var c = h.coefficients, f = h.exponent;
  c.length < n && (c = c.concat(zeros(n - c.length))), c = c.concat(zeros(f - c.length + 1 + (c.length < n ? n - c.length : 0))), c = zeros(-f).concat(c);
  var v = f > 0 ? f : 0;
  return v < c.length - 1 && c.splice(v + 1, 0, "."), h.sign + c.join("");
}
function roundDigits(e, n) {
  for (var r = {
    sign: e.sign,
    coefficients: e.coefficients,
    exponent: e.exponent
  }, o = r.coefficients; n <= 0; )
    o.unshift(0), r.exponent++, n++;
  if (o.length > n) {
    var l = o.splice(n, o.length - n);
    if (l[0] >= 5) {
      var u = n - 1;
      for (o[u]++; o[u] === 10; )
        o.pop(), u === 0 && (o.unshift(0), r.exponent++, u++), u--, o[u]++;
    }
  }
  return r;
}
function zeros(e) {
  for (var n = [], r = 0; r < e; r++)
    n.push(0);
  return n;
}
function digits(e) {
  return e.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
function nearlyEqual$1(e, n, r) {
  if (r == null)
    return e === n;
  if (e === n)
    return !0;
  if (isNaN(e) || isNaN(n))
    return !1;
  if (isFinite(e) && isFinite(n)) {
    var o = Math.abs(e - n);
    return o <= DBL_EPSILON ? !0 : o <= Math.max(Math.abs(e), Math.abs(n)) * r;
  }
  return !1;
}
function _toNumberOrThrow(e, n) {
  if (isNumber$1(e))
    return e;
  if (isBigNumber(e))
    return e.toNumber();
  n();
}
function _toNumberOrDefault$1(e, n) {
  return isNumber$1(e) ? e : isBigNumber(e) ? e.toNumber() : n;
}
function formatBigNumberToBase(e, n, r) {
  var o = e.constructor, l = new o(2), u = "";
  if (r) {
    if (r < 1)
      throw new Error("size must be in greater than 0");
    if (!isInteger$1(r))
      throw new Error("size must be an integer");
    if (e.greaterThan(l.pow(r - 1).sub(1)) || e.lessThan(l.pow(r - 1).mul(-1)))
      throw new Error("Value must be in range [-2^".concat(r - 1, ", 2^").concat(r - 1, "-1]"));
    if (!e.isInteger())
      throw new Error("Value must be an integer");
    e.lessThan(0) && (e = e.add(l.pow(r))), u = "i".concat(r);
  }
  switch (n) {
    case 2:
      return "".concat(e.toBinary()).concat(u);
    case 8:
      return "".concat(e.toOctal()).concat(u);
    case 16:
      return "".concat(e.toHexadecimal()).concat(u);
    default:
      throw new Error("Base ".concat(n, " not supported "));
  }
}
function format$1(e, n) {
  if (typeof n == "function")
    return n(e);
  if (!e.isFinite())
    return e.isNaN() ? "NaN" : e.gt(0) ? "Infinity" : "-Infinity";
  var {
    notation: r,
    precision: o,
    wordSize: l
  } = normalizeFormatOptions(n);
  switch (r) {
    case "fixed":
      return toFixed(e, o);
    case "exponential":
      return toExponential(e, o);
    case "engineering":
      return toEngineering(e, o);
    case "bin":
      return formatBigNumberToBase(e, 2, l);
    case "oct":
      return formatBigNumberToBase(e, 8, l);
    case "hex":
      return formatBigNumberToBase(e, 16, l);
    case "auto": {
      var u = _toNumberOrDefault(n == null ? void 0 : n.lowerExp, -3), h = _toNumberOrDefault(n == null ? void 0 : n.upperExp, 5);
      if (e.isZero())
        return "0";
      var c, f = e.toSignificantDigits(o), v = f.e;
      return v >= u && v < h ? c = f.toFixed() : c = toExponential(e, o), c.replace(/((\.\d*?)(0+))($|e)/, function() {
        var m = arguments[2], g = arguments[4];
        return m !== "." ? m + g : g;
      });
    }
    default:
      throw new Error('Unknown notation "' + r + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function toEngineering(e, n) {
  var r = e.e, o = r % 3 === 0 ? r : r < 0 ? r - 3 - r % 3 : r - r % 3, l = e.mul(Math.pow(10, -o)), u = l.toPrecision(n);
  if (u.indexOf("e") !== -1) {
    var h = e.constructor;
    u = new h(u).toFixed();
  }
  return u + "e" + (r >= 0 ? "+" : "") + o.toString();
}
function toExponential(e, n) {
  return n !== void 0 ? e.toExponential(n - 1) : e.toExponential();
}
function toFixed(e, n) {
  return e.toFixed(n);
}
function _toNumberOrDefault(e, n) {
  return isNumber$1(e) ? e : isBigNumber(e) ? e.toNumber() : n;
}
function format(e, n) {
  var r = _format(e, n);
  return n && typeof n == "object" && "truncate" in n && r.length > n.truncate ? r.substring(0, n.truncate - 3) + "..." : r;
}
function _format(e, n) {
  if (typeof e == "number")
    return format$2(e, n);
  if (isBigNumber(e))
    return format$1(e, n);
  if (looksLikeFraction(e))
    return !n || n.fraction !== "decimal" ? e.s * e.n + "/" + e.d : e.toString();
  if (Array.isArray(e))
    return formatArray(e, n);
  if (isString$1(e))
    return stringify(e);
  if (typeof e == "function")
    return e.syntax ? String(e.syntax) : "function";
  if (e && typeof e == "object") {
    if (typeof e.format == "function")
      return e.format(n);
    if (e && e.toString(n) !== {}.toString())
      return e.toString(n);
    var r = Object.keys(e).map((o) => stringify(o) + ": " + format(e[o], n));
    return "{" + r.join(", ") + "}";
  }
  return String(e);
}
function stringify(e) {
  for (var n = String(e), r = "", o = 0; o < n.length; ) {
    var l = n.charAt(o);
    r += l in controlCharacters ? controlCharacters[l] : l, o++;
  }
  return '"' + r + '"';
}
var controlCharacters = {
  '"': '\\"',
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
function formatArray(e, n) {
  if (Array.isArray(e)) {
    for (var r = "[", o = e.length, l = 0; l < o; l++)
      l !== 0 && (r += ", "), r += formatArray(e[l], n);
    return r += "]", r;
  } else
    return format(e, n);
}
function looksLikeFraction(e) {
  return e && typeof e == "object" && typeof e.s == "number" && typeof e.n == "number" && typeof e.d == "number" || !1;
}
function DimensionError(e, n, r) {
  if (!(this instanceof DimensionError))
    throw new SyntaxError("Constructor must be called with the new operator");
  this.actual = e, this.expected = n, this.relation = r, this.message = "Dimension mismatch (" + (Array.isArray(e) ? "[" + e.join(", ") + "]" : e) + " " + (this.relation || "!=") + " " + (Array.isArray(n) ? "[" + n.join(", ") + "]" : n) + ")", this.stack = new Error().stack;
}
DimensionError.prototype = new RangeError();
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = "DimensionError";
DimensionError.prototype.isDimensionError = !0;
function IndexError(e, n, r) {
  if (!(this instanceof IndexError))
    throw new SyntaxError("Constructor must be called with the new operator");
  this.index = e, arguments.length < 3 ? (this.min = 0, this.max = n) : (this.min = n, this.max = r), this.min !== void 0 && this.index < this.min ? this.message = "Index out of range (" + this.index + " < " + this.min + ")" : this.max !== void 0 && this.index >= this.max ? this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")" : this.message = "Index out of range (" + this.index + ")", this.stack = new Error().stack;
}
IndexError.prototype = new RangeError();
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = "IndexError";
IndexError.prototype.isIndexError = !0;
function arraySize(e) {
  for (var n = []; Array.isArray(e); )
    n.push(e.length), e = e[0];
  return n;
}
function _validate(e, n, r) {
  var o, l = e.length;
  if (l !== n[r])
    throw new DimensionError(l, n[r]);
  if (r < n.length - 1) {
    var u = r + 1;
    for (o = 0; o < l; o++) {
      var h = e[o];
      if (!Array.isArray(h))
        throw new DimensionError(n.length - 1, n.length, "<");
      _validate(e[o], n, u);
    }
  } else
    for (o = 0; o < l; o++)
      if (Array.isArray(e[o]))
        throw new DimensionError(n.length + 1, n.length, ">");
}
function validate(e, n) {
  var r = n.length === 0;
  if (r) {
    if (Array.isArray(e))
      throw new DimensionError(e.length, 0);
  } else
    _validate(e, n, 0);
}
function validateIndex(e, n) {
  if (e !== void 0) {
    if (!isNumber$1(e) || !isInteger$1(e))
      throw new TypeError("Index must be an integer (value: " + e + ")");
    if (e < 0 || typeof n == "number" && e >= n)
      throw new IndexError(e, n);
  }
}
function resize(e, n, r) {
  if (!Array.isArray(n))
    throw new TypeError("Array expected");
  if (n.length === 0)
    throw new Error("Resizing to scalar is not supported");
  n.forEach(function(l) {
    if (!isNumber$1(l) || !isInteger$1(l) || l < 0)
      throw new TypeError("Invalid size, must contain positive integers (size: " + format(n) + ")");
  }), (isNumber$1(e) || isBigNumber(e)) && (e = [e]);
  var o = r !== void 0 ? r : 0;
  return _resize(e, n, 0, o), e;
}
function _resize(e, n, r, o) {
  var l, u, h = e.length, c = n[r], f = Math.min(h, c);
  if (e.length = c, r < n.length - 1) {
    var v = r + 1;
    for (l = 0; l < f; l++)
      u = e[l], Array.isArray(u) || (u = [u], e[l] = u), _resize(u, n, v, o);
    for (l = f; l < c; l++)
      u = [], e[l] = u, _resize(u, n, v, o);
  } else {
    for (l = 0; l < f; l++)
      for (; Array.isArray(e[l]); )
        e[l] = e[l][0];
    for (l = f; l < c; l++)
      e[l] = o;
  }
}
function reshape(e, n) {
  var r = flatten(e), o = r.length;
  if (!Array.isArray(e) || !Array.isArray(n))
    throw new TypeError("Array expected");
  if (n.length === 0)
    throw new DimensionError(0, o, "!=");
  n = processSizesWildcard(n, o);
  var l = product(n);
  if (o !== l)
    throw new DimensionError(l, o, "!=");
  try {
    return _reshape(r, n);
  } catch (u) {
    throw u instanceof DimensionError ? new DimensionError(l, o, "!=") : u;
  }
}
function processSizesWildcard(e, n) {
  var r = product(e), o = e.slice(), l = -1, u = e.indexOf(l), h = e.indexOf(l, u + 1) >= 0;
  if (h)
    throw new Error("More than one wildcard in sizes");
  var c = u >= 0, f = n % r === 0;
  if (c)
    if (f)
      o[u] = -n / r;
    else
      throw new Error("Could not replace wildcard, since " + n + " is no multiple of " + -r);
  return o;
}
function product(e) {
  return e.reduce((n, r) => n * r, 1);
}
function _reshape(e, n) {
  for (var r = e, o, l = n.length - 1; l > 0; l--) {
    var u = n[l];
    o = [];
    for (var h = r.length / u, c = 0; c < h; c++)
      o.push(r.slice(c * u, (c + 1) * u));
    r = o;
  }
  return r;
}
function unsqueeze(e, n, r, o) {
  var l = o || arraySize(e);
  if (r)
    for (var u = 0; u < r; u++)
      e = [e], l.unshift(1);
  for (e = _unsqueeze(e, n, 0); l.length < n; )
    l.push(1);
  return e;
}
function _unsqueeze(e, n, r) {
  var o, l;
  if (Array.isArray(e)) {
    var u = r + 1;
    for (o = 0, l = e.length; o < l; o++)
      e[o] = _unsqueeze(e[o], n, u);
  } else
    for (var h = r; h < n; h++)
      e = [e];
  return e;
}
function flatten(e) {
  if (!Array.isArray(e))
    return e;
  var n = [];
  return e.forEach(function r(o) {
    Array.isArray(o) ? o.forEach(r) : n.push(o);
  }), n;
}
function getArrayDataType(e, n) {
  for (var r, o = 0, l = 0; l < e.length; l++) {
    var u = e[l], h = Array.isArray(u);
    if (l === 0 && h && (o = u.length), h && u.length !== o)
      return;
    var c = h ? getArrayDataType(u, n) : n(u);
    if (r === void 0)
      r = c;
    else if (r !== c)
      return "mixed";
  }
  return r;
}
function concatRecursive(e, n, r, o) {
  if (o < r) {
    if (e.length !== n.length)
      throw new DimensionError(e.length, n.length);
    for (var l = [], u = 0; u < e.length; u++)
      l[u] = concatRecursive(e[u], n[u], r, o + 1);
    return l;
  } else
    return e.concat(n);
}
function concat$1() {
  var e = Array.prototype.slice.call(arguments, 0, -1), n = Array.prototype.slice.call(arguments, -1);
  if (e.length === 1)
    return e[0];
  if (e.length > 1)
    return e.slice(1).reduce(function(r, o) {
      return concatRecursive(r, o, n, 0);
    }, e[0]);
  throw new Error("Wrong number of arguments in function concat");
}
function broadcastSizes() {
  for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
    n[r] = arguments[r];
  for (var o = n.map((y) => y.length), l = Math.max(...o), u = new Array(l).fill(null), h = 0; h < n.length; h++)
    for (var c = n[h], f = o[h], v = 0; v < f; v++) {
      var m = l - f + v;
      c[v] > u[m] && (u[m] = c[v]);
    }
  for (var g = 0; g < n.length; g++)
    checkBroadcastingRules(n[g], u);
  return u;
}
function checkBroadcastingRules(e, n) {
  for (var r = n.length, o = e.length, l = 0; l < o; l++) {
    var u = r - o + l;
    if (e[l] < n[u] && e[l] > 1 || e[l] > n[u])
      throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(e, ") not possible to broadcast dimension ").concat(o, " with size ").concat(e[l], " to size ").concat(n[u]));
  }
}
function broadcastTo(e, n) {
  var r = arraySize(e);
  if (deepStrictEqual(r, n))
    return e;
  checkBroadcastingRules(r, n);
  var o = broadcastSizes(r, n), l = o.length, u = [...Array(l - r.length).fill(1), ...r], h = clone$1(e);
  r.length < l && (h = reshape(h, u), r = arraySize(h));
  for (var c = 0; c < l; c++)
    r[c] < o[c] && (h = stretch(h, o[c], c), r = arraySize(h));
  return h;
}
function stretch(e, n, r) {
  return concat$1(...Array(n).fill(e), r);
}
function clone$1(e) {
  return _extends([], e);
}
function factory(e, n, r, o) {
  function l(u) {
    var h = pickShallow(u, n.map(stripOptionalNotation));
    return assertDependencies(e, n, u), r(h);
  }
  return l.isFactory = !0, l.fn = e, l.dependencies = n.slice().sort(), o && (l.meta = o), l;
}
function assertDependencies(e, n, r) {
  var o = n.filter((u) => !isOptionalDependency(u)).every((u) => r[u] !== void 0);
  if (!o) {
    var l = n.filter((u) => r[u] === void 0);
    throw new Error('Cannot create function "'.concat(e, '", ') + "some dependencies are missing: ".concat(l.map((u) => '"'.concat(u, '"')).join(", "), "."));
  }
}
function isOptionalDependency(e) {
  return e && e[0] === "?";
}
function stripOptionalNotation(e) {
  return e && e[0] === "?" ? e.slice(1) : e;
}
function getSafeProperty(e, n) {
  if (isPlainObject$1(e) && isSafeProperty(e, n))
    return e[n];
  throw typeof e[n] == "function" && isSafeMethod(e, n) ? new Error('Cannot access method "' + n + '" as a property') : new Error('No access to property "' + n + '"');
}
function setSafeProperty(e, n, r) {
  if (isPlainObject$1(e) && isSafeProperty(e, n))
    return e[n] = r, r;
  throw new Error('No access to property "' + n + '"');
}
function hasSafeProperty(e, n) {
  return n in e;
}
function isSafeProperty(e, n) {
  return !e || typeof e != "object" ? !1 : hasOwnProperty$1(safeNativeProperties, n) ? !0 : !(n in Object.prototype || n in Function.prototype);
}
function isSafeMethod(e, n) {
  return e == null || typeof e[n] != "function" || hasOwnProperty$1(e, n) && Object.getPrototypeOf && n in Object.getPrototypeOf(e) ? !1 : hasOwnProperty$1(safeNativeMethods, n) ? !0 : !(n in Object.prototype || n in Function.prototype);
}
function isPlainObject$1(e) {
  return typeof e == "object" && e && e.constructor === Object;
}
var safeNativeProperties = {
  length: !0,
  name: !0
}, safeNativeMethods = {
  toString: !0,
  valueOf: !0,
  toLocaleString: !0
};
class ObjectWrappingMap {
  constructor(n) {
    this.wrappedObject = n, this[Symbol.iterator] = this.entries;
  }
  keys() {
    return Object.keys(this.wrappedObject).values();
  }
  get(n) {
    return getSafeProperty(this.wrappedObject, n);
  }
  set(n, r) {
    return setSafeProperty(this.wrappedObject, n, r), this;
  }
  has(n) {
    return hasSafeProperty(this.wrappedObject, n);
  }
  entries() {
    return mapIterator(this.keys(), (n) => [n, this.get(n)]);
  }
  forEach(n) {
    for (var r of this.keys())
      n(this.get(r), r, this);
  }
  delete(n) {
    delete this.wrappedObject[n];
  }
  clear() {
    for (var n of this.keys())
      this.delete(n);
  }
  get size() {
    return Object.keys(this.wrappedObject).length;
  }
}
function mapIterator(e, n) {
  return {
    next: () => {
      var r = e.next();
      return r.done ? r : {
        value: n(r.value),
        done: !1
      };
    }
  };
}
function isMap(e) {
  return e ? e instanceof Map || e instanceof ObjectWrappingMap || typeof e.set == "function" && typeof e.get == "function" && typeof e.keys == "function" && typeof e.has == "function" : !1;
}
var _createTyped2 = function() {
  return _createTyped2 = typedFunction.create, typedFunction;
}, dependencies$u = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"], createTyped = /* @__PURE__ */ factory("typed", dependencies$u, function(n) {
  var {
    BigNumber: r,
    Complex: o,
    DenseMatrix: l,
    Fraction: u
  } = n, h = _createTyped2();
  return h.clear(), h.addTypes([
    {
      name: "number",
      test: isNumber$1
    },
    {
      name: "Complex",
      test: isComplex
    },
    {
      name: "BigNumber",
      test: isBigNumber
    },
    {
      name: "Fraction",
      test: isFraction
    },
    {
      name: "Unit",
      test: isUnit
    },
    // The following type matches a valid variable name, i.e., an alphanumeric
    // string starting with an alphabetic character. It is used (at least)
    // in the definition of the derivative() function, as the argument telling
    // what to differentiate over must (currently) be a variable.
    {
      name: "identifier",
      test: (c) => isString$1 && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(c)
    },
    {
      name: "string",
      test: isString$1
    },
    {
      name: "Chain",
      test: isChain
    },
    {
      name: "Array",
      test: isArray$1
    },
    {
      name: "Matrix",
      test: isMatrix
    },
    {
      name: "DenseMatrix",
      test: isDenseMatrix
    },
    {
      name: "SparseMatrix",
      test: isSparseMatrix
    },
    {
      name: "Range",
      test: isRange
    },
    {
      name: "Index",
      test: isIndex
    },
    {
      name: "boolean",
      test: isBoolean$1
    },
    {
      name: "ResultSet",
      test: isResultSet
    },
    {
      name: "Help",
      test: isHelp
    },
    {
      name: "function",
      test: isFunction$1
    },
    {
      name: "Date",
      test: isDate$1
    },
    {
      name: "RegExp",
      test: isRegExp$1
    },
    {
      name: "null",
      test: isNull
    },
    {
      name: "undefined",
      test: isUndefined$1
    },
    {
      name: "AccessorNode",
      test: isAccessorNode
    },
    {
      name: "ArrayNode",
      test: isArrayNode
    },
    {
      name: "AssignmentNode",
      test: isAssignmentNode
    },
    {
      name: "BlockNode",
      test: isBlockNode
    },
    {
      name: "ConditionalNode",
      test: isConditionalNode
    },
    {
      name: "ConstantNode",
      test: isConstantNode
    },
    {
      name: "FunctionNode",
      test: isFunctionNode
    },
    {
      name: "FunctionAssignmentNode",
      test: isFunctionAssignmentNode
    },
    {
      name: "IndexNode",
      test: isIndexNode
    },
    {
      name: "Node",
      test: isNode
    },
    {
      name: "ObjectNode",
      test: isObjectNode
    },
    {
      name: "OperatorNode",
      test: isOperatorNode
    },
    {
      name: "ParenthesisNode",
      test: isParenthesisNode
    },
    {
      name: "RangeNode",
      test: isRangeNode
    },
    {
      name: "RelationalNode",
      test: isRelationalNode
    },
    {
      name: "SymbolNode",
      test: isSymbolNode
    },
    {
      name: "Map",
      test: isMap
    },
    {
      name: "Object",
      test: isObject$1
    }
    // order 'Object' last, it matches on other classes too
  ]), h.addConversions([{
    from: "number",
    to: "BigNumber",
    convert: function(f) {
      if (r || throwNoBignumber(f), digits(f) > 15)
        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + f + "). Use function bignumber(x) to convert to BigNumber.");
      return new r(f);
    }
  }, {
    from: "number",
    to: "Complex",
    convert: function(f) {
      return o || throwNoComplex(f), new o(f, 0);
    }
  }, {
    from: "BigNumber",
    to: "Complex",
    convert: function(f) {
      return o || throwNoComplex(f), new o(f.toNumber(), 0);
    }
  }, {
    from: "Fraction",
    to: "BigNumber",
    convert: function(f) {
      throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
    }
  }, {
    from: "Fraction",
    to: "Complex",
    convert: function(f) {
      return o || throwNoComplex(f), new o(f.valueOf(), 0);
    }
  }, {
    from: "number",
    to: "Fraction",
    convert: function(f) {
      u || throwNoFraction(f);
      var v = new u(f);
      if (v.valueOf() !== f)
        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + f + "). Use function fraction(x) to convert to Fraction.");
      return v;
    }
  }, {
    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
    //  from: 'Fraction',
    //  to: 'number',
    //  convert: function (x) {
    //    return x.valueOf()
    //  }
    // }, {
    from: "string",
    to: "number",
    convert: function(f) {
      var v = Number(f);
      if (isNaN(v))
        throw new Error('Cannot convert "' + f + '" to a number');
      return v;
    }
  }, {
    from: "string",
    to: "BigNumber",
    convert: function(f) {
      r || throwNoBignumber(f);
      try {
        return new r(f);
      } catch {
        throw new Error('Cannot convert "' + f + '" to BigNumber');
      }
    }
  }, {
    from: "string",
    to: "Fraction",
    convert: function(f) {
      u || throwNoFraction(f);
      try {
        return new u(f);
      } catch {
        throw new Error('Cannot convert "' + f + '" to Fraction');
      }
    }
  }, {
    from: "string",
    to: "Complex",
    convert: function(f) {
      o || throwNoComplex(f);
      try {
        return new o(f);
      } catch {
        throw new Error('Cannot convert "' + f + '" to Complex');
      }
    }
  }, {
    from: "boolean",
    to: "number",
    convert: function(f) {
      return +f;
    }
  }, {
    from: "boolean",
    to: "BigNumber",
    convert: function(f) {
      return r || throwNoBignumber(f), new r(+f);
    }
  }, {
    from: "boolean",
    to: "Fraction",
    convert: function(f) {
      return u || throwNoFraction(f), new u(+f);
    }
  }, {
    from: "boolean",
    to: "string",
    convert: function(f) {
      return String(f);
    }
  }, {
    from: "Array",
    to: "Matrix",
    convert: function(f) {
      return l || throwNoMatrix(), new l(f);
    }
  }, {
    from: "Matrix",
    to: "Array",
    convert: function(f) {
      return f.valueOf();
    }
  }]), h.onMismatch = (c, f, v) => {
    var m = h.createError(c, f, v);
    if (["wrongType", "mismatch"].includes(m.data.category) && f.length === 1 && isCollection(f[0]) && // check if the function can be unary:
    v.some((y) => !y.params.includes(","))) {
      var g = new TypeError("Function '".concat(c, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(c, ")'."));
      throw g.data = m.data, g;
    }
    throw m;
  }, h.onMismatch = (c, f, v) => {
    var m = h.createError(c, f, v);
    if (["wrongType", "mismatch"].includes(m.data.category) && f.length === 1 && isCollection(f[0]) && // check if the function can be unary:
    v.some((y) => !y.params.includes(","))) {
      var g = new TypeError("Function '".concat(c, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(c, ")'."));
      throw g.data = m.data, g;
    }
    throw m;
  }, h;
});
function throwNoBignumber(e) {
  throw new Error("Cannot convert value ".concat(e, " into a BigNumber: no class 'BigNumber' provided"));
}
function throwNoComplex(e) {
  throw new Error("Cannot convert value ".concat(e, " into a Complex number: no class 'Complex' provided"));
}
function throwNoMatrix() {
  throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
}
function throwNoFraction(e) {
  throw new Error("Cannot convert value ".concat(e, " into a Fraction, no class 'Fraction' provided."));
}
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, inexact, quadrant, external = !0, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var e = new this.constructor(this);
  return e.s < 0 && (e.s = 1), finalise(e);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(e, n) {
  var r, o = this, l = o.constructor;
  if (e = new l(e), n = new l(n), !e.s || !n.s)
    return new l(NaN);
  if (e.gt(n))
    throw Error(invalidArgument + n);
  return r = o.cmp(e), r < 0 ? e : o.cmp(n) > 0 ? n : new l(o);
};
P.comparedTo = P.cmp = function(e) {
  var n, r, o, l, u = this, h = u.d, c = (e = new u.constructor(e)).d, f = u.s, v = e.s;
  if (!h || !c)
    return !f || !v ? NaN : f !== v ? f : h === c ? 0 : !h ^ f < 0 ? 1 : -1;
  if (!h[0] || !c[0])
    return h[0] ? f : c[0] ? -v : 0;
  if (f !== v)
    return f;
  if (u.e !== e.e)
    return u.e > e.e ^ f < 0 ? 1 : -1;
  for (o = h.length, l = c.length, n = 0, r = o < l ? o : l; n < r; ++n)
    if (h[n] !== c[n])
      return h[n] > c[n] ^ f < 0 ? 1 : -1;
  return o === l ? 0 : o > l ^ f < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var e, n, r = this, o = r.constructor;
  return r.d ? r.d[0] ? (e = o.precision, n = o.rounding, o.precision = e + Math.max(r.e, r.sd()) + LOG_BASE, o.rounding = 1, r = cosine(o, toLessThanHalfPi(o, r)), o.precision = e, o.rounding = n, finalise(quadrant == 2 || quadrant == 3 ? r.neg() : r, e, n, !0)) : new o(1) : new o(NaN);
};
P.cubeRoot = P.cbrt = function() {
  var e, n, r, o, l, u, h, c, f, v, m = this, g = m.constructor;
  if (!m.isFinite() || m.isZero())
    return new g(m);
  for (external = !1, u = m.s * mathpow(m.s * m, 1 / 3), !u || Math.abs(u) == 1 / 0 ? (r = digitsToString(m.d), e = m.e, (u = (e - r.length + 1) % 3) && (r += u == 1 || u == -2 ? "0" : "00"), u = mathpow(r, 1 / 3), e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), u == 1 / 0 ? r = "5e" + e : (r = u.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), o = new g(r), o.s = m.s) : o = new g(u.toString()), h = (e = g.precision) + 3; ; )
    if (c = o, f = c.times(c).times(c), v = f.plus(m), o = divide(v.plus(m).times(c), v.plus(f), h + 2, 1), digitsToString(c.d).slice(0, h) === (r = digitsToString(o.d)).slice(0, h))
      if (r = r.slice(h - 3, h + 1), r == "9999" || !l && r == "4999") {
        if (!l && (finalise(c, e + 1, 0), c.times(c).times(c).eq(m))) {
          o = c;
          break;
        }
        h += 4, l = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (finalise(o, e + 1, 1), n = !o.times(o).times(o).eq(m));
        break;
      }
  return external = !0, finalise(o, e, g.rounding, n);
};
P.decimalPlaces = P.dp = function() {
  var e, n = this.d, r = NaN;
  if (n) {
    if (e = n.length - 1, r = (e - mathfloor(this.e / LOG_BASE)) * LOG_BASE, e = n[e], e)
      for (; e % 10 == 0; e /= 10)
        r--;
    r < 0 && (r = 0);
  }
  return r;
};
P.dividedBy = P.div = function(e) {
  return divide(this, new this.constructor(e));
};
P.dividedToIntegerBy = P.divToInt = function(e) {
  var n = this, r = n.constructor;
  return finalise(divide(n, new r(e), 0, 1, 1), r.precision, r.rounding);
};
P.equals = P.eq = function(e) {
  return this.cmp(e) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(e) {
  return this.cmp(e) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(e) {
  var n = this.cmp(e);
  return n == 1 || n === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var e, n, r, o, l, u = this, h = u.constructor, c = new h(1);
  if (!u.isFinite())
    return new h(u.s ? 1 / 0 : NaN);
  if (u.isZero())
    return c;
  r = h.precision, o = h.rounding, h.precision = r + Math.max(u.e, u.sd()) + 4, h.rounding = 1, l = u.d.length, l < 32 ? (e = Math.ceil(l / 3), n = (1 / tinyPow(4, e)).toString()) : (e = 16, n = "2.3283064365386962890625e-10"), u = taylorSeries(h, 1, u.times(n), new h(1), !0);
  for (var f, v = e, m = new h(8); v--; )
    f = u.times(u), u = c.minus(f.times(m.minus(f.times(m))));
  return finalise(u, h.precision = r, h.rounding = o, !0);
};
P.hyperbolicSine = P.sinh = function() {
  var e, n, r, o, l = this, u = l.constructor;
  if (!l.isFinite() || l.isZero())
    return new u(l);
  if (n = u.precision, r = u.rounding, u.precision = n + Math.max(l.e, l.sd()) + 4, u.rounding = 1, o = l.d.length, o < 3)
    l = taylorSeries(u, 2, l, l, !0);
  else {
    e = 1.4 * Math.sqrt(o), e = e > 16 ? 16 : e | 0, l = l.times(1 / tinyPow(5, e)), l = taylorSeries(u, 2, l, l, !0);
    for (var h, c = new u(5), f = new u(16), v = new u(20); e--; )
      h = l.times(l), l = l.times(c.plus(h.times(f.times(h).plus(v))));
  }
  return u.precision = n, u.rounding = r, finalise(l, n, r, !0);
};
P.hyperbolicTangent = P.tanh = function() {
  var e, n, r = this, o = r.constructor;
  return r.isFinite() ? r.isZero() ? new o(r) : (e = o.precision, n = o.rounding, o.precision = e + 7, o.rounding = 1, divide(r.sinh(), r.cosh(), o.precision = e, o.rounding = n)) : new o(r.s);
};
P.inverseCosine = P.acos = function() {
  var e, n = this, r = n.constructor, o = n.abs().cmp(1), l = r.precision, u = r.rounding;
  return o !== -1 ? o === 0 ? n.isNeg() ? getPi(r, l, u) : new r(0) : new r(NaN) : n.isZero() ? getPi(r, l + 4, u).times(0.5) : (r.precision = l + 6, r.rounding = 1, n = n.asin(), e = getPi(r, l + 4, u).times(0.5), r.precision = l, r.rounding = u, e.minus(n));
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var e, n, r = this, o = r.constructor;
  return r.lte(1) ? new o(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = o.precision, n = o.rounding, o.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, o.rounding = 1, external = !1, r = r.times(r).minus(1).sqrt().plus(r), external = !0, o.precision = e, o.rounding = n, r.ln()) : new o(r);
};
P.inverseHyperbolicSine = P.asinh = function() {
  var e, n, r = this, o = r.constructor;
  return !r.isFinite() || r.isZero() ? new o(r) : (e = o.precision, n = o.rounding, o.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, o.rounding = 1, external = !1, r = r.times(r).plus(1).sqrt().plus(r), external = !0, o.precision = e, o.rounding = n, r.ln());
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var e, n, r, o, l = this, u = l.constructor;
  return l.isFinite() ? l.e >= 0 ? new u(l.abs().eq(1) ? l.s / 0 : l.isZero() ? l : NaN) : (e = u.precision, n = u.rounding, o = l.sd(), Math.max(o, e) < 2 * -l.e - 1 ? finalise(new u(l), e, n, !0) : (u.precision = r = o - l.e, l = divide(l.plus(1), new u(1).minus(l), r + e, 1), u.precision = e + 4, u.rounding = 1, l = l.ln(), u.precision = e, u.rounding = n, l.times(0.5))) : new u(NaN);
};
P.inverseSine = P.asin = function() {
  var e, n, r, o, l = this, u = l.constructor;
  return l.isZero() ? new u(l) : (n = l.abs().cmp(1), r = u.precision, o = u.rounding, n !== -1 ? n === 0 ? (e = getPi(u, r + 4, o).times(0.5), e.s = l.s, e) : new u(NaN) : (u.precision = r + 6, u.rounding = 1, l = l.div(new u(1).minus(l.times(l)).sqrt().plus(1)).atan(), u.precision = r, u.rounding = o, l.times(2)));
};
P.inverseTangent = P.atan = function() {
  var e, n, r, o, l, u, h, c, f, v = this, m = v.constructor, g = m.precision, y = m.rounding;
  if (v.isFinite()) {
    if (v.isZero())
      return new m(v);
    if (v.abs().eq(1) && g + 4 <= PI_PRECISION)
      return h = getPi(m, g + 4, y).times(0.25), h.s = v.s, h;
  } else {
    if (!v.s)
      return new m(NaN);
    if (g + 4 <= PI_PRECISION)
      return h = getPi(m, g + 4, y).times(0.5), h.s = v.s, h;
  }
  for (m.precision = c = g + 10, m.rounding = 1, r = Math.min(28, c / LOG_BASE + 2 | 0), e = r; e; --e)
    v = v.div(v.times(v).plus(1).sqrt().plus(1));
  for (external = !1, n = Math.ceil(c / LOG_BASE), o = 1, f = v.times(v), h = new m(v), l = v; e !== -1; )
    if (l = l.times(f), u = h.minus(l.div(o += 2)), l = l.times(f), h = u.plus(l.div(o += 2)), h.d[n] !== void 0)
      for (e = n; h.d[e] === u.d[e] && e--; )
        ;
  return r && (h = h.times(2 << r - 1)), external = !0, finalise(h, m.precision = g, m.rounding = y, !0);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(e) {
  return this.cmp(e) < 0;
};
P.lessThanOrEqualTo = P.lte = function(e) {
  return this.cmp(e) < 1;
};
P.logarithm = P.log = function(e) {
  var n, r, o, l, u, h, c, f, v = this, m = v.constructor, g = m.precision, y = m.rounding, w = 5;
  if (e == null)
    e = new m(10), n = !0;
  else {
    if (e = new m(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1))
      return new m(NaN);
    n = e.eq(10);
  }
  if (r = v.d, v.s < 0 || !r || !r[0] || v.eq(1))
    return new m(r && !r[0] ? -1 / 0 : v.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (n)
    if (r.length > 1)
      u = !0;
    else {
      for (l = r[0]; l % 10 === 0; )
        l /= 10;
      u = l !== 1;
    }
  if (external = !1, c = g + w, h = naturalLogarithm(v, c), o = n ? getLn10(m, c + 10) : naturalLogarithm(e, c), f = divide(h, o, c, 1), checkRoundingDigits(f.d, l = g, y))
    do
      if (c += 10, h = naturalLogarithm(v, c), o = n ? getLn10(m, c + 10) : naturalLogarithm(e, c), f = divide(h, o, c, 1), !u) {
        +digitsToString(f.d).slice(l + 1, l + 15) + 1 == 1e14 && (f = finalise(f, g + 1, 0));
        break;
      }
    while (checkRoundingDigits(f.d, l += 10, y));
  return external = !0, finalise(f, g, y);
};
P.minus = P.sub = function(e) {
  var n, r, o, l, u, h, c, f, v, m, g, y, w = this, E = w.constructor;
  if (e = new E(e), !w.d || !e.d)
    return !w.s || !e.s ? e = new E(NaN) : w.d ? e.s = -e.s : e = new E(e.d || w.s !== e.s ? w : NaN), e;
  if (w.s != e.s)
    return e.s = -e.s, w.plus(e);
  if (v = w.d, y = e.d, c = E.precision, f = E.rounding, !v[0] || !y[0]) {
    if (y[0])
      e.s = -e.s;
    else if (v[0])
      e = new E(w);
    else
      return new E(f === 3 ? -0 : 0);
    return external ? finalise(e, c, f) : e;
  }
  if (r = mathfloor(e.e / LOG_BASE), m = mathfloor(w.e / LOG_BASE), v = v.slice(), u = m - r, u) {
    for (g = u < 0, g ? (n = v, u = -u, h = y.length) : (n = y, r = m, h = v.length), o = Math.max(Math.ceil(c / LOG_BASE), h) + 2, u > o && (u = o, n.length = 1), n.reverse(), o = u; o--; )
      n.push(0);
    n.reverse();
  } else {
    for (o = v.length, h = y.length, g = o < h, g && (h = o), o = 0; o < h; o++)
      if (v[o] != y[o]) {
        g = v[o] < y[o];
        break;
      }
    u = 0;
  }
  for (g && (n = v, v = y, y = n, e.s = -e.s), h = v.length, o = y.length - h; o > 0; --o)
    v[h++] = 0;
  for (o = y.length; o > u; ) {
    if (v[--o] < y[o]) {
      for (l = o; l && v[--l] === 0; )
        v[l] = BASE - 1;
      --v[l], v[o] += BASE;
    }
    v[o] -= y[o];
  }
  for (; v[--h] === 0; )
    v.pop();
  for (; v[0] === 0; v.shift())
    --r;
  return v[0] ? (e.d = v, e.e = getBase10Exponent(v, r), external ? finalise(e, c, f) : e) : new E(f === 3 ? -0 : 0);
};
P.modulo = P.mod = function(e) {
  var n, r = this, o = r.constructor;
  return e = new o(e), !r.d || !e.s || e.d && !e.d[0] ? new o(NaN) : !e.d || r.d && !r.d[0] ? finalise(new o(r), o.precision, o.rounding) : (external = !1, o.modulo == 9 ? (n = divide(r, e.abs(), 0, 3, 1), n.s *= e.s) : n = divide(r, e, 0, o.modulo, 1), n = n.times(e), external = !0, r.minus(n));
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var e = new this.constructor(this);
  return e.s = -e.s, finalise(e);
};
P.plus = P.add = function(e) {
  var n, r, o, l, u, h, c, f, v, m, g = this, y = g.constructor;
  if (e = new y(e), !g.d || !e.d)
    return !g.s || !e.s ? e = new y(NaN) : g.d || (e = new y(e.d || g.s === e.s ? g : NaN)), e;
  if (g.s != e.s)
    return e.s = -e.s, g.minus(e);
  if (v = g.d, m = e.d, c = y.precision, f = y.rounding, !v[0] || !m[0])
    return m[0] || (e = new y(g)), external ? finalise(e, c, f) : e;
  if (u = mathfloor(g.e / LOG_BASE), o = mathfloor(e.e / LOG_BASE), v = v.slice(), l = u - o, l) {
    for (l < 0 ? (r = v, l = -l, h = m.length) : (r = m, o = u, h = v.length), u = Math.ceil(c / LOG_BASE), h = u > h ? u + 1 : h + 1, l > h && (l = h, r.length = 1), r.reverse(); l--; )
      r.push(0);
    r.reverse();
  }
  for (h = v.length, l = m.length, h - l < 0 && (l = h, r = m, m = v, v = r), n = 0; l; )
    n = (v[--l] = v[l] + m[l] + n) / BASE | 0, v[l] %= BASE;
  for (n && (v.unshift(n), ++o), h = v.length; v[--h] == 0; )
    v.pop();
  return e.d = v, e.e = getBase10Exponent(v, o), external ? finalise(e, c, f) : e;
};
P.precision = P.sd = function(e) {
  var n, r = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0)
    throw Error(invalidArgument + e);
  return r.d ? (n = getPrecision(r.d), e && r.e + 1 > n && (n = r.e + 1)) : n = NaN, n;
};
P.round = function() {
  var e = this, n = e.constructor;
  return finalise(new n(e), e.e + 1, n.rounding);
};
P.sine = P.sin = function() {
  var e, n, r = this, o = r.constructor;
  return r.isFinite() ? r.isZero() ? new o(r) : (e = o.precision, n = o.rounding, o.precision = e + Math.max(r.e, r.sd()) + LOG_BASE, o.rounding = 1, r = sine(o, toLessThanHalfPi(o, r)), o.precision = e, o.rounding = n, finalise(quadrant > 2 ? r.neg() : r, e, n, !0)) : new o(NaN);
};
P.squareRoot = P.sqrt = function() {
  var e, n, r, o, l, u, h = this, c = h.d, f = h.e, v = h.s, m = h.constructor;
  if (v !== 1 || !c || !c[0])
    return new m(!v || v < 0 && (!c || c[0]) ? NaN : c ? h : 1 / 0);
  for (external = !1, v = Math.sqrt(+h), v == 0 || v == 1 / 0 ? (n = digitsToString(c), (n.length + f) % 2 == 0 && (n += "0"), v = Math.sqrt(n), f = mathfloor((f + 1) / 2) - (f < 0 || f % 2), v == 1 / 0 ? n = "5e" + f : (n = v.toExponential(), n = n.slice(0, n.indexOf("e") + 1) + f), o = new m(n)) : o = new m(v.toString()), r = (f = m.precision) + 3; ; )
    if (u = o, o = u.plus(divide(h, u, r + 2, 1)).times(0.5), digitsToString(u.d).slice(0, r) === (n = digitsToString(o.d)).slice(0, r))
      if (n = n.slice(r - 3, r + 1), n == "9999" || !l && n == "4999") {
        if (!l && (finalise(u, f + 1, 0), u.times(u).eq(h))) {
          o = u;
          break;
        }
        r += 4, l = 1;
      } else {
        (!+n || !+n.slice(1) && n.charAt(0) == "5") && (finalise(o, f + 1, 1), e = !o.times(o).eq(h));
        break;
      }
  return external = !0, finalise(o, f, m.rounding, e);
};
P.tangent = P.tan = function() {
  var e, n, r = this, o = r.constructor;
  return r.isFinite() ? r.isZero() ? new o(r) : (e = o.precision, n = o.rounding, o.precision = e + 10, o.rounding = 1, r = r.sin(), r.s = 1, r = divide(r, new o(1).minus(r.times(r)).sqrt(), e + 10, 0), o.precision = e, o.rounding = n, finalise(quadrant == 2 || quadrant == 4 ? r.neg() : r, e, n, !0)) : new o(NaN);
};
P.times = P.mul = function(e) {
  var n, r, o, l, u, h, c, f, v, m = this, g = m.constructor, y = m.d, w = (e = new g(e)).d;
  if (e.s *= m.s, !y || !y[0] || !w || !w[0])
    return new g(!e.s || y && !y[0] && !w || w && !w[0] && !y ? NaN : !y || !w ? e.s / 0 : e.s * 0);
  for (r = mathfloor(m.e / LOG_BASE) + mathfloor(e.e / LOG_BASE), f = y.length, v = w.length, f < v && (u = y, y = w, w = u, h = f, f = v, v = h), u = [], h = f + v, o = h; o--; )
    u.push(0);
  for (o = v; --o >= 0; ) {
    for (n = 0, l = f + o; l > o; )
      c = u[l] + w[o] * y[l - o - 1] + n, u[l--] = c % BASE | 0, n = c / BASE | 0;
    u[l] = (u[l] + n) % BASE | 0;
  }
  for (; !u[--h]; )
    u.pop();
  return n ? ++r : u.shift(), e.d = u, e.e = getBase10Exponent(u, r), external ? finalise(e, g.precision, g.rounding) : e;
};
P.toBinary = function(e, n) {
  return toStringBinary(this, 2, e, n);
};
P.toDecimalPlaces = P.toDP = function(e, n) {
  var r = this, o = r.constructor;
  return r = new o(r), e === void 0 ? r : (checkInt32(e, 0, MAX_DIGITS), n === void 0 ? n = o.rounding : checkInt32(n, 0, 8), finalise(r, e + r.e + 1, n));
};
P.toExponential = function(e, n) {
  var r, o = this, l = o.constructor;
  return e === void 0 ? r = finiteToString(o, !0) : (checkInt32(e, 0, MAX_DIGITS), n === void 0 ? n = l.rounding : checkInt32(n, 0, 8), o = finalise(new l(o), e + 1, n), r = finiteToString(o, !0, e + 1)), o.isNeg() && !o.isZero() ? "-" + r : r;
};
P.toFixed = function(e, n) {
  var r, o, l = this, u = l.constructor;
  return e === void 0 ? r = finiteToString(l) : (checkInt32(e, 0, MAX_DIGITS), n === void 0 ? n = u.rounding : checkInt32(n, 0, 8), o = finalise(new u(l), e + l.e + 1, n), r = finiteToString(o, !1, e + o.e + 1)), l.isNeg() && !l.isZero() ? "-" + r : r;
};
P.toFraction = function(e) {
  var n, r, o, l, u, h, c, f, v, m, g, y, w = this, E = w.d, x = w.constructor;
  if (!E)
    return new x(w);
  if (v = r = new x(1), o = f = new x(0), n = new x(o), u = n.e = getPrecision(E) - w.e - 1, h = u % LOG_BASE, n.d[0] = mathpow(10, h < 0 ? LOG_BASE + h : h), e == null)
    e = u > 0 ? n : v;
  else {
    if (c = new x(e), !c.isInt() || c.lt(v))
      throw Error(invalidArgument + c);
    e = c.gt(n) ? u > 0 ? n : v : c;
  }
  for (external = !1, c = new x(digitsToString(E)), m = x.precision, x.precision = u = E.length * LOG_BASE * 2; g = divide(c, n, 0, 1, 1), l = r.plus(g.times(o)), l.cmp(e) != 1; )
    r = o, o = l, l = v, v = f.plus(g.times(l)), f = l, l = n, n = c.minus(g.times(l)), c = l;
  return l = divide(e.minus(r), o, 0, 1, 1), f = f.plus(l.times(v)), r = r.plus(l.times(o)), f.s = v.s = w.s, y = divide(v, o, u, 1).minus(w).abs().cmp(divide(f, r, u, 1).minus(w).abs()) < 1 ? [v, o] : [f, r], x.precision = m, external = !0, y;
};
P.toHexadecimal = P.toHex = function(e, n) {
  return toStringBinary(this, 16, e, n);
};
P.toNearest = function(e, n) {
  var r = this, o = r.constructor;
  if (r = new o(r), e == null) {
    if (!r.d)
      return r;
    e = new o(1), n = o.rounding;
  } else {
    if (e = new o(e), n === void 0 ? n = o.rounding : checkInt32(n, 0, 8), !r.d)
      return e.s ? r : e;
    if (!e.d)
      return e.s && (e.s = r.s), e;
  }
  return e.d[0] ? (external = !1, r = divide(r, e, 0, n, 1).times(e), external = !0, finalise(r)) : (e.s = r.s, r = e), r;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(e, n) {
  return toStringBinary(this, 8, e, n);
};
P.toPower = P.pow = function(e) {
  var n, r, o, l, u, h, c = this, f = c.constructor, v = +(e = new f(e));
  if (!c.d || !e.d || !c.d[0] || !e.d[0])
    return new f(mathpow(+c, v));
  if (c = new f(c), c.eq(1))
    return c;
  if (o = f.precision, u = f.rounding, e.eq(1))
    return finalise(c, o, u);
  if (n = mathfloor(e.e / LOG_BASE), n >= e.d.length - 1 && (r = v < 0 ? -v : v) <= MAX_SAFE_INTEGER)
    return l = intPow(f, c, r, o), e.s < 0 ? new f(1).div(l) : finalise(l, o, u);
  if (h = c.s, h < 0) {
    if (n < e.d.length - 1)
      return new f(NaN);
    if (e.d[n] & 1 || (h = 1), c.e == 0 && c.d[0] == 1 && c.d.length == 1)
      return c.s = h, c;
  }
  return r = mathpow(+c, v), n = r == 0 || !isFinite(r) ? mathfloor(v * (Math.log("0." + digitsToString(c.d)) / Math.LN10 + c.e + 1)) : new f(r + "").e, n > f.maxE + 1 || n < f.minE - 1 ? new f(n > 0 ? h / 0 : 0) : (external = !1, f.rounding = c.s = 1, r = Math.min(12, (n + "").length), l = naturalExponential(e.times(naturalLogarithm(c, o + r)), o), l.d && (l = finalise(l, o + 5, 1), checkRoundingDigits(l.d, o, u) && (n = o + 10, l = finalise(naturalExponential(e.times(naturalLogarithm(c, n + r)), n), n + 5, 1), +digitsToString(l.d).slice(o + 1, o + 15) + 1 == 1e14 && (l = finalise(l, o + 1, 0)))), l.s = h, external = !0, f.rounding = u, finalise(l, o, u));
};
P.toPrecision = function(e, n) {
  var r, o = this, l = o.constructor;
  return e === void 0 ? r = finiteToString(o, o.e <= l.toExpNeg || o.e >= l.toExpPos) : (checkInt32(e, 1, MAX_DIGITS), n === void 0 ? n = l.rounding : checkInt32(n, 0, 8), o = finalise(new l(o), e, n), r = finiteToString(o, e <= o.e || o.e <= l.toExpNeg, e)), o.isNeg() && !o.isZero() ? "-" + r : r;
};
P.toSignificantDigits = P.toSD = function(e, n) {
  var r = this, o = r.constructor;
  return e === void 0 ? (e = o.precision, n = o.rounding) : (checkInt32(e, 1, MAX_DIGITS), n === void 0 ? n = o.rounding : checkInt32(n, 0, 8)), finalise(new o(r), e, n);
};
P.toString = function() {
  var e = this, n = e.constructor, r = finiteToString(e, e.e <= n.toExpNeg || e.e >= n.toExpPos);
  return e.isNeg() && !e.isZero() ? "-" + r : r;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var e = this, n = e.constructor, r = finiteToString(e, e.e <= n.toExpNeg || e.e >= n.toExpPos);
  return e.isNeg() ? "-" + r : r;
};
function digitsToString(e) {
  var n, r, o, l = e.length - 1, u = "", h = e[0];
  if (l > 0) {
    for (u += h, n = 1; n < l; n++)
      o = e[n] + "", r = LOG_BASE - o.length, r && (u += getZeroString(r)), u += o;
    h = e[n], o = h + "", r = LOG_BASE - o.length, r && (u += getZeroString(r));
  } else if (h === 0)
    return "0";
  for (; h % 10 === 0; )
    h /= 10;
  return u + h;
}
function checkInt32(e, n, r) {
  if (e !== ~~e || e < n || e > r)
    throw Error(invalidArgument + e);
}
function checkRoundingDigits(e, n, r, o) {
  var l, u, h, c;
  for (u = e[0]; u >= 10; u /= 10)
    --n;
  return --n < 0 ? (n += LOG_BASE, l = 0) : (l = Math.ceil((n + 1) / LOG_BASE), n %= LOG_BASE), u = mathpow(10, LOG_BASE - n), c = e[l] % u | 0, o == null ? n < 3 ? (n == 0 ? c = c / 100 | 0 : n == 1 && (c = c / 10 | 0), h = r < 4 && c == 99999 || r > 3 && c == 49999 || c == 5e4 || c == 0) : h = (r < 4 && c + 1 == u || r > 3 && c + 1 == u / 2) && (e[l + 1] / u / 100 | 0) == mathpow(10, n - 2) - 1 || (c == u / 2 || c == 0) && (e[l + 1] / u / 100 | 0) == 0 : n < 4 ? (n == 0 ? c = c / 1e3 | 0 : n == 1 ? c = c / 100 | 0 : n == 2 && (c = c / 10 | 0), h = (o || r < 4) && c == 9999 || !o && r > 3 && c == 4999) : h = ((o || r < 4) && c + 1 == u || !o && r > 3 && c + 1 == u / 2) && (e[l + 1] / u / 1e3 | 0) == mathpow(10, n - 3) - 1, h;
}
function convertBase(e, n, r) {
  for (var o, l = [0], u, h = 0, c = e.length; h < c; ) {
    for (u = l.length; u--; )
      l[u] *= n;
    for (l[0] += NUMERALS.indexOf(e.charAt(h++)), o = 0; o < l.length; o++)
      l[o] > r - 1 && (l[o + 1] === void 0 && (l[o + 1] = 0), l[o + 1] += l[o] / r | 0, l[o] %= r);
  }
  return l.reverse();
}
function cosine(e, n) {
  var r, o, l;
  if (n.isZero())
    return n;
  o = n.d.length, o < 32 ? (r = Math.ceil(o / 3), l = (1 / tinyPow(4, r)).toString()) : (r = 16, l = "2.3283064365386962890625e-10"), e.precision += r, n = taylorSeries(e, 1, n.times(l), new e(1));
  for (var u = r; u--; ) {
    var h = n.times(n);
    n = h.times(h).minus(h).times(8).plus(1);
  }
  return e.precision -= r, n;
}
var divide = /* @__PURE__ */ function() {
  function e(o, l, u) {
    var h, c = 0, f = o.length;
    for (o = o.slice(); f--; )
      h = o[f] * l + c, o[f] = h % u | 0, c = h / u | 0;
    return c && o.unshift(c), o;
  }
  function n(o, l, u, h) {
    var c, f;
    if (u != h)
      f = u > h ? 1 : -1;
    else
      for (c = f = 0; c < u; c++)
        if (o[c] != l[c]) {
          f = o[c] > l[c] ? 1 : -1;
          break;
        }
    return f;
  }
  function r(o, l, u, h) {
    for (var c = 0; u--; )
      o[u] -= c, c = o[u] < l[u] ? 1 : 0, o[u] = c * h + o[u] - l[u];
    for (; !o[0] && o.length > 1; )
      o.shift();
  }
  return function(o, l, u, h, c, f) {
    var v, m, g, y, w, E, x, D, F, k, N, H, R, j, S, tt, nt, ft, pt, ct, Nt = o.constructor, kt = o.s == l.s ? 1 : -1, Rt = o.d, Mt = l.d;
    if (!Rt || !Rt[0] || !Mt || !Mt[0])
      return new Nt(
        // Return NaN if either NaN, or both Infinity or 0.
        !o.s || !l.s || (Rt ? Mt && Rt[0] == Mt[0] : !Mt) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          Rt && Rt[0] == 0 || !Mt ? kt * 0 : kt / 0
        )
      );
    for (f ? (w = 1, m = o.e - l.e) : (f = BASE, w = LOG_BASE, m = mathfloor(o.e / w) - mathfloor(l.e / w)), pt = Mt.length, nt = Rt.length, F = new Nt(kt), k = F.d = [], g = 0; Mt[g] == (Rt[g] || 0); g++)
      ;
    if (Mt[g] > (Rt[g] || 0) && m--, u == null ? (j = u = Nt.precision, h = Nt.rounding) : c ? j = u + (o.e - l.e) + 1 : j = u, j < 0)
      k.push(1), E = !0;
    else {
      if (j = j / w + 2 | 0, g = 0, pt == 1) {
        for (y = 0, Mt = Mt[0], j++; (g < nt || y) && j--; g++)
          S = y * f + (Rt[g] || 0), k[g] = S / Mt | 0, y = S % Mt | 0;
        E = y || g < nt;
      } else {
        for (y = f / (Mt[0] + 1) | 0, y > 1 && (Mt = e(Mt, y, f), Rt = e(Rt, y, f), pt = Mt.length, nt = Rt.length), tt = pt, N = Rt.slice(0, pt), H = N.length; H < pt; )
          N[H++] = 0;
        ct = Mt.slice(), ct.unshift(0), ft = Mt[0], Mt[1] >= f / 2 && ++ft;
        do
          y = 0, v = n(Mt, N, pt, H), v < 0 ? (R = N[0], pt != H && (R = R * f + (N[1] || 0)), y = R / ft | 0, y > 1 ? (y >= f && (y = f - 1), x = e(Mt, y, f), D = x.length, H = N.length, v = n(x, N, D, H), v == 1 && (y--, r(x, pt < D ? ct : Mt, D, f))) : (y == 0 && (v = y = 1), x = Mt.slice()), D = x.length, D < H && x.unshift(0), r(N, x, H, f), v == -1 && (H = N.length, v = n(Mt, N, pt, H), v < 1 && (y++, r(N, pt < H ? ct : Mt, H, f))), H = N.length) : v === 0 && (y++, N = [0]), k[g++] = y, v && N[0] ? N[H++] = Rt[tt] || 0 : (N = [Rt[tt]], H = 1);
        while ((tt++ < nt || N[0] !== void 0) && j--);
        E = N[0] !== void 0;
      }
      k[0] || k.shift();
    }
    if (w == 1)
      F.e = m, inexact = E;
    else {
      for (g = 1, y = k[0]; y >= 10; y /= 10)
        g++;
      F.e = g + m * w - 1, finalise(F, c ? u + F.e + 1 : u, h, E);
    }
    return F;
  };
}();
function finalise(e, n, r, o) {
  var l, u, h, c, f, v, m, g, y, w = e.constructor;
  t:
    if (n != null) {
      if (g = e.d, !g)
        return e;
      for (l = 1, c = g[0]; c >= 10; c /= 10)
        l++;
      if (u = n - l, u < 0)
        u += LOG_BASE, h = n, m = g[y = 0], f = m / mathpow(10, l - h - 1) % 10 | 0;
      else if (y = Math.ceil((u + 1) / LOG_BASE), c = g.length, y >= c)
        if (o) {
          for (; c++ <= y; )
            g.push(0);
          m = f = 0, l = 1, u %= LOG_BASE, h = u - LOG_BASE + 1;
        } else
          break t;
      else {
        for (m = c = g[y], l = 1; c >= 10; c /= 10)
          l++;
        u %= LOG_BASE, h = u - LOG_BASE + l, f = h < 0 ? 0 : m / mathpow(10, l - h - 1) % 10 | 0;
      }
      if (o = o || n < 0 || g[y + 1] !== void 0 || (h < 0 ? m : m % mathpow(10, l - h - 1)), v = r < 4 ? (f || o) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : f > 5 || f == 5 && (r == 4 || o || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (u > 0 ? h > 0 ? m / mathpow(10, l - h) : 0 : g[y - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), n < 1 || !g[0])
        return g.length = 0, v ? (n -= e.e + 1, g[0] = mathpow(10, (LOG_BASE - n % LOG_BASE) % LOG_BASE), e.e = -n || 0) : g[0] = e.e = 0, e;
      if (u == 0 ? (g.length = y, c = 1, y--) : (g.length = y + 1, c = mathpow(10, LOG_BASE - u), g[y] = h > 0 ? (m / mathpow(10, l - h) % mathpow(10, h) | 0) * c : 0), v)
        for (; ; )
          if (y == 0) {
            for (u = 1, h = g[0]; h >= 10; h /= 10)
              u++;
            for (h = g[0] += c, c = 1; h >= 10; h /= 10)
              c++;
            u != c && (e.e++, g[0] == BASE && (g[0] = 1));
            break;
          } else {
            if (g[y] += c, g[y] != BASE)
              break;
            g[y--] = 0, c = 1;
          }
      for (u = g.length; g[--u] === 0; )
        g.pop();
    }
  return external && (e.e > w.maxE ? (e.d = null, e.e = NaN) : e.e < w.minE && (e.e = 0, e.d = [0])), e;
}
function finiteToString(e, n, r) {
  if (!e.isFinite())
    return nonFiniteToString(e);
  var o, l = e.e, u = digitsToString(e.d), h = u.length;
  return n ? (r && (o = r - h) > 0 ? u = u.charAt(0) + "." + u.slice(1) + getZeroString(o) : h > 1 && (u = u.charAt(0) + "." + u.slice(1)), u = u + (e.e < 0 ? "e" : "e+") + e.e) : l < 0 ? (u = "0." + getZeroString(-l - 1) + u, r && (o = r - h) > 0 && (u += getZeroString(o))) : l >= h ? (u += getZeroString(l + 1 - h), r && (o = r - l - 1) > 0 && (u = u + "." + getZeroString(o))) : ((o = l + 1) < h && (u = u.slice(0, o) + "." + u.slice(o)), r && (o = r - h) > 0 && (l + 1 === h && (u += "."), u += getZeroString(o))), u;
}
function getBase10Exponent(e, n) {
  var r = e[0];
  for (n *= LOG_BASE; r >= 10; r /= 10)
    n++;
  return n;
}
function getLn10(e, n, r) {
  if (n > LN10_PRECISION)
    throw external = !0, r && (e.precision = r), Error(precisionLimitExceeded);
  return finalise(new e(LN10), n, 1, !0);
}
function getPi(e, n, r) {
  if (n > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new e(PI), n, r, !0);
}
function getPrecision(e) {
  var n = e.length - 1, r = n * LOG_BASE + 1;
  if (n = e[n], n) {
    for (; n % 10 == 0; n /= 10)
      r--;
    for (n = e[0]; n >= 10; n /= 10)
      r++;
  }
  return r;
}
function getZeroString(e) {
  for (var n = ""; e--; )
    n += "0";
  return n;
}
function intPow(e, n, r, o) {
  var l, u = new e(1), h = Math.ceil(o / LOG_BASE + 4);
  for (external = !1; ; ) {
    if (r % 2 && (u = u.times(n), truncate(u.d, h) && (l = !0)), r = mathfloor(r / 2), r === 0) {
      r = u.d.length - 1, l && u.d[r] === 0 && ++u.d[r];
      break;
    }
    n = n.times(n), truncate(n.d, h);
  }
  return external = !0, u;
}
function isOdd(e) {
  return e.d[e.d.length - 1] & 1;
}
function maxOrMin(e, n, r) {
  for (var o, l = new e(n[0]), u = 0; ++u < n.length; )
    if (o = new e(n[u]), o.s)
      l[r](o) && (l = o);
    else {
      l = o;
      break;
    }
  return l;
}
function naturalExponential(e, n) {
  var r, o, l, u, h, c, f, v = 0, m = 0, g = 0, y = e.constructor, w = y.rounding, E = y.precision;
  if (!e.d || !e.d[0] || e.e > 17)
    return new y(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
  for (n == null ? (external = !1, f = E) : f = n, c = new y(0.03125); e.e > -2; )
    e = e.times(c), g += 5;
  for (o = Math.log(mathpow(2, g)) / Math.LN10 * 2 + 5 | 0, f += o, r = u = h = new y(1), y.precision = f; ; ) {
    if (u = finalise(u.times(e), f, 1), r = r.times(++m), c = h.plus(divide(u, r, f, 1)), digitsToString(c.d).slice(0, f) === digitsToString(h.d).slice(0, f)) {
      for (l = g; l--; )
        h = finalise(h.times(h), f, 1);
      if (n == null)
        if (v < 3 && checkRoundingDigits(h.d, f - o, w, v))
          y.precision = f += 10, r = u = c = new y(1), m = 0, v++;
        else
          return finalise(h, y.precision = E, w, external = !0);
      else
        return y.precision = E, h;
    }
    h = c;
  }
}
function naturalLogarithm(e, n) {
  var r, o, l, u, h, c, f, v, m, g, y, w = 1, E = 10, x = e, D = x.d, F = x.constructor, k = F.rounding, N = F.precision;
  if (x.s < 0 || !D || !D[0] || !x.e && D[0] == 1 && D.length == 1)
    return new F(D && !D[0] ? -1 / 0 : x.s != 1 ? NaN : D ? 0 : x);
  if (n == null ? (external = !1, m = N) : m = n, F.precision = m += E, r = digitsToString(D), o = r.charAt(0), Math.abs(u = x.e) < 15e14) {
    for (; o < 7 && o != 1 || o == 1 && r.charAt(1) > 3; )
      x = x.times(e), r = digitsToString(x.d), o = r.charAt(0), w++;
    u = x.e, o > 1 ? (x = new F("0." + r), u++) : x = new F(o + "." + r.slice(1));
  } else
    return v = getLn10(F, m + 2, N).times(u + ""), x = naturalLogarithm(new F(o + "." + r.slice(1)), m - E).plus(v), F.precision = N, n == null ? finalise(x, N, k, external = !0) : x;
  for (g = x, f = h = x = divide(x.minus(1), x.plus(1), m, 1), y = finalise(x.times(x), m, 1), l = 3; ; ) {
    if (h = finalise(h.times(y), m, 1), v = f.plus(divide(h, new F(l), m, 1)), digitsToString(v.d).slice(0, m) === digitsToString(f.d).slice(0, m))
      if (f = f.times(2), u !== 0 && (f = f.plus(getLn10(F, m + 2, N).times(u + ""))), f = divide(f, new F(w), m, 1), n == null)
        if (checkRoundingDigits(f.d, m - E, k, c))
          F.precision = m += E, v = h = x = divide(g.minus(1), g.plus(1), m, 1), y = finalise(x.times(x), m, 1), l = c = 1;
        else
          return finalise(f, F.precision = N, k, external = !0);
      else
        return F.precision = N, f;
    f = v, l += 2;
  }
}
function nonFiniteToString(e) {
  return String(e.s * e.s / 0);
}
function parseDecimal(e, n) {
  var r, o, l;
  for ((r = n.indexOf(".")) > -1 && (n = n.replace(".", "")), (o = n.search(/e/i)) > 0 ? (r < 0 && (r = o), r += +n.slice(o + 1), n = n.substring(0, o)) : r < 0 && (r = n.length), o = 0; n.charCodeAt(o) === 48; o++)
    ;
  for (l = n.length; n.charCodeAt(l - 1) === 48; --l)
    ;
  if (n = n.slice(o, l), n) {
    if (l -= o, e.e = r = r - o - 1, e.d = [], o = (r + 1) % LOG_BASE, r < 0 && (o += LOG_BASE), o < l) {
      for (o && e.d.push(+n.slice(0, o)), l -= LOG_BASE; o < l; )
        e.d.push(+n.slice(o, o += LOG_BASE));
      n = n.slice(o), o = LOG_BASE - n.length;
    } else
      o -= l;
    for (; o--; )
      n += "0";
    e.d.push(+n), external && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
  } else
    e.e = 0, e.d = [0];
  return e;
}
function parseOther(e, n) {
  var r, o, l, u, h, c, f, v, m;
  if (n.indexOf("_") > -1) {
    if (n = n.replace(/(\d)_(?=\d)/g, "$1"), isDecimal.test(n))
      return parseDecimal(e, n);
  } else if (n === "Infinity" || n === "NaN")
    return +n || (e.s = NaN), e.e = NaN, e.d = null, e;
  if (isHex.test(n))
    r = 16, n = n.toLowerCase();
  else if (isBinary.test(n))
    r = 2;
  else if (isOctal.test(n))
    r = 8;
  else
    throw Error(invalidArgument + n);
  for (u = n.search(/p/i), u > 0 ? (f = +n.slice(u + 1), n = n.substring(2, u)) : n = n.slice(2), u = n.indexOf("."), h = u >= 0, o = e.constructor, h && (n = n.replace(".", ""), c = n.length, u = c - u, l = intPow(o, new o(r), u, u * 2)), v = convertBase(n, r, BASE), m = v.length - 1, u = m; v[u] === 0; --u)
    v.pop();
  return u < 0 ? new o(e.s * 0) : (e.e = getBase10Exponent(v, m), e.d = v, external = !1, h && (e = divide(e, l, c * 4)), f && (e = e.times(Math.abs(f) < 54 ? mathpow(2, f) : Decimal.pow(2, f))), external = !0, e);
}
function sine(e, n) {
  var r, o = n.d.length;
  if (o < 3)
    return n.isZero() ? n : taylorSeries(e, 2, n, n);
  r = 1.4 * Math.sqrt(o), r = r > 16 ? 16 : r | 0, n = n.times(1 / tinyPow(5, r)), n = taylorSeries(e, 2, n, n);
  for (var l, u = new e(5), h = new e(16), c = new e(20); r--; )
    l = n.times(n), n = n.times(u.plus(l.times(h.times(l).minus(c))));
  return n;
}
function taylorSeries(e, n, r, o, l) {
  var u, h, c, f, v = e.precision, m = Math.ceil(v / LOG_BASE);
  for (external = !1, f = r.times(r), c = new e(o); ; ) {
    if (h = divide(c.times(f), new e(n++ * n++), v, 1), c = l ? o.plus(h) : o.minus(h), o = divide(h.times(f), new e(n++ * n++), v, 1), h = c.plus(o), h.d[m] !== void 0) {
      for (u = m; h.d[u] === c.d[u] && u--; )
        ;
      if (u == -1)
        break;
    }
    u = c, c = o, o = h, h = u;
  }
  return external = !0, h.d.length = m + 1, h;
}
function tinyPow(e, n) {
  for (var r = e; --n; )
    r *= e;
  return r;
}
function toLessThanHalfPi(e, n) {
  var r, o = n.s < 0, l = getPi(e, e.precision, 1), u = l.times(0.5);
  if (n = n.abs(), n.lte(u))
    return quadrant = o ? 4 : 1, n;
  if (r = n.divToInt(l), r.isZero())
    quadrant = o ? 3 : 2;
  else {
    if (n = n.minus(r.times(l)), n.lte(u))
      return quadrant = isOdd(r) ? o ? 2 : 3 : o ? 4 : 1, n;
    quadrant = isOdd(r) ? o ? 1 : 4 : o ? 3 : 2;
  }
  return n.minus(l).abs();
}
function toStringBinary(e, n, r, o) {
  var l, u, h, c, f, v, m, g, y, w = e.constructor, E = r !== void 0;
  if (E ? (checkInt32(r, 1, MAX_DIGITS), o === void 0 ? o = w.rounding : checkInt32(o, 0, 8)) : (r = w.precision, o = w.rounding), !e.isFinite())
    m = nonFiniteToString(e);
  else {
    for (m = finiteToString(e), h = m.indexOf("."), E ? (l = 2, n == 16 ? r = r * 4 - 3 : n == 8 && (r = r * 3 - 2)) : l = n, h >= 0 && (m = m.replace(".", ""), y = new w(1), y.e = m.length - h, y.d = convertBase(finiteToString(y), 10, l), y.e = y.d.length), g = convertBase(m, 10, l), u = f = g.length; g[--f] == 0; )
      g.pop();
    if (!g[0])
      m = E ? "0p+0" : "0";
    else {
      if (h < 0 ? u-- : (e = new w(e), e.d = g, e.e = u, e = divide(e, y, r, o, 0, l), g = e.d, u = e.e, v = inexact), h = g[r], c = l / 2, v = v || g[r + 1] !== void 0, v = o < 4 ? (h !== void 0 || v) && (o === 0 || o === (e.s < 0 ? 3 : 2)) : h > c || h === c && (o === 4 || v || o === 6 && g[r - 1] & 1 || o === (e.s < 0 ? 8 : 7)), g.length = r, v)
        for (; ++g[--r] > l - 1; )
          g[r] = 0, r || (++u, g.unshift(1));
      for (f = g.length; !g[f - 1]; --f)
        ;
      for (h = 0, m = ""; h < f; h++)
        m += NUMERALS.charAt(g[h]);
      if (E) {
        if (f > 1)
          if (n == 16 || n == 8) {
            for (h = n == 16 ? 4 : 3, --f; f % h; f++)
              m += "0";
            for (g = convertBase(m, l, n), f = g.length; !g[f - 1]; --f)
              ;
            for (h = 1, m = "1."; h < f; h++)
              m += NUMERALS.charAt(g[h]);
          } else
            m = m.charAt(0) + "." + m.slice(1);
        m = m + (u < 0 ? "p" : "p+") + u;
      } else if (u < 0) {
        for (; ++u; )
          m = "0" + m;
        m = "0." + m;
      } else if (++u > f)
        for (u -= f; u--; )
          m += "0";
      else
        u < f && (m = m.slice(0, u) + "." + m.slice(u));
    }
    m = (n == 16 ? "0x" : n == 2 ? "0b" : n == 8 ? "0o" : "") + m;
  }
  return e.s < 0 ? "-" + m : m;
}
function truncate(e, n) {
  if (e.length > n)
    return e.length = n, !0;
}
function abs(e) {
  return new this(e).abs();
}
function acos(e) {
  return new this(e).acos();
}
function acosh(e) {
  return new this(e).acosh();
}
function add$1(e, n) {
  return new this(e).plus(n);
}
function asin(e) {
  return new this(e).asin();
}
function asinh(e) {
  return new this(e).asinh();
}
function atan(e) {
  return new this(e).atan();
}
function atanh(e) {
  return new this(e).atanh();
}
function atan2(e, n) {
  e = new this(e), n = new this(n);
  var r, o = this.precision, l = this.rounding, u = o + 4;
  return !e.s || !n.s ? r = new this(NaN) : !e.d && !n.d ? (r = getPi(this, u, 1).times(n.s > 0 ? 0.25 : 0.75), r.s = e.s) : !n.d || e.isZero() ? (r = n.s < 0 ? getPi(this, o, l) : new this(0), r.s = e.s) : !e.d || n.isZero() ? (r = getPi(this, u, 1).times(0.5), r.s = e.s) : n.s < 0 ? (this.precision = u, this.rounding = 1, r = this.atan(divide(e, n, u, 1)), n = getPi(this, u, 1), this.precision = o, this.rounding = l, r = e.s < 0 ? r.minus(n) : r.plus(n)) : r = this.atan(divide(e, n, u, 1)), r;
}
function cbrt(e) {
  return new this(e).cbrt();
}
function ceil(e) {
  return finalise(e = new this(e), e.e + 1, 2);
}
function clamp(e, n, r) {
  return new this(e).clamp(n, r);
}
function config(e) {
  if (!e || typeof e != "object")
    throw Error(decimalError + "Object expected");
  var n, r, o, l = e.defaults === !0, u = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (n = 0; n < u.length; n += 3)
    if (r = u[n], l && (this[r] = DEFAULTS[r]), (o = e[r]) !== void 0)
      if (mathfloor(o) === o && o >= u[n + 1] && o <= u[n + 2])
        this[r] = o;
      else
        throw Error(invalidArgument + r + ": " + o);
  if (r = "crypto", l && (this[r] = DEFAULTS[r]), (o = e[r]) !== void 0)
    if (o === !0 || o === !1 || o === 0 || o === 1)
      if (o)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(cryptoUnavailable);
      else
        this[r] = !1;
    else
      throw Error(invalidArgument + r + ": " + o);
  return this;
}
function cos$1(e) {
  return new this(e).cos();
}
function cosh$1(e) {
  return new this(e).cosh();
}
function clone(e) {
  var n, r, o;
  function l(u) {
    var h, c, f, v = this;
    if (!(v instanceof l))
      return new l(u);
    if (v.constructor = l, isDecimalInstance(u)) {
      v.s = u.s, external ? !u.d || u.e > l.maxE ? (v.e = NaN, v.d = null) : u.e < l.minE ? (v.e = 0, v.d = [0]) : (v.e = u.e, v.d = u.d.slice()) : (v.e = u.e, v.d = u.d ? u.d.slice() : u.d);
      return;
    }
    if (f = typeof u, f === "number") {
      if (u === 0) {
        v.s = 1 / u < 0 ? -1 : 1, v.e = 0, v.d = [0];
        return;
      }
      if (u < 0 ? (u = -u, v.s = -1) : v.s = 1, u === ~~u && u < 1e7) {
        for (h = 0, c = u; c >= 10; c /= 10)
          h++;
        external ? h > l.maxE ? (v.e = NaN, v.d = null) : h < l.minE ? (v.e = 0, v.d = [0]) : (v.e = h, v.d = [u]) : (v.e = h, v.d = [u]);
        return;
      } else if (u * 0 !== 0) {
        u || (v.s = NaN), v.e = NaN, v.d = null;
        return;
      }
      return parseDecimal(v, u.toString());
    } else if (f !== "string")
      throw Error(invalidArgument + u);
    return (c = u.charCodeAt(0)) === 45 ? (u = u.slice(1), v.s = -1) : (c === 43 && (u = u.slice(1)), v.s = 1), isDecimal.test(u) ? parseDecimal(v, u) : parseOther(v, u);
  }
  if (l.prototype = P, l.ROUND_UP = 0, l.ROUND_DOWN = 1, l.ROUND_CEIL = 2, l.ROUND_FLOOR = 3, l.ROUND_HALF_UP = 4, l.ROUND_HALF_DOWN = 5, l.ROUND_HALF_EVEN = 6, l.ROUND_HALF_CEIL = 7, l.ROUND_HALF_FLOOR = 8, l.EUCLID = 9, l.config = l.set = config, l.clone = clone, l.isDecimal = isDecimalInstance, l.abs = abs, l.acos = acos, l.acosh = acosh, l.add = add$1, l.asin = asin, l.asinh = asinh, l.atan = atan, l.atanh = atanh, l.atan2 = atan2, l.cbrt = cbrt, l.ceil = ceil, l.clamp = clamp, l.cos = cos$1, l.cosh = cosh$1, l.div = div, l.exp = exp, l.floor = floor, l.hypot = hypot$1, l.ln = ln, l.log = log, l.log10 = log10, l.log2 = log2, l.max = max, l.min = min, l.mod = mod, l.mul = mul, l.pow = pow, l.random = random, l.round = round, l.sign = sign$1, l.sin = sin$1, l.sinh = sinh$1, l.sqrt = sqrt, l.sub = sub, l.sum = sum, l.tan = tan, l.tanh = tanh, l.trunc = trunc, e === void 0 && (e = {}), e && e.defaults !== !0)
    for (o = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], n = 0; n < o.length; )
      e.hasOwnProperty(r = o[n++]) || (e[r] = this[r]);
  return l.config(e), l;
}
function div(e, n) {
  return new this(e).div(n);
}
function exp(e) {
  return new this(e).exp();
}
function floor(e) {
  return finalise(e = new this(e), e.e + 1, 3);
}
function hypot$1() {
  var e, n, r = new this(0);
  for (external = !1, e = 0; e < arguments.length; )
    if (n = new this(arguments[e++]), n.d)
      r.d && (r = r.plus(n.times(n)));
    else {
      if (n.s)
        return external = !0, new this(1 / 0);
      r = n;
    }
  return external = !0, r.sqrt();
}
function isDecimalInstance(e) {
  return e instanceof Decimal || e && e.toStringTag === tag || !1;
}
function ln(e) {
  return new this(e).ln();
}
function log(e, n) {
  return new this(e).log(n);
}
function log2(e) {
  return new this(e).log(2);
}
function log10(e) {
  return new this(e).log(10);
}
function max() {
  return maxOrMin(this, arguments, "lt");
}
function min() {
  return maxOrMin(this, arguments, "gt");
}
function mod(e, n) {
  return new this(e).mod(n);
}
function mul(e, n) {
  return new this(e).mul(n);
}
function pow(e, n) {
  return new this(e).pow(n);
}
function random(e) {
  var n, r, o, l, u = 0, h = new this(1), c = [];
  if (e === void 0 ? e = this.precision : checkInt32(e, 1, MAX_DIGITS), o = Math.ceil(e / LOG_BASE), this.crypto)
    if (crypto.getRandomValues)
      for (n = crypto.getRandomValues(new Uint32Array(o)); u < o; )
        l = n[u], l >= 429e7 ? n[u] = crypto.getRandomValues(new Uint32Array(1))[0] : c[u++] = l % 1e7;
    else if (crypto.randomBytes) {
      for (n = crypto.randomBytes(o *= 4); u < o; )
        l = n[u] + (n[u + 1] << 8) + (n[u + 2] << 16) + ((n[u + 3] & 127) << 24), l >= 214e7 ? crypto.randomBytes(4).copy(n, u) : (c.push(l % 1e7), u += 4);
      u = o / 4;
    } else
      throw Error(cryptoUnavailable);
  else
    for (; u < o; )
      c[u++] = Math.random() * 1e7 | 0;
  for (o = c[--u], e %= LOG_BASE, o && e && (l = mathpow(10, LOG_BASE - e), c[u] = (o / l | 0) * l); c[u] === 0; u--)
    c.pop();
  if (u < 0)
    r = 0, c = [0];
  else {
    for (r = -1; c[0] === 0; r -= LOG_BASE)
      c.shift();
    for (o = 1, l = c[0]; l >= 10; l /= 10)
      o++;
    o < LOG_BASE && (r -= LOG_BASE - o);
  }
  return h.e = r, h.d = c, h;
}
function round(e) {
  return finalise(e = new this(e), e.e + 1, this.rounding);
}
function sign$1(e) {
  return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
}
function sin$1(e) {
  return new this(e).sin();
}
function sinh$1(e) {
  return new this(e).sinh();
}
function sqrt(e) {
  return new this(e).sqrt();
}
function sub(e, n) {
  return new this(e).sub(n);
}
function sum() {
  var e = 0, n = arguments, r = new this(n[e]);
  for (external = !1; r.s && ++e < n.length; )
    r = r.plus(n[e]);
  return external = !0, finalise(r, this.precision, this.rounding);
}
function tan(e) {
  return new this(e).tan();
}
function tanh(e) {
  return new this(e).tanh();
}
function trunc(e) {
  return finalise(e = new this(e), e.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var name$u = "BigNumber", dependencies$t = ["?on", "config"], createBigNumberClass = /* @__PURE__ */ factory(name$u, dependencies$t, (e) => {
  var {
    on: n,
    config: r
  } = e, o = Decimal.clone({
    precision: r.precision,
    modulo: Decimal.EUCLID
  });
  return o.prototype = Object.create(o.prototype), o.prototype.type = "BigNumber", o.prototype.isBigNumber = !0, o.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  }, o.fromJSON = function(l) {
    return new o(l.value);
  }, n && n("config", function(l, u) {
    l.precision !== u.precision && o.config({
      precision: l.precision
    });
  }), o;
}, {
  isClass: !0
}), complex = { exports: {} };
/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
(function(e, n) {
  (function(r) {
    var o = Math.cosh || function(g) {
      return Math.abs(g) < 1e-9 ? 1 - g : (Math.exp(g) + Math.exp(-g)) * 0.5;
    }, l = Math.sinh || function(g) {
      return Math.abs(g) < 1e-9 ? g : (Math.exp(g) - Math.exp(-g)) * 0.5;
    }, u = function(g) {
      var y = Math.PI / 4;
      if (-y > g || g > y)
        return Math.cos(g) - 1;
      var w = g * g;
      return w * (w * (w * (w * (w * (w * (w * (w / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
    }, h = function(g, y) {
      var w = Math.abs(g), E = Math.abs(y);
      return w < 3e3 && E < 3e3 ? Math.sqrt(w * w + E * E) : (w < E ? (w = E, E = g / y) : E = y / g, w * Math.sqrt(1 + E * E));
    }, c = function() {
      throw SyntaxError("Invalid Param");
    };
    function f(g, y) {
      var w = Math.abs(g), E = Math.abs(y);
      return g === 0 ? Math.log(E) : y === 0 ? Math.log(w) : w < 3e3 && E < 3e3 ? Math.log(g * g + y * y) * 0.5 : (g = g / 2, y = y / 2, 0.5 * Math.log(g * g + y * y) + Math.LN2);
    }
    var v = function(g, y) {
      var w = { re: 0, im: 0 };
      if (g == null)
        w.re = w.im = 0;
      else if (y !== void 0)
        w.re = g, w.im = y;
      else
        switch (typeof g) {
          case "object":
            if ("im" in g && "re" in g)
              w.re = g.re, w.im = g.im;
            else if ("abs" in g && "arg" in g) {
              if (!Number.isFinite(g.abs) && Number.isFinite(g.arg))
                return m.INFINITY;
              w.re = g.abs * Math.cos(g.arg), w.im = g.abs * Math.sin(g.arg);
            } else if ("r" in g && "phi" in g) {
              if (!Number.isFinite(g.r) && Number.isFinite(g.phi))
                return m.INFINITY;
              w.re = g.r * Math.cos(g.phi), w.im = g.r * Math.sin(g.phi);
            } else
              g.length === 2 ? (w.re = g[0], w.im = g[1]) : c();
            break;
          case "string":
            w.im = /* void */
            w.re = 0;
            var E = g.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g), x = 1, D = 0;
            E === null && c();
            for (var F = 0; F < E.length; F++) {
              var k = E[F];
              k === " " || k === "	" || k === `
` || (k === "+" ? x++ : k === "-" ? D++ : k === "i" || k === "I" ? (x + D === 0 && c(), E[F + 1] !== " " && !isNaN(E[F + 1]) ? (w.im += parseFloat((D % 2 ? "-" : "") + E[F + 1]), F++) : w.im += parseFloat((D % 2 ? "-" : "") + "1"), x = D = 0) : ((x + D === 0 || isNaN(k)) && c(), E[F + 1] === "i" || E[F + 1] === "I" ? (w.im += parseFloat((D % 2 ? "-" : "") + k), F++) : w.re += parseFloat((D % 2 ? "-" : "") + k), x = D = 0));
            }
            x + D > 0 && c();
            break;
          case "number":
            w.im = 0, w.re = g;
            break;
          default:
            c();
        }
      return isNaN(w.re) || isNaN(w.im), w;
    };
    function m(g, y) {
      if (!(this instanceof m))
        return new m(g, y);
      var w = v(g, y);
      this.re = w.re, this.im = w.im;
    }
    m.prototype = {
      re: 0,
      im: 0,
      /**
       * Calculates the sign of a complex number, which is a normalized complex
       *
       * @returns {Complex}
       */
      sign: function() {
        var g = this.abs();
        return new m(
          this.re / g,
          this.im / g
        );
      },
      /**
       * Adds two complex numbers
       *
       * @returns {Complex}
       */
      add: function(g, y) {
        var w = new m(g, y);
        return this.isInfinite() && w.isInfinite() ? m.NAN : this.isInfinite() || w.isInfinite() ? m.INFINITY : new m(
          this.re + w.re,
          this.im + w.im
        );
      },
      /**
       * Subtracts two complex numbers
       *
       * @returns {Complex}
       */
      sub: function(g, y) {
        var w = new m(g, y);
        return this.isInfinite() && w.isInfinite() ? m.NAN : this.isInfinite() || w.isInfinite() ? m.INFINITY : new m(
          this.re - w.re,
          this.im - w.im
        );
      },
      /**
       * Multiplies two complex numbers
       *
       * @returns {Complex}
       */
      mul: function(g, y) {
        var w = new m(g, y);
        return this.isInfinite() && w.isZero() || this.isZero() && w.isInfinite() ? m.NAN : this.isInfinite() || w.isInfinite() ? m.INFINITY : w.im === 0 && this.im === 0 ? new m(this.re * w.re, 0) : new m(
          this.re * w.re - this.im * w.im,
          this.re * w.im + this.im * w.re
        );
      },
      /**
       * Divides two complex numbers
       *
       * @returns {Complex}
       */
      div: function(g, y) {
        var w = new m(g, y);
        if (this.isZero() && w.isZero() || this.isInfinite() && w.isInfinite())
          return m.NAN;
        if (this.isInfinite() || w.isZero())
          return m.INFINITY;
        if (this.isZero() || w.isInfinite())
          return m.ZERO;
        g = this.re, y = this.im;
        var E = w.re, x = w.im, D, F;
        return x === 0 ? new m(g / E, y / E) : Math.abs(E) < Math.abs(x) ? (F = E / x, D = E * F + x, new m(
          (g * F + y) / D,
          (y * F - g) / D
        )) : (F = x / E, D = x * F + E, new m(
          (g + y * F) / D,
          (y - g * F) / D
        ));
      },
      /**
       * Calculate the power of two complex numbers
       *
       * @returns {Complex}
       */
      pow: function(g, y) {
        var w = new m(g, y);
        if (g = this.re, y = this.im, w.isZero())
          return m.ONE;
        if (w.im === 0) {
          if (y === 0 && g > 0)
            return new m(Math.pow(g, w.re), 0);
          if (g === 0)
            switch ((w.re % 4 + 4) % 4) {
              case 0:
                return new m(Math.pow(y, w.re), 0);
              case 1:
                return new m(0, Math.pow(y, w.re));
              case 2:
                return new m(-Math.pow(y, w.re), 0);
              case 3:
                return new m(0, -Math.pow(y, w.re));
            }
        }
        if (g === 0 && y === 0 && w.re > 0 && w.im >= 0)
          return m.ZERO;
        var E = Math.atan2(y, g), x = f(g, y);
        return g = Math.exp(w.re * x - w.im * E), y = w.im * x + w.re * E, new m(
          g * Math.cos(y),
          g * Math.sin(y)
        );
      },
      /**
       * Calculate the complex square root
       *
       * @returns {Complex}
       */
      sqrt: function() {
        var g = this.re, y = this.im, w = this.abs(), E, x;
        if (g >= 0) {
          if (y === 0)
            return new m(Math.sqrt(g), 0);
          E = 0.5 * Math.sqrt(2 * (w + g));
        } else
          E = Math.abs(y) / Math.sqrt(2 * (w - g));
        return g <= 0 ? x = 0.5 * Math.sqrt(2 * (w - g)) : x = Math.abs(y) / Math.sqrt(2 * (w + g)), new m(E, y < 0 ? -x : x);
      },
      /**
       * Calculate the complex exponent
       *
       * @returns {Complex}
       */
      exp: function() {
        var g = Math.exp(this.re);
        return this.im, new m(
          g * Math.cos(this.im),
          g * Math.sin(this.im)
        );
      },
      /**
       * Calculate the complex exponent and subtracts one.
       *
       * This may be more accurate than `Complex(x).exp().sub(1)` if
       * `x` is small.
       *
       * @returns {Complex}
       */
      expm1: function() {
        var g = this.re, y = this.im;
        return new m(
          Math.expm1(g) * Math.cos(y) + u(y),
          Math.exp(g) * Math.sin(y)
        );
      },
      /**
       * Calculate the natural log
       *
       * @returns {Complex}
       */
      log: function() {
        var g = this.re, y = this.im;
        return new m(
          f(g, y),
          Math.atan2(y, g)
        );
      },
      /**
       * Calculate the magnitude of the complex number
       *
       * @returns {number}
       */
      abs: function() {
        return h(this.re, this.im);
      },
      /**
       * Calculate the angle of the complex number
       *
       * @returns {number}
       */
      arg: function() {
        return Math.atan2(this.im, this.re);
      },
      /**
       * Calculate the sine of the complex number
       *
       * @returns {Complex}
       */
      sin: function() {
        var g = this.re, y = this.im;
        return new m(
          Math.sin(g) * o(y),
          Math.cos(g) * l(y)
        );
      },
      /**
       * Calculate the cosine
       *
       * @returns {Complex}
       */
      cos: function() {
        var g = this.re, y = this.im;
        return new m(
          Math.cos(g) * o(y),
          -Math.sin(g) * l(y)
        );
      },
      /**
       * Calculate the tangent
       *
       * @returns {Complex}
       */
      tan: function() {
        var g = 2 * this.re, y = 2 * this.im, w = Math.cos(g) + o(y);
        return new m(
          Math.sin(g) / w,
          l(y) / w
        );
      },
      /**
       * Calculate the cotangent
       *
       * @returns {Complex}
       */
      cot: function() {
        var g = 2 * this.re, y = 2 * this.im, w = Math.cos(g) - o(y);
        return new m(
          -Math.sin(g) / w,
          l(y) / w
        );
      },
      /**
       * Calculate the secant
       *
       * @returns {Complex}
       */
      sec: function() {
        var g = this.re, y = this.im, w = 0.5 * o(2 * y) + 0.5 * Math.cos(2 * g);
        return new m(
          Math.cos(g) * o(y) / w,
          Math.sin(g) * l(y) / w
        );
      },
      /**
       * Calculate the cosecans
       *
       * @returns {Complex}
       */
      csc: function() {
        var g = this.re, y = this.im, w = 0.5 * o(2 * y) - 0.5 * Math.cos(2 * g);
        return new m(
          Math.sin(g) * o(y) / w,
          -Math.cos(g) * l(y) / w
        );
      },
      /**
       * Calculate the complex arcus sinus
       *
       * @returns {Complex}
       */
      asin: function() {
        var g = this.re, y = this.im, w = new m(
          y * y - g * g + 1,
          -2 * g * y
        ).sqrt(), E = new m(
          w.re - y,
          w.im + g
        ).log();
        return new m(E.im, -E.re);
      },
      /**
       * Calculate the complex arcus cosinus
       *
       * @returns {Complex}
       */
      acos: function() {
        var g = this.re, y = this.im, w = new m(
          y * y - g * g + 1,
          -2 * g * y
        ).sqrt(), E = new m(
          w.re - y,
          w.im + g
        ).log();
        return new m(Math.PI / 2 - E.im, E.re);
      },
      /**
       * Calculate the complex arcus tangent
       *
       * @returns {Complex}
       */
      atan: function() {
        var g = this.re, y = this.im;
        if (g === 0) {
          if (y === 1)
            return new m(0, 1 / 0);
          if (y === -1)
            return new m(0, -1 / 0);
        }
        var w = g * g + (1 - y) * (1 - y), E = new m(
          (1 - y * y - g * g) / w,
          -2 * g / w
        ).log();
        return new m(-0.5 * E.im, 0.5 * E.re);
      },
      /**
       * Calculate the complex arcus cotangent
       *
       * @returns {Complex}
       */
      acot: function() {
        var g = this.re, y = this.im;
        if (y === 0)
          return new m(Math.atan2(1, g), 0);
        var w = g * g + y * y;
        return w !== 0 ? new m(
          g / w,
          -y / w
        ).atan() : new m(
          g !== 0 ? g / 0 : 0,
          y !== 0 ? -y / 0 : 0
        ).atan();
      },
      /**
       * Calculate the complex arcus secant
       *
       * @returns {Complex}
       */
      asec: function() {
        var g = this.re, y = this.im;
        if (g === 0 && y === 0)
          return new m(0, 1 / 0);
        var w = g * g + y * y;
        return w !== 0 ? new m(
          g / w,
          -y / w
        ).acos() : new m(
          g !== 0 ? g / 0 : 0,
          y !== 0 ? -y / 0 : 0
        ).acos();
      },
      /**
       * Calculate the complex arcus cosecans
       *
       * @returns {Complex}
       */
      acsc: function() {
        var g = this.re, y = this.im;
        if (g === 0 && y === 0)
          return new m(Math.PI / 2, 1 / 0);
        var w = g * g + y * y;
        return w !== 0 ? new m(
          g / w,
          -y / w
        ).asin() : new m(
          g !== 0 ? g / 0 : 0,
          y !== 0 ? -y / 0 : 0
        ).asin();
      },
      /**
       * Calculate the complex sinh
       *
       * @returns {Complex}
       */
      sinh: function() {
        var g = this.re, y = this.im;
        return new m(
          l(g) * Math.cos(y),
          o(g) * Math.sin(y)
        );
      },
      /**
       * Calculate the complex cosh
       *
       * @returns {Complex}
       */
      cosh: function() {
        var g = this.re, y = this.im;
        return new m(
          o(g) * Math.cos(y),
          l(g) * Math.sin(y)
        );
      },
      /**
       * Calculate the complex tanh
       *
       * @returns {Complex}
       */
      tanh: function() {
        var g = 2 * this.re, y = 2 * this.im, w = o(g) + Math.cos(y);
        return new m(
          l(g) / w,
          Math.sin(y) / w
        );
      },
      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      coth: function() {
        var g = 2 * this.re, y = 2 * this.im, w = o(g) - Math.cos(y);
        return new m(
          l(g) / w,
          -Math.sin(y) / w
        );
      },
      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      csch: function() {
        var g = this.re, y = this.im, w = Math.cos(2 * y) - o(2 * g);
        return new m(
          -2 * l(g) * Math.cos(y) / w,
          2 * o(g) * Math.sin(y) / w
        );
      },
      /**
       * Calculate the complex sech
       *
       * @returns {Complex}
       */
      sech: function() {
        var g = this.re, y = this.im, w = Math.cos(2 * y) + o(2 * g);
        return new m(
          2 * o(g) * Math.cos(y) / w,
          -2 * l(g) * Math.sin(y) / w
        );
      },
      /**
       * Calculate the complex asinh
       *
       * @returns {Complex}
       */
      asinh: function() {
        var g = this.im;
        this.im = -this.re, this.re = g;
        var y = this.asin();
        return this.re = -this.im, this.im = g, g = y.re, y.re = -y.im, y.im = g, y;
      },
      /**
       * Calculate the complex acosh
       *
       * @returns {Complex}
       */
      acosh: function() {
        var g = this.acos();
        if (g.im <= 0) {
          var y = g.re;
          g.re = -g.im, g.im = y;
        } else {
          var y = g.im;
          g.im = -g.re, g.re = y;
        }
        return g;
      },
      /**
       * Calculate the complex atanh
       *
       * @returns {Complex}
       */
      atanh: function() {
        var g = this.re, y = this.im, w = g > 1 && y === 0, E = 1 - g, x = 1 + g, D = E * E + y * y, F = D !== 0 ? new m(
          (x * E - y * y) / D,
          (y * E + x * y) / D
        ) : new m(
          g !== -1 ? g / 0 : 0,
          y !== 0 ? y / 0 : 0
        ), k = F.re;
        return F.re = f(F.re, F.im) / 2, F.im = Math.atan2(F.im, k) / 2, w && (F.im = -F.im), F;
      },
      /**
       * Calculate the complex acoth
       *
       * @returns {Complex}
       */
      acoth: function() {
        var g = this.re, y = this.im;
        if (g === 0 && y === 0)
          return new m(0, Math.PI / 2);
        var w = g * g + y * y;
        return w !== 0 ? new m(
          g / w,
          -y / w
        ).atanh() : new m(
          g !== 0 ? g / 0 : 0,
          y !== 0 ? -y / 0 : 0
        ).atanh();
      },
      /**
       * Calculate the complex acsch
       *
       * @returns {Complex}
       */
      acsch: function() {
        var g = this.re, y = this.im;
        if (y === 0)
          return new m(
            g !== 0 ? Math.log(g + Math.sqrt(g * g + 1)) : 1 / 0,
            0
          );
        var w = g * g + y * y;
        return w !== 0 ? new m(
          g / w,
          -y / w
        ).asinh() : new m(
          g !== 0 ? g / 0 : 0,
          y !== 0 ? -y / 0 : 0
        ).asinh();
      },
      /**
       * Calculate the complex asech
       *
       * @returns {Complex}
       */
      asech: function() {
        var g = this.re, y = this.im;
        if (this.isZero())
          return m.INFINITY;
        var w = g * g + y * y;
        return w !== 0 ? new m(
          g / w,
          -y / w
        ).acosh() : new m(
          g !== 0 ? g / 0 : 0,
          y !== 0 ? -y / 0 : 0
        ).acosh();
      },
      /**
       * Calculate the complex inverse 1/z
       *
       * @returns {Complex}
       */
      inverse: function() {
        if (this.isZero())
          return m.INFINITY;
        if (this.isInfinite())
          return m.ZERO;
        var g = this.re, y = this.im, w = g * g + y * y;
        return new m(g / w, -y / w);
      },
      /**
       * Returns the complex conjugate
       *
       * @returns {Complex}
       */
      conjugate: function() {
        return new m(this.re, -this.im);
      },
      /**
       * Gets the negated complex number
       *
       * @returns {Complex}
       */
      neg: function() {
        return new m(-this.re, -this.im);
      },
      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      ceil: function(g) {
        return g = Math.pow(10, g || 0), new m(
          Math.ceil(this.re * g) / g,
          Math.ceil(this.im * g) / g
        );
      },
      /**
       * Floors the actual complex number
       *
       * @returns {Complex}
       */
      floor: function(g) {
        return g = Math.pow(10, g || 0), new m(
          Math.floor(this.re * g) / g,
          Math.floor(this.im * g) / g
        );
      },
      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      round: function(g) {
        return g = Math.pow(10, g || 0), new m(
          Math.round(this.re * g) / g,
          Math.round(this.im * g) / g
        );
      },
      /**
       * Compares two complex numbers
       *
       * **Note:** new Complex(Infinity).equals(Infinity) === false
       *
       * @returns {boolean}
       */
      equals: function(g, y) {
        var w = new m(g, y);
        return Math.abs(w.re - this.re) <= m.EPSILON && Math.abs(w.im - this.im) <= m.EPSILON;
      },
      /**
       * Clones the actual object
       *
       * @returns {Complex}
       */
      clone: function() {
        return new m(this.re, this.im);
      },
      /**
       * Gets a string of the actual complex number
       *
       * @returns {string}
       */
      toString: function() {
        var g = this.re, y = this.im, w = "";
        return this.isNaN() ? "NaN" : this.isInfinite() ? "Infinity" : (Math.abs(g) < m.EPSILON && (g = 0), Math.abs(y) < m.EPSILON && (y = 0), y === 0 ? w + g : (g !== 0 ? (w += g, w += " ", y < 0 ? (y = -y, w += "-") : w += "+", w += " ") : y < 0 && (y = -y, w += "-"), y !== 1 && (w += y), w + "i"));
      },
      /**
       * Returns the actual number as a vector
       *
       * @returns {Array}
       */
      toVector: function() {
        return [this.re, this.im];
      },
      /**
       * Returns the actual real value of the current object
       *
       * @returns {number|null}
       */
      valueOf: function() {
        return this.im === 0 ? this.re : null;
      },
      /**
       * Determines whether a complex number is not on the Riemann sphere.
       *
       * @returns {boolean}
       */
      isNaN: function() {
        return isNaN(this.re) || isNaN(this.im);
      },
      /**
       * Determines whether or not a complex number is at the zero pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isZero: function() {
        return this.im === 0 && this.re === 0;
      },
      /**
       * Determines whether a complex number is not at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isFinite: function() {
        return isFinite(this.re) && isFinite(this.im);
      },
      /**
       * Determines whether or not a complex number is at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isInfinite: function() {
        return !(this.isNaN() || this.isFinite());
      }
    }, m.ZERO = new m(0, 0), m.ONE = new m(1, 0), m.I = new m(0, 1), m.PI = new m(Math.PI, 0), m.E = new m(Math.E, 0), m.INFINITY = new m(1 / 0, 1 / 0), m.NAN = new m(NaN, NaN), m.EPSILON = 1e-15, Object.defineProperty(m, "__esModule", { value: !0 }), m.default = m, m.Complex = m, e.exports = m;
  })();
})(complex);
var complexExports = complex.exports;
const Complex$1 = /* @__PURE__ */ getDefaultExportFromCjs(complexExports);
var name$t = "Complex", dependencies$s = [], createComplexClass = /* @__PURE__ */ factory(name$t, dependencies$s, () => (Object.defineProperty(Complex$1, "name", {
  value: "Complex"
}), Complex$1.prototype.constructor = Complex$1, Complex$1.prototype.type = "Complex", Complex$1.prototype.isComplex = !0, Complex$1.prototype.toJSON = function() {
  return {
    mathjs: "Complex",
    re: this.re,
    im: this.im
  };
}, Complex$1.prototype.toPolar = function() {
  return {
    r: this.abs(),
    phi: this.arg()
  };
}, Complex$1.prototype.format = function(e) {
  var n = "", r = this.im, o = this.re, l = format$2(this.re, e), u = format$2(this.im, e), h = isNumber$1(e) ? e : e ? e.precision : null;
  if (h !== null) {
    var c = Math.pow(10, -h);
    Math.abs(o / r) < c && (o = 0), Math.abs(r / o) < c && (r = 0);
  }
  return r === 0 ? n = l : o === 0 ? r === 1 ? n = "i" : r === -1 ? n = "-i" : n = u + "i" : r < 0 ? r === -1 ? n = l + " - i" : n = l + " - " + u.substring(1) + "i" : r === 1 ? n = l + " + i" : n = l + " + " + u + "i", n;
}, Complex$1.fromPolar = function(e) {
  switch (arguments.length) {
    case 1: {
      var n = arguments[0];
      if (typeof n == "object")
        return Complex$1(n);
      throw new TypeError("Input has to be an object with r and phi keys.");
    }
    case 2: {
      var r = arguments[0], o = arguments[1];
      if (isNumber$1(r)) {
        if (isUnit(o) && o.hasBase("ANGLE") && (o = o.toNumber("rad")), isNumber$1(o))
          return new Complex$1({
            r,
            phi: o
          });
        throw new TypeError("Phi is not a number nor an angle unit.");
      } else
        throw new TypeError("Radius r is not a number.");
    }
    default:
      throw new SyntaxError("Wrong number of arguments in function fromPolar");
  }
}, Complex$1.prototype.valueOf = Complex$1.prototype.toString, Complex$1.fromJSON = function(e) {
  return new Complex$1(e);
}, Complex$1.compare = function(e, n) {
  return e.re > n.re ? 1 : e.re < n.re ? -1 : e.im > n.im ? 1 : e.im < n.im ? -1 : 0;
}, Complex$1), {
  isClass: !0
}), fraction = { exports: {} };
/**
 * @license Fraction.js v4.3.0 20/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
(function(e, n) {
  (function(r) {
    var o = 2e3, l = {
      s: 1,
      n: 0,
      d: 1
    };
    function u(F, k) {
      if (isNaN(F = parseInt(F, 10)))
        throw x();
      return F * k;
    }
    function h(F, k) {
      if (k === 0)
        throw E();
      var N = Object.create(w.prototype);
      N.s = F < 0 ? -1 : 1, F = F < 0 ? -F : F;
      var H = y(F, k);
      return N.n = F / H, N.d = k / H, N;
    }
    function c(F) {
      for (var k = {}, N = F, H = 2, R = 4; R <= N; ) {
        for (; N % H === 0; )
          N /= H, k[H] = (k[H] || 0) + 1;
        R += 1 + 2 * H++;
      }
      return N !== F ? N > 1 && (k[N] = (k[N] || 0) + 1) : k[F] = (k[F] || 0) + 1, k;
    }
    var f = function(F, k) {
      var N = 0, H = 1, R = 1, j = 0, S = 0, tt = 0, nt = 1, ft = 1, pt = 0, ct = 1, Nt = 1, kt = 1, Rt = 1e7, Mt;
      if (F != null)
        if (k !== void 0) {
          if (N = F, H = k, R = N * H, N % 1 !== 0 || H % 1 !== 0)
            throw D();
        } else
          switch (typeof F) {
            case "object": {
              if ("d" in F && "n" in F)
                N = F.n, H = F.d, "s" in F && (N *= F.s);
              else if (0 in F)
                N = F[0], 1 in F && (H = F[1]);
              else
                throw x();
              R = N * H;
              break;
            }
            case "number": {
              if (F < 0 && (R = F, F = -F), F % 1 === 0)
                N = F;
              else if (F > 0) {
                for (F >= 1 && (ft = Math.pow(10, Math.floor(1 + Math.log(F) / Math.LN10)), F /= ft); ct <= Rt && kt <= Rt; )
                  if (Mt = (pt + Nt) / (ct + kt), F === Mt) {
                    ct + kt <= Rt ? (N = pt + Nt, H = ct + kt) : kt > ct ? (N = Nt, H = kt) : (N = pt, H = ct);
                    break;
                  } else
                    F > Mt ? (pt += Nt, ct += kt) : (Nt += pt, kt += ct), ct > Rt ? (N = Nt, H = kt) : (N = pt, H = ct);
                N *= ft;
              } else
                (isNaN(F) || isNaN(k)) && (H = N = NaN);
              break;
            }
            case "string": {
              if (ct = F.match(/\d+|./g), ct === null)
                throw x();
              if (ct[pt] === "-" ? (R = -1, pt++) : ct[pt] === "+" && pt++, ct.length === pt + 1 ? S = u(ct[pt++], R) : ct[pt + 1] === "." || ct[pt] === "." ? (ct[pt] !== "." && (j = u(ct[pt++], R)), pt++, (pt + 1 === ct.length || ct[pt + 1] === "(" && ct[pt + 3] === ")" || ct[pt + 1] === "'" && ct[pt + 3] === "'") && (S = u(ct[pt], R), nt = Math.pow(10, ct[pt].length), pt++), (ct[pt] === "(" && ct[pt + 2] === ")" || ct[pt] === "'" && ct[pt + 2] === "'") && (tt = u(ct[pt + 1], R), ft = Math.pow(10, ct[pt + 1].length) - 1, pt += 3)) : ct[pt + 1] === "/" || ct[pt + 1] === ":" ? (S = u(ct[pt], R), nt = u(ct[pt + 2], 1), pt += 3) : ct[pt + 3] === "/" && ct[pt + 1] === " " && (j = u(ct[pt], R), S = u(ct[pt + 2], R), nt = u(ct[pt + 4], 1), pt += 5), ct.length <= pt) {
                H = nt * ft, R = /* void */
                N = tt + H * j + ft * S;
                break;
              }
            }
            default:
              throw x();
          }
      if (H === 0)
        throw E();
      l.s = R < 0 ? -1 : 1, l.n = Math.abs(N), l.d = Math.abs(H);
    };
    function v(F, k, N) {
      for (var H = 1; k > 0; F = F * F % N, k >>= 1)
        k & 1 && (H = H * F % N);
      return H;
    }
    function m(F, k) {
      for (; k % 2 === 0; k /= 2)
        ;
      for (; k % 5 === 0; k /= 5)
        ;
      if (k === 1)
        return 0;
      for (var N = 10 % k, H = 1; N !== 1; H++)
        if (N = N * 10 % k, H > o)
          return 0;
      return H;
    }
    function g(F, k, N) {
      for (var H = 1, R = v(10, N, k), j = 0; j < 300; j++) {
        if (H === R)
          return j;
        H = H * 10 % k, R = R * 10 % k;
      }
      return 0;
    }
    function y(F, k) {
      if (!F)
        return k;
      if (!k)
        return F;
      for (; ; ) {
        if (F %= k, !F)
          return k;
        if (k %= F, !k)
          return F;
      }
    }
    function w(F, k) {
      if (f(F, k), this instanceof w)
        F = y(l.d, l.n), this.s = l.s, this.n = l.n / F, this.d = l.d / F;
      else
        return h(l.s * l.n, l.d);
    }
    var E = function() {
      return new Error("Division by Zero");
    }, x = function() {
      return new Error("Invalid argument");
    }, D = function() {
      return new Error("Parameters must be integer");
    };
    w.prototype = {
      s: 1,
      n: 0,
      d: 1,
      /**
       * Calculates the absolute value
       *
       * Ex: new Fraction(-4).abs() => 4
       **/
      abs: function() {
        return h(this.n, this.d);
      },
      /**
       * Inverts the sign of the current fraction
       *
       * Ex: new Fraction(-4).neg() => 4
       **/
      neg: function() {
        return h(-this.s * this.n, this.d);
      },
      /**
       * Adds two rational numbers
       *
       * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
       **/
      add: function(F, k) {
        return f(F, k), h(
          this.s * this.n * l.d + l.s * this.d * l.n,
          this.d * l.d
        );
      },
      /**
       * Subtracts two rational numbers
       *
       * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
       **/
      sub: function(F, k) {
        return f(F, k), h(
          this.s * this.n * l.d - l.s * this.d * l.n,
          this.d * l.d
        );
      },
      /**
       * Multiplies two rational numbers
       *
       * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
       **/
      mul: function(F, k) {
        return f(F, k), h(
          this.s * l.s * this.n * l.n,
          this.d * l.d
        );
      },
      /**
       * Divides two rational numbers
       *
       * Ex: new Fraction("-17.(345)").inverse().div(3)
       **/
      div: function(F, k) {
        return f(F, k), h(
          this.s * l.s * this.n * l.d,
          this.d * l.n
        );
      },
      /**
       * Clones the actual object
       *
       * Ex: new Fraction("-17.(345)").clone()
       **/
      clone: function() {
        return h(this.s * this.n, this.d);
      },
      /**
       * Calculates the modulo of two rational numbers - a more precise fmod
       *
       * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
       **/
      mod: function(F, k) {
        if (isNaN(this.n) || isNaN(this.d))
          return new w(NaN);
        if (F === void 0)
          return h(this.s * this.n % this.d, 1);
        if (f(F, k), l.n === 0 && this.d === 0)
          throw E();
        return h(
          this.s * (l.d * this.n) % (l.n * this.d),
          l.d * this.d
        );
      },
      /**
       * Calculates the fractional gcd of two rational numbers
       *
       * Ex: new Fraction(5,8).gcd(3,7) => 1/56
       */
      gcd: function(F, k) {
        return f(F, k), h(y(l.n, this.n) * y(l.d, this.d), l.d * this.d);
      },
      /**
       * Calculates the fractional lcm of two rational numbers
       *
       * Ex: new Fraction(5,8).lcm(3,7) => 15
       */
      lcm: function(F, k) {
        return f(F, k), l.n === 0 && this.n === 0 ? h(0, 1) : h(l.n * this.n, y(l.n, this.n) * y(l.d, this.d));
      },
      /**
       * Calculates the ceil of a rational number
       *
       * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
       **/
      ceil: function(F) {
        return F = Math.pow(10, F || 0), isNaN(this.n) || isNaN(this.d) ? new w(NaN) : h(Math.ceil(F * this.s * this.n / this.d), F);
      },
      /**
       * Calculates the floor of a rational number
       *
       * Ex: new Fraction('4.(3)').floor() => (4 / 1)
       **/
      floor: function(F) {
        return F = Math.pow(10, F || 0), isNaN(this.n) || isNaN(this.d) ? new w(NaN) : h(Math.floor(F * this.s * this.n / this.d), F);
      },
      /**
       * Rounds a rational numbers
       *
       * Ex: new Fraction('4.(3)').round() => (4 / 1)
       **/
      round: function(F) {
        return F = Math.pow(10, F || 0), isNaN(this.n) || isNaN(this.d) ? new w(NaN) : h(Math.round(F * this.s * this.n / this.d), F);
      },
      /**
       * Gets the inverse of the fraction, means numerator and denominator are exchanged
       *
       * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
       **/
      inverse: function() {
        return h(this.s * this.d, this.n);
      },
      /**
       * Calculates the fraction to some rational exponent, if possible
       *
       * Ex: new Fraction(-1,2).pow(-3) => -8
       */
      pow: function(F, k) {
        if (f(F, k), l.d === 1)
          return l.s < 0 ? h(Math.pow(this.s * this.d, l.n), Math.pow(this.n, l.n)) : h(Math.pow(this.s * this.n, l.n), Math.pow(this.d, l.n));
        if (this.s < 0)
          return null;
        var N = c(this.n), H = c(this.d), R = 1, j = 1;
        for (var S in N)
          if (S !== "1") {
            if (S === "0") {
              R = 0;
              break;
            }
            if (N[S] *= l.n, N[S] % l.d === 0)
              N[S] /= l.d;
            else
              return null;
            R *= Math.pow(S, N[S]);
          }
        for (var S in H)
          if (S !== "1") {
            if (H[S] *= l.n, H[S] % l.d === 0)
              H[S] /= l.d;
            else
              return null;
            j *= Math.pow(S, H[S]);
          }
        return l.s < 0 ? h(j, R) : h(R, j);
      },
      /**
       * Check if two rational numbers are the same
       *
       * Ex: new Fraction(19.6).equals([98, 5]);
       **/
      equals: function(F, k) {
        return f(F, k), this.s * this.n * l.d === l.s * l.n * this.d;
      },
      /**
       * Check if two rational numbers are the same
       *
       * Ex: new Fraction(19.6).equals([98, 5]);
       **/
      compare: function(F, k) {
        f(F, k);
        var N = this.s * this.n * l.d - l.s * l.n * this.d;
        return (0 < N) - (N < 0);
      },
      simplify: function(F) {
        if (isNaN(this.n) || isNaN(this.d))
          return this;
        F = F || 1e-3;
        for (var k = this.abs(), N = k.toContinued(), H = 1; H < N.length; H++) {
          for (var R = h(N[H - 1], 1), j = H - 2; j >= 0; j--)
            R = R.inverse().add(N[j]);
          if (Math.abs(R.sub(k).valueOf()) < F)
            return R.mul(this.s);
        }
        return this;
      },
      /**
       * Check if two rational numbers are divisible
       *
       * Ex: new Fraction(19.6).divisible(1.5);
       */
      divisible: function(F, k) {
        return f(F, k), !(!(l.n * this.d) || this.n * l.d % (l.n * this.d));
      },
      /**
       * Returns a decimal representation of the fraction
       *
       * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
       **/
      valueOf: function() {
        return this.s * this.n / this.d;
      },
      /**
       * Returns a string-fraction representation of a Fraction object
       *
       * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
       **/
      toFraction: function(F) {
        var k, N = "", H = this.n, R = this.d;
        return this.s < 0 && (N += "-"), R === 1 ? N += H : (F && (k = Math.floor(H / R)) > 0 && (N += k, N += " ", H %= R), N += H, N += "/", N += R), N;
      },
      /**
       * Returns a latex representation of a Fraction object
       *
       * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
       **/
      toLatex: function(F) {
        var k, N = "", H = this.n, R = this.d;
        return this.s < 0 && (N += "-"), R === 1 ? N += H : (F && (k = Math.floor(H / R)) > 0 && (N += k, H %= R), N += "\\frac{", N += H, N += "}{", N += R, N += "}"), N;
      },
      /**
       * Returns an array of continued fraction elements
       *
       * Ex: new Fraction("7/8").toContinued() => [0,1,7]
       */
      toContinued: function() {
        var F, k = this.n, N = this.d, H = [];
        if (isNaN(k) || isNaN(N))
          return H;
        do
          H.push(Math.floor(k / N)), F = k % N, k = N, N = F;
        while (k !== 1);
        return H;
      },
      /**
       * Creates a string representation of a fraction with all digits
       *
       * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
       **/
      toString: function(F) {
        var k = this.n, N = this.d;
        if (isNaN(k) || isNaN(N))
          return "NaN";
        F = F || 15;
        var H = m(k, N), R = g(k, N, H), j = this.s < 0 ? "-" : "";
        if (j += k / N | 0, k %= N, k *= 10, k && (j += "."), H) {
          for (var S = R; S--; )
            j += k / N | 0, k %= N, k *= 10;
          j += "(";
          for (var S = H; S--; )
            j += k / N | 0, k %= N, k *= 10;
          j += ")";
        } else
          for (var S = F; k && S--; )
            j += k / N | 0, k %= N, k *= 10;
        return j;
      }
    }, Object.defineProperty(w, "__esModule", { value: !0 }), w.default = w, w.Fraction = w, e.exports = w;
  })();
})(fraction);
var fractionExports = fraction.exports;
const Fraction$1 = /* @__PURE__ */ getDefaultExportFromCjs(fractionExports);
var name$s = "Fraction", dependencies$r = [], createFractionClass = /* @__PURE__ */ factory(name$s, dependencies$r, () => (Object.defineProperty(Fraction$1, "name", {
  value: "Fraction"
}), Fraction$1.prototype.constructor = Fraction$1, Fraction$1.prototype.type = "Fraction", Fraction$1.prototype.isFraction = !0, Fraction$1.prototype.toJSON = function() {
  return {
    mathjs: "Fraction",
    n: this.s * this.n,
    d: this.d
  };
}, Fraction$1.fromJSON = function(e) {
  return new Fraction$1(e);
}, Fraction$1), {
  isClass: !0
}), name$r = "Matrix", dependencies$q = [], createMatrixClass = /* @__PURE__ */ factory(name$r, dependencies$q, () => {
  function e() {
    if (!(this instanceof e))
      throw new SyntaxError("Constructor must be called with the new operator");
  }
  return e.prototype.type = "Matrix", e.prototype.isMatrix = !0, e.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  }, e.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  }, e.prototype.create = function(n, r) {
    throw new Error("Cannot invoke create on a Matrix interface");
  }, e.prototype.subset = function(n, r, o) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  }, e.prototype.get = function(n) {
    throw new Error("Cannot invoke get on a Matrix interface");
  }, e.prototype.set = function(n, r, o) {
    throw new Error("Cannot invoke set on a Matrix interface");
  }, e.prototype.resize = function(n, r) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  }, e.prototype.reshape = function(n, r) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  }, e.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  }, e.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  }, e.prototype.map = function(n, r) {
    throw new Error("Cannot invoke map on a Matrix interface");
  }, e.prototype.forEach = function(n) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  }, e.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  }, e.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  }, e.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  }, e.prototype.format = function(n) {
    throw new Error("Cannot invoke format on a Matrix interface");
  }, e.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  }, e;
}, {
  isClass: !0
});
function maxArgumentCount(e) {
  return Object.keys(e.signatures || {}).reduce(function(n, r) {
    var o = (r.match(/,/g) || []).length + 1;
    return Math.max(n, o);
  }, -1);
}
var name$q = "DenseMatrix", dependencies$p = ["Matrix"], createDenseMatrixClass = /* @__PURE__ */ factory(name$q, dependencies$p, (e) => {
  var {
    Matrix: n
  } = e;
  function r(m, g) {
    if (!(this instanceof r))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (g && !isString$1(g))
      throw new Error("Invalid datatype: " + g);
    if (isMatrix(m))
      m.type === "DenseMatrix" ? (this._data = clone$2(m._data), this._size = clone$2(m._size), this._datatype = g || m._datatype) : (this._data = m.toArray(), this._size = m.size(), this._datatype = g || m._datatype);
    else if (m && isArray$1(m.data) && isArray$1(m.size))
      this._data = m.data, this._size = m.size, validate(this._data, this._size), this._datatype = g || m.datatype;
    else if (isArray$1(m))
      this._data = v(m), this._size = arraySize(this._data), validate(this._data, this._size), this._datatype = g;
    else {
      if (m)
        throw new TypeError("Unsupported type of data (" + typeOf(m) + ")");
      this._data = [], this._size = [0], this._datatype = g;
    }
  }
  r.prototype = new n(), r.prototype.createDenseMatrix = function(m, g) {
    return new r(m, g);
  }, Object.defineProperty(r, "name", {
    value: "DenseMatrix"
  }), r.prototype.constructor = r, r.prototype.type = "DenseMatrix", r.prototype.isDenseMatrix = !0, r.prototype.getDataType = function() {
    return getArrayDataType(this._data, typeOf);
  }, r.prototype.storage = function() {
    return "dense";
  }, r.prototype.datatype = function() {
    return this._datatype;
  }, r.prototype.create = function(m, g) {
    return new r(m, g);
  }, r.prototype.subset = function(m, g, y) {
    switch (arguments.length) {
      case 1:
        return o(this, m);
      case 2:
      case 3:
        return u(this, m, g, y);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  }, r.prototype.get = function(m) {
    if (!isArray$1(m))
      throw new TypeError("Array expected");
    if (m.length !== this._size.length)
      throw new DimensionError(m.length, this._size.length);
    for (var g = 0; g < m.length; g++)
      validateIndex(m[g], this._size[g]);
    for (var y = this._data, w = 0, E = m.length; w < E; w++) {
      var x = m[w];
      validateIndex(x, y.length), y = y[x];
    }
    return y;
  }, r.prototype.set = function(m, g, y) {
    if (!isArray$1(m))
      throw new TypeError("Array expected");
    if (m.length < this._size.length)
      throw new DimensionError(m.length, this._size.length, "<");
    var w, E, x, D = m.map(function(k) {
      return k + 1;
    });
    f(this, D, y);
    var F = this._data;
    for (w = 0, E = m.length - 1; w < E; w++)
      x = m[w], validateIndex(x, F.length), F = F[x];
    return x = m[m.length - 1], validateIndex(x, F.length), F[x] = g, this;
  };
  function o(m, g) {
    if (!isIndex(g))
      throw new TypeError("Invalid index");
    var y = g.isScalar();
    if (y)
      return m.get(g.min());
    var w = g.size();
    if (w.length !== m._size.length)
      throw new DimensionError(w.length, m._size.length);
    for (var E = g.min(), x = g.max(), D = 0, F = m._size.length; D < F; D++)
      validateIndex(E[D], m._size[D]), validateIndex(x[D], m._size[D]);
    return new r(l(m._data, g, w.length, 0), m._datatype);
  }
  function l(m, g, y, w) {
    var E = w === y - 1, x = g.dimension(w);
    return E ? x.map(function(D) {
      return validateIndex(D, m.length), m[D];
    }).valueOf() : x.map(function(D) {
      validateIndex(D, m.length);
      var F = m[D];
      return l(F, g, y, w + 1);
    }).valueOf();
  }
  function u(m, g, y, w) {
    if (!g || g.isIndex !== !0)
      throw new TypeError("Invalid index");
    var E = g.size(), x = g.isScalar(), D;
    if (isMatrix(y) ? (D = y.size(), y = y.valueOf()) : D = arraySize(y), x) {
      if (D.length !== 0)
        throw new TypeError("Scalar expected");
      m.set(g.min(), y, w);
    } else {
      if (!deepStrictEqual(D, E))
        try {
          D.length === 0 ? y = broadcastTo([y], E) : y = broadcastTo(y, E), D = arraySize(y);
        } catch {
        }
      if (E.length < m._size.length)
        throw new DimensionError(E.length, m._size.length, "<");
      if (D.length < E.length) {
        for (var F = 0, k = 0; E[F] === 1 && D[F] === 1; )
          F++;
        for (; E[F] === 1; )
          k++, F++;
        y = unsqueeze(y, E.length, k, D);
      }
      if (!deepStrictEqual(E, D))
        throw new DimensionError(E, D, ">");
      var N = g.max().map(function(j) {
        return j + 1;
      });
      f(m, N, w);
      var H = E.length, R = 0;
      h(m._data, g, y, H, R);
    }
    return m;
  }
  function h(m, g, y, w, E) {
    var x = E === w - 1, D = g.dimension(E);
    x ? D.forEach(function(F, k) {
      validateIndex(F), m[F] = y[k[0]];
    }) : D.forEach(function(F, k) {
      validateIndex(F), h(m[F], g, y[k[0]], w, E + 1);
    });
  }
  r.prototype.resize = function(m, g, y) {
    if (!isCollection(m))
      throw new TypeError("Array or Matrix expected");
    var w = m.valueOf().map((x) => Array.isArray(x) && x.length === 1 ? x[0] : x), E = y ? this.clone() : this;
    return c(E, w, g);
  };
  function c(m, g, y) {
    if (g.length === 0) {
      for (var w = m._data; isArray$1(w); )
        w = w[0];
      return w;
    }
    return m._size = g.slice(0), m._data = resize(m._data, m._size, y), m;
  }
  r.prototype.reshape = function(m, g) {
    var y = g ? this.clone() : this;
    y._data = reshape(y._data, m);
    var w = y._size.reduce((E, x) => E * x);
    return y._size = processSizesWildcard(m, w), y;
  };
  function f(m, g, y) {
    for (var w = m._size.slice(0), E = !1; w.length < g.length; )
      w.push(0), E = !0;
    for (var x = 0, D = g.length; x < D; x++)
      g[x] > w[x] && (w[x] = g[x], E = !0);
    E && c(m, w, y);
  }
  r.prototype.clone = function() {
    var m = new r({
      data: clone$2(this._data),
      size: clone$2(this._size),
      datatype: this._datatype
    });
    return m;
  }, r.prototype.size = function() {
    return this._size.slice(0);
  }, r.prototype.map = function(m) {
    var g = this, y = maxArgumentCount(m), w = function D(F, k) {
      return isArray$1(F) ? F.map(function(N, H) {
        return D(N, k.concat(H));
      }) : y === 1 ? m(F) : y === 2 ? m(F, k) : m(F, k, g);
    }, E = w(this._data, []), x = this._datatype !== void 0 ? getArrayDataType(E, typeOf) : void 0;
    return new r(E, x);
  }, r.prototype.forEach = function(m) {
    var g = this, y = function w(E, x) {
      isArray$1(E) ? E.forEach(function(D, F) {
        w(D, x.concat(F));
      }) : m(E, x, g);
    };
    y(this._data, []);
  }, r.prototype[Symbol.iterator] = function* () {
    var m = function* g(y, w) {
      if (isArray$1(y))
        for (var E = 0; E < y.length; E++)
          yield* g(y[E], w.concat(E));
      else
        yield {
          value: y,
          index: w
        };
    };
    yield* m(this._data, []);
  }, r.prototype.rows = function() {
    var m = [], g = this.size();
    if (g.length !== 2)
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    var y = this._data;
    for (var w of y)
      m.push(new r([w], this._datatype));
    return m;
  }, r.prototype.columns = function() {
    var m = this, g = [], y = this.size();
    if (y.length !== 2)
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    for (var w = this._data, E = function(F) {
      var k = w.map((N) => [N[F]]);
      g.push(new r(k, m._datatype));
    }, x = 0; x < y[1]; x++)
      E(x);
    return g;
  }, r.prototype.toArray = function() {
    return clone$2(this._data);
  }, r.prototype.valueOf = function() {
    return this._data;
  }, r.prototype.format = function(m) {
    return format(this._data, m);
  }, r.prototype.toString = function() {
    return format(this._data);
  }, r.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  }, r.prototype.diagonal = function(m) {
    if (m) {
      if (isBigNumber(m) && (m = m.toNumber()), !isNumber$1(m) || !isInteger$1(m))
        throw new TypeError("The parameter k must be an integer number");
    } else
      m = 0;
    for (var g = m > 0 ? m : 0, y = m < 0 ? -m : 0, w = this._size[0], E = this._size[1], x = Math.min(w - y, E - g), D = [], F = 0; F < x; F++)
      D[F] = this._data[F + y][F + g];
    return new r({
      data: D,
      size: [x],
      datatype: this._datatype
    });
  }, r.diagonal = function(m, g, y, w) {
    if (!isArray$1(m))
      throw new TypeError("Array expected, size parameter");
    if (m.length !== 2)
      throw new Error("Only two dimensions matrix are supported");
    if (m = m.map(function(S) {
      if (isBigNumber(S) && (S = S.toNumber()), !isNumber$1(S) || !isInteger$1(S) || S < 1)
        throw new Error("Size values must be positive integers");
      return S;
    }), y) {
      if (isBigNumber(y) && (y = y.toNumber()), !isNumber$1(y) || !isInteger$1(y))
        throw new TypeError("The parameter k must be an integer number");
    } else
      y = 0;
    var E = y > 0 ? y : 0, x = y < 0 ? -y : 0, D = m[0], F = m[1], k = Math.min(D - x, F - E), N;
    if (isArray$1(g)) {
      if (g.length !== k)
        throw new Error("Invalid value array length");
      N = function(tt) {
        return g[tt];
      };
    } else if (isMatrix(g)) {
      var H = g.size();
      if (H.length !== 1 || H[0] !== k)
        throw new Error("Invalid matrix length");
      N = function(tt) {
        return g.get([tt]);
      };
    } else
      N = function() {
        return g;
      };
    w || (w = isBigNumber(N(0)) ? N(0).mul(0) : 0);
    var R = [];
    if (m.length > 0) {
      R = resize(R, m, w);
      for (var j = 0; j < k; j++)
        R[j + x][j + E] = N(j);
    }
    return new r({
      data: R,
      size: [D, F]
    });
  }, r.fromJSON = function(m) {
    return new r(m);
  }, r.prototype.swapRows = function(m, g) {
    if (!isNumber$1(m) || !isInteger$1(m) || !isNumber$1(g) || !isInteger$1(g))
      throw new Error("Row index must be positive integers");
    if (this._size.length !== 2)
      throw new Error("Only two dimensional matrix is supported");
    return validateIndex(m, this._size[0]), validateIndex(g, this._size[0]), r._swapRows(m, g, this._data), this;
  }, r._swapRows = function(m, g, y) {
    var w = y[m];
    y[m] = y[g], y[g] = w;
  };
  function v(m) {
    return isMatrix(m) ? v(m.valueOf()) : isArray$1(m) ? m.map(v) : m;
  }
  return r;
}, {
  isClass: !0
});
function deepMap(e, n, r) {
  return e && typeof e.map == "function" ? e.map(function(o) {
    return deepMap(o, n);
  }) : n(e);
}
var name$p = "isInteger", dependencies$o = ["typed"], createIsInteger = /* @__PURE__ */ factory(name$p, dependencies$o, (e) => {
  var {
    typed: n
  } = e;
  return n(name$p, {
    number: isInteger$1,
    // TODO: what to do with isInteger(add(0.1, 0.2))  ?
    BigNumber: function(o) {
      return o.isInt();
    },
    Fraction: function(o) {
      return o.d === 1 && isFinite(o.n);
    },
    "Array | Matrix": n.referToSelf((r) => (o) => deepMap(o, r))
  });
}), n2 = "number, number";
function addNumber(e, n) {
  return e + n;
}
addNumber.signature = n2;
function multiplyNumber(e, n) {
  return e * n;
}
multiplyNumber.signature = n2;
function nearlyEqual(e, n, r) {
  if (r == null)
    return e.eq(n);
  if (e.eq(n))
    return !0;
  if (e.isNaN() || n.isNaN())
    return !1;
  if (e.isFinite() && n.isFinite()) {
    var o = e.minus(n).abs();
    if (o.isZero())
      return !0;
    var l = e.constructor.max(e.abs(), n.abs());
    return o.lte(l.times(r));
  }
  return !1;
}
function complexEquals(e, n, r) {
  return nearlyEqual$1(e.re, n.re, r) && nearlyEqual$1(e.im, n.im, r);
}
var createCompareUnits = /* @__PURE__ */ factory("compareUnits", ["typed"], (e) => {
  var {
    typed: n
  } = e;
  return {
    "Unit, Unit": n.referToSelf((r) => (o, l) => {
      if (!o.equalBase(l))
        throw new Error("Cannot compare units with different base");
      return n.find(r, [o.valueType(), l.valueType()])(o.value, l.value);
    })
  };
}), name$o = "equalScalar", dependencies$n = ["typed", "config"], createEqualScalar = /* @__PURE__ */ factory(name$o, dependencies$n, (e) => {
  var {
    typed: n,
    config: r
  } = e, o = createCompareUnits({
    typed: n
  });
  return n(name$o, {
    "boolean, boolean": function(u, h) {
      return u === h;
    },
    "number, number": function(u, h) {
      return nearlyEqual$1(u, h, r.epsilon);
    },
    "BigNumber, BigNumber": function(u, h) {
      return u.eq(h) || nearlyEqual(u, h, r.epsilon);
    },
    "Fraction, Fraction": function(u, h) {
      return u.equals(h);
    },
    "Complex, Complex": function(u, h) {
      return complexEquals(u, h, r.epsilon);
    }
  }, o);
});
factory(name$o, ["typed", "config"], (e) => {
  var {
    typed: n,
    config: r
  } = e;
  return n(name$o, {
    "number, number": function(l, u) {
      return nearlyEqual$1(l, u, r.epsilon);
    }
  });
});
var name$n = "SparseMatrix", dependencies$m = ["typed", "equalScalar", "Matrix"], createSparseMatrixClass = /* @__PURE__ */ factory(name$n, dependencies$m, (e) => {
  var {
    typed: n,
    equalScalar: r,
    Matrix: o
  } = e;
  function l(x, D) {
    if (!(this instanceof l))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (D && !isString$1(D))
      throw new Error("Invalid datatype: " + D);
    if (isMatrix(x))
      u(this, x, D);
    else if (x && isArray$1(x.index) && isArray$1(x.ptr) && isArray$1(x.size))
      this._values = x.values, this._index = x.index, this._ptr = x.ptr, this._size = x.size, this._datatype = D || x.datatype;
    else if (isArray$1(x))
      h(this, x, D);
    else {
      if (x)
        throw new TypeError("Unsupported type of data (" + typeOf(x) + ")");
      this._values = [], this._index = [], this._ptr = [0], this._size = [0, 0], this._datatype = D;
    }
  }
  function u(x, D, F) {
    D.type === "SparseMatrix" ? (x._values = D._values ? clone$2(D._values) : void 0, x._index = clone$2(D._index), x._ptr = clone$2(D._ptr), x._size = clone$2(D._size), x._datatype = F || D._datatype) : h(x, D.valueOf(), F || D._datatype);
  }
  function h(x, D, F) {
    x._values = [], x._index = [], x._ptr = [], x._datatype = F;
    var k = D.length, N = 0, H = r, R = 0;
    if (isString$1(F) && (H = n.find(r, [F, F]) || r, R = n.convert(0, F)), k > 0) {
      var j = 0;
      do {
        x._ptr.push(x._index.length);
        for (var S = 0; S < k; S++) {
          var tt = D[S];
          if (isArray$1(tt)) {
            if (j === 0 && N < tt.length && (N = tt.length), j < tt.length) {
              var nt = tt[j];
              H(nt, R) || (x._values.push(nt), x._index.push(S));
            }
          } else
            j === 0 && N < 1 && (N = 1), H(tt, R) || (x._values.push(tt), x._index.push(S));
        }
        j++;
      } while (j < N);
    }
    x._ptr.push(x._index.length), x._size = [k, N];
  }
  l.prototype = new o(), l.prototype.createSparseMatrix = function(x, D) {
    return new l(x, D);
  }, Object.defineProperty(l, "name", {
    value: "SparseMatrix"
  }), l.prototype.constructor = l, l.prototype.type = "SparseMatrix", l.prototype.isSparseMatrix = !0, l.prototype.getDataType = function() {
    return getArrayDataType(this._values, typeOf);
  }, l.prototype.storage = function() {
    return "sparse";
  }, l.prototype.datatype = function() {
    return this._datatype;
  }, l.prototype.create = function(x, D) {
    return new l(x, D);
  }, l.prototype.density = function() {
    var x = this._size[0], D = this._size[1];
    return x !== 0 && D !== 0 ? this._index.length / (x * D) : 0;
  }, l.prototype.subset = function(x, D, F) {
    if (!this._values)
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    switch (arguments.length) {
      case 1:
        return c(this, x);
      case 2:
      case 3:
        return f(this, x, D, F);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function c(x, D) {
    if (!isIndex(D))
      throw new TypeError("Invalid index");
    var F = D.isScalar();
    if (F)
      return x.get(D.min());
    var k = D.size();
    if (k.length !== x._size.length)
      throw new DimensionError(k.length, x._size.length);
    var N, H, R, j, S = D.min(), tt = D.max();
    for (N = 0, H = x._size.length; N < H; N++)
      validateIndex(S[N], x._size[N]), validateIndex(tt[N], x._size[N]);
    var nt = x._values, ft = x._index, pt = x._ptr, ct = D.dimension(0), Nt = D.dimension(1), kt = [], Rt = [];
    ct.forEach(function(it, rt) {
      Rt[it] = rt[0], kt[it] = !0;
    });
    var Mt = nt ? [] : void 0, G = [], Y = [];
    return Nt.forEach(function(it) {
      for (Y.push(G.length), R = pt[it], j = pt[it + 1]; R < j; R++)
        N = ft[R], kt[N] === !0 && (G.push(Rt[N]), Mt && Mt.push(nt[R]));
    }), Y.push(G.length), new l({
      values: Mt,
      index: G,
      ptr: Y,
      size: k,
      datatype: x._datatype
    });
  }
  function f(x, D, F, k) {
    if (!D || D.isIndex !== !0)
      throw new TypeError("Invalid index");
    var N = D.size(), H = D.isScalar(), R;
    if (isMatrix(F) ? (R = F.size(), F = F.toArray()) : R = arraySize(F), H) {
      if (R.length !== 0)
        throw new TypeError("Scalar expected");
      x.set(D.min(), F, k);
    } else {
      if (N.length !== 1 && N.length !== 2)
        throw new DimensionError(N.length, x._size.length, "<");
      if (R.length < N.length) {
        for (var j = 0, S = 0; N[j] === 1 && R[j] === 1; )
          j++;
        for (; N[j] === 1; )
          S++, j++;
        F = unsqueeze(F, N.length, S, R);
      }
      if (!deepStrictEqual(N, R))
        throw new DimensionError(N, R, ">");
      if (N.length === 1) {
        var tt = D.dimension(0);
        tt.forEach(function(pt, ct) {
          validateIndex(pt), x.set([pt, 0], F[ct[0]], k);
        });
      } else {
        var nt = D.dimension(0), ft = D.dimension(1);
        nt.forEach(function(pt, ct) {
          validateIndex(pt), ft.forEach(function(Nt, kt) {
            validateIndex(Nt), x.set([pt, Nt], F[ct[0]][kt[0]], k);
          });
        });
      }
    }
    return x;
  }
  l.prototype.get = function(x) {
    if (!isArray$1(x))
      throw new TypeError("Array expected");
    if (x.length !== this._size.length)
      throw new DimensionError(x.length, this._size.length);
    if (!this._values)
      throw new Error("Cannot invoke get on a Pattern only matrix");
    var D = x[0], F = x[1];
    validateIndex(D, this._size[0]), validateIndex(F, this._size[1]);
    var k = v(D, this._ptr[F], this._ptr[F + 1], this._index);
    return k < this._ptr[F + 1] && this._index[k] === D ? this._values[k] : 0;
  }, l.prototype.set = function(x, D, F) {
    if (!isArray$1(x))
      throw new TypeError("Array expected");
    if (x.length !== this._size.length)
      throw new DimensionError(x.length, this._size.length);
    if (!this._values)
      throw new Error("Cannot invoke set on a Pattern only matrix");
    var k = x[0], N = x[1], H = this._size[0], R = this._size[1], j = r, S = 0;
    isString$1(this._datatype) && (j = n.find(r, [this._datatype, this._datatype]) || r, S = n.convert(0, this._datatype)), (k > H - 1 || N > R - 1) && (y(this, Math.max(k + 1, H), Math.max(N + 1, R), F), H = this._size[0], R = this._size[1]), validateIndex(k, H), validateIndex(N, R);
    var tt = v(k, this._ptr[N], this._ptr[N + 1], this._index);
    return tt < this._ptr[N + 1] && this._index[tt] === k ? j(D, S) ? m(tt, N, this._values, this._index, this._ptr) : this._values[tt] = D : j(D, S) || g(tt, k, N, D, this._values, this._index, this._ptr), this;
  };
  function v(x, D, F, k) {
    if (F - D === 0)
      return F;
    for (var N = D; N < F; N++)
      if (k[N] === x)
        return N;
    return D;
  }
  function m(x, D, F, k, N) {
    F.splice(x, 1), k.splice(x, 1);
    for (var H = D + 1; H < N.length; H++)
      N[H]--;
  }
  function g(x, D, F, k, N, H, R) {
    N.splice(x, 0, k), H.splice(x, 0, D);
    for (var j = F + 1; j < R.length; j++)
      R[j]++;
  }
  l.prototype.resize = function(x, D, F) {
    if (!isCollection(x))
      throw new TypeError("Array or Matrix expected");
    var k = x.valueOf().map((H) => Array.isArray(H) && H.length === 1 ? H[0] : H);
    if (k.length !== 2)
      throw new Error("Only two dimensions matrix are supported");
    k.forEach(function(H) {
      if (!isNumber$1(H) || !isInteger$1(H) || H < 0)
        throw new TypeError("Invalid size, must contain positive integers (size: " + format(k) + ")");
    });
    var N = F ? this.clone() : this;
    return y(N, k[0], k[1], D);
  };
  function y(x, D, F, k) {
    var N = k || 0, H = r, R = 0;
    isString$1(x._datatype) && (H = n.find(r, [x._datatype, x._datatype]) || r, R = n.convert(0, x._datatype), N = n.convert(N, x._datatype));
    var j = !H(N, R), S = x._size[0], tt = x._size[1], nt, ft, pt;
    if (F > tt) {
      for (ft = tt; ft < F; ft++)
        if (x._ptr[ft] = x._values.length, j)
          for (nt = 0; nt < S; nt++)
            x._values.push(N), x._index.push(nt);
      x._ptr[F] = x._values.length;
    } else
      F < tt && (x._ptr.splice(F + 1, tt - F), x._values.splice(x._ptr[F], x._values.length), x._index.splice(x._ptr[F], x._index.length));
    if (tt = F, D > S) {
      if (j) {
        var ct = 0;
        for (ft = 0; ft < tt; ft++) {
          x._ptr[ft] = x._ptr[ft] + ct, pt = x._ptr[ft + 1] + ct;
          var Nt = 0;
          for (nt = S; nt < D; nt++, Nt++)
            x._values.splice(pt + Nt, 0, N), x._index.splice(pt + Nt, 0, nt), ct++;
        }
        x._ptr[tt] = x._values.length;
      }
    } else if (D < S) {
      var kt = 0;
      for (ft = 0; ft < tt; ft++) {
        x._ptr[ft] = x._ptr[ft] - kt;
        var Rt = x._ptr[ft], Mt = x._ptr[ft + 1] - kt;
        for (pt = Rt; pt < Mt; pt++)
          nt = x._index[pt], nt > D - 1 && (x._values.splice(pt, 1), x._index.splice(pt, 1), kt++);
      }
      x._ptr[ft] = x._values.length;
    }
    return x._size[0] = D, x._size[1] = F, x;
  }
  l.prototype.reshape = function(x, D) {
    if (!isArray$1(x))
      throw new TypeError("Array expected");
    if (x.length !== 2)
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    x.forEach(function(it) {
      if (!isNumber$1(it) || !isInteger$1(it) || it <= -2 || it === 0)
        throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format(x) + ")");
    });
    var F = this._size[0] * this._size[1];
    x = processSizesWildcard(x, F);
    var k = x[0] * x[1];
    if (F !== k)
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    var N = D ? this.clone() : this;
    if (this._size[0] === x[0] && this._size[1] === x[1])
      return N;
    for (var H = [], R = 0; R < N._ptr.length; R++)
      for (var j = 0; j < N._ptr[R + 1] - N._ptr[R]; j++)
        H.push(R);
    for (var S = N._values.slice(), tt = N._index.slice(), nt = 0; nt < N._index.length; nt++) {
      var ft = tt[nt], pt = H[nt], ct = ft * N._size[1] + pt;
      H[nt] = ct % x[1], tt[nt] = Math.floor(ct / x[1]);
    }
    N._values.length = 0, N._index.length = 0, N._ptr.length = x[1] + 1, N._size = x.slice();
    for (var Nt = 0; Nt < N._ptr.length; Nt++)
      N._ptr[Nt] = 0;
    for (var kt = 0; kt < S.length; kt++) {
      var Rt = tt[kt], Mt = H[kt], G = S[kt], Y = v(Rt, N._ptr[Mt], N._ptr[Mt + 1], N._index);
      g(Y, Rt, Mt, G, N._values, N._index, N._ptr);
    }
    return N;
  }, l.prototype.clone = function() {
    var x = new l({
      values: this._values ? clone$2(this._values) : void 0,
      index: clone$2(this._index),
      ptr: clone$2(this._ptr),
      size: clone$2(this._size),
      datatype: this._datatype
    });
    return x;
  }, l.prototype.size = function() {
    return this._size.slice(0);
  }, l.prototype.map = function(x, D) {
    if (!this._values)
      throw new Error("Cannot invoke map on a Pattern only matrix");
    var F = this, k = this._size[0], N = this._size[1], H = maxArgumentCount(x), R = function(S, tt, nt) {
      return H === 1 ? x(S) : H === 2 ? x(S, [tt, nt]) : x(S, [tt, nt], F);
    };
    return w(this, 0, k - 1, 0, N - 1, R, D);
  };
  function w(x, D, F, k, N, H, R) {
    var j = [], S = [], tt = [], nt = r, ft = 0;
    isString$1(x._datatype) && (nt = n.find(r, [x._datatype, x._datatype]) || r, ft = n.convert(0, x._datatype));
    for (var pt = function(yt, St, Ft) {
      yt = H(yt, St, Ft), nt(yt, ft) || (j.push(yt), S.push(St));
    }, ct = k; ct <= N; ct++) {
      tt.push(j.length);
      var Nt = x._ptr[ct], kt = x._ptr[ct + 1];
      if (R)
        for (var Rt = Nt; Rt < kt; Rt++) {
          var Mt = x._index[Rt];
          Mt >= D && Mt <= F && pt(x._values[Rt], Mt - D, ct - k);
        }
      else {
        for (var G = {}, Y = Nt; Y < kt; Y++) {
          var it = x._index[Y];
          G[it] = x._values[Y];
        }
        for (var rt = D; rt <= F; rt++) {
          var ht = rt in G ? G[rt] : 0;
          pt(ht, rt - D, ct - k);
        }
      }
    }
    return tt.push(j.length), new l({
      values: j,
      index: S,
      ptr: tt,
      size: [F - D + 1, N - k + 1]
    });
  }
  l.prototype.forEach = function(x, D) {
    if (!this._values)
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    for (var F = this, k = this._size[0], N = this._size[1], H = 0; H < N; H++) {
      var R = this._ptr[H], j = this._ptr[H + 1];
      if (D)
        for (var S = R; S < j; S++) {
          var tt = this._index[S];
          x(this._values[S], [tt, H], F);
        }
      else {
        for (var nt = {}, ft = R; ft < j; ft++) {
          var pt = this._index[ft];
          nt[pt] = this._values[ft];
        }
        for (var ct = 0; ct < k; ct++) {
          var Nt = ct in nt ? nt[ct] : 0;
          x(Nt, [ct, H], F);
        }
      }
    }
  }, l.prototype[Symbol.iterator] = function* () {
    if (!this._values)
      throw new Error("Cannot iterate a Pattern only matrix");
    for (var x = this._size[1], D = 0; D < x; D++)
      for (var F = this._ptr[D], k = this._ptr[D + 1], N = F; N < k; N++) {
        var H = this._index[N];
        yield {
          value: this._values[N],
          index: [H, D]
        };
      }
  }, l.prototype.toArray = function() {
    return E(this._values, this._index, this._ptr, this._size, !0);
  }, l.prototype.valueOf = function() {
    return E(this._values, this._index, this._ptr, this._size, !1);
  };
  function E(x, D, F, k, N) {
    var H = k[0], R = k[1], j = [], S, tt;
    for (S = 0; S < H; S++)
      for (j[S] = [], tt = 0; tt < R; tt++)
        j[S][tt] = 0;
    for (tt = 0; tt < R; tt++)
      for (var nt = F[tt], ft = F[tt + 1], pt = nt; pt < ft; pt++)
        S = D[pt], j[S][tt] = x ? N ? clone$2(x[pt]) : x[pt] : 1;
    return j;
  }
  return l.prototype.format = function(x) {
    for (var D = this._size[0], F = this._size[1], k = this.density(), N = "Sparse Matrix [" + format(D, x) + " x " + format(F, x) + "] density: " + format(k, x) + `
`, H = 0; H < F; H++)
      for (var R = this._ptr[H], j = this._ptr[H + 1], S = R; S < j; S++) {
        var tt = this._index[S];
        N += `
    (` + format(tt, x) + ", " + format(H, x) + ") ==> " + (this._values ? format(this._values[S], x) : "X");
      }
    return N;
  }, l.prototype.toString = function() {
    return format(this.toArray());
  }, l.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  }, l.prototype.diagonal = function(x) {
    if (x) {
      if (isBigNumber(x) && (x = x.toNumber()), !isNumber$1(x) || !isInteger$1(x))
        throw new TypeError("The parameter k must be an integer number");
    } else
      x = 0;
    var D = x > 0 ? x : 0, F = x < 0 ? -x : 0, k = this._size[0], N = this._size[1], H = Math.min(k - F, N - D), R = [], j = [], S = [];
    S[0] = 0;
    for (var tt = D; tt < N && R.length < H; tt++)
      for (var nt = this._ptr[tt], ft = this._ptr[tt + 1], pt = nt; pt < ft; pt++) {
        var ct = this._index[pt];
        if (ct === tt - D + F) {
          R.push(this._values[pt]), j[R.length - 1] = ct - F;
          break;
        }
      }
    return S.push(R.length), new l({
      values: R,
      index: j,
      ptr: S,
      size: [H, 1]
    });
  }, l.fromJSON = function(x) {
    return new l(x);
  }, l.diagonal = function(x, D, F, k, N) {
    if (!isArray$1(x))
      throw new TypeError("Array expected, size parameter");
    if (x.length !== 2)
      throw new Error("Only two dimensions matrix are supported");
    if (x = x.map(function(it) {
      if (isBigNumber(it) && (it = it.toNumber()), !isNumber$1(it) || !isInteger$1(it) || it < 1)
        throw new Error("Size values must be positive integers");
      return it;
    }), F) {
      if (isBigNumber(F) && (F = F.toNumber()), !isNumber$1(F) || !isInteger$1(F))
        throw new TypeError("The parameter k must be an integer number");
    } else
      F = 0;
    var H = r, R = 0;
    isString$1(N) && (H = n.find(r, [N, N]) || r, R = n.convert(0, N));
    var j = F > 0 ? F : 0, S = F < 0 ? -F : 0, tt = x[0], nt = x[1], ft = Math.min(tt - S, nt - j), pt;
    if (isArray$1(D)) {
      if (D.length !== ft)
        throw new Error("Invalid value array length");
      pt = function(rt) {
        return D[rt];
      };
    } else if (isMatrix(D)) {
      var ct = D.size();
      if (ct.length !== 1 || ct[0] !== ft)
        throw new Error("Invalid matrix length");
      pt = function(rt) {
        return D.get([rt]);
      };
    } else
      pt = function() {
        return D;
      };
    for (var Nt = [], kt = [], Rt = [], Mt = 0; Mt < nt; Mt++) {
      Rt.push(Nt.length);
      var G = Mt - j;
      if (G >= 0 && G < ft) {
        var Y = pt(G);
        H(Y, R) || (kt.push(G + S), Nt.push(Y));
      }
    }
    return Rt.push(Nt.length), new l({
      values: Nt,
      index: kt,
      ptr: Rt,
      size: [tt, nt]
    });
  }, l.prototype.swapRows = function(x, D) {
    if (!isNumber$1(x) || !isInteger$1(x) || !isNumber$1(D) || !isInteger$1(D))
      throw new Error("Row index must be positive integers");
    if (this._size.length !== 2)
      throw new Error("Only two dimensional matrix is supported");
    return validateIndex(x, this._size[0]), validateIndex(D, this._size[0]), l._swapRows(x, D, this._size[1], this._values, this._index, this._ptr), this;
  }, l._forEachRow = function(x, D, F, k, N) {
    for (var H = k[x], R = k[x + 1], j = H; j < R; j++)
      N(F[j], D[j]);
  }, l._swapRows = function(x, D, F, k, N, H) {
    for (var R = 0; R < F; R++) {
      var j = H[R], S = H[R + 1], tt = v(x, j, S, N), nt = v(D, j, S, N);
      if (tt < S && nt < S && N[tt] === x && N[nt] === D) {
        if (k) {
          var ft = k[tt];
          k[tt] = k[nt], k[nt] = ft;
        }
        continue;
      }
      if (tt < S && N[tt] === x && (nt >= S || N[nt] !== D)) {
        var pt = k ? k[tt] : void 0;
        N.splice(nt, 0, D), k && k.splice(nt, 0, pt), N.splice(nt <= tt ? tt + 1 : tt, 1), k && k.splice(nt <= tt ? tt + 1 : tt, 1);
        continue;
      }
      if (nt < S && N[nt] === D && (tt >= S || N[tt] !== x)) {
        var ct = k ? k[nt] : void 0;
        N.splice(tt, 0, x), k && k.splice(tt, 0, ct), N.splice(tt <= nt ? nt + 1 : nt, 1), k && k.splice(tt <= nt ? nt + 1 : nt, 1);
      }
    }
  }, l;
}, {
  isClass: !0
}), name$m = "matrix", dependencies$l = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"], createMatrix = /* @__PURE__ */ factory(name$m, dependencies$l, (e) => {
  var {
    typed: n,
    Matrix: r,
    DenseMatrix: o,
    SparseMatrix: l
  } = e;
  return n(name$m, {
    "": function() {
      return u([]);
    },
    string: function(c) {
      return u([], c);
    },
    "string, string": function(c, f) {
      return u([], c, f);
    },
    Array: function(c) {
      return u(c);
    },
    Matrix: function(c) {
      return u(c, c.storage());
    },
    "Array | Matrix, string": u,
    "Array | Matrix, string, string": u
  });
  function u(h, c, f) {
    if (c === "dense" || c === "default" || c === void 0)
      return new o(h, f);
    if (c === "sparse")
      return new l(h, f);
    throw new TypeError("Unknown matrix type " + JSON.stringify(c) + ".");
  }
}), name$l = "addScalar", dependencies$k = ["typed"], createAddScalar = /* @__PURE__ */ factory(name$l, dependencies$k, (e) => {
  var {
    typed: n
  } = e;
  return n(name$l, {
    "number, number": addNumber,
    "Complex, Complex": function(o, l) {
      return o.add(l);
    },
    "BigNumber, BigNumber": function(o, l) {
      return o.plus(l);
    },
    "Fraction, Fraction": function(o, l) {
      return o.add(l);
    },
    "Unit, Unit": n.referToSelf((r) => (o, l) => {
      if (o.value === null || o.value === void 0)
        throw new Error("Parameter x contains a unit with undefined value");
      if (l.value === null || l.value === void 0)
        throw new Error("Parameter y contains a unit with undefined value");
      if (!o.equalBase(l))
        throw new Error("Units do not match");
      var u = o.clone();
      return u.value = n.find(r, [u.valueType(), l.valueType()])(u.value, l.value), u.fixPrefix = !1, u;
    })
  });
}), name$k = "matAlgo11xS0s", dependencies$j = ["typed", "equalScalar"], createMatAlgo11xS0s = /* @__PURE__ */ factory(name$k, dependencies$j, (e) => {
  var {
    typed: n,
    equalScalar: r
  } = e;
  return function(l, u, h, c) {
    var f = l._values, v = l._index, m = l._ptr, g = l._size, y = l._datatype;
    if (!f)
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    var w = g[0], E = g[1], x, D = r, F = 0, k = h;
    typeof y == "string" && (x = y, D = n.find(r, [x, x]), F = n.convert(0, x), u = n.convert(u, x), k = n.find(h, [x, x]));
    for (var N = [], H = [], R = [], j = 0; j < E; j++) {
      R[j] = H.length;
      for (var S = m[j], tt = m[j + 1], nt = S; nt < tt; nt++) {
        var ft = v[nt], pt = c ? k(u, f[nt]) : k(f[nt], u);
        D(pt, F) || (H.push(ft), N.push(pt));
      }
    }
    return R[E] = H.length, l.createSparseMatrix({
      values: N,
      index: H,
      ptr: R,
      size: [w, E],
      datatype: x
    });
  };
}), name$j = "matAlgo12xSfs", dependencies$i = ["typed", "DenseMatrix"], createMatAlgo12xSfs = /* @__PURE__ */ factory(name$j, dependencies$i, (e) => {
  var {
    typed: n,
    DenseMatrix: r
  } = e;
  return function(l, u, h, c) {
    var f = l._values, v = l._index, m = l._ptr, g = l._size, y = l._datatype;
    if (!f)
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    var w = g[0], E = g[1], x, D = h;
    typeof y == "string" && (x = y, u = n.convert(u, x), D = n.find(h, [x, x]));
    for (var F = [], k = [], N = [], H = 0; H < E; H++) {
      for (var R = H + 1, j = m[H], S = m[H + 1], tt = j; tt < S; tt++) {
        var nt = v[tt];
        k[nt] = f[tt], N[nt] = R;
      }
      for (var ft = 0; ft < w; ft++)
        H === 0 && (F[ft] = []), N[ft] === R ? F[ft][H] = c ? D(u, k[ft]) : D(k[ft], u) : F[ft][H] = c ? D(u, 0) : D(0, u);
    }
    return new r({
      data: F,
      size: [w, E],
      datatype: x
    });
  };
}), name$i = "matAlgo14xDs", dependencies$h = ["typed"], createMatAlgo14xDs = /* @__PURE__ */ factory(name$i, dependencies$h, (e) => {
  var {
    typed: n
  } = e;
  return function(l, u, h, c) {
    var f = l._data, v = l._size, m = l._datatype, g, y = h;
    typeof m == "string" && (g = m, u = n.convert(u, g), y = n.find(h, [g, g]));
    var w = v.length > 0 ? r(y, 0, v, v[0], f, u, c) : [];
    return l.createDenseMatrix({
      data: w,
      size: clone$2(v),
      datatype: g
    });
  };
  function r(o, l, u, h, c, f, v) {
    var m = [];
    if (l === u.length - 1)
      for (var g = 0; g < h; g++)
        m[g] = v ? o(f, c[g]) : o(c[g], f);
    else
      for (var y = 0; y < h; y++)
        m[y] = r(o, l + 1, u, u[l + 1], c[y], f, v);
    return m;
  }
}), name$h = "matAlgo03xDSf", dependencies$g = ["typed"], createMatAlgo03xDSf = /* @__PURE__ */ factory(name$h, dependencies$g, (e) => {
  var {
    typed: n
  } = e;
  return function(o, l, u, h) {
    var c = o._data, f = o._size, v = o._datatype || o.getDataType(), m = l._values, g = l._index, y = l._ptr, w = l._size, E = l._datatype || l._data === void 0 ? l._datatype : l.getDataType();
    if (f.length !== w.length)
      throw new DimensionError(f.length, w.length);
    if (f[0] !== w[0] || f[1] !== w[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + f + ") must match Matrix B (" + w + ")");
    if (!m)
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    var x = f[0], D = f[1], F, k = 0, N = u;
    typeof v == "string" && v === E && v !== "mixed" && (F = v, k = n.convert(0, F), N = n.find(u, [F, F]));
    for (var H = [], R = 0; R < x; R++)
      H[R] = [];
    for (var j = [], S = [], tt = 0; tt < D; tt++) {
      for (var nt = tt + 1, ft = y[tt], pt = y[tt + 1], ct = ft; ct < pt; ct++) {
        var Nt = g[ct];
        j[Nt] = h ? N(m[ct], c[Nt][tt]) : N(c[Nt][tt], m[ct]), S[Nt] = nt;
      }
      for (var kt = 0; kt < x; kt++)
        S[kt] === nt ? H[kt][tt] = j[kt] : H[kt][tt] = h ? N(k, c[kt][tt]) : N(c[kt][tt], k);
    }
    return o.createDenseMatrix({
      data: H,
      size: [x, D],
      datatype: v === o._datatype && E === l._datatype ? F : void 0
    });
  };
}), name$g = "matAlgo13xDD", dependencies$f = ["typed"], createMatAlgo13xDD = /* @__PURE__ */ factory(name$g, dependencies$f, (e) => {
  var {
    typed: n
  } = e;
  return function(l, u, h) {
    var c = l._data, f = l._size, v = l._datatype, m = u._data, g = u._size, y = u._datatype, w = [];
    if (f.length !== g.length)
      throw new DimensionError(f.length, g.length);
    for (var E = 0; E < f.length; E++) {
      if (f[E] !== g[E])
        throw new RangeError("Dimension mismatch. Matrix A (" + f + ") must match Matrix B (" + g + ")");
      w[E] = f[E];
    }
    var x, D = h;
    typeof v == "string" && v === y && (x = v, D = n.find(h, [x, x]));
    var F = w.length > 0 ? r(D, 0, w, w[0], c, m) : [];
    return l.createDenseMatrix({
      data: F,
      size: w,
      datatype: x
    });
  };
  function r(o, l, u, h, c, f) {
    var v = [];
    if (l === u.length - 1)
      for (var m = 0; m < h; m++)
        v[m] = o(c[m], f[m]);
    else
      for (var g = 0; g < h; g++)
        v[g] = r(o, l + 1, u, u[l + 1], c[g], f[g]);
    return v;
  }
}), name$f = "broadcast", dependancies = ["concat"], createBroadcast = /* @__PURE__ */ factory(name$f, dependancies, (e) => {
  var {
    concat: n
  } = e;
  return function(l, u) {
    var h = Math.max(l._size.length, u._size.length);
    if (l._size.length === u._size.length && l._size.every((E, x) => E === u._size[x]))
      return [l, u];
    for (var c = r(l._size, h, 0), f = r(u._size, h, 0), v = [], m = 0; m < h; m++)
      v[m] = Math.max(c[m], f[m]);
    checkBroadcastingRules(c, v), checkBroadcastingRules(f, v);
    var g = l.clone(), y = u.clone();
    g._size.length < h ? g.reshape(r(g._size, h, 1)) : y._size.length < h && y.reshape(r(y._size, h, 1));
    for (var w = 0; w < h; w++)
      g._size[w] < v[w] && (g = o(g, v[w], w)), y._size[w] < v[w] && (y = o(y, v[w], w));
    return [g, y];
  };
  function r(l, u, h) {
    return [...Array(u - l.length).fill(h), ...l];
  }
  function o(l, u, h) {
    return n(...Array(u).fill(l), h);
  }
}), name$e = "matrixAlgorithmSuite", dependencies$e = ["typed", "matrix", "concat"], createMatrixAlgorithmSuite = /* @__PURE__ */ factory(name$e, dependencies$e, (e) => {
  var {
    typed: n,
    matrix: r,
    concat: o
  } = e, l = createMatAlgo13xDD({
    typed: n
  }), u = createMatAlgo14xDs({
    typed: n
  }), h = createBroadcast({
    concat: o
  });
  return function(f) {
    var v = f.elop, m = f.SD || f.DS, g;
    v ? (g = {
      "DenseMatrix, DenseMatrix": (x, D) => l(...h(x, D), v),
      "Array, Array": (x, D) => l(...h(r(x), r(D)), v).valueOf(),
      "Array, DenseMatrix": (x, D) => l(...h(r(x), D), v),
      "DenseMatrix, Array": (x, D) => l(...h(x, r(D)), v)
    }, f.SS && (g["SparseMatrix, SparseMatrix"] = (x, D) => f.SS(...h(x, D), v, !1)), f.DS && (g["DenseMatrix, SparseMatrix"] = (x, D) => f.DS(...h(x, D), v, !1), g["Array, SparseMatrix"] = (x, D) => f.DS(...h(r(x), D), v, !1)), m && (g["SparseMatrix, DenseMatrix"] = (x, D) => m(...h(D, x), v, !0), g["SparseMatrix, Array"] = (x, D) => m(...h(r(D), x), v, !0))) : (g = {
      "DenseMatrix, DenseMatrix": n.referToSelf((x) => (D, F) => l(...h(D, F), x)),
      "Array, Array": n.referToSelf((x) => (D, F) => l(...h(r(D), r(F)), x).valueOf()),
      "Array, DenseMatrix": n.referToSelf((x) => (D, F) => l(...h(r(D), F), x)),
      "DenseMatrix, Array": n.referToSelf((x) => (D, F) => l(...h(D, r(F)), x))
    }, f.SS && (g["SparseMatrix, SparseMatrix"] = n.referToSelf((x) => (D, F) => f.SS(...h(D, F), x, !1))), f.DS && (g["DenseMatrix, SparseMatrix"] = n.referToSelf((x) => (D, F) => f.DS(...h(D, F), x, !1)), g["Array, SparseMatrix"] = n.referToSelf((x) => (D, F) => f.DS(...h(r(D), F), x, !1))), m && (g["SparseMatrix, DenseMatrix"] = n.referToSelf((x) => (D, F) => m(...h(F, D), x, !0)), g["SparseMatrix, Array"] = n.referToSelf((x) => (D, F) => m(...h(r(F), D), x, !0))));
    var y = f.scalar || "any", w = f.Ds || f.Ss;
    w && (v ? (g["DenseMatrix," + y] = (x, D) => u(x, D, v, !1), g[y + ", DenseMatrix"] = (x, D) => u(D, x, v, !0), g["Array," + y] = (x, D) => u(r(x), D, v, !1).valueOf(), g[y + ", Array"] = (x, D) => u(r(D), x, v, !0).valueOf()) : (g["DenseMatrix," + y] = n.referToSelf((x) => (D, F) => u(D, F, x, !1)), g[y + ", DenseMatrix"] = n.referToSelf((x) => (D, F) => u(F, D, x, !0)), g["Array," + y] = n.referToSelf((x) => (D, F) => u(r(D), F, x, !1).valueOf()), g[y + ", Array"] = n.referToSelf((x) => (D, F) => u(r(F), D, x, !0).valueOf())));
    var E = f.sS !== void 0 ? f.sS : f.Ss;
    return v ? (f.Ss && (g["SparseMatrix," + y] = (x, D) => f.Ss(x, D, v, !1)), E && (g[y + ", SparseMatrix"] = (x, D) => E(D, x, v, !0))) : (f.Ss && (g["SparseMatrix," + y] = n.referToSelf((x) => (D, F) => f.Ss(D, F, x, !1))), E && (g[y + ", SparseMatrix"] = n.referToSelf((x) => (D, F) => E(F, D, x, !0)))), v && v.signatures && extend$2(g, v.signatures), g;
  };
}), name$d = "multiplyScalar", dependencies$d = ["typed"], createMultiplyScalar = /* @__PURE__ */ factory(name$d, dependencies$d, (e) => {
  var {
    typed: n
  } = e;
  return n("multiplyScalar", {
    "number, number": multiplyNumber,
    "Complex, Complex": function(o, l) {
      return o.mul(l);
    },
    "BigNumber, BigNumber": function(o, l) {
      return o.times(l);
    },
    "Fraction, Fraction": function(o, l) {
      return o.mul(l);
    },
    "number | Fraction | BigNumber | Complex, Unit": (r, o) => o.multiply(r),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (r, o) => r.multiply(o)
  });
}), name$c = "multiply", dependencies$c = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"], createMultiply = /* @__PURE__ */ factory(name$c, dependencies$c, (e) => {
  var {
    typed: n,
    matrix: r,
    addScalar: o,
    multiplyScalar: l,
    equalScalar: u,
    dot: h
  } = e, c = createMatAlgo11xS0s({
    typed: n,
    equalScalar: u
  }), f = createMatAlgo14xDs({
    typed: n
  });
  function v(R, j) {
    switch (R.length) {
      case 1:
        switch (j.length) {
          case 1:
            if (R[0] !== j[0])
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            break;
          case 2:
            if (R[0] !== j[0])
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + R[0] + ") must match Matrix rows (" + j[0] + ")");
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + j.length + " dimensions)");
        }
        break;
      case 2:
        switch (j.length) {
          case 1:
            if (R[1] !== j[0])
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + R[1] + ") must match Vector length (" + j[0] + ")");
            break;
          case 2:
            if (R[1] !== j[0])
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + R[1] + ") must match Matrix B rows (" + j[0] + ")");
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + j.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + R.length + " dimensions)");
    }
  }
  function m(R, j, S) {
    if (S === 0)
      throw new Error("Cannot multiply two empty vectors");
    return h(R, j);
  }
  function g(R, j) {
    if (j.storage() !== "dense")
      throw new Error("Support for SparseMatrix not implemented");
    return y(R, j);
  }
  function y(R, j) {
    var S = R._data, tt = R._size, nt = R._datatype || R.getDataType(), ft = j._data, pt = j._size, ct = j._datatype || j.getDataType(), Nt = tt[0], kt = pt[1], Rt, Mt = o, G = l;
    nt && ct && nt === ct && typeof nt == "string" && nt !== "mixed" && (Rt = nt, Mt = n.find(o, [Rt, Rt]), G = n.find(l, [Rt, Rt]));
    for (var Y = [], it = 0; it < kt; it++) {
      for (var rt = G(S[0], ft[0][it]), ht = 1; ht < Nt; ht++)
        rt = Mt(rt, G(S[ht], ft[ht][it]));
      Y[it] = rt;
    }
    return R.createDenseMatrix({
      data: Y,
      size: [kt],
      datatype: nt === R._datatype && ct === j._datatype ? Rt : void 0
    });
  }
  var w = n("_multiplyMatrixVector", {
    "DenseMatrix, any": x,
    "SparseMatrix, any": k
  }), E = n("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": D,
    "DenseMatrix, SparseMatrix": F,
    "SparseMatrix, DenseMatrix": N,
    "SparseMatrix, SparseMatrix": H
  });
  function x(R, j) {
    var S = R._data, tt = R._size, nt = R._datatype || R.getDataType(), ft = j._data, pt = j._datatype || j.getDataType(), ct = tt[0], Nt = tt[1], kt, Rt = o, Mt = l;
    nt && pt && nt === pt && typeof nt == "string" && nt !== "mixed" && (kt = nt, Rt = n.find(o, [kt, kt]), Mt = n.find(l, [kt, kt]));
    for (var G = [], Y = 0; Y < ct; Y++) {
      for (var it = S[Y], rt = Mt(it[0], ft[0]), ht = 1; ht < Nt; ht++)
        rt = Rt(rt, Mt(it[ht], ft[ht]));
      G[Y] = rt;
    }
    return R.createDenseMatrix({
      data: G,
      size: [ct],
      datatype: nt === R._datatype && pt === j._datatype ? kt : void 0
    });
  }
  function D(R, j) {
    var S = R._data, tt = R._size, nt = R._datatype || R.getDataType(), ft = j._data, pt = j._size, ct = j._datatype || j.getDataType(), Nt = tt[0], kt = tt[1], Rt = pt[1], Mt, G = o, Y = l;
    nt && ct && nt === ct && typeof nt == "string" && nt !== "mixed" && nt !== "mixed" && (Mt = nt, G = n.find(o, [Mt, Mt]), Y = n.find(l, [Mt, Mt]));
    for (var it = [], rt = 0; rt < Nt; rt++) {
      var ht = S[rt];
      it[rt] = [];
      for (var bt = 0; bt < Rt; bt++) {
        for (var yt = Y(ht[0], ft[0][bt]), St = 1; St < kt; St++)
          yt = G(yt, Y(ht[St], ft[St][bt]));
        it[rt][bt] = yt;
      }
    }
    return R.createDenseMatrix({
      data: it,
      size: [Nt, Rt],
      datatype: nt === R._datatype && ct === j._datatype ? Mt : void 0
    });
  }
  function F(R, j) {
    var S = R._data, tt = R._size, nt = R._datatype || R.getDataType(), ft = j._values, pt = j._index, ct = j._ptr, Nt = j._size, kt = j._datatype || j._data === void 0 ? j._datatype : j.getDataType();
    if (!ft)
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    var Rt = tt[0], Mt = Nt[1], G, Y = o, it = l, rt = u, ht = 0;
    nt && kt && nt === kt && typeof nt == "string" && nt !== "mixed" && (G = nt, Y = n.find(o, [G, G]), it = n.find(l, [G, G]), rt = n.find(u, [G, G]), ht = n.convert(0, G));
    for (var bt = [], yt = [], St = [], Ft = j.createSparseMatrix({
      values: bt,
      index: yt,
      ptr: St,
      size: [Rt, Mt],
      datatype: nt === R._datatype && kt === j._datatype ? G : void 0
    }), zt = 0; zt < Mt; zt++) {
      St[zt] = yt.length;
      var Zt = ct[zt], J = ct[zt + 1];
      if (J > Zt)
        for (var et = 0, at = 0; at < Rt; at++) {
          for (var gt = at + 1, wt = void 0, Et = Zt; Et < J; Et++) {
            var qt = pt[Et];
            et !== gt ? (wt = it(S[at][qt], ft[Et]), et = gt) : wt = Y(wt, it(S[at][qt], ft[Et]));
          }
          et === gt && !rt(wt, ht) && (yt.push(at), bt.push(wt));
        }
    }
    return St[Mt] = yt.length, Ft;
  }
  function k(R, j) {
    var S = R._values, tt = R._index, nt = R._ptr, ft = R._datatype || R._data === void 0 ? R._datatype : R.getDataType();
    if (!S)
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    var pt = j._data, ct = j._datatype || j.getDataType(), Nt = R._size[0], kt = j._size[0], Rt = [], Mt = [], G = [], Y, it = o, rt = l, ht = u, bt = 0;
    ft && ct && ft === ct && typeof ft == "string" && ft !== "mixed" && (Y = ft, it = n.find(o, [Y, Y]), rt = n.find(l, [Y, Y]), ht = n.find(u, [Y, Y]), bt = n.convert(0, Y));
    var yt = [], St = [];
    G[0] = 0;
    for (var Ft = 0; Ft < kt; Ft++) {
      var zt = pt[Ft];
      if (!ht(zt, bt))
        for (var Zt = nt[Ft], J = nt[Ft + 1], et = Zt; et < J; et++) {
          var at = tt[et];
          St[at] ? yt[at] = it(yt[at], rt(zt, S[et])) : (St[at] = !0, Mt.push(at), yt[at] = rt(zt, S[et]));
        }
    }
    for (var gt = Mt.length, wt = 0; wt < gt; wt++) {
      var Et = Mt[wt];
      Rt[wt] = yt[Et];
    }
    return G[1] = Mt.length, R.createSparseMatrix({
      values: Rt,
      index: Mt,
      ptr: G,
      size: [Nt, 1],
      datatype: ft === R._datatype && ct === j._datatype ? Y : void 0
    });
  }
  function N(R, j) {
    var S = R._values, tt = R._index, nt = R._ptr, ft = R._datatype || R._data === void 0 ? R._datatype : R.getDataType();
    if (!S)
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    var pt = j._data, ct = j._datatype || j.getDataType(), Nt = R._size[0], kt = j._size[0], Rt = j._size[1], Mt, G = o, Y = l, it = u, rt = 0;
    ft && ct && ft === ct && typeof ft == "string" && ft !== "mixed" && (Mt = ft, G = n.find(o, [Mt, Mt]), Y = n.find(l, [Mt, Mt]), it = n.find(u, [Mt, Mt]), rt = n.convert(0, Mt));
    for (var ht = [], bt = [], yt = [], St = R.createSparseMatrix({
      values: ht,
      index: bt,
      ptr: yt,
      size: [Nt, Rt],
      datatype: ft === R._datatype && ct === j._datatype ? Mt : void 0
    }), Ft = [], zt = [], Zt = 0; Zt < Rt; Zt++) {
      yt[Zt] = bt.length;
      for (var J = Zt + 1, et = 0; et < kt; et++) {
        var at = pt[et][Zt];
        if (!it(at, rt))
          for (var gt = nt[et], wt = nt[et + 1], Et = gt; Et < wt; Et++) {
            var qt = tt[Et];
            zt[qt] !== J ? (zt[qt] = J, bt.push(qt), Ft[qt] = Y(at, S[Et])) : Ft[qt] = G(Ft[qt], Y(at, S[Et]));
          }
      }
      for (var Jt = yt[Zt], Gt = bt.length, Yt = Jt; Yt < Gt; Yt++) {
        var he = bt[Yt];
        ht[Yt] = Ft[he];
      }
    }
    return yt[Rt] = bt.length, St;
  }
  function H(R, j) {
    var S = R._values, tt = R._index, nt = R._ptr, ft = R._datatype || R._data === void 0 ? R._datatype : R.getDataType(), pt = j._values, ct = j._index, Nt = j._ptr, kt = j._datatype || j._data === void 0 ? j._datatype : j.getDataType(), Rt = R._size[0], Mt = j._size[1], G = S && pt, Y, it = o, rt = l;
    ft && kt && ft === kt && typeof ft == "string" && ft !== "mixed" && (Y = ft, it = n.find(o, [Y, Y]), rt = n.find(l, [Y, Y]));
    for (var ht = G ? [] : void 0, bt = [], yt = [], St = R.createSparseMatrix({
      values: ht,
      index: bt,
      ptr: yt,
      size: [Rt, Mt],
      datatype: ft === R._datatype && kt === j._datatype ? Y : void 0
    }), Ft = G ? [] : void 0, zt = [], Zt, J, et, at, gt, wt, Et, qt, Jt = 0; Jt < Mt; Jt++) {
      yt[Jt] = bt.length;
      var Gt = Jt + 1;
      for (gt = Nt[Jt], wt = Nt[Jt + 1], at = gt; at < wt; at++)
        if (qt = ct[at], G)
          for (J = nt[qt], et = nt[qt + 1], Zt = J; Zt < et; Zt++)
            Et = tt[Zt], zt[Et] !== Gt ? (zt[Et] = Gt, bt.push(Et), Ft[Et] = rt(pt[at], S[Zt])) : Ft[Et] = it(Ft[Et], rt(pt[at], S[Zt]));
        else
          for (J = nt[qt], et = nt[qt + 1], Zt = J; Zt < et; Zt++)
            Et = tt[Zt], zt[Et] !== Gt && (zt[Et] = Gt, bt.push(Et));
      if (G)
        for (var Yt = yt[Jt], he = bt.length, Pe = Yt; Pe < he; Pe++) {
          var ce = bt[Pe];
          ht[Pe] = Ft[ce];
        }
    }
    return yt[Mt] = bt.length, St;
  }
  return n(name$c, l, {
    // we extend the signatures of multiplyScalar with signatures dealing with matrices
    "Array, Array": n.referTo("Matrix, Matrix", (R) => (j, S) => {
      v(arraySize(j), arraySize(S));
      var tt = R(r(j), r(S));
      return isMatrix(tt) ? tt.valueOf() : tt;
    }),
    "Matrix, Matrix": function(j, S) {
      var tt = j.size(), nt = S.size();
      return v(tt, nt), tt.length === 1 ? nt.length === 1 ? m(j, S, tt[0]) : g(j, S) : nt.length === 1 ? w(j, S) : E(j, S);
    },
    "Matrix, Array": n.referTo("Matrix,Matrix", (R) => (j, S) => R(j, r(S))),
    "Array, Matrix": n.referToSelf((R) => (j, S) => R(r(j, S.storage()), S)),
    "SparseMatrix, any": function(j, S) {
      return c(j, S, l, !1);
    },
    "DenseMatrix, any": function(j, S) {
      return f(j, S, l, !1);
    },
    "any, SparseMatrix": function(j, S) {
      return c(S, j, l, !0);
    },
    "any, DenseMatrix": function(j, S) {
      return f(S, j, l, !0);
    },
    "Array, any": function(j, S) {
      return f(r(j), S, l, !1).valueOf();
    },
    "any, Array": function(j, S) {
      return f(r(S), j, l, !0).valueOf();
    },
    "any, any": l,
    "any, any, ...any": n.referToSelf((R) => (j, S, tt) => {
      for (var nt = R(j, S), ft = 0; ft < tt.length; ft++)
        nt = R(nt, tt[ft]);
      return nt;
    })
  });
}), name$b = "matAlgo07xSSf", dependencies$b = ["typed", "DenseMatrix"], createMatAlgo07xSSf = /* @__PURE__ */ factory(name$b, dependencies$b, (e) => {
  var {
    typed: n,
    DenseMatrix: r
  } = e;
  return function(u, h, c) {
    var f = u._size, v = u._datatype || u._data === void 0 ? u._datatype : u.getDataType(), m = h._size, g = h._datatype || h._data === void 0 ? h._datatype : h.getDataType();
    if (f.length !== m.length)
      throw new DimensionError(f.length, m.length);
    if (f[0] !== m[0] || f[1] !== m[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + f + ") must match Matrix B (" + m + ")");
    var y = f[0], w = f[1], E, x = 0, D = c;
    typeof v == "string" && v === g && v !== "mixed" && (E = v, x = n.convert(0, E), D = n.find(c, [E, E]));
    var F, k, N = [];
    for (F = 0; F < y; F++)
      N[F] = [];
    var H = [], R = [], j = [], S = [];
    for (k = 0; k < w; k++) {
      var tt = k + 1;
      for (o(u, k, j, H, tt), o(h, k, S, R, tt), F = 0; F < y; F++) {
        var nt = j[F] === tt ? H[F] : x, ft = S[F] === tt ? R[F] : x;
        N[F][k] = D(nt, ft);
      }
    }
    return new r({
      data: N,
      size: [y, w],
      datatype: v === u._datatype && g === h._datatype ? E : void 0
    });
  };
  function o(l, u, h, c, f) {
    for (var v = l._values, m = l._index, g = l._ptr, y = g[u], w = g[u + 1]; y < w; y++) {
      var E = m[y];
      h[E] = f, c[E] = v[y];
    }
  }
}), name$a = "conj", dependencies$a = ["typed"], createConj = /* @__PURE__ */ factory(name$a, dependencies$a, (e) => {
  var {
    typed: n
  } = e;
  return n(name$a, {
    "number | BigNumber | Fraction": (r) => r,
    Complex: (r) => r.conjugate(),
    "Array | Matrix": n.referToSelf((r) => (o) => deepMap(o, r))
  });
}), name$9 = "concat", dependencies$9 = ["typed", "matrix", "isInteger"], createConcat = /* @__PURE__ */ factory(name$9, dependencies$9, (e) => {
  var {
    typed: n,
    matrix: r,
    isInteger: o
  } = e;
  return n(name$9, {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    "...Array | Matrix | number | BigNumber": function(u) {
      var h, c = u.length, f = -1, v, m = !1, g = [];
      for (h = 0; h < c; h++) {
        var y = u[h];
        if (isMatrix(y) && (m = !0), isNumber$1(y) || isBigNumber(y)) {
          if (h !== c - 1)
            throw new Error("Dimension must be specified as last argument");
          if (v = f, f = y.valueOf(), !o(f))
            throw new TypeError("Integer number expected for dimension");
          if (f < 0 || h > 0 && f > v)
            throw new IndexError(f, v + 1);
        } else {
          var w = clone$2(y).valueOf(), E = arraySize(w);
          if (g[h] = w, v = f, f = E.length - 1, h > 0 && f !== v)
            throw new DimensionError(v + 1, f + 1);
        }
      }
      if (g.length === 0)
        throw new SyntaxError("At least one matrix expected");
      for (var x = g.shift(); g.length; )
        x = concat$1(x, g.shift(), f);
      return m ? r(x) : x;
    },
    "...string": function(u) {
      return u.join("");
    }
  });
}), name$8 = "getMatrixDataType", dependencies$8 = ["typed"], createGetMatrixDataType = /* @__PURE__ */ factory(name$8, dependencies$8, (e) => {
  var {
    typed: n
  } = e;
  return n(name$8, {
    Array: function(o) {
      return getArrayDataType(o, typeOf);
    },
    Matrix: function(o) {
      return o.getDataType();
    }
  });
});
function noMatrix() {
  throw new Error('No "matrix" implementation available');
}
var name$7 = "size", dependencies$7 = ["typed", "config", "?matrix"], createSize = /* @__PURE__ */ factory(name$7, dependencies$7, (e) => {
  var {
    typed: n,
    config: r,
    matrix: o
  } = e;
  return n(name$7, {
    Matrix: function(u) {
      return u.create(u.size());
    },
    Array: arraySize,
    string: function(u) {
      return r.matrix === "Array" ? [u.length] : o([u.length]);
    },
    "number | Complex | BigNumber | Unit | boolean | null": function(u) {
      return r.matrix === "Array" ? [] : o ? o([]) : noMatrix();
    }
  });
}), name$6 = "smaller", dependencies$6 = ["typed", "config", "matrix", "DenseMatrix", "concat"], createSmaller = /* @__PURE__ */ factory(name$6, dependencies$6, (e) => {
  var {
    typed: n,
    config: r,
    matrix: o,
    DenseMatrix: l,
    concat: u
  } = e, h = createMatAlgo03xDSf({
    typed: n
  }), c = createMatAlgo07xSSf({
    typed: n,
    DenseMatrix: l
  }), f = createMatAlgo12xSfs({
    typed: n,
    DenseMatrix: l
  }), v = createMatrixAlgorithmSuite({
    typed: n,
    matrix: o,
    concat: u
  }), m = createCompareUnits({
    typed: n
  });
  return n(name$6, createSmallerNumber({
    typed: n,
    config: r
  }), {
    "boolean, boolean": (g, y) => g < y,
    "BigNumber, BigNumber": function(y, w) {
      return y.lt(w) && !nearlyEqual(y, w, r.epsilon);
    },
    "Fraction, Fraction": (g, y) => g.compare(y) === -1,
    "Complex, Complex": function(y, w) {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, m, v({
    SS: c,
    DS: h,
    Ss: f
  }));
}), createSmallerNumber = /* @__PURE__ */ factory(name$6, ["typed", "config"], (e) => {
  var {
    typed: n,
    config: r
  } = e;
  return n(name$6, {
    "number, number": function(l, u) {
      return l < u && !nearlyEqual$1(l, u, r.epsilon);
    }
  });
}), name$5 = "ImmutableDenseMatrix", dependencies$5 = ["smaller", "DenseMatrix"], createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name$5, dependencies$5, (e) => {
  var {
    smaller: n,
    DenseMatrix: r
  } = e;
  function o(l, u) {
    if (!(this instanceof o))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (u && !isString$1(u))
      throw new Error("Invalid datatype: " + u);
    if (isMatrix(l) || isArray$1(l)) {
      var h = new r(l, u);
      this._data = h._data, this._size = h._size, this._datatype = h._datatype, this._min = null, this._max = null;
    } else if (l && isArray$1(l.data) && isArray$1(l.size))
      this._data = l.data, this._size = l.size, this._datatype = l.datatype, this._min = typeof l.min < "u" ? l.min : null, this._max = typeof l.max < "u" ? l.max : null;
    else {
      if (l)
        throw new TypeError("Unsupported type of data (" + typeOf(l) + ")");
      this._data = [], this._size = [0], this._datatype = u, this._min = null, this._max = null;
    }
  }
  return o.prototype = new r(), o.prototype.type = "ImmutableDenseMatrix", o.prototype.isImmutableDenseMatrix = !0, o.prototype.subset = function(l) {
    switch (arguments.length) {
      case 1: {
        var u = r.prototype.subset.call(this, l);
        return isMatrix(u) ? new o({
          data: u._data,
          size: u._size,
          datatype: u._datatype
        }) : u;
      }
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  }, o.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  }, o.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  }, o.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  }, o.prototype.clone = function() {
    return new o({
      data: clone$2(this._data),
      size: clone$2(this._size),
      datatype: this._datatype
    });
  }, o.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  }, o.fromJSON = function(l) {
    return new o(l);
  }, o.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  }, o.prototype.min = function() {
    if (this._min === null) {
      var l = null;
      this.forEach(function(u) {
        (l === null || n(u, l)) && (l = u);
      }), this._min = l !== null ? l : void 0;
    }
    return this._min;
  }, o.prototype.max = function() {
    if (this._max === null) {
      var l = null;
      this.forEach(function(u) {
        (l === null || n(l, u)) && (l = u);
      }), this._max = l !== null ? l : void 0;
    }
    return this._max;
  }, o;
}, {
  isClass: !0
}), name$4 = "Index", dependencies$4 = ["ImmutableDenseMatrix", "getMatrixDataType"], createIndexClass = /* @__PURE__ */ factory(name$4, dependencies$4, (e) => {
  var {
    ImmutableDenseMatrix: n,
    getMatrixDataType: r
  } = e;
  function o(u) {
    if (!(this instanceof o))
      throw new SyntaxError("Constructor must be called with the new operator");
    this._dimensions = [], this._sourceSize = [], this._isScalar = !0;
    for (var h = 0, c = arguments.length; h < c; h++) {
      var f = arguments[h], v = isArray$1(f), m = isMatrix(f), g = null;
      if (isRange(f))
        this._dimensions.push(f), this._isScalar = !1;
      else if (v || m) {
        var y = void 0;
        r(f) === "boolean" ? (v && (y = l(_booleansArrayToNumbersForIndex(f).valueOf())), m && (y = l(_booleansArrayToNumbersForIndex(f._data).valueOf())), g = f.valueOf().length) : y = l(f.valueOf()), this._dimensions.push(y);
        var w = y.size();
        (w.length !== 1 || w[0] !== 1 || g !== null) && (this._isScalar = !1);
      } else if (typeof f == "number")
        this._dimensions.push(l([f]));
      else if (typeof f == "string")
        this._dimensions.push(f);
      else
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      this._sourceSize.push(g);
    }
  }
  o.prototype.type = "Index", o.prototype.isIndex = !0;
  function l(u) {
    for (var h = 0, c = u.length; h < c; h++)
      if (typeof u[h] != "number" || !isInteger$1(u[h]))
        throw new TypeError("Index parameters must be positive integer numbers");
    return new n(u);
  }
  return o.prototype.clone = function() {
    var u = new o();
    return u._dimensions = clone$2(this._dimensions), u._isScalar = this._isScalar, u._sourceSize = this._sourceSize, u;
  }, o.create = function(u) {
    var h = new o();
    return o.apply(h, u), h;
  }, o.prototype.size = function() {
    for (var u = [], h = 0, c = this._dimensions.length; h < c; h++) {
      var f = this._dimensions[h];
      u[h] = typeof f == "string" ? 1 : f.size()[0];
    }
    return u;
  }, o.prototype.max = function() {
    for (var u = [], h = 0, c = this._dimensions.length; h < c; h++) {
      var f = this._dimensions[h];
      u[h] = typeof f == "string" ? f : f.max();
    }
    return u;
  }, o.prototype.min = function() {
    for (var u = [], h = 0, c = this._dimensions.length; h < c; h++) {
      var f = this._dimensions[h];
      u[h] = typeof f == "string" ? f : f.min();
    }
    return u;
  }, o.prototype.forEach = function(u) {
    for (var h = 0, c = this._dimensions.length; h < c; h++)
      u(this._dimensions[h], h, this);
  }, o.prototype.dimension = function(u) {
    return this._dimensions[u] || null;
  }, o.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] == "string";
  }, o.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  }, o.prototype.isScalar = function() {
    return this._isScalar;
  }, o.prototype.toArray = function() {
    for (var u = [], h = 0, c = this._dimensions.length; h < c; h++) {
      var f = this._dimensions[h];
      u.push(typeof f == "string" ? f : f.toArray());
    }
    return u;
  }, o.prototype.valueOf = o.prototype.toArray, o.prototype.toString = function() {
    for (var u = [], h = 0, c = this._dimensions.length; h < c; h++) {
      var f = this._dimensions[h];
      typeof f == "string" ? u.push(JSON.stringify(f)) : u.push(f.toString());
    }
    return "[" + u.join(", ") + "]";
  }, o.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  }, o.fromJSON = function(u) {
    return o.create(u.dimensions);
  }, o;
}, {
  isClass: !0
});
function _booleansArrayToNumbersForIndex(e) {
  var n = [];
  return e.forEach((r, o) => {
    r && n.push(o);
  }), n;
}
var createTrigUnit = /* @__PURE__ */ factory("trigUnit", ["typed"], (e) => {
  var {
    typed: n
  } = e;
  return {
    Unit: n.referToSelf((r) => (o) => {
      if (!o.hasBase(o.constructor.BASE_UNITS.ANGLE))
        throw new TypeError("Unit in function cot is no angle");
      return n.find(r, o.valueType())(o.value);
    })
  };
}), name$3 = "cos", dependencies$3 = ["typed"], createCos = /* @__PURE__ */ factory(name$3, dependencies$3, (e) => {
  var {
    typed: n
  } = e, r = createTrigUnit({
    typed: n
  });
  return n(name$3, {
    number: Math.cos,
    "Complex | BigNumber": (o) => o.cos()
  }, r);
}), name$2 = "sin", dependencies$2 = ["typed"], createSin = /* @__PURE__ */ factory(name$2, dependencies$2, (e) => {
  var {
    typed: n
  } = e, r = createTrigUnit({
    typed: n
  });
  return n(name$2, {
    number: Math.sin,
    "Complex | BigNumber": (o) => o.sin()
  }, r);
}), name$1 = "dot", dependencies$1 = ["typed", "addScalar", "multiplyScalar", "conj", "size"], createDot = /* @__PURE__ */ factory(name$1, dependencies$1, (e) => {
  var {
    typed: n,
    addScalar: r,
    multiplyScalar: o,
    conj: l,
    size: u
  } = e;
  return n(name$1, {
    "Array | DenseMatrix, Array | DenseMatrix": c,
    "SparseMatrix, SparseMatrix": f
  });
  function h(m, g) {
    var y = v(m), w = v(g), E, x;
    if (y.length === 1)
      E = y[0];
    else if (y.length === 2 && y[1] === 1)
      E = y[0];
    else
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + y.join(", ") + ")");
    if (w.length === 1)
      x = w[0];
    else if (w.length === 2 && w[1] === 1)
      x = w[0];
    else
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + w.join(", ") + ")");
    if (E !== x)
      throw new RangeError("Vectors must have equal length (" + E + " != " + x + ")");
    if (E === 0)
      throw new RangeError("Cannot calculate the dot product of empty vectors");
    return E;
  }
  function c(m, g) {
    var y = h(m, g), w = isMatrix(m) ? m._data : m, E = isMatrix(m) ? m._datatype || m.getDataType() : void 0, x = isMatrix(g) ? g._data : g, D = isMatrix(g) ? g._datatype || g.getDataType() : void 0, F = v(m).length === 2, k = v(g).length === 2, N = r, H = o;
    if (E && D && E === D && typeof E == "string" && E !== "mixed") {
      var R = E;
      N = n.find(r, [R, R]), H = n.find(o, [R, R]);
    }
    if (!F && !k) {
      for (var j = H(l(w[0]), x[0]), S = 1; S < y; S++)
        j = N(j, H(l(w[S]), x[S]));
      return j;
    }
    if (!F && k) {
      for (var tt = H(l(w[0]), x[0][0]), nt = 1; nt < y; nt++)
        tt = N(tt, H(l(w[nt]), x[nt][0]));
      return tt;
    }
    if (F && !k) {
      for (var ft = H(l(w[0][0]), x[0]), pt = 1; pt < y; pt++)
        ft = N(ft, H(l(w[pt][0]), x[pt]));
      return ft;
    }
    if (F && k) {
      for (var ct = H(l(w[0][0]), x[0][0]), Nt = 1; Nt < y; Nt++)
        ct = N(ct, H(l(w[Nt][0]), x[Nt][0]));
      return ct;
    }
  }
  function f(m, g) {
    h(m, g);
    for (var y = m._index, w = m._values, E = g._index, x = g._values, D = 0, F = r, k = o, N = 0, H = 0; N < y.length && H < E.length; ) {
      var R = y[N], j = E[H];
      if (R < j) {
        N++;
        continue;
      }
      if (R > j) {
        H++;
        continue;
      }
      R === j && (D = F(D, k(w[N], x[H])), N++, H++);
    }
    return D;
  }
  function v(m) {
    return isMatrix(m) ? m.size() : u(m);
  }
}), name = "index", dependencies = ["typed", "Index"], createIndex = /* @__PURE__ */ factory(name, dependencies, (e) => {
  var {
    typed: n,
    Index: r
  } = e;
  return n(name, {
    "...number | string | BigNumber | Range | Array | Matrix": function(l) {
      var u = l.map(function(c) {
        return isBigNumber(c) ? c.toNumber() : isArray$1(c) || isMatrix(c) ? c.map(function(f) {
          return isBigNumber(f) ? f.toNumber() : f;
        }) : c;
      }), h = new r();
      return r.apply(h, u), h;
    }
  });
}), BigNumber = /* @__PURE__ */ createBigNumberClass({
  config: config$1
}), Complex = /* @__PURE__ */ createComplexClass({}), Fraction = /* @__PURE__ */ createFractionClass({}), Matrix = /* @__PURE__ */ createMatrixClass({}), DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
  Matrix
}), typed = /* @__PURE__ */ createTyped({
  BigNumber,
  Complex,
  DenseMatrix,
  Fraction
}), addScalar = /* @__PURE__ */ createAddScalar({
  typed
}), conj = /* @__PURE__ */ createConj({
  typed
}), cos = /* @__PURE__ */ createCos({
  typed
}), equalScalar = /* @__PURE__ */ createEqualScalar({
  config: config$1,
  typed
}), getMatrixDataType = /* @__PURE__ */ createGetMatrixDataType({
  typed
}), isInteger = /* @__PURE__ */ createIsInteger({
  typed
}), multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
  typed
}), sin = /* @__PURE__ */ createSin({
  typed
}), SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
  Matrix,
  equalScalar,
  typed
}), matrix = /* @__PURE__ */ createMatrix({
  DenseMatrix,
  Matrix,
  SparseMatrix,
  typed
}), size = /* @__PURE__ */ createSize({
  matrix,
  config: config$1,
  typed
}), concat = /* @__PURE__ */ createConcat({
  isInteger,
  matrix,
  typed
}), smaller = /* @__PURE__ */ createSmaller({
  DenseMatrix,
  concat,
  config: config$1,
  matrix,
  typed
}), dot = /* @__PURE__ */ createDot({
  addScalar,
  conj,
  multiplyScalar,
  size,
  typed
}), ImmutableDenseMatrix = /* @__PURE__ */ createImmutableDenseMatrixClass({
  DenseMatrix,
  smaller
}), Index = /* @__PURE__ */ createIndexClass({
  ImmutableDenseMatrix,
  getMatrixDataType
}), multiply = /* @__PURE__ */ createMultiply({
  addScalar,
  dot,
  equalScalar,
  matrix,
  multiplyScalar,
  typed
}), index = /* @__PURE__ */ createIndex({
  Index,
  typed
});
function getLocator(e, n) {
  n === void 0 && (n = {});
  var r = n.offsetLine || 0, o = n.offsetColumn || 0, l = e.split(`
`), u = 0, h = l.map(function(g, y) {
    var w = u + g.length + 1, E = { start: u, end: w, line: y };
    return u = w, E;
  }), c = 0;
  function f(g, y) {
    return g.start <= y && y < g.end;
  }
  function v(g, y) {
    return { line: r + g.line, column: o + y - g.start, character: y };
  }
  function m(g, y) {
    typeof g == "string" && (g = e.indexOf(g, y || 0));
    for (var w = h[c], E = g >= w.end ? 1 : -1; w; ) {
      if (f(w, g))
        return v(w, g);
      c += E, w = h[c];
    }
  }
  return m;
}
function locate(e, n, r) {
  if (typeof r == "number")
    throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");
  return getLocator(e, r)(n, r && r.startIndex);
}
var validNameCharacters = /[a-zA-Z0-9:_-]/, whitespace$1 = /[\s\t\r\n]/, quotemark = /['"]/;
function repeat(e, n) {
  for (var r = ""; n--; )
    r += e;
  return r;
}
function parse$1(e) {
  var n = "", r = [], o = c, l = null, u = null;
  function h(H) {
    var R = locate(e, N), j = R.line, S = R.column, tt = e.slice(0, N), nt = /(^|\n).*$/.exec(tt)[0].replace(/\t/g, "  "), ft = e.slice(N), pt = /.*(\n|$)/.exec(ft)[0], ct = "" + nt + pt + `
` + repeat(" ", nt.length) + "^";
    throw new Error(
      H + " (" + j + ":" + S + `). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!

` + ct
    );
  }
  function c() {
    for (; N < e.length && e[N] !== "<" || !validNameCharacters.test(e[N + 1]); )
      n += e[N++];
    return f();
  }
  function f() {
    for (var H = ""; N < e.length && e[N] !== "<"; )
      H += e[N++];
    return /\S/.test(H) && l.children.push({ type: "text", value: H }), e[N] === "<" ? v : f;
  }
  function v() {
    var H = e[N];
    if (H === "?")
      return f;
    if (H === "!") {
      if (e.slice(N + 1, N + 3) === "--")
        return m;
      if (e.slice(N + 1, N + 8) === "[CDATA[")
        return g;
      if (/doctype/i.test(e.slice(N + 1, N + 8)))
        return f;
    }
    if (H === "/")
      return y;
    var R = w(), j = {
      type: "element",
      tagName: R,
      properties: {},
      children: []
    };
    l ? l.children.push(j) : u = j;
    for (var S; N < e.length && (S = E()); )
      j.properties[S.name] = S.value;
    var tt = !1;
    return e[N] === "/" && (N += 1, tt = !0), e[N] !== ">" && h("Expected >"), tt || (l = j, r.push(j)), f;
  }
  function m() {
    var H = e.indexOf("-->", N);
    return ~H || h("expected -->"), N = H + 2, f;
  }
  function g() {
    var H = e.indexOf("]]>", N);
    return ~H || h("expected ]]>"), l.children.push(e.slice(N + 7, H)), N = H + 2, f;
  }
  function y() {
    var H = w();
    return H || h("Expected tag name"), H !== l.tagName && h("Expected closing tag </" + H + "> to match opening tag <" + l.tagName + ">"), k(), e[N] !== ">" && h("Expected >"), r.pop(), l = r[r.length - 1], f;
  }
  function w() {
    for (var H = ""; N < e.length && validNameCharacters.test(e[N]); )
      H += e[N++];
    return H;
  }
  function E() {
    if (!whitespace$1.test(e[N]))
      return null;
    k();
    var H = w();
    if (!H)
      return null;
    var R = !0;
    return k(), e[N] === "=" && (N += 1, k(), R = x(), !isNaN(R) && R.trim() !== "" && (R = +R)), { name: H, value: R };
  }
  function x() {
    return quotemark.test(e[N]) ? F() : D();
  }
  function D() {
    var H = "";
    do {
      var R = e[N];
      if (R === " " || R === ">" || R === "/")
        return H;
      H += R, N += 1;
    } while (N < e.length);
    return H;
  }
  function F() {
    for (var H = e[N++], R = "", j = !1; N < e.length; ) {
      var S = e[N++];
      if (S === H && !j)
        return R;
      S === "\\" && !j && (j = !0), R += j ? "\\" + S : S, j = !1;
    }
  }
  function k() {
    for (; N < e.length && whitespace$1.test(e[N]); )
      N += 1;
  }
  for (var N = c.length; N < e.length; )
    o || h("Unexpected character"), o = o(), N += 1;
  return o !== f && h("Unexpected end of input"), u.tagName === "svg" && (u.metadata = n), {
    type: "root",
    children: [u]
  };
}
class SvgItem {
  constructor(n, r, o) {
    this._itemData = n, this._id = "", this._initMatrix = o, this._center = [0, 0], this._type = r, this._radus = 0, this._circleCenter = [0, 0], this._style = {
      fillColor: "#ff0000",
      color: "#FF0000",
      lineWidth: 3
    }, this._positions = [], this.pathcount = 0, this._analysisItem(n);
  }
  _analysisStyle(n) {
    var r = n.split(/[:;]/), o = r.length, l = {};
    for (let u = 0; u < o - 1; u += 2)
      l[`${r[u]}`] = r[u + 1];
    this._style.fillColor = l.fill, this._style.color = l.stroke, this._style.lineWidth = l["stroke-width"], defined(this._style.lineWidth) && (this._style.lineWidth.slice(-2) == "px" ? this._style.lineWidth = Number(this._style.lineWidth.split("p")[0]) : this._style.lineWidth = Number(this._style.lineWidth));
  }
  //解析sva对象，解析成feature
  _analysisItem(n) {
  }
  getTransformMatrix(n) {
  }
  // GetStyle() {
  //     return this._style;
  // }
  // GetType() {
  //     return this._type;
  // }
  // GetID() {
  //     return this._id;
  // }
  // getPoitons() {
  //     return this._positions;
  // }
  // getRadus() {
  //     this._r;
  // }
  // GetRectwh() {
  //     return { width: this._rectwidth, height: this._rectheight }
  // }
  // IsCurve() {
  //     return this._iscurve;
  // }
  // getShow() {
  //     return this._isshow;
  // }
  // trim
  trim(n) {
    return n.replace(/^\s+|\s+$/g, "");
  }
  // compress spaces
  compressSpaces(n) {
    return n.replace(/[\s\r\t\n]+/gm, " ");
  }
}
var SvgTypes = /* @__PURE__ */ ((e) => (e[e.default = 0] = "default", e[e.RECT = 1] = "RECT", e[e.CIRCLE = 2] = "CIRCLE", e[e.PATH = 3] = "PATH", e))(SvgTypes || {});
class Point2D {
  constructor(n, r) {
    this.angleTo = function(o) {
      return Math.atan2(o.y - this.y, o.x - this.x);
    }, this.x = n, this.y = r;
  }
}
class SvgPathItem extends SvgItem {
  constructor(n, r) {
    super(n, SvgTypes.PATH, r), this._getPoint = function() {
      var o = new Point2D(this._getScalar(), this._getScalar());
      return this._makeAbsolute(o);
    }, this._makeAbsolute = function(o) {
      return this._isRelativeCommand() && (o.x += this.current.x, o.y += this.current.y), o;
    }, this._addMarker = function(o, l = null, u = null) {
      u != null && this.angles.length > 0 && this.angles[this.angles.length - 1] == null && (this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(u)), this._addMarkerAngle(o, l == null ? null : l.angleTo(o));
    }, this._addMarkerAngle = function(o, l) {
      this.points.push(o), this._positions[this.pathcount - 1].push([o.x, o.y]), this.angles.push(l), this._points;
    }, this._addBezierCurve = function(o, l, u, h, c, f, v, m) {
      var g = [o, l], y = [u, h], w = [c, f], E = [v, m];
      this._addPoint(g[0], g[1]), this._addPoint(E[0], E[1]);
      var x;
      for (x = 0; x <= 1; x++) {
        var D = function(tt) {
          return Math.pow(1 - tt, 3) * g[x] + 3 * Math.pow(1 - tt, 2) * tt * y[x] + 3 * (1 - tt) * Math.pow(tt, 2) * w[x] + Math.pow(tt, 3) * E[x];
        }, F = 6 * g[x] - 12 * y[x] + 6 * w[x], k = -3 * g[x] + 9 * y[x] - 9 * w[x] + 3 * E[x], N = 3 * y[x] - 3 * g[x];
        if (k == 0) {
          if (F == 0)
            continue;
          var H = -N / F;
          0 < H && H < 1 && (x == 0 && this._addX(D(H)), x == 1 && this._addY(D(H)));
          continue;
        }
        var R = Math.pow(F, 2) - 4 * N * k;
        if (!(R < 0)) {
          var j = (-F + Math.sqrt(R)) / (2 * k);
          0 < j && j < 1 && (x == 0 && this._addX(D(j)), x == 1 && this._addY(D(j)));
          var S = (-F - Math.sqrt(R)) / (2 * k);
          0 < S && S < 1 && (x == 0 && this._addX(D(S)), x == 1 && this._addY(D(S)));
        }
      }
    }, this.tokens = [], this._reset(), this._initPathItem(n);
  }
  _initPathItem(n) {
    var r = n.d;
    {
      r = r.replace(/,/gm, " ");
      for (var o = 0; o < 2; o++)
        r = r.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, "$1 $2");
      r = r.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"), r = r.replace(/([0-9])([+\-])/gm, "$1 $2");
      for (var o = 0; o < 2; o++)
        r = r.replace(/(\.[0-9]*)(\.)/gm, "$1 $2");
      for (r = r.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, "$1 $3 $4 "), r = this.compressSpaces(r), r = this.trim(r), this._pathParser(r), this._reset(); !this._isEnd(); )
        switch (this._nextCommand(), this.command) {
          case "M":
          case "m":
            this.pathcount++, this._positions.push([]);
            var l = this._getAsCurrentPoint();
            for (this._addMarker(l), this.start = this.current; !this._isCommandOrEnd(); ) {
              var l = this._getAsCurrentPoint();
              this._addMarker(l, this.start);
            }
            break;
          case "L":
          case "l":
            for (; !this._isCommandOrEnd(); ) {
              var u = this.current, l = this._getAsCurrentPoint();
              this._addMarker(l, u);
            }
            break;
          case "H":
          case "h":
            for (; !this._isCommandOrEnd(); ) {
              var h = new Point2D((this._isRelativeCommand() ? this.current.x : 0) + this._getScalar(), this.current.y);
              this._addMarker(h, this.current), this.current = new Point2D(h.x, h.y);
            }
            break;
          case "V":
          case "v":
            for (; !this._isCommandOrEnd(); ) {
              var h = new Point2D(this.current.x, (this._isRelativeCommand() ? this.current.y : 0) + this._getScalar());
              this._addMarker(h, this.current), this.current = new Point2D(h.x, h.y);
            }
            break;
          case "C":
          case "c":
            for (var c = []; !this._isCommandOrEnd(); ) {
              var f = this.current, v = this._getPoint(), m = this._getAsControlPoint(), g = this._getAsCurrentPoint();
              c.push([f.x, f.y]), c.push([v.x, v.y]), c.push([m.x, m.y]), c.push([g.x, g.y]);
              var y = 20;
              if (c.length == 4) {
                for (let Mt = 0; Mt < y; Mt++) {
                  let G = this._multyPointBezier(Mt / y, c);
                  this._positions[this.pathcount - 1].push(G);
                }
                this._positions[this.pathcount - 1].push(c[c.length - 1]), c = [];
              }
            }
            if (c.length != 0) {
              for (let Mt = 0; Mt < y; Mt++) {
                let G = this._multyPointBezier(Mt / y, c);
                this._positions[this.pathcount - 1].push(G);
              }
              this._positions[this.pathcount - 1].push(c[c.length - 1]), c = [];
            }
            break;
          case "S":
          case "s":
            for (; !this._isCommandOrEnd(); ) {
              var f = this.current;
              let G = this._getReflectedControlPoint();
              var m = this._getAsControlPoint(), g = this._getAsCurrentPoint();
              this._addMarker(g, m, G);
            }
            break;
          case "Q":
          case "q":
            for (; !this._isCommandOrEnd(); ) {
              var f = this.current, m = this._getAsControlPoint(), g = this._getAsCurrentPoint();
              this._addMarker(g, m, m);
            }
            break;
          case "T":
          case "t":
            break;
          case "A":
          case "a":
            for (; !this._isCommandOrEnd(); ) {
              var f = this.current, w = this._getScalar(), E = this._getScalar(), x = this._getScalar() * (Math.PI / 180), D = this._getScalar(), F = this._getScalar(), g = this._getAsCurrentPoint(), k = new Point2D(
                Math.cos(x) * (f.x - g.x) / 2 + Math.sin(x) * (f.y - g.y) / 2,
                -Math.sin(x) * (f.x - g.x) / 2 + Math.cos(x) * (f.y - g.y) / 2
              ), N = Math.pow(k.x, 2) / Math.pow(w, 2) + Math.pow(k.y, 2) / Math.pow(E, 2);
              N > 1 && (w *= Math.sqrt(N), E *= Math.sqrt(N));
              var H = (D == F ? -1 : 1) * Math.sqrt(
                (Math.pow(w, 2) * Math.pow(E, 2) - Math.pow(w, 2) * Math.pow(k.y, 2) - Math.pow(E, 2) * Math.pow(k.x, 2)) / (Math.pow(w, 2) * Math.pow(k.y, 2) + Math.pow(E, 2) * Math.pow(k.x, 2))
              );
              isNaN(H) && (H = 0);
              var R = new Point2D(H * w * k.y / E, H * -E * k.x / w), j = new Point2D(
                (f.x + g.x) / 2 + Math.cos(x) * R.x - Math.sin(x) * R.y,
                (f.y + g.y) / 2 + Math.sin(x) * R.x + Math.cos(x) * R.y
              ), S = function(Y) {
                return Math.sqrt(Math.pow(Y[0], 2) + Math.pow(Y[1], 2));
              }, tt = function(Y, it) {
                return (Y[0] * it[0] + Y[1] * it[1]) / (S(Y) * S(it));
              }, nt = function(Y, it) {
                return (Y[0] * it[1] < Y[1] * it[0] ? -1 : 1) * Math.acos(tt(Y, it));
              }, ft = nt([1, 0], [(k.x - R.x) / w, (k.y - R.y) / E]), pt = [(k.x - R.x) / w, (k.y - R.y) / E], ct = [(-k.x - R.x) / w, (-k.y - R.y) / E], Nt = nt(pt, ct);
              tt(pt, ct) <= -1 && (Nt = Math.PI), tt(pt, ct) >= 1 && (Nt = 0);
              var kt = 1 - F ? 1 : -1, Rt = ft + kt * (Nt / 2);
              new Point2D(
                j.x + w * Math.cos(Rt),
                j.y + E * Math.sin(Rt)
              ), this._center = [Number(n["sodipodi:cx"]), Number(n["sodipodi:cy"])], this.ellipseArcLength(w, E, this.points[this.points.length - 1].x, this.points[this.points.length - 1].y, g.x, g.y, { cx: n["sodipodi:cx"], cy: n["sodipodi:cy"] });
            }
            break;
          case "Z":
          case "z":
            this._positions[this.pathcount - 1].push(this._positions[this.pathcount - 1][0]), this.current = this.start;
        }
    }
    this._analysisStyle(n.style);
  }
  //
  _pathParser(n) {
    this.tokens = n.split(" ");
  }
  _getToken() {
    return this.i++, this.tokens[this.i];
  }
  //
  _isEnd() {
    return this.i >= this.tokens.length - 1;
  }
  _isCommandOrEnd() {
    return this._isEnd() ? !0 : this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
  }
  _reset() {
    this.i = -1, this.command = "", this.previousCommand = "", this.start = new Point2D(0, 0), this.control = new Point2D(0, 0), this.current = new Point2D(0, 0), this.points = [], this.angles = [], this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN;
  }
  //
  _isRelativeCommand() {
    switch (this.command) {
      case "m":
      case "l":
      case "h":
      case "v":
      case "c":
      case "s":
      case "q":
      case "t":
      case "a":
      case "z":
        return !0;
    }
    return !1;
  }
  //
  // _getToken() {
  //     this.i++;
  //
  //     return this.tokens[this.i];
  // }
  //
  _getScalar() {
    return parseFloat(this._getToken());
  }
  _nextCommand() {
    this.previousCommand = this.command, this.command = this._getToken();
  }
  _getAsControlPoint() {
    var n = this._getPoint();
    return this.control = n, n;
  }
  _getAsCurrentPoint() {
    var n = this._getPoint();
    return this.current = n, n;
  }
  _getReflectedControlPoint() {
    if (this.previousCommand.toLowerCase() != "c" && this.previousCommand.toLowerCase() != "s" && this.previousCommand.toLowerCase() != "q" && this.previousCommand.toLowerCase() != "t")
      return this.current;
    var n = new Point2D(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
    return n;
  }
  _multyPointBezier(n, r) {
    let o = r.length, l = 0, u = 0, h = function(c, f) {
      let v = 1, m = 1;
      for (; f > 0; )
        v *= c, m *= f, c--, f--;
      return v / m;
    };
    for (let c = 0; c < o; c++) {
      let f = r[c];
      l += f[0] * Math.pow(1 - n, o - 1 - c) * Math.pow(n, c) * h(o - 1, c), u += f[1] * Math.pow(1 - n, o - 1 - c) * Math.pow(n, c) * h(o - 1, c);
    }
    return [l, u];
  }
  // _parseBezierPath(bezier, numSegments) {
  //     var testpoint = []
  //     var points = [];
  //     // for (let index = 0; index < numSegments; index++) {
  //
  //     //     //   var p= this._multyPointBezier(index/numSegments,[[bezier.sx,bezier.sy],[bezier.x1,bezier.y1],[bezier.x2,bezier.y2],[bezier.x,bezier.y]])
  //
  //     //     var p = this._multyPointBezier(index / numSegments, [[0, 18], [16, -23], [49, 21], [83, 67], [100, 12], [100, 12]])
  //     //     // this._positions[this.pathcount - 1].push(p)
  //     //     points.push({ x: p[0], y: p[1] })
  //     // }
  //     // console.log(testpoint);
  //
  //
  //
  //
  //     var bezier = bezier;
  //     var startX = bezier.sx;
  //     var startY = bezier.sy;
  //
  //     //   if (bezier.pathSegType === SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS) {
  //     var ctrlPt1X = bezier.x1 ? bezier.x1 : 0;
  //     var ctrlPt1Y = bezier.y1 ? bezier.y1 : 0;
  //     var ctrlPt2X = bezier.x2 ? bezier.x2 : 0;
  //     var ctrlPt2Y = bezier.y2 ? bezier.y2 : 0;
  //     var endX = bezier.x;
  //     var endY = bezier.y
  //
  //     for (var j = 0; j < numSegments; j++) {
  //         var t = (j + 1) / numSegments;
  //         var x = startX * (1 - t) * (1 - t) * (1 - t) + 3 * ctrlPt1X * t * (1 - t) * (1 - t) + 3 * ctrlPt2X * t * t * (1 - t) + endX * t * t * t;
  //         var y = startY * (1 - t) * (1 - t) * (1 - t) + 3 * ctrlPt1Y * t * (1 - t) * (1 - t) + 3 * ctrlPt2Y * t * t * (1 - t) + endY * t * t * t;
  //         this._positions[this.pathcount - 1].push([x, y])
  //
  //         //   points.push({ x:x, y:y });
  //     }
  //     // console.log(points);
  //     //   }
  //     //   else if (bezier.pathSegType === SVGPathSeg.PATHSEG_LINE_TO_ABS) {
  //     // var endX = bezier.x ? bezier.x : 0;
  //     // var endY = bezier.y ? bezier.y : 0;
  //
  //     // points.push({ x:startX, y:startY });
  //     // for (var j=1; j<numSegments; j++) {
  //     //   var t = j / numSegments;
  //     //   var x = (1-t)*startX + t*endX;
  //     //   var y = (1-t)*startY + t*endY;
  //     //   points.push({ x:x, y:y });
  //     // }
  //     // points.push({ x:endX, y:endY });
  //     // this._positions.push([x,y])
  //     //   }
  //
  //
  //     return points;
  // }
  ellipseArcLength(n, r, o, l, u, h, c) {
    o = o - c.cx, u = u - c.cx, l = l - c.cy, h = h - c.cy;
    const f = 0.1;
    let v = 0, m = Math.atan2(l - 0, o - 0) < 0 ? Math.atan2(l - 0, o - 0) + 2 * Math.PI : Math.atan2(l - 0, o - 0), g, y, w = Math.atan2(h - 0, u - 0) < 0 ? Math.atan2(h - 0, u - 0) + 2 * Math.PI : Math.atan2(h - 0, u - 0);
    for (; m < w; )
      g = n * Math.cos(m), y = r * Math.sin(m), this._addMarkerAngle(new Point2D(g + c.cx, y + c.cy), null), m += f;
    return v;
  }
}
class SvgRecteItem extends SvgItem {
  constructor(n, r) {
    super(n, SvgTypes.RECT, r), this._initPathItem(n);
  }
  _initPathItem(n) {
    this._rectwidth = Number(n.width), this._rectheight = Number(n.height);
    var r = [Number(n.x), Number(n.y)];
    this._positions.push(r), this._positions.push([r[0], r[1] + this._rectheight]), this._positions.push([r[0] + this._rectwidth, r[1] + this._rectheight]), this._positions.push([r[0] + this._rectwidth, r[1]]), this._positions.push(r), this._analysisStyle(n.style);
  }
}
const An = class An extends BaseObject {
  constructor() {
    super(), this._className = "MatrixOperation";
  }
  // 提供一个获取实例的静态方法
  static getInstance() {
    return An._instance || (An._instance = new An()), An._instance;
  }
  /**
   * @作者: Wangjianbo
   * @时间: 2024/04/26 10:01:28
   * @描述:两个3*3的矩阵相乘， 2*2 部分时坐标的缩放和旋转  第三列时坐标的移动
   * @参数：必须时 math.js matrix 3*3矩阵
   */
  matrixMultiply3X3(n, r) {
    let o = this.matrix3ToMatrix2(n);
    var l = o.matrix, u = o.translate;
    let h = this.matrix3ToMatrix2(r), c = h.matrix, f = h.translate, v = multiply(l, c);
    var m = matrix([[v._data[0][0], v._data[0][1], u[0] + f[0]], [v._data[1][0], v._data[1][1], u[1] + f[1]], [0, 0, 1]]);
    return m;
  }
  /**
   * @作者: Wangjianbo
   * @时间: 2024/04/26 10:14:05
   * @描述:3*3矩阵转为2*2矩阵 并且返回移位
   * @参数：Matrix3
   */
  matrix3ToMatrix2(n) {
    var r = matrix([[n._data[0][0], n._data[0][1]], [n._data[1][0], n._data[1][1]]]), o = [n._data[0][2], n._data[1][2]];
    return { matrix: r, translate: o };
  }
};
An._instance = null;
let MatrixOperation = An;
class SvgCircleItem extends SvgItem {
  /**
   * @param {svg item 字符串} svg字符串
   */
  constructor(n, r) {
    super(n, SvgTypes.CIRCLE, r), this._initItem(n);
  }
  _initItem(n) {
    this._radus = n.r, this._circleCenter = [n.cx, n.cy], this._analysisStyle(n.style);
  }
}
class SvgObject extends BaseObject {
  constructor(n) {
    super(), this._svgData = n, this._width = 0, this._height = 0, this._items = [], this._view = { width: 0, height: 0 }, this._analysisSVG(this._svgData);
  }
  //解析sva对象，解析成items
  _analysisSVG(n) {
    let r = parse$1(n);
    {
      var o = r.children[0], l = o.properties.viewBox.split(" ");
      this._view = { height: Number(l[2]), width: Number(l[3]) }, this._parserSvgElement(o, this._getTransformMatrix(o.properties.transform));
    }
  }
  _parserSvgElement(n, r) {
    let o = MatrixOperation.getInstance();
    switch (n.tagName) {
      case "defs":
        break;
      case "svg":
      case "g": {
        if (n.properties.style) {
          var l = n.properties.style.split(/[:;]/), u = l.length, h = {};
          for (let c = 0; c < u - 1; c += 2)
            h[`${l[c]}`] = l[c + 1];
          if (h.display && h.display == "none")
            break;
        }
        n.children && n.children.length > 0 && n.children.forEach((c) => {
          let f = this._getTransformMatrix(n.properties.transform);
          this._parserSvgElement(c, o.matrixMultiply3X3(r, f));
        });
        break;
      }
      case "rect": {
        let c = this._getTransformMatrix(n.properties.transform), f = new SvgRecteItem(n.properties, o.matrixMultiply3X3(r, c));
        this._items.push(f);
        break;
      }
      case "path": {
        let c = this._getTransformMatrix(n.properties.transform), f = new SvgPathItem(n.properties, o.matrixMultiply3X3(r, c));
        this._items.push(f);
        break;
      }
      case "circle": {
        let c = this._getTransformMatrix(n.properties.transform), f = new SvgCircleItem(n.properties, o.matrixMultiply3X3(r, c));
        this._items.push(f);
        break;
      }
    }
  }
  _getTransformMatrix(n) {
    var r = matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]]);
    if (defined(n)) {
      var o = n.split("(");
      if (o.length > 1)
        if (o[0] == "matrix") {
          if (o = o[1].split(")"), o.length == 2)
            return o = o[0].split(","), r = matrix([[Number(o[0]), Number(o[2]), Number(o[4])], [Number(o[1]), Number(o[3]), Number(o[5])], [0, 0, 1]]), r;
        } else {
          if (o[0] == "scale")
            return o = o[1].split(")"), r = matrix([[Number(o[0]), 0, 0], [0, Number(o[1]), 0], [0, 0, 1]]), r;
          if (o[0] == "translate")
            return o = o[1].split(")"), o = o[0].split(" "), r = matrix([[1, 0, Number(o[0])], [0, 1, Number(o[1])], [0, 0, 1]]), r;
          if (o[0] == "rotate") {
            o = o[1].split(")");
            let l = Number(o[0]) / 180 * Math.PI;
            return r = matrix([[Math.cos(l), -Math.sin(l), 0], [Math.sin(l), Math.cos(l), 0], [0, 0, 1]]), r;
          }
        }
    }
    return r;
  }
  _analysisItems(n) {
    n.forEach((r) => {
    });
  }
}
class SymbolUtilsMethods extends BaseObject {
  constructor() {
    super(), this.getAzimuth = function(n, r) {
      var o, l = Math.asin(Math.abs(r.getLat() - n.getLat()) / Math.sqrt((n.getLon() - r.getLon()) * (n.getLon() - r.getLon()) + (n.getLat() - r.getLat()) * (n.getLat() - r.getLat())));
      return r.getLat() >= n.getLat() && r.getLon() >= n.getLon() ? o = l + Math.PI : r.getLat() >= n.getLat() && r.getLon() < n.getLon() ? o = Math.PI * 2 - l : r.getLat() < n.getLat() && r.getLon() < n.getLon() ? o = l : r.getLat() < n.getLat() && r.getLon() >= n.getLon() && (o = Math.PI - l), o;
    }, SymbolUtilsMethods._instance = null;
  }
  static getInstance() {
    return SymbolUtilsMethods._instance == null && (SymbolUtilsMethods._instance = new SymbolUtilsMethods()), SymbolUtilsMethods._instance;
  }
  /**
   * @作者: Wangjianbo
   * @时间: 2024/06/28 09:24:19
   * @描述:计算地理距离
   * @参数：经纬度点
   * @结果  返回距离单位为千米
   */
  distance(n, r) {
    let o = point([n.getLon(), n.getLat()]), l = point([r.getLon(), r.getLat()]);
    var h = distance(o, l, { units: "kilometers" });
    return h;
  }
  geoDistance(n, r) {
    return Math.sqrt((n.getLon() - r.getLon()) * (n.getLon() - r.getLon()) + (n.getLat() - r.getLat()) * (n.getLat() - r.getLat()));
  }
  rhumbDistance(n, r) {
    let o = point([n.getLon(), n.getLat()]), l = point([r.getLon(), r.getLat()]);
    var h = rhumbDistance(o, l, { units: "kilometers" });
    return h;
  }
  getCirclePoints(n, r) {
    var o = [n.getLon(), n.getLat()], l = { steps: 120, units: "kilometers" }, u = circle(o, r, l);
    return getCoords(u);
  }
  pixPointDistance(n, r) {
    let o = 0;
    return o = Math.sqrt(r.getY() - n.getY()) * (r.getY() - n.getY()) + (r.getX() - n.getX()) * (r.getX() - n.getX()), o;
  }
  rotateLatLngs(n, r, o) {
    for (let g = 0; g < n.length; g++)
      if (this.isArray(n[g]))
        this.rotateLatLngs(n[g], r, o);
      else {
        var l = point([r.getLon(), r.getLat()]), u = point([n[g].getLon(), n[g].getLat()]), h = bearing(l, u), c = { units: "kilometers" }, f = distance(l, u, c), v = destination(l, f, h - o, c), m = getCoord(v);
        n[g]._x = m[0], n[g]._y = m[1];
      }
    return n;
  }
  isArray(n) {
    return Object.prototype.toString.call(n) === "[object Array]";
  }
  clearSamePts(n) {
    let r = n.length;
    for (let o = 0; o < r - 1; )
      equalFuzzy(n[o].getLon(), n[o + 1].getLon()) && equalFuzzy(n[o].getLat(), n[o + 1].getLat()) ? (n.splice(o, 1), r--) : o++;
    return n;
  }
  getNormal(n, r, o) {
    var l = n.getLon() - r.getLon(), u = n.getLat() - r.getLat(), h = Math.sqrt(l * l + u * u);
    l /= h, u /= h;
    var c = o.getLon() - r.getLon(), f = o.getLat() - r.getLat(), v = Math.sqrt(c * c + f * f);
    c /= v, f /= v;
    var m = l + c, g = u + f;
    return [m, g];
  }
  isClockWise(n, r, o) {
    return (o.getLat() - n.getLat()) * (r.getLon() - n.getLon()) > (r.getLat() - n.getLat()) * (o.getLon() - n.getLon());
  }
  getBisectorNormals(n, r, o, l) {
    var u = this.getNormal(r, o, l), h = Math.sqrt(u[0] * u[0] + u[1] * u[1]), c = u[0] / h, f = u[1] / h, v = this.geoDistance(r, o), m = this.geoDistance(o, l);
    if (h > 1e-4)
      if (this.isClockWise(r, o, l)) {
        var g = n * v, y = o.getLon() - g * f, w = o.getLat() + g * c, E = [y, w];
        g = n * m, y = o.getLon() + g * f, w = o.getLat() - g * c;
        var x = [y, w];
      } else
        g = n * v, y = o.getLon() + g * f, w = o.getLat() - g * c, E = [y, w], g = n * m, y = o.getLon() - g * f, w = o.getLat() + g * c, x = [y, w];
    else
      y = o.getLon() + n * (r.getLon() - o.getLon()), w = o.getLat() + n * (r.getLat() - o.getLat()), E = [y, w], y = o.getLon() + n * (l.getLon() - o.getLon()), w = o.getLat() + n * (l.getLat() - o.getLat()), x = [y, w];
    return [E, x];
  }
  getCubicValue(n, r, o, l, u) {
    n = Math.max(Math.min(n, 1), 0);
    var h = 1 - n, c = n * n, f = c * n, v = h * h, m = v * h, g = m * r.getLon() + 3 * v * n * o[0] + 3 * h * c * l[0] + f * u.getLon(), y = m * r.getLat() + 3 * v * n * o[1] + 3 * h * c * l[1] + f * u.getLat();
    return new GeoPoint3D(g, y);
  }
}
class SymbolSVG extends Symbol$1 {
  constructor() {
    super(FeatureType.Polyline), this.minEditPts = 1, this.maxEditPts = 1, this._svgText = "", this._view = null, this._init = !1, this._svgItems = [], this._svgAnchor = [], this._svgObject = null;
  }
  calculateParts() {
    if (super.calculateParts(), this.controlPoints.length == 0 || this._svgText === "")
      return;
    let n = MatrixOperation.getInstance();
    var r = -this._rotate;
    if (this._components = [], this._init || (this._svgObject = new SvgObject(this._svgText), this._init = !0), !!defined(this._map)) {
      var o = this._map._map.latLngToLayerPoint({
        lng: this.controlPoints[0].getLon(),
        lat: this.controlPoints[0].getLat()
      });
      matrix([[this._scale, 0, 0], [0, this._scale, 0]]), this._svgObject._items.forEach((u) => {
        let h = [];
        var c = n.matrix3ToMatrix2(u._initMatrix);
        c.matrix;
        let f = [o.x - this._svgObject._view.width * 0.5, o.y - this._svgObject._view.height * 0.5];
        switch (c.translate[0], c.translate[1], u._type) {
          case SvgTypes.RECT: {
            u._positions.forEach((m) => {
              const g = matrix([[m[0]], [m[1]], [1]]);
              let w = multiply(u._initMatrix, g).toArray();
              var E = this.rotatePointAroundCenter(w[0][0], w[1][0], this._svgObject._view.width * 0.5, this._svgObject._view.height * 0.5, this._scale, -(r * Math.PI / 180));
              let x = this._map._map.layerPointToLatLng({
                x: Number(E.x) + f[0],
                y: Number(E.y) + f[1]
              });
              h.push(new GeoPoint3D(x.lng, x.lat));
            });
            break;
          }
          case SvgTypes.PATH: {
            u._positions.forEach((m) => {
              m.forEach((g) => {
                const y = matrix([[g[0]], [g[1]], [1]]);
                let E = multiply(u._initMatrix, y).toArray();
                var x = this.rotatePointAroundCenter(E[0][0], E[1][0], this._svgObject._view.width * 0.5, this._svgObject._view.height * 0.5, this._scale, -(r * Math.PI / 180));
                let D = this._map._map.layerPointToLatLng({
                  x: Number(x.x) + f[0],
                  y: Number(x.y) + f[1]
                });
                h.push(new GeoPoint3D(D.lng, D.lat));
              });
            });
            break;
          }
          case SvgTypes.CIRCLE: {
            const m = matrix([[u._circleCenter[0]], [u._circleCenter[1]], [1]]);
            let y = multiply(u._initMatrix, m).toArray();
            var v = this.rotatePointAroundCenter(y[0][0], y[1][0], this._svgObject._view.width * 0.5, this._svgObject._view.height * 0.5, this._scale, -(r * Math.PI / 180));
            let w = this._map._map.layerPointToLatLng({
              x: Number(v.x) + f[0],
              y: Number(v.y) + f[1]
            }), E = [Number(v.x) + f[0], Number(v.y) + f[1]], x = [E[0] + u._radus * this._scale, E[1]], D = this._map._map.layerPointToLatLng({
              x: x[0],
              y: x[1]
            }), F = SymbolUtilsMethods.getInstance().distance(new GeoPoint2D(w.lng, w.lat), new GeoPoint2D(D.lng, D.lat));
            SymbolUtilsMethods.getInstance().getCirclePoints(new GeoPoint2D(w.lng, w.lat), F).forEach((N) => {
              N.forEach((H) => [
                h.push(new GeoPoint3D(H[0], H[1]))
              ]);
            });
            break;
          }
        }
        u._style.fillColor != "none" && defined(u._style.fillColor) && (u._style.lineOpacity = 0, this.addCell(SymbolCellType.Polygon, h, { style: u._style })), this.addCell(SymbolCellType.PolyLine, h, { style: u._style }), u._style.lineOpacity = 1;
      });
      var l = this._map._map.layerPointToLatLng({ x: o.x, y: o.y - this._svgObject._view.height * 0.5 * this._scale });
      this.addCell(SymbolCellType.Text, [new GeoPoint3D(l.lng, l.lat)]);
    }
  }
  // 假设 mathjs 提供了必要的数学函数和矩阵操作
  rotatePointAroundCenter(n, r, o, l, u = 1, h = 0) {
    var c = cos(h), f = sin(h), v = matrix([[c, -f, 0], [f, c, 0]]), m = matrix([[1, 0, -o], [0, 1, -l], [0, 0, 1]]), g = matrix([[1, 0, o], [0, 1, l], [0, 0, 1]]), y = matrix([[u, 0, 0], [0, u, 0]]), w = matrix([[n], [r], [1]]), E = multiply(y, multiply(m, w)).toArray(), x = multiply(v, matrix([E[0], E[1], [1]])).toArray(), D = multiply(g, matrix([x[0], x[1], [1]])), F = D.subset(index(0, 0)), k = D.subset(index(1, 0));
    return { x: F, y: k };
  }
  // 使用示例
  //     var x = 1;
  //     var y = 2;
  //     var cx = 0;
  //     var cy = 0;
  //     var theta = math.pi / 4; // 45度
  //     var rotatedPoint = rotatePointAroundCenter(x, y, cx, cy, theta);
  //     console.log(rotatedPoint); // 输出旋转后的点
}
class SymbolGatherPlace extends Symbol$1 {
  constructor() {
    super(FeatureType.Region), this.minEditPts = 2, this.maxEditPts = 3, this.t = 0.4;
  }
  calculateParts() {
    super.calculateParts();
    var n = SymbolUtilsMethods.getInstance(), r = this.controlPoints.slice(), o = n.clearSamePts(r);
    if (!(o.length < 2)) {
      if (o.length == this.minEditPts) {
        var h = midPoint(o[0], o[1]), l = n.geoDistance(o[0], h) / 0.9, u = this.getThirdPoint(o[0], h, 90, l, !0);
        o = [o[0], u, o[1]];
      }
      var h = midPoint(o[0], o[2]);
      o.push(h, o[0], o[1]);
      for (var c = [], f = 0; f < o.length - 2; f++) {
        var v = o[f], m = o[f + 1], g = o[f + 2], y = n.getBisectorNormals(this.t, v, m, g);
        c = c.concat(y);
      }
      var w = c.length;
      c = [c[w - 1]].concat(c.slice(0, w - 1));
      var E = [];
      for (f = 0; f < o.length - 2; f++) {
        v = o[f], m = o[f + 1], E.push(v);
        for (var x = 0; x <= 100; x++) {
          var u = n.getCubicValue(x / 100, v, c[f * 2], c[f * 2 + 1], m);
          E.push(u);
        }
        E.push(m);
      }
      this._components = [], this.addCell(SymbolCellType.Polygon, E);
    }
  }
  getThirdPoint(n, r, o, l, u) {
    var h = SymbolUtilsMethods.getInstance();
    o = o * Math.PI / 180;
    var c = h.getAzimuth(n, r), f = u ? c + o : c - o, v = l * Math.cos(f), m = l * Math.sin(f);
    return new GeoPoint3D(r.getLon() + v, r.getLat() + m);
  }
}
class SymbolEntity extends Symbol$1 {
  constructor() {
    super(FeatureType.Entity), this._options = null, this.minEditPts = 1, this.maxEditPts = 999;
  }
  calculateParts() {
    if (super.calculateParts(), this._components = [], defined(this._options)) {
      var n = this.controlPoints[0];
      let r = this._map._map.latLngToLayerPoint({ lng: n.getLon(), lat: n.getLat() });
      if (defined(this._options.text)) {
        let o = this._map._map.layerPointToLatLng([r.x + this._options.text.offSet[0], r.y + this._options.text.offSet[1]]);
        this.addCell(SymbolCellType.Text, [new GeoPoint3D(o.lng, o.lat)], { text: this._options.text.text, style: this._options.text.style });
      }
      if (defined(this._options.image)) {
        let o = this._map._map.layerPointToLatLng([r.x + this._options.image.offSet[0], r.y + this._options.image.offSet[1]]);
        this.addCell(SymbolCellType.image, [new GeoPoint3D(o.lng, o.lat)], { style: this._options.image });
      }
    }
  }
}
class SymbolPositionResult extends Symbol$1 {
  constructor() {
    super(FeatureType.AreaResult), this.minEditPts = 1, this.maxEditPts = 1;
  }
  calculateParts() {
    super.calculateParts(), this.controlPoints.length == 1 && (this._components = [], this.addCell(SymbolCellType.Pin, this.controlPoints), this.addCell(SymbolCellType.Text, this.controlPoints, { text: `${this.controlPoints[0].getLon().toFixed(4)},${this.controlPoints[0].getLat().toFixed(4)}` }));
  }
}
class SymbolCircle extends Symbol$1 {
  constructor() {
    super(FeatureType.Circle), this.minEditPts = 1, this.maxEditPts = 2, this._radius = 0, this._center = new GeoPoint3D(), this._baseRadius = !1, this.canAddDeletePoint = !1;
  }
  updateRadiud() {
    if (this.controlPoints.length === 2) {
      var n = point([this.controlPoints[0].getLat(), this.controlPoints[0].getLon()]), r = point([this.controlPoints[1].getLat(), this.controlPoints[1].getLon()]), o = bearing(n, r);
      let u = { units: "kilometers" };
      var l = destination(n, this._radius, o, u);
      let h = getCoord(l);
      this.controlPoints[1] = new GeoPoint3D(h[0], h[1]);
    } else
      this.controlPoints.length == 1;
  }
  updatecenter() {
    if (this.controlPoints.length === 2) {
      var n = point([this.controlPoints[0].getLat(), this.controlPoints[0].getLon()]), r = point([this.controlPoints[1].getLat(), this.controlPoints[1].getLon()]), o = bearing(n, r);
      let u = { units: "kilometers" };
      var l = destination(n, this._radius, o, u);
      let h = getCoord(l);
      this.controlPoints[1] = new GeoPoint3D(h[0], h[1]);
    } else
      this.controlPoints.length == 1;
  }
  calculateParts() {
    if (super.calculateParts(), !(this.controlPoints.length < this.minEditPts)) {
      if (this.controlPoints.length === 2) {
        let c = [];
        this._components = [];
        var n = this.controlPoints[0], r = this.controlPoints[1];
        this._radius = SymbolUtilsMethods.getInstance().distance(new GeoPoint2D(n.getLon(), n.getLat()), new GeoPoint2D(r.getLon(), r.getLat()));
        var o = { steps: 36, units: "kilometers", properties: { foo: "bar" } }, l = [n.getLon(), n.getLat()], u = circle(l, this._radius, o), h = getCoords(u);
        h[0].forEach((f) => {
          c.push(new GeoPoint3D(f[0], f[1]));
        }), this.addCell(SymbolCellType.Polygon, c);
      } else if (this.controlPoints.length === 1) {
        let c = [];
        this._components = [];
        var n = this.controlPoints[0];
        let v = { steps: 36, units: "kilometers", properties: { foo: "bar" } }, m = [n.getLon(), n.getLat()], g = circle(m, this._radius, v);
        getCoords(g)[0].forEach((w) => {
          c.push(new GeoPoint3D(w[0], w[1]));
        }), this.addCell(SymbolCellType.Polygon, c);
      }
    }
  }
}
class SymbolEllipse extends Symbol$1 {
  constructor() {
    super(FeatureType.Ellipse), this.minEditPts = 1, this.maxEditPts = 3, this._xSemiAxis = 0, this._ySemiAxis = 0, this._center = null, this.canAddDeletePoint = !0;
  }
  updatex() {
    if (this.controlPoints.length == 3) {
      var n = point([this.controlPoints[0].getLat(), this.controlPoints[0].getLon()]), r = point([this.controlPoints[1].getLat(), this.controlPoints[1].getLon()]), o = bearing(n, r);
      let u = { units: "kilometers" };
      var l = destination(n, this._xSemiAxis, o, u);
      let h = getCoord(l);
      this.controlPoints[1] = new GeoPoint3D(h[0], h[1]);
    } else if (this.controlPoints.length != 1) {
      var n = point([this.controlPoints[0].getLat(), this.controlPoints[0].getLon()]);
      let h = { units: "kilometers" };
      var l = destination(n, this._xSemiAxis, 90, h);
      let f = getCoord(l);
      this.controlPoints[1] = new GeoPoint3D(f[0], f[1]);
    }
  }
  updatey() {
    if (this.controlPoints.length == 3) {
      var n = point([this.controlPoints[0].getLat(), this.controlPoints[0].getLon()]), r = point([this.controlPoints[2].getLat(), this.controlPoints[2].getLon()]), o = bearing(n, r);
      let u = { units: "kilometers" };
      var l = destination(n, this._ySemiAxis, o, u);
      let h = getCoord(l);
      this.controlPoints[2] = new GeoPoint3D(h[0], h[1]);
    } else if (this.controlPoints.length != 1) {
      var n = point([this.controlPoints[0].getLat(), this.controlPoints[0].getLon()]);
      let h = { units: "kilometers" };
      var l = destination(n, this._ySemiAxis, 0, h);
      let f = getCoord(l);
      this.controlPoints[2] = new GeoPoint3D(f[0], f[1]);
    }
  }
  updatecenter() {
    if (this.controlPoints.length == 3) {
      var n = point([this.controlPoints[0].getLat(), this.controlPoints[0].getLon()]), r = point([this.controlPoints[1].getLat(), this.controlPoints[1].getLon()]), o = point([this.controlPoints[2].getLat(), this.controlPoints[2].getLon()]), l = bearing(n, r), u = bearing(n, o);
      let f = { units: "kilometers" };
      var h = destination(n, this._xSemiAxis, l, f);
      let v = getCoord(h);
      this.controlPoints[1] = new GeoPoint3D(v[0], v[1]);
      var c = destination(n, this._ySemiAxis, u, f);
      let m = getCoord(c);
      this.controlPoints[2] = new GeoPoint3D(m[0], m[1]);
    }
  }
  calculateParts() {
    if (super.calculateParts(), !(this.controlPoints.length < this.minEditPts)) {
      if (this.controlPoints.length == 2) {
        let v = [];
        this._components = [];
        var n = this.controlPoints[0], r = this.controlPoints[1], o = SymbolUtilsMethods.getInstance().distance(new GeoPoint2D(n.getLon(), n.getLat()), new GeoPoint2D(r.getLon(), r.getLat())), l = { steps: 128, units: "kilometers", angle: this._rotate }, u = [n.getLon(), n.getLat()], h = ellipse(u, o, o * 0.5, l), c = getCoords(h);
        c[0].forEach((m) => {
          v.push(new GeoPoint3D(m[0], m[1]));
        }), this.addCell(SymbolCellType.Polygon, v);
      } else if (this.controlPoints.length == 3) {
        let v = [];
        this._components = [];
        var n = this.controlPoints[0], r = this.controlPoints[1], f = this.controlPoints[2];
        this._xSemiAxis = SymbolUtilsMethods.getInstance().distance(new GeoPoint2D(n.getLon(), n.getLat()), new GeoPoint2D(r.getLon(), r.getLat())), this._ySemiAxis = SymbolUtilsMethods.getInstance().distance(new GeoPoint2D(n.getLon(), n.getLat()), new GeoPoint2D(f.getLon(), f.getLat()));
        var l = { steps: 128, units: "kilometers", angle: this._rotate }, u = [n.getLon(), n.getLat()], h = ellipse(u, this._xSemiAxis, this._ySemiAxis, l), c = getCoords(h);
        c[0].forEach((D) => {
          v.push(new GeoPoint3D(D[0], D[1]));
        }), this.addCell(SymbolCellType.Polygon, v);
      } else if (this.controlPoints.length === 1) {
        if (this._xSemiAxis === 0 || this._ySemiAxis === 0)
          return;
        let v = [];
        this._components = [];
        let m = this.controlPoints[0], g = { steps: 128, units: "kilometers", angle: this._rotate }, y = [m.getLon(), m.getLat()], w = ellipse(y, this._xSemiAxis, this._ySemiAxis, g);
        getCoords(w)[0].forEach((x) => {
          v.push(new GeoPoint3D(x[0], x[1]));
        }), this.addCell(SymbolCellType.Polygon, v);
      }
    }
  }
}
const Tn = class Tn extends BaseObject {
  // 防止外部直接实例化
  constructor() {
    super(), this._className = "SymbolFactory";
  }
  // 提供一个获取实例的静态方法
  static getInstance() {
    return Tn._instance || (Tn._instance = new Tn()), Tn._instance;
  }
  create(n) {
    switch (n) {
      case FeatureType.Polyline:
        return new SymbolPolyline();
      case FeatureType.Polygon:
        return new SymbolPolygon();
      case FeatureType.Pin:
        return new SymbolPin();
      case FeatureType.Rectangle:
        return new SymbolRectangle();
      case FeatureType.PlotPng:
        return new SymbolPlotPng();
      case FeatureType.Text:
        return new SymbolText();
      case FeatureType.Circle:
        return new SymbolCircle();
      case FeatureType.Ellipse:
        return new SymbolEllipse();
      case FeatureType.DistanceResult:
        return new SymbolDistanceResult();
      case FeatureType.AreaResult:
        return new SymbolAreaResult();
      case FeatureType.PositionResult:
        return new SymbolPositionResult();
      case FeatureType.AngleResult:
        return new SymbolAngleResult();
      case FeatureType.MultiLines:
        return new SymbolMultiLines();
      case FeatureType.MultiText:
        return new SymbolMultiText();
      case FeatureType.SVG:
        return new SymbolSVG();
      case FeatureType.Region:
        return new SymbolGatherPlace();
      case FeatureType.Entity:
        return new SymbolEntity();
      default:
        return null;
    }
  }
};
Tn._instance = null;
let SymbolFactory = Tn;
leafletSrcExports.RotatableMarker = leafletSrcExports.Marker.extend({
  options: {
    angle: 0,
    autoRotate: !1,
    rotationOrigin: "center",
    rotationAlignment: "auto",
    rotationAngle: 0
  },
  update() {
    defined(this._icon) && (leafletSrcExports.Marker.prototype.update.call(this), this._icon.style.transformOrigin = "center");
  },
  _setPos(e) {
    leafletSrcExports.Marker.prototype._setPos.call(this, e), !(!defined(this._icon) || !defined(this._icon.style)) && (this._icon.style.transform = `${this._icon.style.transform} rotate(${this.options.rotationAngle}deg)`);
  },
  rotate(e) {
    this.options.rotationAngle = e, this.update();
  }
});
leafletSrcExports.svgFeature = leafletSrcExports.Path.extend({
  options: {
    svg: ""
  },
  update() {
    this._icon.style.transformOrigin = "center";
  },
  initialize(e) {
    console.log("initialize", e);
  },
  onAdd(e) {
    var n = leafletSrcExports.svg().addTo(e), r = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1"><rect x="10" y="10" width="50" height="50" style="fill:#ff0000"/></svg>', o = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    o.innerHTML = r, n.getPane("overlayPane").appendChild(o);
  },
  _setPos(e) {
    this._icon.style.transform = `${this._icon.style.transform} rotate(${this.options.rotationAngle}deg)`;
  },
  rotate(e) {
    this.options.rotationAngle = e, this.update();
  }
});
leafletSrcExports.Canvas.LABEL_FACTOR = {
  l: 0,
  r: -1,
  t: 0,
  b: -1
};
leafletSrcExports.Canvas.LABEL_ALIGN = { l: "left", r: "right", b: "bottom", t: "top", i: "ideographic", h: "hanging", c: "center", m: "middle" };
leafletSrcExports.Canvas.include({
  _updateTextPt: function(e, n) {
    var r = n.options, o = 1;
    r.fontPercent !== 100 && (o = r.fontPercent / 100), this._ctx.fillStyle = r.fontColor, r.fontStroke === !0 && (this._ctx.strokeStyle = r.fontStrokeColor, this._ctx.setLineDash([]), this._ctx.lineWidth = r.fontStrokeWidth), this._ctx.globalAlpha = r.fontOpacity || 1;
    var l = [r.fontStyle ? r.fontStyle : "normal", "normal", r.fontWeight ? r.fontWeight : "normal", r.fontSize ? r.fontSize + "px" : "1em", r.fontFamily ? r.fontFamily : "sans-serif"].join(" "), u = r.text.split(`
`), h = u.length;
    if (this._ctx.fillText) {
      this._ctx.font = l, this._ctx.textAlign = leafletSrcExports.Canvas.LABEL_ALIGN[r.labelAlign[0]] || "center", this._ctx.textBaseline = leafletSrcExports.Canvas.LABEL_ALIGN[r.labelAlign[1]] || "middle";
      var c = leafletSrcExports.Canvas.LABEL_FACTOR[r.labelAlign[1]];
      c == null && (c = -0.5);
      var f = this._ctx.measureText("MGMG").height || this._ctx.measureText("xx").width;
      e.y += f * c * (h - 1);
      for (var v = 0; v < h; v++)
        if (r.fontSpace != 0) {
          var m = 0, g = u[v].split(""), y = this._ctx.measureText(u[v]).width + r.fontSpace * (g.length - 1), w = r.labelAlign[0] || "c";
          w === "c" ? m -= y / 2 - this._ctx.measureText(u[v][0]).width / 2 : w === "r" && (m -= y - r.fontSize);
          var E = 0, x = u[v].split(""), D = "";
          this._ctx.save(), this._ctx.translate(e.x, e.y), r.labelRotation != 0 && this._ctx.rotate(r.labelRotation * Math.PI / 180), this._ctx.scale(o, 1);
          for (var F = 0; F < x.length; F++)
            r.fontStroke === !0 && this._ctx.strokeText(x[F], m + E, f * v), this._ctx.fillText(x[F], m + E, f * v), D += x[F], E = this._ctx.measureText(D).width + parseFloat(r.fontSpace) * (F + 1);
          this._ctx.restore();
        } else
          this._ctx.save(), this._ctx.translate(e.x, e.y), r.labelRotation != 0 && this._ctx.rotate(r.labelRotation * Math.PI / 180), this._ctx.scale(o, 1), r.fontStroke === !0 && this._ctx.strokeText(u[v], 0, f * v), this._ctx.fillText(u[v], 0, f * v), this._ctx.restore();
    }
  },
  _updateText: function(e) {
    if (e.options.text != null && !(e.options.fontSize < 6)) {
      e.options.fontPercent === void 0 && (e.options.fontPercent = 100), e.options.fontPercent < 0 && (e.options.fontPercent = 0), e.options.fontPercent > 400 && (e.options.fontPercent = 400), e.options.fontSpace === void 0 && (e.options.fontSpace = 0), e.options.fontSpace > 30 || e.options.fontSpace < 0 && (e.options.fontSpace = 0);
      var n = e._latlng, r = this._map.latLngToLayerPoint(n);
      if (r != null) {
        if (e.options.labelXOffset || e.options.labelYOffset) {
          var o = isNaN(e.options.labelXOffset) ? 0 : e.options.labelXOffset, l = isNaN(e.options.labelYOffset) ? 0 : e.options.labelYOffset;
          r.x += o, r.y -= l;
        }
        if (e.options.fontBackground === !0) {
          this._ctx.font = [e.options.fontStyle ? e.options.fontStyle : "normal", "normal", e.options.fontWeight ? e.options.fontWeight : "normal", e.options.fontSize ? e.options.fontSize + "px" : "1em", e.options.fontFamily ? e.options.fontFamily : "sans-serif"].join(" ");
          var u = e.options.labelRotation;
          e.options.labelRotation = 0;
          var h = e.getPxBounds();
          e.options.labelRotation = u;
          var c = h.min.x, f = h.min.y, v = h.max.x - h.min.x, m = h.max.y - h.min.y;
          this._ctx.fillStyle = e.options.fontBackgroundColor, this._ctx.globalAlpha = 1, this._ctx.save(), this._ctx.translate(c, f), e.options.labelRotation != 0 && this._ctx.rotate(e.options.labelRotation * Math.PI / 180), this._ctx.fillStyle = "#ff0000", this._ctx.fillRect(0, 0, v, m), this._ctx.restore();
        }
        if (e.options.fontShadow === !0) {
          var g = leafletSrcExports.point(r.x, r.y);
          if (e.options.fontShadowOffsetX && (g.x += e.options.fontShadowOffsetX), e.options.fontShadowOffsetY && (g.y += e.options.fontShadowOffsetY), e.options.labelRotation !== 0) {
            var y = r.x, w = r.y, E = e.options.labelRotation * Math.PI / 180, x = Math.sqrt(Math.pow(g.x - y, 2) + Math.pow(g.y - w, 2)), D = E + Math.atan2(g.y - w, g.x - y);
            g.x = y + x * Math.cos(D), g.y = w + x * Math.sin(D);
          }
          var F = e.options.fontStroke;
          e.options.fontStroke = !1;
          var k = e.options.fontColor;
          e.options.fontColor = e.options.fontShadowColor, this._updateTextPt(g, e), e.options.fontColor = k, e.options.fontStroke = F;
        }
        this._updateTextPt(r, e);
      }
    }
  }
});
const Text = leafletSrcExports.Path.extend({
  affiliation: null,
  options: {
    text: "",
    labelAlign: "cb",
    labelRotation: 0,
    fontColor: "#FFFFFF",
    fontSize: 14,
    fontOpacity: 1,
    fontFamily: "微软雅黑",
    fontWeight: "normal",
    fontStyle: "",
    fontSpace: 0,
    fontPercent: 100,
    fontStroke: !1,
    fontStrokeColor: "#ff0000",
    fontStrokeWidth: 2,
    fontBackground: 1,
    fontBackgroundColor: "#ff0000",
    fontShadow: 1,
    fontShadowColor: "#ff0000",
    fontShadowOffsetX: 0,
    fontShadowOffsetY: 0,
    interactive: !0
  },
  _textNode: null,
  _backgroundTextNode: null,
  _shadowTextNode: null,
  _tspanNodeObj: null,
  initialize: function(e, n) {
    leafletSrcExports.setOptions(this, n), this._latlng = leafletSrcExports.latLng(e[0]), this._text = this.options.text, this._tspanNodeObj = {}, n.isdragon && this.dragging.enable();
  },
  onAdd: function() {
    leafletSrcExports.Path.prototype.onAdd.call(this), this.on("drag", this._onDrag, this).on("click", this._onClick, this);
  },
  onRemove: function() {
    this._removeNode(), leafletSrcExports.Path.prototype.onRemove.call(this), this.off("drag", this._onDrag, this).off("click", this._onClick, this);
  },
  _onClick(e) {
  },
  _onDrag(e) {
  },
  _removeNode: function() {
    this._textNode && this._textNode.parentNode && (leafletSrcExports.DomUtil.remove(this._textNode), this.removeInteractiveTarget(this._textNode), delete this._textNode, this._textNode = null), this._backgroundTextNode && this._backgroundTextNode.parentNode && (this._renderer._rootGroup.removeChild(this._backgroundTextNode), delete this._backgroundTextNode, this._backgroundTextNode = null), this._shadowTextNode && this._shadowTextNode.parentNode && (this._renderer._rootGroup.removeChild(this._shadowTextNode), delete this._shadowTextNode, this._shadowTextNode = null), this._tspanNodeObj = {}, this._textNode && (leafletSrcExports.DomUtil.remove(this._textNode), this.removeInteractiveTarget(this._textNode), delete this._textNode, this._textNode = null), this._backgroundTextNode && (delete this._backgroundTextNode, this._backgroundTextNode = null), this._shadowTextNode && (delete this._shadowTextNode, this._shadowTextNode = null);
  },
  setLatLngs: function(e) {
    return this._latlng = leafletSrcExports.latLng(e[0]), this.redraw(), this.fire("move", { latlng: this._latlng });
  },
  getLatLngs: function() {
    return [this._latlng];
  },
  _resizeByWidth(e, n) {
  },
  _resizeByHeight(e, n) {
  },
  // _move: function (lat, lng) {
  //     CommonUtil.moveLatLngs(this.getLatLngs(), lat, lng);
  //     const latlngs = this.getLatLngs();
  //     this.affiliation.symbol.textPoint = new Point(latlngs[0].lng, latlngs[0].lat)
  //     this.symbol.positionPoints = [this.affiliation.symbol.textPoint]
  //     this.affiliation.symbol.moved = true;
  //     this.redraw();
  // },
  // move: function (lat, lng) {
  //     this._move.call(this, lat, lng)
  // },
  // _rotate(rotate, anchorPoint) {
  //     CommonUtil.rotateLatLngs(this.getLatLngs(), anchorPoint, rotate);
  //     const latlngs = this.getLatLngs();
  //     this.affiliation.symbol.textPoint = new Point(latlngs[0].lng, latlngs[0].lat)
  //     this.symbol.positionPoints = [this.affiliation.symbol.textPoint]
  // },
  _resize(e, n) {
  },
  setText: function(e) {
    return this.options.text = this._text = e, this.redraw();
  },
  getText: function() {
    return this._text;
  },
  setStyle: function(e) {
    var n = e && e.text || this._text;
    return leafletSrcExports.Path.prototype.setStyle.call(this, e), this.setText(n), this;
  },
  getBounds: function() {
    return this._updateBounds(), this._bounds;
  },
  _project: function() {
    this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
  },
  getPxBounds: function(e) {
    this._point = this._map.latLngToLayerPoint(this._latlng);
    var n = 1;
    this.options.fontPercent && this.options.fontPercent !== 100 && (n = this.options.fontPercent / 100);
    var r = 0, o = 0, l = this.options.text.split(`
`), u = l.length;
    if (this._renderer instanceof leafletSrcExports.Canvas) {
      var h = [this.options.fontStyle ? this.options.fontStyle : "normal", "normal", this.options.fontWeight ? this.options.fontWeight : "normal", this.options.fontSize ? this.options.fontSize + "px" : "1em", this.options.fontFamily ? this.options.fontFamily : "sans-serif"].join(" ");
      this._renderer._ctx.font = h, this.options.fontSize = parseFloat(this.options.fontSize);
      let k = leafletSrcExports.Canvas.LABEL_FACTOR[this.options.labelAlign[1]];
      k == null && (k = -0.5);
      let N = this._renderer._ctx.measureText("Mg").height || this._renderer._ctx.measureText("xx").width;
      o = N * k * (u - 1) + N * u;
      for (let H = 0; H < u; H++)
        if (this.options.fontSpace && this.options.fontSpace != 0 || this.options.fontPercent && this.options.fontPercent != 100) {
          let R = (this._renderer._ctx.measureText(l[H]).width + this.options.fontSpace * (l[H].length - 1)) * n;
          r < R && (r = R);
        } else {
          let R = this._renderer._ctx.measureText(l[H]).width;
          r < R && (r = R);
        }
    } else if (this._renderer instanceof leafletSrcExports.SVG) {
      let k = leafletSrcExports.SVG.LABEL_VFACTOR[this.options.labelAlign[1]];
      k == null && (k = -0.5);
      let N = this.options.fontSize;
      o = N * k * (u - 1) + N * u;
      for (let H = 0; H < u; H++) {
        let R = getTextWidth(this.options, l[H]);
        r < R && (r = R);
      }
    } else {
      this.options.fontSize = parseFloat(this.options.fontSize);
      let k = this.options.fontSize;
      o = k * (u - 1) + k * u;
      for (let N = 0; N < u; N++) {
        let H = getTextWidth(this.options, l[N]);
        r < H && (r = H);
      }
    }
    this.options.fontSize < 6 && (r = 0);
    var c = 0, f = 0, v = 0, m = 0, g = this.options.labelAlign || "cm";
    for (var y in g === "lt" ? (c = this._point.x, f = this.options.fontFamily == "微软雅黑" || this.options.fontFamily == "Microsoft YaHei" ? this._point.y : this._point.y - this.options.fontSize / 2, v = this._point.x + r, m = this._point.y + o) : g === "ct" ? (c = this._point.x - r / 2, f = this.options.fontFamily == "微软雅黑" || this.options.fontFamily == "Microsoft YaHei" ? this._point.y : this._point.y - this.options.fontSize / 2, v = this._point.x + r / 2, m = this._point.y + o) : g === "rt" ? (c = this._point.x - r, f = this.options.fontFamily == "微软雅黑" || this.options.fontFamily == "Microsoft YaHei" ? this._point.y : this._point.y - this.options.fontSize / 2, v = this._point.x, m = this._point.y + o) : g === "lb" ? (c = this._point.x, f = this._point.y - o, v = this._point.x + r, m = this.options.fontFamily == "微软雅黑" || this.options.fontFamily == "Microsoft YaHei" ? this._point.y : this._point.y + this.options.fontSize / 2) : g === "cb" ? (c = this._point.x - r / 2, f = this._point.y - o, v = this._point.x + r / 2, m = this._point.y, m = this.options.fontFamily == "微软雅黑" || this.options.fontFamily == "Microsoft YaHei" ? this._point.y : this._point.y + this.options.fontSize / 2) : g === "rb" ? (c = this._point.x - r, f = this._point.y - o, v = this._point.x, m = this.options.fontFamily == "微软雅黑" || this.options.fontFamily == "Microsoft YaHei" ? this._point.y : this._point.y + this.options.fontSize / 2) : g === "lm" ? (c = this._point.x, f = this._point.y - o / 2, v = this._point.x + r, m = this._point.y + o / 2) : g === "cm" ? (c = this._point.x - r / 2, f = this._point.y - o / 2, v = this._point.x + r / 2, m = this._point.y + o / 2) : g === "rm" && (c = this._point.x - r, f = this._point.y - o / 2, v = this._point.x, m = this._point.y + o / 2), e && this.options.fontShadow && (this.options.fontShadowOffsetX !== 0 || this.options.fontShadowOffsetY !== 0) && (this.options.fontShadowOffsetX > 0 ? v += this.options.fontShadowOffsetX : c += this.options.fontShadowOffsetX, this.options.fontShadowOffsetY > 0 ? m += this.options.fontShadowOffsetY : f += this.options.fontShadowOffsetY), this._eventParents)
      if (this.options.fontPercent === 0 && this.options.fontPercent === 0) {
        var w = v - c, E = (w + this.options.fontSpace * (this.options.text.length - 1)) * this.options.fontPercent / 100 - w;
        switch (g) {
          case "lt":
          case "lm":
          case "lb":
            v += E;
            break;
          case "rt":
          case "rm":
          case "rb":
            c -= E;
            break;
          case "ct":
          case "cm":
          case "cb":
            c -= E / 2, v += E / 2;
        }
      }
    var x = new leafletSrcExports.Bounds();
    if (this.options.labelRotation && this.options.labelRotation !== 0) {
      var D = [];
      D.push(leafletSrcExports.point(c, f)), D.push(leafletSrcExports.point(c, m)), D.push(leafletSrcExports.point(v, f)), D.push(leafletSrcExports.point(v, m));
      var F = this.options.labelRotation * (Math.PI / 180);
      for (let k = 0; k < D.length; k++)
        rotateAngle(this._point, F, D[k]), x.extend(D[k]);
    } else
      x = leafletSrcExports.bounds(leafletSrcExports.point(c, f), leafletSrcExports.point(v, m));
    return x;
  },
  _updateBounds: function() {
    this._pxBounds = this.getPxBounds(!0);
    var e = this._map.layerPointToLatLng(this._pxBounds.min), n = this._map.layerPointToLatLng(this._pxBounds.max);
    this._bounds = leafletSrcExports.latLngBounds(e, n);
  },
  _update: function() {
    this._map && this._updatePath();
  },
  _updatePath: function() {
    this._renderer._updateText(this);
  },
  _containsPoint: function(e) {
    return this._pxBounds.contains(e);
  },
  _empty: function() {
    return this._text && !this._renderer._bounds.intersects(this._pxBounds);
  }
}), Fn = class Fn extends BaseObject {
  constructor() {
    super(), this._className = "LeafletElementFactory";
  }
  // 提供一个获取实例的静态方法
  static getInstance() {
    return Fn._instance || (Fn._instance = new Fn()), Fn._instance;
  }
  create(n, r, o) {
    let l = null;
    switch (n) {
      case SymbolCellType.circleMark: {
        l = new leafletSrcExports.CircleMarker(r[0], {
          radius: o.style.radius,
          // 半径单位是像素
          fillColor: o.style.fillColor,
          // 填充颜色
          color: o.style.color,
          // 边框颜色
          weight: o.style.weight,
          // 边框宽度，保持为1以匹配半径
          opacity: o.style.opacity,
          // 填充透明度
          fillOpacity: o.style.fillOpacity
          // 边框透明度
        });
        break;
      }
    }
    return l;
  }
};
Fn._instance = null;
let LeafletElementFactory = Fn;
L.PathDraggable = L.Draggable.extend({
  initialize: function(e) {
    this._path = e, this._canvas = e._map.getRenderer(e) instanceof L.Canvas;
    var n = this._canvas ? this._path._map.getRenderer(this._path)._container : this._path._path;
    L.Draggable.prototype.initialize.call(this, n, n, !0);
  },
  _updatePosition: function() {
    var e = { originalEvent: this._lastEvent };
    this.fire("drag", e);
  },
  _onDown: function(e) {
    if (this._path._map) {
      var n = e.touches ? e.touches[0] : e;
      this._startPoint = new L.Point(n.clientX, n.clientY), !(this._canvas && !this._path._containsPoint(this._path._map.mouseEventToLayerPoint(n))) && L.Draggable.prototype._onDown.call(this, e);
    }
  }
});
L.Handler.PathDrag = L.Handler.extend({
  initialize: function(e) {
    this._path = e;
  },
  getEvents: function() {
    return {
      dragstart: this._onDragStart,
      drag: this._onDrag,
      dragend: this._onDragEnd
    };
  },
  addHooks: function() {
    this._draggable || (this._draggable = new L.PathDraggable(this._path)), this._draggable.on(this.getEvents(), this).enable(), L.DomUtil.addClass(this._draggable._element, "leaflet-path-draggable");
  },
  removeHooks: function() {
    this._draggable.off(this.getEvents(), this).disable(), L.DomUtil.removeClass(this._draggable._element, "leaflet-path-draggable");
  },
  moved: function() {
    return this._draggable && this._draggable._moved;
  },
  _onDragStart: function() {
    this._startPoint = this._draggable._startPoint, this._path.closePopup().fire("movestart").fire("dragstart");
  },
  _onDrag: function(e) {
    var n = this._path, r = e.originalEvent.touches && e.originalEvent.touches.length === 1 ? e.originalEvent.touches[0] : e.originalEvent, o = L.point(r.clientX, r.clientY), l = n._map.layerPointToLatLng(o);
    this._offset = o.subtract(this._startPoint), this._startPoint = o, this._path.eachLatLng(this.updateLatLng, this), n.redraw(), e.latlng = l, e.offset = this._offset, n.fire("drag", e), e.latlng = this._path.getCenter ? this._path.getCenter() : this._path.getLatLng(), n.fire("move", e);
  },
  _onDragEnd: function(e) {
    this._path._bounds && this.resetBounds(), this._path.fire("moveend").fire("dragend", e);
  },
  latLngToLayerPoint: function(e) {
    var n = this._path._map.project(L.latLng(e));
    return n._subtract(this._path._map.getPixelOrigin());
  },
  updateLatLng: function(e) {
    var n = this.latLngToLayerPoint(e);
    n._add(this._offset);
    var r = this._path._map.layerPointToLatLng(n);
    e.lat = r.lat, e.lng = r.lng;
  },
  resetBounds: function() {
    this._path._bounds = new L.LatLngBounds(), this._path.eachLatLng(function(e) {
      this._bounds.extend(e);
    });
  }
});
L.Path.include({
  eachLatLng: function(e, n) {
    n = n || this;
    var r = function(o) {
      for (var l = 0; l < o.length; l++)
        L.Util.isArray(o[l]) ? r(o[l]) : e.call(n, o[l]);
    };
    r(this.getLatLngs ? this.getLatLngs() : [this.getLatLng()]);
  }
});
L.Path.addInitHook(function() {
  this.dragging = new L.Handler.PathDrag(this), this.options.draggable && this.once("add", function() {
    this.dragging.enable();
  });
});
class Feature extends BaseObject {
  constructor(n, r = null, o = null) {
    super(), this._className = "Feature", this._code = n, this._elements = [], this._points = [], this._featureComponents = new leafletSrcExports.FeatureGroup(), this._show = !0, this._featureRotate = 0, this._featureStyle = r || new FeatureStyle(), this._addMark = null, this._deleteMark = null, this._symbol = SymbolFactory.getInstance().create(n), this._map = null, this._controlsMarkers = [], this._elementFactory = LeafletElementFactory.getInstance(), this._multiTexts = [], this._rotateMarker = null, this._lastPixel = null, this._scaleMarker = null, this._unaddMouseEvents = [], this._userMouseEvents = [], this._id = o || this._id, this._initialize(), this._deleteIcon = new leafletSrcExports.DivIcon({
      iconSize: new leafletSrcExports.Point(16, 16),
      className: "leaflet-div-delete-icon"
    }), this._addIcon = new leafletSrcExports.DivIcon({
      iconSize: new leafletSrcExports.Point(16, 16),
      className: "leaflet-div-add-icon"
    }), this._options = {
      zIndexOffset: 2e3,
      icon: new leafletSrcExports.DivIcon({
        iconSize: new leafletSrcExports.Point(8, 8),
        className: "leaflet-div-icon leaflet-editing-icon"
      })
    }, this._pinIconOptions = {
      width: 40,
      height: 40,
      iconAnchorX: 14,
      iconAnchorY: 35
    }, this._plotPngOptions = {
      width: 48,
      height: 48,
      iconAnchorX: 24,
      iconAnchorY: 24
    }, this._zIndexOffset = 2e3, this._selectBorder = null;
  }
  setTexts(n) {
    this._multiTexts = n.slice(), this.redraw();
  }
  setSvgText(n) {
    if (this._symbol._type = FeatureType.SVG) {
      var r = this._symbol;
      r._svgText = n, this.redraw();
    }
  }
  getFeatureId() {
    return this._id;
  }
  finishDraw() {
    this._layer._layerType == LayerType.PLOT && this._layer._drawHandler._finishShape();
  }
  setStyle(n) {
    defined(n) && (this._featureStyle = n, this.redraw());
  }
  getStyle() {
    return this._featureStyle;
  }
  getBounds() {
    var n = [], r;
    if (!(this._symbol._type == FeatureType.Text || this._symbol._type == FeatureType.Pin))
      if (this._symbol._type == FeatureType.PlotPng) {
        if (this._symbol.controlPoints.length == 0)
          return null;
        var o = this._map._map.latLngToLayerPoint(leafletSrcExports.latLng(this._symbol.controlPoints[0].getLat(), this._symbol.controlPoints[0].getLon())), l = this._map._map.layerPointToLatLng({
          x: o.x - this._pinIconOptions.width * 0.5 * this._symbol._scale,
          y: o.y - this._pinIconOptions.height * 0.5 * this._symbol._scale
        }), u = this._map._map.layerPointToLatLng({
          x: o.x + this._pinIconOptions.width * 0.5 * this._symbol._scale,
          y: o.y + this._pinIconOptions.height * 0.5 * this._symbol._scale
        });
        r = leafletSrcExports.latLngBounds(l, u);
      } else
        r = this._featureComponents.getBounds();
    return n.push(new GeoPoint2D(r.getWest(), r.getNorth())), n.push(new GeoPoint2D(r.getEast(), r.getSouth())), n;
  }
  getCircleRadius() {
    if (this._symbol._type == FeatureType.Circle) {
      var n = this._symbol;
      return n ? n._radius : -999;
    }
    return -999;
  }
  setCircleRadius(n = 0) {
    if (this._symbol._type == FeatureType.Circle) {
      var r = this._symbol;
      r && (r._radius = n, this.redraw());
    }
  }
  /**
   * @作者: Wangjianbo
   * @时间: 2024/06/30 11:01:12
   * @描述:设置圆的半径 单位为米
   * @参数：
   */
  setCenter(n) {
    switch (this.getType()) {
      case FeatureType.Ellipse: {
        this._symbol.controlPoints[0] = n, this._symbol.updatecenter();
        break;
      }
      case FeatureType.Circle: {
        this._symbol.controlPoints[0] = n, this._symbol.updatecenter();
        break;
      }
    }
    this.redraw();
  }
  getCenter() {
    let n = null;
    switch (this._symbol._type) {
      case FeatureType.Text:
      case FeatureType.Pin:
      case FeatureType.PlotPng:
      case FeatureType.Ellipse:
      case FeatureType.Circle: {
        n = this.getPoints()[0];
        break;
      }
      default: {
        let r = this._featureComponents.getBounds().getCenter();
        n = new GeoPoint2D(r.lng, r.lat);
        break;
      }
    }
    return n;
  }
  /**
   * @作者: Wangjianbo
   * @时间: 2024/07/01 09:10:25
   * @描述:获取椭圆想轴半径 单位为千米
   * @参数：
   */
  getXSemiAxis() {
    if (this.getType() == FeatureType.Ellipse) {
      let n = this._symbol;
      return n ? n._xSemiAxis : -999;
    } else
      return -999;
  }
  /**
   * @作者: Wangjianbo
   * @时间: 2024/07/01 09:10:50
   * @描述:获取椭圆Y轴半径单位千米
   * @参数：
   */
  getYSemiAxis() {
    if (this.getType() == FeatureType.Ellipse) {
      let n = this._symbol;
      return n ? n._ySemiAxis : -999;
    } else
      return -999;
  }
  /**
   * @作者: Wangjianbo
   * @时间: 2024/07/01 10:25:32
   * @描述:设置椭圆x轴半径 单位千米
   * @参数：
   */
  setXSemiAxis(n = 0) {
    if (this.getType() == FeatureType.Ellipse) {
      let r = this._symbol;
      r && (r._xSemiAxis = n, r.updatex(), this.redraw());
    }
  }
  /**
   * @作者: Wangjianbo
   * @时间: 2024/07/01 10:26:03
   * @描述:设置椭圆Y轴半径单位为千米
   * @参数：
   */
  setYSemiAxis(n) {
    if (this.getType() == FeatureType.Ellipse) {
      let r = this._symbol;
      r && (r._ySemiAxis = n, r.updatey(), this.redraw());
    }
  }
  zoomTo() {
    var n = null;
    if (this._symbol._type == FeatureType.Text || this._symbol._type == FeatureType.Pin || this._symbol._type == FeatureType.PlotPng)
      n = this.getPoints(), defined(this._layer) && defined(this._layer._map) && defined(n) && this._layer._map._map.flyTo(leafletSrcExports.latLng(n[0].getLat(), n[0].getLon()));
    else {
      var r = this._featureComponents.getBounds();
      if (defined(this._layer) && defined(this._layer._map)) {
        var o = r.getEast() - r.getWest(), l = r.getNorth() - r.getSouth(), u = leafletSrcExports.latLng(r.getSouth() - o, r.getWest() - l), h = leafletSrcExports.latLng(r.getNorth() + o, r.getEast() + l), c = leafletSrcExports.latLngBounds(u, h);
        this._layer._map._map.flyToBounds(c);
      }
    }
  }
  setEditeFeature() {
    if (this._layer._layerType == LayerType.PLOT) {
      let n = this._layer;
      n._unselectFeatures(), n._editeFeature = this, n._onTriggerMapClick = !0, n._selectedFeatures.push(this), this.createControlPointsMarkers(), this._featureComponents.on("mousemove", this._featureMouseMove, this), this._featureComponents.on("mouseout", this._featureMouseOut, this), this._featureComponents.on("click", this._featureClick, this);
    }
  }
  _update() {
  }
  rotate(n) {
    if (this._featureRotate = n, this._symbol._type == FeatureType.PlotPng)
      this._featureComponents.eachLayer((r) => {
        defined(r.rotate) && r.rotate(this._featureRotate);
      });
    else if (this._symbol._type == FeatureType.SVG || this._symbol._type == FeatureType.Ellipse) {
      if (this._symbol._rotate = this._featureRotate, this._symbol.controlPoints.length == 0)
        return;
      this.redraw();
    }
  }
  getRotate() {
    return this._symbol._rotate;
  }
  setScale(n) {
    this._symbol._scale = n, this.redraw();
  }
  getScale() {
    return this._symbol._scale;
  }
  getType() {
    return this._symbol._type;
  }
  creatSelectedBorder(n) {
    this._selectBorder = leafletSrcExports.polyline(n, {
      dashArray: [10, 20],
      color: "#333333",
      draggable: !0
    }).addTo(this._map._map), this._selectBorder.on("dragstart", function(r) {
      this._cleanControlMarkers(), this._cleanRotateMarker(), this._map._map.dragging.disable();
    }, this), this._selectBorder.on("drag", (r) => {
      if (this._map._map) {
        var o = this.getPoints(), l = [];
        o && o.length > 0 && o.forEach((u) => {
          var h = this._map._map.latLngToContainerPoint(leafletSrcExports.latLng(u.getLat(), u.getLon()));
          h.x += r.offset.x, h.y += r.offset.y;
          let c = this._map._map.containerPointToLatLng(h);
          l.push(new GeoPoint3D(c.lng, c.lat));
        }), this.setPoints(l);
      }
    }), this._selectBorder.on("dragend", (r) => {
      r.target.getLatLngs(), this.createControlPointsMarkers(), this._createRotateMarker(n[3]), this._map._map.dragging.enable();
    }, this), this._selectBorder.on("mouseover", () => {
      this._selectBorder._renderer._container.style.cursor = "move";
    }), this._selectBorder.on("mouseout", () => {
      this._selectBorder && (this._selectBorder._renderer._container.style.cursor = "");
    });
  }
  createControlPointsMarkers() {
    if (this.cleanControlsPointsMarkers(), this._symbol.getControls().forEach((o) => {
      const l = new leafletSrcExports.Marker({ lat: o.getLat(), lon: o.getLon() }, {
        icon: this._options.icon,
        zIndexOffset: 2 * this._options.zIndexOffset,
        draggable: !0
      }).addTo(this._map._map);
      l.on("dragstart", this._markerDragstart, this), l.on("drag", this._markerDragOn, this), l.on("dragend", this._markerDragEnd, this), l.on("click", this._markerClick, this), l.on("mousemove", this._markerMove, this), l.on("mouseout", this._markerOut, this), l.draggable = !0, this._controlsMarkers.push(l);
    }), !(this._symbol._type == FeatureType.Pin || this._symbol._type == FeatureType.Text)) {
      var n = this.getBounds(), r = [
        leafletSrcExports.latLng(n[0].getLat(), n[0].getLon()),
        leafletSrcExports.latLng(n[1].getLat(), n[0].getLon()),
        leafletSrcExports.latLng(n[1].getLat(), n[1].getLon()),
        leafletSrcExports.latLng(n[0].getLat(), n[1].getLon()),
        leafletSrcExports.latLng(n[0].getLat(), n[0].getLon())
      ];
      if (this.creatSelectedBorder(r), this._createRotateMarker(r[3]), this._symbol._type == FeatureType.SVG || this._symbol._type == FeatureType.PlotPng) {
        let o = leafletSrcExports.divIcon({
          iconSize: [32, 32],
          iconAnchor: [8, 16],
          className: "leaflet-div-scale-icon leaflet-editing-control"
        });
        this._scaleMarker = leafletSrcExports.marker(r[1], {
          icon: o,
          zIndexOffset: 4 * this._options.zIndexOffset,
          draggable: !0
        }).addTo(this._map._map), this._scaleMarker.on("drag", this._markerScaleDragOn, this), this._scaleMarker.on("dragstart", this._markerScaleDragstart, this), this._scaleMarker.on("dragend", this._markerScaleDragEnd, this), this._scaleMarker.on("mousedown", this._markerScaleMove, this), this._scaleMarker.on("mouseout", this._markerScaleOut, this);
      }
    }
  }
  cleanControlsPointsMarkers() {
    this._deleteScaleMarker(), this._cleanRotateMarker(), this.cleanControlMarkersAndBoarder();
  }
  _createRotateMarker(n) {
    this._cleanRotateMarker();
    let r = leafletSrcExports.divIcon({
      iconSize: [32, 32],
      iconAnchor: [8, 16],
      className: "leaflet-div-rotate-icon leaflet-editing-control"
    });
    this._rotateMarker = leafletSrcExports.marker(n, {
      icon: r,
      zIndexOffset: 4 * this._options.zIndexOffset,
      draggable: !0
    }).addTo(this._map._map), this._rotateMarker.on("drag", this._markerRotateDragOn, this), this._rotateMarker.on("dragstart", this._markerRotateDragstart, this), this._rotateMarker.on("dragend", this._markerRotateDragEnd, this), this._rotateMarker.on("mousedown", this._markerRotateMove, this), this._rotateMarker.on("mouseout", this._markerRotateOut, this);
  }
  _cleanRotateMarker() {
    this._rotateMarker && (this._rotateMarker.off("drag", this._markerRotateDragOn, this), this._rotateMarker.off("dragstart", this._markerRotateDragstart, this), this._rotateMarker.off("dragend", this._markerRotateDragEnd, this), this._rotateMarker.off("mousedown", this._markerRotateMove, this), this._rotateMarker.off("mouseout", this._markerRotateOut, this), this._map._map.removeLayer(this._rotateMarker), this._rotateMarker.remove(), this._rotateMarker = null);
  }
  _cleanControlMarkers() {
    this._controlsMarkers.forEach((n) => {
      n.off("dragstart", this._markerDragstart, this), n.off("drag", this._markerDragOn, this), n.off("dragend", this._markerDragEnd, this), n.off("click", this._markerClick, this), n.off("mousemove", this._markerMove, this), n.off("mouseout", this._markerOut, this), this._map._map.removeLayer(n);
    }), this._controlsMarkers = [];
  }
  cleanControlMarkersAndBoarder() {
    this._selectBorder && (this._map._map.removeLayer(this._selectBorder), this._selectBorder = null), this._cleanControlMarkers();
  }
  cleanBoarderAndRotateMaker() {
    this._selectBorder && (this._map._map.removeLayer(this._selectBorder), this._selectBorder = null), this._cleanRotateMarker();
  }
  getPoints() {
    return this._symbol.controlPoints;
  }
  setPoints(n) {
    this._symbol.controlPoints = n.slice(), this.redraw();
  }
  //添加鼠标事件
  addMouseEvent(n, r) {
    this._userMouseEvents.push({ type: n, callback: r });
  }
  removeMouseEvent(n, r) {
    var o = this._userMouseEvents.find((l) => l.type == n && l.callback == r);
    if (o) {
      const l = this._userMouseEvents.indexOf(o);
      return l > -1 && this._userMouseEvents.splice(l, 1), !0;
    }
    return !1;
  }
  //移除鼠标事件
  //左击事件
  _userMouseLClickEvent(n) {
    this._userMouseEvents.forEach((r) => {
      r.type == MouseEventType.MouseLClick && r.callback({
        feature: this,
        containerPoint: n.containerPoint,
        layerPoint: n.layerPoint,
        positions: this.getPoints(),
        type: MouseEventType.MouseLClick
      });
    });
  }
  //
  _uerMouseEnterEvent(n) {
    this._userMouseEvents.forEach((r) => {
      r.type == MouseEventType.MouseEnter && r.callback({
        feature: this,
        containerPoint: n.containerPoint,
        layerPoint: n.layerPoint,
        positions: this.getPoints(),
        type: MouseEventType.MouseEnter
      });
    });
  }
  _uerMouseOutEvent(n) {
    this._userMouseEvents.forEach((r) => {
      r.type == MouseEventType.MouseOut && r.callback({
        feature: this,
        containerPoint: n.containerPoint,
        layerPoint: n.layerPoint,
        positions: this.getPoints(),
        type: MouseEventType.MouseOut
      });
    });
  }
  redraw() {
    this._symbol.calculateParts(), defined(this._layer) && this._layer._layerType == LayerType.PLOT && this._featureComponents.eachLayer((n) => {
      n.off("contextmenu", this._contextmenuEvent, this);
    }), this._featureComponents.clearLayers(), this._redrawComponents();
  }
  _initialize() {
    this._featureComponents.on("click", this._userMouseLClickEvent, this), this._featureComponents.on("mouseout", this._uerMouseOutEvent, this), this._featureComponents.on("mouseover", this._uerMouseEnterEvent, this);
  }
  _redrawComponents() {
    for (let n = 0; n < this._symbol._components.length; n++) {
      let r = this._symbol._components[n], o = [];
      for (let u = 0; u < r._points.length; u++)
        o.push(new leafletSrcExports.LatLng(
          r._points[u].getLat(),
          r._points[u].getLon()
        ));
      r._options && r._options.text && (this._featureStyle.text = r._options.text), this._symbol._type == FeatureType.Entity && (this._symbol._options && this._symbol._options.image && (this._featureStyle.plotPntURL = this._symbol._options.image.image), this._symbol._options.text && (this._featureStyle.text = this._symbol._options.text.text)), this._symbol._type == FeatureType.MultiText && (this._featureStyle.text = this._multiTexts[n]);
      const l = this._createFeatureComponent(r._type, o, r._options);
      if (!defined(l))
        return;
      l.on("contextmenu", this._contextmenuEvent, this), this._show && (this._addComponent(l), l.symbol = r, l.type = r._type, defined(l.redraw) && l.redraw());
    }
  }
  _createFeatureComponent(n, r, o = null) {
    let l = null;
    switch (defined(o) && defined(o.style) && (this._featureStyle.lineColor = o.style.color == "#FF0000" || o.style.color == "#ff0000" ? this._featureStyle.lineColor : o.style.color, this._featureStyle.lineOpacity = o.style.lineOpacity, this._featureStyle.fillOpacity = o.style.fillOpacity, this._featureStyle.fillColor = o.style.fillColor), n) {
      case SymbolCellType.PolyLine: {
        l = leafletSrcExports.polyline(r), l._featureid = this._id;
        break;
      }
      case SymbolCellType.Polygon: {
        l = leafletSrcExports.polygon(r), l._featureid = this._id;
        break;
      }
      case SymbolCellType.Pin: {
        let h = leafletSrcExports.divIcon({
          className: "leaflet-div-icon leaflet-div-svg-pin",
          // iconUrl: PinConPng,
          iconSize: [this._pinIconOptions.width, this._pinIconOptions.height],
          html: `<svg  t="1714965776290"   class="icon" viewBox="0 0 45 45" p-id="4253" width="45"  height="45"  id="svg15"  xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
                  <path  d="M 9.4123818,2.6844345 A 15.858454,14.404535 0 0 1 25.602275,2.8056921 C 30.537039,5.590429 33.533803,10.561981 33.506183,15.903575 33.3911,21.21381 30.175678,26.208359 26.156976,30.067686 A 43.103233,39.151486 0 0 1 18.427993,35.963303 2.69985,2.4523251 0 0 1 17.488915,36.264355 1.8873632,1.7143279 0 0 1 16.591267,36.015568 42.615279,38.708269 0 0 1 5.4535221,26.509411 21.359427,19.401174 0 0 1 1.2829091,15.640154 C 1.2806091,10.283925 4.3832491,5.3374612 9.4123818,2.6844345 Z M 12.317079,17.858327 a 5.4733528,4.9715508 0 0 0 5.059055,3.129694 5.3835884,4.8900158 0 0 0 3.873698,-1.465542 c 1.026541,-0.949152 1.601957,-2.236988 1.597353,-3.581272 a 5.5769282,5.0656296 0 0 0 -3.36503,-4.689314 5.3997005,4.9046503 0 0 0 -5.970513,1.087135 5.6505815,5.1325305 0 0 0 -1.194563,5.519299 z"
                     fill="${this._featureStyle.fillColor}" p-id="4254" id="path11" style="stroke-width:${this._featureStyle.lineWidth};stroke:${this._featureStyle.lineColor};Opactiy:${this._featureStyle.lineOpacity};fill-opacity:${this._featureStyle.fillOpacity} " />
                  <path  d="m 5.8862341,40.447732 a 11.508313,2.0906439 0 1 0 23.0166249,0 11.508313,2.0906439 0 1 0 -23.0166249,0 z"
                     fill="#200e32"  opacity="0.4" p-id="4255"  id="path13" style="stroke-width:0.0514128" />
                       </svg>`,
          iconAnchor: [this._pinIconOptions.iconAnchorX, this._pinIconOptions.iconAnchorY]
        });
        l = leafletSrcExports.marker(r[0], { icon: h }), l._featureid = this._id;
        break;
      }
      case SymbolCellType.PlotPng: {
        let h = leafletSrcExports.icon({
          iconUrl: this._featureStyle.plotPntURL,
          iconSize: [this._plotPngOptions.width * this._symbol._scale, this._plotPngOptions.height * this._symbol._scale],
          iconAnchor: [this._plotPngOptions.iconAnchorX * this._symbol._scale, this._plotPngOptions.iconAnchorY * this._symbol._scale]
        });
        l = new leafletSrcExports.RotatableMarker(r[0], { icon: h }), l.rotate(this._featureRotate), l._featureid = this._id;
        break;
      }
      case SymbolCellType.image: {
        let h = leafletSrcExports.icon({
          iconUrl: o.style.image,
          iconSize: o.style.size,
          iconAnchor: [o.style.size[0] * 0.5, o.style.size[1] * 0.5]
        });
        l = new leafletSrcExports.RotatableMarker(r[0], { icon: h }), l.rotate(0), l._featureid = this._id;
        break;
      }
      case SymbolCellType.Text: {
        var u = {
          text: this._featureStyle.text,
          labelAlign: "cb",
          fontSize: 100,
          fontBackground: 1,
          labelRotation: 0,
          fontColor: "#FF0000",
          fontOpacity: 1,
          // fontFamily: "微软雅黑",
          fontWeight: "normal",
          fontStyle: "",
          fontSpace: 1,
          fontPercent: 100,
          fontStroke: 1,
          fontStrokeColor: "#ff0000",
          fontStrokeWidth: 20,
          fontBackgroundColor: "#ff0000",
          fontShadow: 1,
          fontShadowColor: "#ff0000",
          fontShadowOffsetX: 0,
          fontShadowOffsetY: 20,
          interactive: !0
        };
        if (o && o.style)
          u.fontColor = o.style.fontColor, u.fontSize = o.style.fontSize, u.labelAlign = o.style.labelAlign;
        else
          var u = Clone(this._featureStyle);
        l = new Text(r, u), l.affiliation = this, l._featureid = this._id;
        break;
      }
      case SymbolCellType.circleMark: {
        defined(o) && (this._featureStyle.lineColor = o.style.color, this._featureStyle.fillOpacity = o.style.fillOpacity, this._featureStyle.fillColor = o.style.fillColor), l = this._elementFactory.create(SymbolCellType.circleMark, r, o), l._featureid = this._id;
        break;
      }
    }
    if (defined(l)) {
      var u = {
        color: this._featureStyle.lineColor,
        opacity: this._featureStyle.lineOpacity,
        weight: this._featureStyle.lineWidth,
        fillColor: this._featureStyle.fillColor,
        fillOpacity: this._featureStyle.fillOpacity
      };
      leafletSrcExports.setOptions(l, u);
    }
    return l;
  }
  _addComponent(n) {
    n.addTo(this._featureComponents);
  }
  _contextmenuEvent(n) {
    if (this._layer && this._layer._layerType == LayerType.PLOT) {
      var r = this._layer;
      r._rightClickCallback && r._rightClickCallback(r, this);
    }
  }
  _featureClick(n) {
    if (n.originalEvent.altKey && this._addMark) {
      var r = this._symbol.controlPoints.length, o = 999999999, l = [];
      for (let m = 0; m < r - 1; m++) {
        var u = this._symbol.controlPoints[m], h = this._symbol.controlPoints[m + 1], c = point([n.latlng.lng, n.latlng.lat]), f = lineString([[u.getLon(), u.getLat()], [h.getLon(), h.getLat()]]), v = pointToLineDistance(c, f, { units: "miles" });
        o > pointToLineDistance(c, f, { units: "miles" }) && (o = v, l[0] = m, l[1] = m + 1);
      }
      this._symbol.controlPoints.splice(l[1], 0, new GeoPoint3D(n.latlng.lng, n.latlng.lat)), this.createControlPointsMarkers(), this.redraw();
    }
  }
  _featureMouseMove(n) {
    if (!n.originalEvent.altKey) {
      this._addMark && (this._map._map.removeLayer(this._addMark), this._addMark = null);
      return;
    }
    const r = this._map._map.mouseEventToLayerPoint(n.originalEvent), o = this._map._map.layerPointToLatLng({ x: r.x - 10, y: r.y - 10 });
    this._addMark == null ? this._addMark = new leafletSrcExports.Marker(o, {
      icon: this._addIcon,
      zIndexOffset: 2 * this._zIndexOffset,
      draggable: !0
    }).addTo(this._map._map) : this._addMark.setLatLng(o);
  }
  _featureMouseOut(n) {
    this._map._map.getContainer().style.cursor = "", this._addMark != null && (this._map._map.removeLayer(this._addMark), this._addMark = null);
  }
  _markerDragOn(n) {
    var r = [];
    this._controlsMarkers.forEach((o) => {
      r.push(new GeoPoint3D(o._latlng.lng, o._latlng.lat));
    }), this.setPoints(r);
  }
  _markerDragstart(n) {
    this._map._map.dragging.disable(), this.cleanBoarderAndRotateMaker();
  }
  _markerDragEnd(n) {
    let r = n.target, o = r.getLatLng();
    r.setLatLng(o), this.createControlPointsMarkers(), this._map._map.dragging.enable();
  }
  //旋转maker
  _markerRotateDragOn(n) {
    const r = this.getCenter(), o = this._map._map.latLngToLayerPoint(leafletSrcExports.latLng(r.getLat(), r.getLon())), l = this._map._map.latLngToLayerPoint(n.latlng), u = this._map._map.latLngToLayerPoint(n.oldLatLng), h = l.x - o.x - (u.x - o.x), c = l.y - o.y - (u.y - o.y);
    if (h !== 0 && c !== 0) {
      let v = 0;
      if (this._lastPixel !== void 0 ? v = 180 * (Math.atan2(this._lastPixel.y - o.y, this._lastPixel.x - o.x) - Math.atan2(l.y - o.y, l.x - o.x)) / Math.PI : v = 180 * (Math.atan2(u.y - o.y, u.x - o.x) - Math.atan2(l.y - o.y, l.x - o.x)) / Math.PI, this._featureRotate -= v, this._symbol._type == FeatureType.Rectangle || this._symbol._type == FeatureType.SVG)
        this.rotate(this._featureRotate);
      else if (this._symbol._type == FeatureType.PlotPng)
        this.rotate(this._featureRotate);
      else if (this._symbol._type == FeatureType.Ellipse) {
        this.rotate(this._featureRotate);
        var f = this.getPoints();
        this.setPoints(SymbolUtilsMethods.getInstance().rotateLatLngs(f, this.getCenter(), v));
      } else {
        var f = this.getPoints();
        this.setPoints(SymbolUtilsMethods.getInstance().rotateLatLngs(f, this.getCenter(), v));
      }
      this._layer.getLayerType() == LayerType.PLOT && this._layer._callback(this);
    }
    if (this._lastPixel = l, this._layer && this._layer.getLayerType() == LayerType.PLOT) {
      let v = this._layer;
      v._callback && v._callback(this);
    }
  }
  _markerRotateDragstart(n) {
    this._map._map.dragging.disable(), this._lastPixel = this._map._map.latLngToLayerPoint(n.target._latlng), this.cleanControlMarkersAndBoarder(), this._deleteScaleMarker();
  }
  _markerRotateDragEnd(n) {
    this.createControlPointsMarkers(), this._map._map.dragging.enable();
  }
  _markerRotateMove(n) {
    console.log("_markerRotateMove");
  }
  _markerRotateOut(n) {
    this._map._map.getContainer().style.cursor = "";
  }
  //缩放marker
  _markerScaleDragOn(n) {
    if (this._symbol._type == FeatureType.SVG || this._symbol._type == FeatureType.PlotPng) {
      const h = this.getCenter(), c = this.getBounds(), f = n.latlng;
      var r = h.getLon() - f.lng, o = h.getLat() - f.lat;
      if (r <= 0 || o <= 0)
        return;
      if (r >= o) {
        var l = c[1].getLon() - c[0].getLon();
        this._symbol._scale *= r / (l * 0.5);
      } else {
        var u = c[0].getLat() - c[1].getLat();
        this._symbol._scale *= o / (u * 0.5);
      }
      this.redraw();
    }
  }
  _markerScaleDragstart(n) {
    var r = this._map._map.latLngToLayerPoint(n.target._latlng);
    this._lastPixel = r, this._map._map.dragging.disable(), this.cleanControlMarkersAndBoarder(), this._cleanRotateMarker();
  }
  _markerScaleDragEnd(n) {
    this.createControlPointsMarkers(), this._map._map.dragging.enable(), this._lastPixel = null;
  }
  _markerScaleMove(n) {
    console.log("_markerRotateMove");
  }
  _markerScaleOut(n) {
    this._map._map.getContainer().style.cursor = "";
  }
  _markerMove(n) {
    if (defined(this._addMark) && (this._map._map.removeLayer(this._addMark), this._addMark = null), defined(this._deleteMark) && (this._map._map.removeLayer(this._deleteMark), this._deleteMark = null), n.originalEvent.altKey) {
      this._map._map.getContainer().style.cursor = "pointer";
      const r = this._map._map.mouseEventToLayerPoint(n.originalEvent), o = this._map._map.layerPointToLatLng({ x: r.x - 15, y: r.y - 15 });
      this._deleteMark == null ? this._deleteMark = new leafletSrcExports.Marker(o, {
        icon: this._deleteIcon,
        zIndexOffset: 2 * this._zIndexOffset,
        draggable: !0
      }).addTo(this._map._map) : this._deleteMark.setLatLng(o);
    }
  }
  _markerOut(n) {
    this._map._map.getContainer().style.cursor = "", this._deleteMark != null && (this._map._map.removeLayer(this._deleteMark), this._deleteMark = null);
  }
  _markerClick(n) {
    n.originalEvent.altKey && this._deleteMark && this._deleteControlPoint(n.target._leaflet_id);
  }
  _borderlineDrag(n) {
  }
  //删除控制点
  _deleteControlPoint(n) {
    if (!(this.getPoints().length <= this._symbol.minEditPts)) {
      var r = this._controlsMarkers.length;
      for (let o = 0; o < r; o++) {
        const l = this._controlsMarkers[o];
        if (n == l._leaflet_id)
          if (this._map._map.removeLayer(this._deleteMark), this._deleteMark = null, o == 0) {
            this._controlsMarkers.shift(), this._map._map.removeLayer(l);
            break;
          } else if (o == r - 1) {
            this._controlsMarkers.pop(), this._map._map.removeLayer(l);
            break;
          } else {
            this._controlsMarkers.splice(o, 1), this._map._map.removeLayer(l);
            break;
          }
      }
      this._symbol.controlPoints = [], this._controlsMarkers.forEach((o) => {
        this._symbol.controlPoints.push(new GeoPoint3D(o._latlng.lng, o._latlng.lat));
      }), this.redraw();
    }
  }
  _createScaleMarker() {
    this._deleteScaleMarker();
  }
  _deleteScaleMarker() {
    (this._symbol._type == FeatureType.SVG || this._symbol._type == FeatureType.PlotPng) && this._scaleMarker && this._scaleMarker && (this._scaleMarker.off("drag", this._markerScaleDragOn, this), this._scaleMarker.off("dragstart", this._markerScaleDragstart, this), this._scaleMarker.off("dragend", this._markerScaleDragEnd, this), this._scaleMarker.off("mousedown", this._markerScaleMove, this), this._scaleMarker.off("mouseout", this._markerScaleOut, this), this._map._map.removeLayer(this._scaleMarker), this._scaleMarker.remove(), this._scaleMarker = null);
  }
}
class LonLatGridLayer extends FeatureLayer {
  constructor(n, r = null) {
    super(n, new FeatureLayerOptions()), this._lnglinesFeature = null, this._lngtexts = null, this._latlinesFeature = null, this._lattexts = null, this._zoom = this._map._map.getZoom(), this._initialize();
  }
  static getInstance(n) {
    if (!LonLatGridLayer._instance) {
      let r = new FeatureLayerOptions("经纬网格");
      LonLatGridLayer._instance = new LonLatGridLayer(n, r);
    }
    return LonLatGridLayer._instance;
  }
  _initialize() {
    super._initialize(), this._lons = [], this._lats = [], this._points = [], this._texts = [], this._textPoints = [], this._lnglatIntervals = [60, 50, 40, 30, 20, 10, 5, 2.5, 1.25, 0.625, 0.3125, 0.15625, 0.078125, 0.039, 0.0195, 975e-5, 4875e-6, 24375e-7, 121875e-8, 609375e-9, 3086875e-10, 5e-5, 3e-5, 1e-5], this._getlons(), this._getLats(), this._getLines(), this._getTextPoints(), this._latlinesFeature = new Feature(FeatureType.MultiLines);
    var n = new FeatureStyle({ lineColor: "#555555", lineWidth: 1 });
    this._latlinesFeature.setStyle(n), this._latlinesFeature.setPoints(this._points), this.addFeature(this._latlinesFeature), this._multiTextFeature = new Feature(FeatureType.MultiText), this._multiTextFeature.setTexts(this._texts), this._multiTextFeature.setPoints(this._textPoints), this.addFeature(this._multiTextFeature), this.hide();
  }
  redraw() {
    super.redraw(), this._getlons(), this._getLats(), this._getLines(), this._getTextPoints(), this._latlinesFeature && this._latlinesFeature.setPoints(this._points), this._multiTextFeature && (this._multiTextFeature.setTexts(this._texts), this._multiTextFeature.setPoints(this._textPoints));
  }
  _getlons() {
    var n = this._map._map.getBounds();
    if (this._lons = [], defined(n)) {
      var r = n.getEast() - n.getWest(), o = n.getWest() - r * 0.5, l = n.getEast() + r * 0.5;
      l = l > 180 ? 180 : l;
      var u = this._lnglatIntervals[Number(this._map._map.getZoom())], h = Math.round(o / u) * u;
      h = h < -180 ? -180 : h;
      for (var c = h; c < l; )
        this._lons.push(c), c += u;
    }
  }
  _getLats() {
    var n = this._map._map.getBounds();
    if (this._lats = [], defined(n)) {
      var r = n.getNorth() - n.getSouth(), o = n.getSouth() - r * 0.5;
      o = o < -85.05 ? -85.05 : o;
      var l = n.getNorth() + r * 0.5;
      l = l > 85.05 ? 85.05 : l;
      for (var u = this._lnglatIntervals[Number(this._map._map.getZoom())], h = Math.round(o / u) * u, c = h; c < l; )
        this._lats.push(c), c += u;
    }
  }
  _getLines() {
    this._points = [];
    for (let n = 0; n < this._lons.length; n++)
      this._points.push(new GeoPoint3D(this._lons[n], this._lats[0])), this._points.push(new GeoPoint3D(this._lons[n], this._lats[this._lats.length - 1]));
    for (let n = 0; n < this._lats.length; n++)
      this._points.push(new GeoPoint3D(this._lons[0], this._lats[n])), this._points.push(new GeoPoint3D(this._lons[this._lons.length - 1], this._lats[n]));
  }
  _getTextPoints() {
    var n = this._map._map.getBounds();
    this._texts = [], this._textPoints = [];
    for (let r = 0; r < this._lons.length; r++)
      this._lons[r] > n.getWest() && this._lons[r] < n.getEast() && (this._texts.push(`${this._lons[r]}`), this._textPoints.push(new GeoPoint3D(this._lons[r], n.getNorth())));
    for (let r = 0; r < this._lats.length; r++)
      this._lats[r] > n.getSouth() && this._lats[r] < n.getNorth() && (this._texts.push(`${this._lats[r]}`), this._textPoints.push(new GeoPoint3D(n.getWest(), this._lats[r])));
  }
}
function globals(e) {
  e("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), e("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), e("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), e.WGS84 = e["EPSG:4326"], e["EPSG:3785"] = e["EPSG:3857"], e.GOOGLE = e["EPSG:3857"], e["EPSG:900913"] = e["EPSG:3857"], e["EPSG:102113"] = e["EPSG:3857"];
}
var PJD_3PARAM = 1, PJD_7PARAM = 2, PJD_GRIDSHIFT = 3, PJD_WGS84 = 4, PJD_NODATUM = 5, SRS_WGS84_SEMIMAJOR = 6378137, SRS_WGS84_SEMIMINOR = 6356752314e-3, SRS_WGS84_ESQUARED = 0.0066943799901413165, SEC_TO_RAD = 484813681109536e-20, HALF_PI = Math.PI / 2, SIXTH = 0.16666666666666666, RA4 = 0.04722222222222222, RA6 = 0.022156084656084655, EPSLN = 1e-10, D2R$1 = 0.017453292519943295, R2D = 57.29577951308232, FORTPI = Math.PI / 4, TWO_PI = Math.PI * 2, SPI = 3.14159265359, exports$2 = {};
exports$2.greenwich = 0;
exports$2.lisbon = -9.131906111111;
exports$2.paris = 2.337229166667;
exports$2.bogota = -74.080916666667;
exports$2.madrid = -3.687938888889;
exports$2.rome = 12.452333333333;
exports$2.bern = 7.439583333333;
exports$2.jakarta = 106.807719444444;
exports$2.ferro = -17.666666666667;
exports$2.brussels = 4.367975;
exports$2.stockholm = 18.058277777778;
exports$2.athens = 23.7163375;
exports$2.oslo = 10.722916666667;
const units = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(e, n) {
  if (e[n])
    return e[n];
  for (var r = Object.keys(e), o = n.toLowerCase().replace(ignoredChar, ""), l = -1, u, h; ++l < r.length; )
    if (u = r[l], h = u.toLowerCase().replace(ignoredChar, ""), h === o)
      return e[u];
}
function projStr(e) {
  var n = {}, r = e.split("+").map(function(c) {
    return c.trim();
  }).filter(function(c) {
    return c;
  }).reduce(function(c, f) {
    var v = f.split("=");
    return v.push(!0), c[v[0].toLowerCase()] = v[1], c;
  }, {}), o, l, u, h = {
    proj: "projName",
    datum: "datumCode",
    rf: function(c) {
      n.rf = parseFloat(c);
    },
    lat_0: function(c) {
      n.lat0 = c * D2R$1;
    },
    lat_1: function(c) {
      n.lat1 = c * D2R$1;
    },
    lat_2: function(c) {
      n.lat2 = c * D2R$1;
    },
    lat_ts: function(c) {
      n.lat_ts = c * D2R$1;
    },
    lon_0: function(c) {
      n.long0 = c * D2R$1;
    },
    lon_1: function(c) {
      n.long1 = c * D2R$1;
    },
    lon_2: function(c) {
      n.long2 = c * D2R$1;
    },
    alpha: function(c) {
      n.alpha = parseFloat(c) * D2R$1;
    },
    gamma: function(c) {
      n.rectified_grid_angle = parseFloat(c);
    },
    lonc: function(c) {
      n.longc = c * D2R$1;
    },
    x_0: function(c) {
      n.x0 = parseFloat(c);
    },
    y_0: function(c) {
      n.y0 = parseFloat(c);
    },
    k_0: function(c) {
      n.k0 = parseFloat(c);
    },
    k: function(c) {
      n.k0 = parseFloat(c);
    },
    a: function(c) {
      n.a = parseFloat(c);
    },
    b: function(c) {
      n.b = parseFloat(c);
    },
    r: function(c) {
      n.a = n.b = parseFloat(c);
    },
    r_a: function() {
      n.R_A = !0;
    },
    zone: function(c) {
      n.zone = parseInt(c, 10);
    },
    south: function() {
      n.utmSouth = !0;
    },
    towgs84: function(c) {
      n.datum_params = c.split(",").map(function(f) {
        return parseFloat(f);
      });
    },
    to_meter: function(c) {
      n.to_meter = parseFloat(c);
    },
    units: function(c) {
      n.units = c;
      var f = match(units, c);
      f && (n.to_meter = f.to_meter);
    },
    from_greenwich: function(c) {
      n.from_greenwich = c * D2R$1;
    },
    pm: function(c) {
      var f = match(exports$2, c);
      n.from_greenwich = (f || parseFloat(c)) * D2R$1;
    },
    nadgrids: function(c) {
      c === "@null" ? n.datumCode = "none" : n.nadgrids = c;
    },
    axis: function(c) {
      var f = "ewnsud";
      c.length === 3 && f.indexOf(c.substr(0, 1)) !== -1 && f.indexOf(c.substr(1, 1)) !== -1 && f.indexOf(c.substr(2, 1)) !== -1 && (n.axis = c);
    },
    approx: function() {
      n.approx = !0;
    }
  };
  for (o in r)
    l = r[o], o in h ? (u = h[o], typeof u == "function" ? u(l) : n[u] = l) : n[o] = l;
  return typeof n.datumCode == "string" && n.datumCode !== "WGS84" && (n.datumCode = n.datumCode.toLowerCase()), n;
}
var NEUTRAL = 1, KEYWORD = 2, NUMBER = 3, QUOTED = 4, AFTERQUOTE = 5, ENDED = -1, whitespace = /\s/, latin = /[A-Za-z]/, keyword = /[A-Za-z84_]/, endThings = /[,\]]/, digets = /[\d\.E\-\+]/;
function Parser(e) {
  if (typeof e != "string")
    throw new Error("not a string");
  this.text = e.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
  var e = this.text[this.place++];
  if (this.state !== QUOTED)
    for (; whitespace.test(e); ) {
      if (this.place >= this.text.length)
        return;
      e = this.text[this.place++];
    }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(e);
    case KEYWORD:
      return this.keyword(e);
    case QUOTED:
      return this.quoted(e);
    case AFTERQUOTE:
      return this.afterquote(e);
    case NUMBER:
      return this.number(e);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function(e) {
  if (e === '"') {
    this.word += '"', this.state = QUOTED;
    return;
  }
  if (endThings.test(e)) {
    this.word = this.word.trim(), this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(e) {
  if (e === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = NEUTRAL;
    return;
  }
  if (e === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = NEUTRAL, this.currentObject = this.stack.pop(), this.currentObject || (this.state = ENDED);
    return;
  }
};
Parser.prototype.number = function(e) {
  if (digets.test(e)) {
    this.word += e;
    return;
  }
  if (endThings.test(e)) {
    this.word = parseFloat(this.word), this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(e) {
  if (e === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += e;
};
Parser.prototype.keyword = function(e) {
  if (keyword.test(e)) {
    this.word += e;
    return;
  }
  if (e === "[") {
    var n = [];
    n.push(this.word), this.level++, this.root === null ? this.root = n : this.currentObject.push(n), this.stack.push(this.currentObject), this.currentObject = n, this.state = NEUTRAL;
    return;
  }
  if (endThings.test(e)) {
    this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(e) {
  if (latin.test(e)) {
    this.word = e, this.state = KEYWORD;
    return;
  }
  if (e === '"') {
    this.word = "", this.state = QUOTED;
    return;
  }
  if (digets.test(e)) {
    this.word = e, this.state = NUMBER;
    return;
  }
  if (endThings.test(e)) {
    this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === ENDED)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(e) {
  var n = new Parser(e);
  return n.output();
}
function mapit(e, n, r) {
  Array.isArray(n) && (r.unshift(n), n = null);
  var o = n ? {} : e, l = r.reduce(function(u, h) {
    return sExpr(h, u), u;
  }, o);
  n && (e[n] = l);
}
function sExpr(e, n) {
  if (!Array.isArray(e)) {
    n[e] = !0;
    return;
  }
  var r = e.shift();
  if (r === "PARAMETER" && (r = e.shift()), e.length === 1) {
    if (Array.isArray(e[0])) {
      n[r] = {}, sExpr(e[0], n[r]);
      return;
    }
    n[r] = e[0];
    return;
  }
  if (!e.length) {
    n[r] = !0;
    return;
  }
  if (r === "TOWGS84") {
    n[r] = e;
    return;
  }
  if (r === "AXIS") {
    r in n || (n[r] = []), n[r].push(e);
    return;
  }
  Array.isArray(r) || (n[r] = {});
  var o;
  switch (r) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      n[r] = {
        name: e[0].toLowerCase(),
        convert: e[1]
      }, e.length === 3 && sExpr(e[2], n[r]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      n[r] = {
        name: e[0],
        a: e[1],
        rf: e[2]
      }, e.length === 4 && sExpr(e[3], n[r]);
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      e[0] = ["name", e[0]], mapit(n, r, e);
      return;
    default:
      for (o = -1; ++o < e.length; )
        if (!Array.isArray(e[o]))
          return sExpr(e, n[r]);
      return mapit(n, r, e);
  }
}
var D2R = 0.017453292519943295;
function rename(e, n) {
  var r = n[0], o = n[1];
  !(r in e) && o in e && (e[r] = e[o], n.length === 3 && (e[r] = n[2](e[r])));
}
function d2r(e) {
  return e * D2R;
}
function cleanWKT(e) {
  if (e.type === "GEOGCS" ? e.projName = "longlat" : e.type === "LOCAL_CS" ? (e.projName = "identity", e.local = !0) : typeof e.PROJECTION == "object" ? e.projName = Object.keys(e.PROJECTION)[0] : e.projName = e.PROJECTION, e.AXIS) {
    for (var n = "", r = 0, o = e.AXIS.length; r < o; ++r) {
      var l = [e.AXIS[r][0].toLowerCase(), e.AXIS[r][1].toLowerCase()];
      l[0].indexOf("north") !== -1 || (l[0] === "y" || l[0] === "lat") && l[1] === "north" ? n += "n" : l[0].indexOf("south") !== -1 || (l[0] === "y" || l[0] === "lat") && l[1] === "south" ? n += "s" : l[0].indexOf("east") !== -1 || (l[0] === "x" || l[0] === "lon") && l[1] === "east" ? n += "e" : (l[0].indexOf("west") !== -1 || (l[0] === "x" || l[0] === "lon") && l[1] === "west") && (n += "w");
    }
    n.length === 2 && (n += "u"), n.length === 3 && (e.axis = n);
  }
  e.UNIT && (e.units = e.UNIT.name.toLowerCase(), e.units === "metre" && (e.units = "meter"), e.UNIT.convert && (e.type === "GEOGCS" ? e.DATUM && e.DATUM.SPHEROID && (e.to_meter = e.UNIT.convert * e.DATUM.SPHEROID.a) : e.to_meter = e.UNIT.convert));
  var u = e.GEOGCS;
  e.type === "GEOGCS" && (u = e), u && (u.DATUM ? e.datumCode = u.DATUM.name.toLowerCase() : e.datumCode = u.name.toLowerCase(), e.datumCode.slice(0, 2) === "d_" && (e.datumCode = e.datumCode.slice(2)), (e.datumCode === "new_zealand_geodetic_datum_1949" || e.datumCode === "new_zealand_1949") && (e.datumCode = "nzgd49"), (e.datumCode === "wgs_1984" || e.datumCode === "world_geodetic_system_1984") && (e.PROJECTION === "Mercator_Auxiliary_Sphere" && (e.sphere = !0), e.datumCode = "wgs84"), e.datumCode.slice(-6) === "_ferro" && (e.datumCode = e.datumCode.slice(0, -6)), e.datumCode.slice(-8) === "_jakarta" && (e.datumCode = e.datumCode.slice(0, -8)), ~e.datumCode.indexOf("belge") && (e.datumCode = "rnb72"), u.DATUM && u.DATUM.SPHEROID && (e.ellps = u.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), e.ellps.toLowerCase().slice(0, 13) === "international" && (e.ellps = "intl"), e.a = u.DATUM.SPHEROID.a, e.rf = parseFloat(u.DATUM.SPHEROID.rf, 10)), u.DATUM && u.DATUM.TOWGS84 && (e.datum_params = u.DATUM.TOWGS84), ~e.datumCode.indexOf("osgb_1936") && (e.datumCode = "osgb36"), ~e.datumCode.indexOf("osni_1952") && (e.datumCode = "osni52"), (~e.datumCode.indexOf("tm65") || ~e.datumCode.indexOf("geodetic_datum_of_1965")) && (e.datumCode = "ire65"), e.datumCode === "ch1903+" && (e.datumCode = "ch1903"), ~e.datumCode.indexOf("israel") && (e.datumCode = "isr93")), e.b && !isFinite(e.b) && (e.b = e.a);
  function h(v) {
    var m = e.to_meter || 1;
    return v * m;
  }
  var c = function(v) {
    return rename(e, v);
  }, f = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", h],
    ["y0", "false_northing", h],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  f.forEach(c), !e.long0 && e.longc && (e.projName === "Albers_Conic_Equal_Area" || e.projName === "Lambert_Azimuthal_Equal_Area") && (e.long0 = e.longc), !e.lat_ts && e.lat1 && (e.projName === "Stereographic_South_Pole" || e.projName === "Polar Stereographic (variant B)") ? (e.lat0 = d2r(e.lat1 > 0 ? 90 : -90), e.lat_ts = e.lat1) : !e.lat_ts && e.lat0 && e.projName === "Polar_Stereographic" && (e.lat_ts = e.lat0, e.lat0 = d2r(e.lat0 > 0 ? 90 : -90));
}
function wkt(e) {
  var n = parseString(e), r = n.shift(), o = n.shift();
  n.unshift(["name", o]), n.unshift(["type", r]);
  var l = {};
  return sExpr(n, l), cleanWKT(l), l;
}
function defs(e) {
  var n = this;
  if (arguments.length === 2) {
    var r = arguments[1];
    typeof r == "string" ? r.charAt(0) === "+" ? defs[e] = projStr(arguments[1]) : defs[e] = wkt(arguments[1]) : defs[e] = r;
  } else if (arguments.length === 1) {
    if (Array.isArray(e))
      return e.map(function(o) {
        Array.isArray(o) ? defs.apply(n, o) : defs(o);
      });
    if (typeof e == "string") {
      if (e in defs)
        return defs[e];
    } else
      "EPSG" in e ? defs["EPSG:" + e.EPSG] = e : "ESRI" in e ? defs["ESRI:" + e.ESRI] = e : "IAU2000" in e ? defs["IAU2000:" + e.IAU2000] = e : console.log(e);
    return;
  }
}
globals(defs);
function testObj(e) {
  return typeof e == "string";
}
function testDef(e) {
  return e in defs;
}
var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function testWKT(e) {
  return codeWords.some(function(n) {
    return e.indexOf(n) > -1;
  });
}
var codes = ["3857", "900913", "3785", "102113"];
function checkMercator(e) {
  var n = match(e, "authority");
  if (n) {
    var r = match(n, "epsg");
    return r && codes.indexOf(r) > -1;
  }
}
function checkProjStr(e) {
  var n = match(e, "extension");
  if (n)
    return match(n, "proj4");
}
function testProj(e) {
  return e[0] === "+";
}
function parse(e) {
  if (testObj(e)) {
    if (testDef(e))
      return defs[e];
    if (testWKT(e)) {
      var n = wkt(e);
      if (checkMercator(n))
        return defs["EPSG:3857"];
      var r = checkProjStr(n);
      return r ? projStr(r) : n;
    }
    if (testProj(e))
      return projStr(e);
  } else
    return e;
}
function extend$1(e, n) {
  e = e || {};
  var r, o;
  if (!n)
    return e;
  for (o in n)
    r = n[o], r !== void 0 && (e[o] = r);
  return e;
}
function msfnz(e, n, r) {
  var o = e * n;
  return r / Math.sqrt(1 - o * o);
}
function sign(e) {
  return e < 0 ? -1 : 1;
}
function adjust_lon(e) {
  return Math.abs(e) <= SPI ? e : e - sign(e) * TWO_PI;
}
function tsfnz(e, n, r) {
  var o = e * r, l = 0.5 * e;
  return o = Math.pow((1 - o) / (1 + o), l), Math.tan(0.5 * (HALF_PI - n)) / o;
}
function phi2z(e, n) {
  for (var r = 0.5 * e, o, l, u = HALF_PI - 2 * Math.atan(n), h = 0; h <= 15; h++)
    if (o = e * Math.sin(u), l = HALF_PI - 2 * Math.atan(n * Math.pow((1 - o) / (1 + o), r)) - u, u += l, Math.abs(l) <= 1e-10)
      return u;
  return -9999;
}
function init$w() {
  var e = this.b / this.a;
  this.es = 1 - e * e, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function forward$v(e) {
  var n = e.x, r = e.y;
  if (r * R2D > 90 && r * R2D < -90 && n * R2D > 180 && n * R2D < -180)
    return null;
  var o, l;
  if (Math.abs(Math.abs(r) - HALF_PI) <= EPSLN)
    return null;
  if (this.sphere)
    o = this.x0 + this.a * this.k0 * adjust_lon(n - this.long0), l = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * r));
  else {
    var u = Math.sin(r), h = tsfnz(this.e, r, u);
    o = this.x0 + this.a * this.k0 * adjust_lon(n - this.long0), l = this.y0 - this.a * this.k0 * Math.log(h);
  }
  return e.x = o, e.y = l, e;
}
function inverse$v(e) {
  var n = e.x - this.x0, r = e.y - this.y0, o, l;
  if (this.sphere)
    l = HALF_PI - 2 * Math.atan(Math.exp(-r / (this.a * this.k0)));
  else {
    var u = Math.exp(-r / (this.a * this.k0));
    if (l = phi2z(this.e, u), l === -9999)
      return null;
  }
  return o = adjust_lon(this.long0 + n / (this.a * this.k0)), e.x = o, e.y = l, e;
}
var names$x = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const merc = {
  init: init$w,
  forward: forward$v,
  inverse: inverse$v,
  names: names$x
};
function init$v() {
}
function identity(e) {
  return e;
}
var names$w = ["longlat", "identity"];
const longlat = {
  init: init$v,
  forward: identity,
  inverse: identity,
  names: names$w
};
var projs = [merc, longlat], names$v = {}, projStore = [];
function add(e, n) {
  var r = projStore.length;
  return e.names ? (projStore[r] = e, e.names.forEach(function(o) {
    names$v[o.toLowerCase()] = r;
  }), this) : (console.log(n), !0);
}
function get(e) {
  if (!e)
    return !1;
  var n = e.toLowerCase();
  if (typeof names$v[n] < "u" && projStore[names$v[n]])
    return projStore[names$v[n]];
}
function start() {
  projs.forEach(add);
}
const projections = {
  start,
  add,
  get
};
var exports$1 = {};
exports$1.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports$1.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports$1.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports$1.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports$1.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
exports$1.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports$1.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports$1.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
exports$1.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports$1.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports$1.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports$1.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports$1.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports$1.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
exports$1.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports$1.clrk80ign = {
  a: 63782492e-1,
  b: 6356515,
  rf: 293.4660213,
  ellipseName: "Clarke 1880 (IGN)"
};
exports$1.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports$1.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports$1.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports$1.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports$1.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports$1.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports$1.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports$1.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports$1.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports$1.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports$1.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports$1.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports$1.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports$1.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
exports$1.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
exports$1.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports$1.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports$1.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
exports$1.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
exports$1.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
exports$1.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports$1.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
exports$1.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
exports$1.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports$1.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports$1.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var WGS84 = exports$1.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports$1.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function eccentricity(e, n, r, o) {
  var l = e * e, u = n * n, h = (l - u) / l, c = 0;
  o ? (e *= 1 - h * (SIXTH + h * (RA4 + h * RA6)), l = e * e, h = 0) : c = Math.sqrt(h);
  var f = (l - u) / u;
  return {
    es: h,
    e: c,
    ep2: f
  };
}
function sphere(e, n, r, o, l) {
  if (!e) {
    var u = match(exports$1, o);
    u || (u = WGS84), e = u.a, n = u.b, r = u.rf;
  }
  return r && !n && (n = (1 - 1 / r) * e), (r === 0 || Math.abs(e - n) < EPSLN) && (l = !0, n = e), {
    a: e,
    b: n,
    rf: r,
    sphere: l
  };
}
var exports = {};
exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
exports.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
exports.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
exports.militargeographische_institut = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Militar-Geographische Institut"
};
exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
exports.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
exports.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function datum(e, n, r, o, l, u, h) {
  var c = {};
  return e === void 0 || e === "none" ? c.datum_type = PJD_NODATUM : c.datum_type = PJD_WGS84, n && (c.datum_params = n.map(parseFloat), (c.datum_params[0] !== 0 || c.datum_params[1] !== 0 || c.datum_params[2] !== 0) && (c.datum_type = PJD_3PARAM), c.datum_params.length > 3 && (c.datum_params[3] !== 0 || c.datum_params[4] !== 0 || c.datum_params[5] !== 0 || c.datum_params[6] !== 0) && (c.datum_type = PJD_7PARAM, c.datum_params[3] *= SEC_TO_RAD, c.datum_params[4] *= SEC_TO_RAD, c.datum_params[5] *= SEC_TO_RAD, c.datum_params[6] = c.datum_params[6] / 1e6 + 1)), h && (c.datum_type = PJD_GRIDSHIFT, c.grids = h), c.a = r, c.b = o, c.es = l, c.ep2 = u, c;
}
var loadedNadgrids = {};
function nadgrid(e, n) {
  var r = new DataView(n), o = detectLittleEndian(r), l = readHeader(r, o), u = readSubgrids(r, l, o), h = { header: l, subgrids: u };
  return loadedNadgrids[e] = h, h;
}
function getNadgrids(e) {
  if (e === void 0)
    return null;
  var n = e.split(",");
  return n.map(parseNadgridString);
}
function parseNadgridString(e) {
  if (e.length === 0)
    return null;
  var n = e[0] === "@";
  return n && (e = e.slice(1)), e === "null" ? { name: "null", mandatory: !n, grid: null, isNull: !0 } : {
    name: e,
    mandatory: !n,
    grid: loadedNadgrids[e] || null,
    isNull: !1
  };
}
function secondsToRadians(e) {
  return e / 3600 * Math.PI / 180;
}
function detectLittleEndian(e) {
  var n = e.getInt32(8, !1);
  return n === 11 ? !1 : (n = e.getInt32(8, !0), n !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function readHeader(e, n) {
  return {
    nFields: e.getInt32(8, n),
    nSubgridFields: e.getInt32(24, n),
    nSubgrids: e.getInt32(40, n),
    shiftType: decodeString(e, 56, 64).trim(),
    fromSemiMajorAxis: e.getFloat64(120, n),
    fromSemiMinorAxis: e.getFloat64(136, n),
    toSemiMajorAxis: e.getFloat64(152, n),
    toSemiMinorAxis: e.getFloat64(168, n)
  };
}
function decodeString(e, n, r) {
  return String.fromCharCode.apply(null, new Uint8Array(e.buffer.slice(n, r)));
}
function readSubgrids(e, n, r) {
  for (var o = 176, l = [], u = 0; u < n.nSubgrids; u++) {
    var h = readGridHeader(e, o, r), c = readGridNodes(e, o, h, r), f = Math.round(
      1 + (h.upperLongitude - h.lowerLongitude) / h.longitudeInterval
    ), v = Math.round(
      1 + (h.upperLatitude - h.lowerLatitude) / h.latitudeInterval
    );
    l.push({
      ll: [secondsToRadians(h.lowerLongitude), secondsToRadians(h.lowerLatitude)],
      del: [secondsToRadians(h.longitudeInterval), secondsToRadians(h.latitudeInterval)],
      lim: [f, v],
      count: h.gridNodeCount,
      cvs: mapNodes(c)
    }), o += 176 + h.gridNodeCount * 16;
  }
  return l;
}
function mapNodes(e) {
  return e.map(function(n) {
    return [secondsToRadians(n.longitudeShift), secondsToRadians(n.latitudeShift)];
  });
}
function readGridHeader(e, n, r) {
  return {
    name: decodeString(e, n + 8, n + 16).trim(),
    parent: decodeString(e, n + 24, n + 24 + 8).trim(),
    lowerLatitude: e.getFloat64(n + 72, r),
    upperLatitude: e.getFloat64(n + 88, r),
    lowerLongitude: e.getFloat64(n + 104, r),
    upperLongitude: e.getFloat64(n + 120, r),
    latitudeInterval: e.getFloat64(n + 136, r),
    longitudeInterval: e.getFloat64(n + 152, r),
    gridNodeCount: e.getInt32(n + 168, r)
  };
}
function readGridNodes(e, n, r, o) {
  for (var l = n + 176, u = 16, h = [], c = 0; c < r.gridNodeCount; c++) {
    var f = {
      latitudeShift: e.getFloat32(l + c * u, o),
      longitudeShift: e.getFloat32(l + c * u + 4, o),
      latitudeAccuracy: e.getFloat32(l + c * u + 8, o),
      longitudeAccuracy: e.getFloat32(l + c * u + 12, o)
    };
    h.push(f);
  }
  return h;
}
function Projection(e, n) {
  if (!(this instanceof Projection))
    return new Projection(e);
  n = n || function(v) {
    if (v)
      throw v;
  };
  var r = parse(e);
  if (typeof r != "object") {
    n(e);
    return;
  }
  var o = Projection.projections.get(r.projName);
  if (!o) {
    n(e);
    return;
  }
  if (r.datumCode && r.datumCode !== "none") {
    var l = match(exports, r.datumCode);
    l && (r.datum_params = r.datum_params || (l.towgs84 ? l.towgs84.split(",") : null), r.ellps = l.ellipse, r.datumName = l.datumName ? l.datumName : r.datumCode);
  }
  r.k0 = r.k0 || 1, r.axis = r.axis || "enu", r.ellps = r.ellps || "wgs84", r.lat1 = r.lat1 || r.lat0;
  var u = sphere(r.a, r.b, r.rf, r.ellps, r.sphere), h = eccentricity(u.a, u.b, u.rf, r.R_A), c = getNadgrids(r.nadgrids), f = r.datum || datum(
    r.datumCode,
    r.datum_params,
    u.a,
    u.b,
    h.es,
    h.ep2,
    c
  );
  extend$1(this, r), extend$1(this, o), this.a = u.a, this.b = u.b, this.rf = u.rf, this.sphere = u.sphere, this.es = h.es, this.e = h.e, this.ep2 = h.ep2, this.datum = f, this.init(), n(null, this);
}
Projection.projections = projections;
Projection.projections.start();
function compareDatums(e, n) {
  return e.datum_type !== n.datum_type || e.a !== n.a || Math.abs(e.es - n.es) > 5e-11 ? !1 : e.datum_type === PJD_3PARAM ? e.datum_params[0] === n.datum_params[0] && e.datum_params[1] === n.datum_params[1] && e.datum_params[2] === n.datum_params[2] : e.datum_type === PJD_7PARAM ? e.datum_params[0] === n.datum_params[0] && e.datum_params[1] === n.datum_params[1] && e.datum_params[2] === n.datum_params[2] && e.datum_params[3] === n.datum_params[3] && e.datum_params[4] === n.datum_params[4] && e.datum_params[5] === n.datum_params[5] && e.datum_params[6] === n.datum_params[6] : !0;
}
function geodeticToGeocentric(e, n, r) {
  var o = e.x, l = e.y, u = e.z ? e.z : 0, h, c, f, v;
  if (l < -HALF_PI && l > -1.001 * HALF_PI)
    l = -HALF_PI;
  else if (l > HALF_PI && l < 1.001 * HALF_PI)
    l = HALF_PI;
  else {
    if (l < -HALF_PI)
      return { x: -1 / 0, y: -1 / 0, z: e.z };
    if (l > HALF_PI)
      return { x: 1 / 0, y: 1 / 0, z: e.z };
  }
  return o > Math.PI && (o -= 2 * Math.PI), c = Math.sin(l), v = Math.cos(l), f = c * c, h = r / Math.sqrt(1 - n * f), {
    x: (h + u) * v * Math.cos(o),
    y: (h + u) * v * Math.sin(o),
    z: (h * (1 - n) + u) * c
  };
}
function geocentricToGeodetic(e, n, r, o) {
  var l = 1e-12, u = l * l, h = 30, c, f, v, m, g, y, w, E, x, D, F, k, N, H = e.x, R = e.y, j = e.z ? e.z : 0, S, tt, nt;
  if (c = Math.sqrt(H * H + R * R), f = Math.sqrt(H * H + R * R + j * j), c / r < l) {
    if (S = 0, f / r < l)
      return tt = HALF_PI, nt = -o, {
        x: e.x,
        y: e.y,
        z: e.z
      };
  } else
    S = Math.atan2(R, H);
  v = j / f, m = c / f, g = 1 / Math.sqrt(1 - n * (2 - n) * m * m), E = m * (1 - n) * g, x = v * g, N = 0;
  do
    N++, w = r / Math.sqrt(1 - n * x * x), nt = c * E + j * x - w * (1 - n * x * x), y = n * w / (w + nt), g = 1 / Math.sqrt(1 - y * (2 - y) * m * m), D = m * (1 - y) * g, F = v * g, k = F * E - D * x, E = D, x = F;
  while (k * k > u && N < h);
  return tt = Math.atan(F / Math.abs(D)), {
    x: S,
    y: tt,
    z: nt
  };
}
function geocentricToWgs84(e, n, r) {
  if (n === PJD_3PARAM)
    return {
      x: e.x + r[0],
      y: e.y + r[1],
      z: e.z + r[2]
    };
  if (n === PJD_7PARAM) {
    var o = r[0], l = r[1], u = r[2], h = r[3], c = r[4], f = r[5], v = r[6];
    return {
      x: v * (e.x - f * e.y + c * e.z) + o,
      y: v * (f * e.x + e.y - h * e.z) + l,
      z: v * (-c * e.x + h * e.y + e.z) + u
    };
  }
}
function geocentricFromWgs84(e, n, r) {
  if (n === PJD_3PARAM)
    return {
      x: e.x - r[0],
      y: e.y - r[1],
      z: e.z - r[2]
    };
  if (n === PJD_7PARAM) {
    var o = r[0], l = r[1], u = r[2], h = r[3], c = r[4], f = r[5], v = r[6], m = (e.x - o) / v, g = (e.y - l) / v, y = (e.z - u) / v;
    return {
      x: m + f * g - c * y,
      y: -f * m + g + h * y,
      z: c * m - h * g + y
    };
  }
}
function checkParams(e) {
  return e === PJD_3PARAM || e === PJD_7PARAM;
}
function datum_transform(e, n, r) {
  if (compareDatums(e, n) || e.datum_type === PJD_NODATUM || n.datum_type === PJD_NODATUM)
    return r;
  var o = e.a, l = e.es;
  if (e.datum_type === PJD_GRIDSHIFT) {
    var u = applyGridShift(e, !1, r);
    if (u !== 0)
      return;
    o = SRS_WGS84_SEMIMAJOR, l = SRS_WGS84_ESQUARED;
  }
  var h = n.a, c = n.b, f = n.es;
  if (n.datum_type === PJD_GRIDSHIFT && (h = SRS_WGS84_SEMIMAJOR, c = SRS_WGS84_SEMIMINOR, f = SRS_WGS84_ESQUARED), l === f && o === h && !checkParams(e.datum_type) && !checkParams(n.datum_type))
    return r;
  if (r = geodeticToGeocentric(r, l, o), checkParams(e.datum_type) && (r = geocentricToWgs84(r, e.datum_type, e.datum_params)), checkParams(n.datum_type) && (r = geocentricFromWgs84(r, n.datum_type, n.datum_params)), r = geocentricToGeodetic(r, f, h, c), n.datum_type === PJD_GRIDSHIFT) {
    var v = applyGridShift(n, !0, r);
    if (v !== 0)
      return;
  }
  return r;
}
function applyGridShift(e, n, r) {
  if (e.grids === null || e.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  var o = { x: -r.x, y: r.y }, l = { x: Number.NaN, y: Number.NaN }, u = [];
  t:
    for (var h = 0; h < e.grids.length; h++) {
      var c = e.grids[h];
      if (u.push(c.name), c.isNull) {
        l = o;
        break;
      }
      if (c.mandatory, c.grid === null) {
        if (c.mandatory)
          return console.log("Unable to find mandatory grid '" + c.name + "'"), -1;
        continue;
      }
      for (var f = c.grid.subgrids, v = 0, m = f.length; v < m; v++) {
        var g = f[v], y = (Math.abs(g.del[1]) + Math.abs(g.del[0])) / 1e4, w = g.ll[0] - y, E = g.ll[1] - y, x = g.ll[0] + (g.lim[0] - 1) * g.del[0] + y, D = g.ll[1] + (g.lim[1] - 1) * g.del[1] + y;
        if (!(E > o.y || w > o.x || D < o.y || x < o.x) && (l = applySubgridShift(o, n, g), !isNaN(l.x)))
          break t;
      }
    }
  return isNaN(l.x) ? (console.log("Failed to find a grid shift table for location '" + -o.x * R2D + " " + o.y * R2D + " tried: '" + u + "'"), -1) : (r.x = -l.x, r.y = l.y, 0);
}
function applySubgridShift(e, n, r) {
  var o = { x: Number.NaN, y: Number.NaN };
  if (isNaN(e.x))
    return o;
  var l = { x: e.x, y: e.y };
  l.x -= r.ll[0], l.y -= r.ll[1], l.x = adjust_lon(l.x - Math.PI) + Math.PI;
  var u = nadInterpolate(l, r);
  if (n) {
    if (isNaN(u.x))
      return o;
    u.x = l.x - u.x, u.y = l.y - u.y;
    var h = 9, c = 1e-12, f, v;
    do {
      if (v = nadInterpolate(u, r), isNaN(v.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      f = { x: l.x - (v.x + u.x), y: l.y - (v.y + u.y) }, u.x += f.x, u.y += f.y;
    } while (h-- && Math.abs(f.x) > c && Math.abs(f.y) > c);
    if (h < 0)
      return console.log("Inverse grid shift iterator failed to converge."), o;
    o.x = adjust_lon(u.x + r.ll[0]), o.y = u.y + r.ll[1];
  } else
    isNaN(u.x) || (o.x = e.x + u.x, o.y = e.y + u.y);
  return o;
}
function nadInterpolate(e, n) {
  var r = { x: e.x / n.del[0], y: e.y / n.del[1] }, o = { x: Math.floor(r.x), y: Math.floor(r.y) }, l = { x: r.x - 1 * o.x, y: r.y - 1 * o.y }, u = { x: Number.NaN, y: Number.NaN }, h;
  if (o.x < 0 || o.x >= n.lim[0] || o.y < 0 || o.y >= n.lim[1])
    return u;
  h = o.y * n.lim[0] + o.x;
  var c = { x: n.cvs[h][0], y: n.cvs[h][1] };
  h++;
  var f = { x: n.cvs[h][0], y: n.cvs[h][1] };
  h += n.lim[0];
  var v = { x: n.cvs[h][0], y: n.cvs[h][1] };
  h--;
  var m = { x: n.cvs[h][0], y: n.cvs[h][1] }, g = l.x * l.y, y = l.x * (1 - l.y), w = (1 - l.x) * (1 - l.y), E = (1 - l.x) * l.y;
  return u.x = w * c.x + y * f.x + E * m.x + g * v.x, u.y = w * c.y + y * f.y + E * m.y + g * v.y, u;
}
function adjust_axis(e, n, r) {
  var o = r.x, l = r.y, u = r.z || 0, h, c, f, v = {};
  for (f = 0; f < 3; f++)
    if (!(n && f === 2 && r.z === void 0))
      switch (f === 0 ? (h = o, "ew".indexOf(e.axis[f]) !== -1 ? c = "x" : c = "y") : f === 1 ? (h = l, "ns".indexOf(e.axis[f]) !== -1 ? c = "y" : c = "x") : (h = u, c = "z"), e.axis[f]) {
        case "e":
          v[c] = h;
          break;
        case "w":
          v[c] = -h;
          break;
        case "n":
          v[c] = h;
          break;
        case "s":
          v[c] = -h;
          break;
        case "u":
          r[c] !== void 0 && (v.z = h);
          break;
        case "d":
          r[c] !== void 0 && (v.z = -h);
          break;
        default:
          return null;
      }
  return v;
}
function common(e) {
  var n = {
    x: e[0],
    y: e[1]
  };
  return e.length > 2 && (n.z = e[2]), e.length > 3 && (n.m = e[3]), n;
}
function checkSanity(e) {
  checkCoord(e.x), checkCoord(e.y);
}
function checkCoord(e) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(e))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof e != "number" || e !== e || !isFinite(e))
    throw new TypeError("coordinates must be finite numbers");
}
function checkNotWGS(e, n) {
  return (e.datum.datum_type === PJD_3PARAM || e.datum.datum_type === PJD_7PARAM || e.datum.datum_type === PJD_GRIDSHIFT) && n.datumCode !== "WGS84" || (n.datum.datum_type === PJD_3PARAM || n.datum.datum_type === PJD_7PARAM || n.datum.datum_type === PJD_GRIDSHIFT) && e.datumCode !== "WGS84";
}
function transform(e, n, r, o) {
  var l;
  Array.isArray(r) ? r = common(r) : r = {
    x: r.x,
    y: r.y,
    z: r.z,
    m: r.m
  };
  var u = r.z !== void 0;
  if (checkSanity(r), e.datum && n.datum && checkNotWGS(e, n) && (l = new Projection("WGS84"), r = transform(e, l, r, o), e = l), o && e.axis !== "enu" && (r = adjust_axis(e, !1, r)), e.projName === "longlat")
    r = {
      x: r.x * D2R$1,
      y: r.y * D2R$1,
      z: r.z || 0
    };
  else if (e.to_meter && (r = {
    x: r.x * e.to_meter,
    y: r.y * e.to_meter,
    z: r.z || 0
  }), r = e.inverse(r), !r)
    return;
  if (e.from_greenwich && (r.x += e.from_greenwich), r = datum_transform(e.datum, n.datum, r), !!r)
    return n.from_greenwich && (r = {
      x: r.x - n.from_greenwich,
      y: r.y,
      z: r.z || 0
    }), n.projName === "longlat" ? r = {
      x: r.x * R2D,
      y: r.y * R2D,
      z: r.z || 0
    } : (r = n.forward(r), n.to_meter && (r = {
      x: r.x / n.to_meter,
      y: r.y / n.to_meter,
      z: r.z || 0
    })), o && n.axis !== "enu" ? adjust_axis(n, !0, r) : (r && !u && delete r.z, r);
}
var wgs84 = Projection("WGS84");
function transformer(e, n, r, o) {
  var l, u, h;
  return Array.isArray(r) ? (l = transform(e, n, r, o) || { x: NaN, y: NaN }, r.length > 2 ? typeof e.name < "u" && e.name === "geocent" || typeof n.name < "u" && n.name === "geocent" ? typeof l.z == "number" ? [l.x, l.y, l.z].concat(r.splice(3)) : [l.x, l.y, r[2]].concat(r.splice(3)) : [l.x, l.y].concat(r.splice(2)) : [l.x, l.y]) : (u = transform(e, n, r, o), h = Object.keys(r), h.length === 2 || h.forEach(function(c) {
    if (typeof e.name < "u" && e.name === "geocent" || typeof n.name < "u" && n.name === "geocent") {
      if (c === "x" || c === "y" || c === "z")
        return;
    } else if (c === "x" || c === "y")
      return;
    u[c] = r[c];
  }), u);
}
function checkProj(e) {
  return e instanceof Projection ? e : e.oProj ? e.oProj : Projection(e);
}
function proj4(e, n, r) {
  e = checkProj(e);
  var o = !1, l;
  return typeof n > "u" ? (n = e, e = wgs84, o = !0) : (typeof n.x < "u" || Array.isArray(n)) && (r = n, n = e, e = wgs84, o = !0), n = checkProj(n), r ? transformer(e, n, r) : (l = {
    forward: function(u, h) {
      return transformer(e, n, u, h);
    },
    inverse: function(u, h) {
      return transformer(n, e, u, h);
    }
  }, o && (l.oProj = n), l);
}
var NUM_100K_SETS = 6, SET_ORIGIN_COLUMN_LETTERS = "AJSAJS", SET_ORIGIN_ROW_LETTERS = "AFAFAF", A = 65, I = 73, O = 79, V = 86, Z = 90;
const mgrs = {
  forward: forward$u,
  inverse: inverse$u,
  toPoint
};
function forward$u(e, n) {
  return n = n || 5, encode$2(LLtoUTM({
    lat: e[1],
    lon: e[0]
  }), n);
}
function inverse$u(e) {
  var n = UTMtoLL(decode(e.toUpperCase()));
  return n.lat && n.lon ? [n.lon, n.lat, n.lon, n.lat] : [n.left, n.bottom, n.right, n.top];
}
function toPoint(e) {
  var n = UTMtoLL(decode(e.toUpperCase()));
  return n.lat && n.lon ? [n.lon, n.lat] : [(n.left + n.right) / 2, (n.top + n.bottom) / 2];
}
function degToRad(e) {
  return e * (Math.PI / 180);
}
function radToDeg(e) {
  return 180 * (e / Math.PI);
}
function LLtoUTM(e) {
  var n = e.lat, r = e.lon, o = 6378137, l = 669438e-8, u = 0.9996, h, c, f, v, m, g, y, w = degToRad(n), E = degToRad(r), x, D;
  D = Math.floor((r + 180) / 6) + 1, r === 180 && (D = 60), n >= 56 && n < 64 && r >= 3 && r < 12 && (D = 32), n >= 72 && n < 84 && (r >= 0 && r < 9 ? D = 31 : r >= 9 && r < 21 ? D = 33 : r >= 21 && r < 33 ? D = 35 : r >= 33 && r < 42 && (D = 37)), h = (D - 1) * 6 - 180 + 3, x = degToRad(h), c = l / (1 - l), f = o / Math.sqrt(1 - l * Math.sin(w) * Math.sin(w)), v = Math.tan(w) * Math.tan(w), m = c * Math.cos(w) * Math.cos(w), g = Math.cos(w) * (E - x), y = o * ((1 - l / 4 - 3 * l * l / 64 - 5 * l * l * l / 256) * w - (3 * l / 8 + 3 * l * l / 32 + 45 * l * l * l / 1024) * Math.sin(2 * w) + (15 * l * l / 256 + 45 * l * l * l / 1024) * Math.sin(4 * w) - 35 * l * l * l / 3072 * Math.sin(6 * w));
  var F = u * f * (g + (1 - v + m) * g * g * g / 6 + (5 - 18 * v + v * v + 72 * m - 58 * c) * g * g * g * g * g / 120) + 5e5, k = u * (y + f * Math.tan(w) * (g * g / 2 + (5 - v + 9 * m + 4 * m * m) * g * g * g * g / 24 + (61 - 58 * v + v * v + 600 * m - 330 * c) * g * g * g * g * g * g / 720));
  return n < 0 && (k += 1e7), {
    northing: Math.round(k),
    easting: Math.round(F),
    zoneNumber: D,
    zoneLetter: getLetterDesignator(n)
  };
}
function UTMtoLL(e) {
  var n = e.northing, r = e.easting, o = e.zoneLetter, l = e.zoneNumber;
  if (l < 0 || l > 60)
    return null;
  var u = 0.9996, h = 6378137, c = 669438e-8, f, v = (1 - Math.sqrt(1 - c)) / (1 + Math.sqrt(1 - c)), m, g, y, w, E, x, D, F, k, N = r - 5e5, H = n;
  o < "N" && (H -= 1e7), D = (l - 1) * 6 - 180 + 3, f = c / (1 - c), x = H / u, F = x / (h * (1 - c / 4 - 3 * c * c / 64 - 5 * c * c * c / 256)), k = F + (3 * v / 2 - 27 * v * v * v / 32) * Math.sin(2 * F) + (21 * v * v / 16 - 55 * v * v * v * v / 32) * Math.sin(4 * F) + 151 * v * v * v / 96 * Math.sin(6 * F), m = h / Math.sqrt(1 - c * Math.sin(k) * Math.sin(k)), g = Math.tan(k) * Math.tan(k), y = f * Math.cos(k) * Math.cos(k), w = h * (1 - c) / Math.pow(1 - c * Math.sin(k) * Math.sin(k), 1.5), E = N / (m * u);
  var R = k - m * Math.tan(k) / w * (E * E / 2 - (5 + 3 * g + 10 * y - 4 * y * y - 9 * f) * E * E * E * E / 24 + (61 + 90 * g + 298 * y + 45 * g * g - 252 * f - 3 * y * y) * E * E * E * E * E * E / 720);
  R = radToDeg(R);
  var j = (E - (1 + 2 * g + y) * E * E * E / 6 + (5 - 2 * y + 28 * g - 3 * y * y + 8 * f + 24 * g * g) * E * E * E * E * E / 120) / Math.cos(k);
  j = D + radToDeg(j);
  var S;
  if (e.accuracy) {
    var tt = UTMtoLL({
      northing: e.northing + e.accuracy,
      easting: e.easting + e.accuracy,
      zoneLetter: e.zoneLetter,
      zoneNumber: e.zoneNumber
    });
    S = {
      top: tt.lat,
      right: tt.lon,
      bottom: R,
      left: j
    };
  } else
    S = {
      lat: R,
      lon: j
    };
  return S;
}
function getLetterDesignator(e) {
  var n = "Z";
  return 84 >= e && e >= 72 ? n = "X" : 72 > e && e >= 64 ? n = "W" : 64 > e && e >= 56 ? n = "V" : 56 > e && e >= 48 ? n = "U" : 48 > e && e >= 40 ? n = "T" : 40 > e && e >= 32 ? n = "S" : 32 > e && e >= 24 ? n = "R" : 24 > e && e >= 16 ? n = "Q" : 16 > e && e >= 8 ? n = "P" : 8 > e && e >= 0 ? n = "N" : 0 > e && e >= -8 ? n = "M" : -8 > e && e >= -16 ? n = "L" : -16 > e && e >= -24 ? n = "K" : -24 > e && e >= -32 ? n = "J" : -32 > e && e >= -40 ? n = "H" : -40 > e && e >= -48 ? n = "G" : -48 > e && e >= -56 ? n = "F" : -56 > e && e >= -64 ? n = "E" : -64 > e && e >= -72 ? n = "D" : -72 > e && e >= -80 && (n = "C"), n;
}
function encode$2(e, n) {
  var r = "00000" + e.easting, o = "00000" + e.northing;
  return e.zoneNumber + e.zoneLetter + get100kID(e.easting, e.northing, e.zoneNumber) + r.substr(r.length - 5, n) + o.substr(o.length - 5, n);
}
function get100kID(e, n, r) {
  var o = get100kSetForZone(r), l = Math.floor(e / 1e5), u = Math.floor(n / 1e5) % 20;
  return getLetter100kID(l, u, o);
}
function get100kSetForZone(e) {
  var n = e % NUM_100K_SETS;
  return n === 0 && (n = NUM_100K_SETS), n;
}
function getLetter100kID(e, n, r) {
  var o = r - 1, l = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(o), u = SET_ORIGIN_ROW_LETTERS.charCodeAt(o), h = l + e - 1, c = u + n, f = !1;
  h > Z && (h = h - Z + A - 1, f = !0), (h === I || l < I && h > I || (h > I || l < I) && f) && h++, (h === O || l < O && h > O || (h > O || l < O) && f) && (h++, h === I && h++), h > Z && (h = h - Z + A - 1), c > V ? (c = c - V + A - 1, f = !0) : f = !1, (c === I || u < I && c > I || (c > I || u < I) && f) && c++, (c === O || u < O && c > O || (c > O || u < O) && f) && (c++, c === I && c++), c > V && (c = c - V + A - 1);
  var v = String.fromCharCode(h) + String.fromCharCode(c);
  return v;
}
function decode(e) {
  if (e && e.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var n = e.length, r = null, o = "", l, u = 0; !/[A-Z]/.test(l = e.charAt(u)); ) {
    if (u >= 2)
      throw "MGRSPoint bad conversion from: " + e;
    o += l, u++;
  }
  var h = parseInt(o, 10);
  if (u === 0 || u + 3 > n)
    throw "MGRSPoint bad conversion from: " + e;
  var c = e.charAt(u++);
  if (c <= "A" || c === "B" || c === "Y" || c >= "Z" || c === "I" || c === "O")
    throw "MGRSPoint zone letter " + c + " not handled: " + e;
  r = e.substring(u, u += 2);
  for (var f = get100kSetForZone(h), v = getEastingFromChar(r.charAt(0), f), m = getNorthingFromChar(r.charAt(1), f); m < getMinNorthing(c); )
    m += 2e6;
  var g = n - u;
  if (g % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + e;
  var y = g / 2, w = 0, E = 0, x, D, F, k, N;
  return y > 0 && (x = 1e5 / Math.pow(10, y), D = e.substring(u, u + y), w = parseFloat(D) * x, F = e.substring(u + y), E = parseFloat(F) * x), k = w + v, N = E + m, {
    easting: k,
    northing: N,
    zoneLetter: c,
    zoneNumber: h,
    accuracy: x
  };
}
function getEastingFromChar(e, n) {
  for (var r = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(n - 1), o = 1e5, l = !1; r !== e.charCodeAt(0); ) {
    if (r++, r === I && r++, r === O && r++, r > Z) {
      if (l)
        throw "Bad character: " + e;
      r = A, l = !0;
    }
    o += 1e5;
  }
  return o;
}
function getNorthingFromChar(e, n) {
  if (e > "V")
    throw "MGRSPoint given invalid Northing " + e;
  for (var r = SET_ORIGIN_ROW_LETTERS.charCodeAt(n - 1), o = 0, l = !1; r !== e.charCodeAt(0); ) {
    if (r++, r === I && r++, r === O && r++, r > V) {
      if (l)
        throw "Bad character: " + e;
      r = A, l = !0;
    }
    o += 1e5;
  }
  return o;
}
function getMinNorthing(e) {
  var n;
  switch (e) {
    case "C":
      n = 11e5;
      break;
    case "D":
      n = 2e6;
      break;
    case "E":
      n = 28e5;
      break;
    case "F":
      n = 37e5;
      break;
    case "G":
      n = 46e5;
      break;
    case "H":
      n = 55e5;
      break;
    case "J":
      n = 64e5;
      break;
    case "K":
      n = 73e5;
      break;
    case "L":
      n = 82e5;
      break;
    case "M":
      n = 91e5;
      break;
    case "N":
      n = 0;
      break;
    case "P":
      n = 8e5;
      break;
    case "Q":
      n = 17e5;
      break;
    case "R":
      n = 26e5;
      break;
    case "S":
      n = 35e5;
      break;
    case "T":
      n = 44e5;
      break;
    case "U":
      n = 53e5;
      break;
    case "V":
      n = 62e5;
      break;
    case "W":
      n = 7e6;
      break;
    case "X":
      n = 79e5;
      break;
    default:
      n = -1;
  }
  if (n >= 0)
    return n;
  throw "Invalid zone letter: " + e;
}
function Point(e, n, r) {
  if (!(this instanceof Point))
    return new Point(e, n, r);
  if (Array.isArray(e))
    this.x = e[0], this.y = e[1], this.z = e[2] || 0;
  else if (typeof e == "object")
    this.x = e.x, this.y = e.y, this.z = e.z || 0;
  else if (typeof e == "string" && typeof n > "u") {
    var o = e.split(",");
    this.x = parseFloat(o[0], 10), this.y = parseFloat(o[1], 10), this.z = parseFloat(o[2], 10) || 0;
  } else
    this.x = e, this.y = n, this.z = r || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Point.fromMGRS = function(e) {
  return new Point(toPoint(e));
};
Point.prototype.toMGRS = function(e) {
  return forward$u([this.x, this.y], e);
};
var C00 = 1, C02 = 0.25, C04 = 0.046875, C06 = 0.01953125, C08 = 0.01068115234375, C22 = 0.75, C44 = 0.46875, C46 = 0.013020833333333334, C48 = 0.007120768229166667, C66 = 0.3645833333333333, C68 = 0.005696614583333333, C88 = 0.3076171875;
function pj_enfn(e) {
  var n = [];
  n[0] = C00 - e * (C02 + e * (C04 + e * (C06 + e * C08))), n[1] = e * (C22 - e * (C04 + e * (C06 + e * C08)));
  var r = e * e;
  return n[2] = r * (C44 - e * (C46 + e * C48)), r *= e, n[3] = r * (C66 - e * C68), n[4] = r * e * C88, n;
}
function pj_mlfn(e, n, r, o) {
  return r *= n, n *= n, o[0] * e - r * (o[1] + n * (o[2] + n * (o[3] + n * o[4])));
}
var MAX_ITER$3 = 20;
function pj_inv_mlfn(e, n, r) {
  for (var o = 1 / (1 - n), l = e, u = MAX_ITER$3; u; --u) {
    var h = Math.sin(l), c = 1 - n * h * h;
    if (c = (pj_mlfn(l, h, Math.cos(l), r) - e) * (c * Math.sqrt(c)) * o, l -= c, Math.abs(c) < EPSLN)
      return l;
  }
  return l;
}
function init$u() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = pj_enfn(this.es), this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function forward$t(e) {
  var n = e.x, r = e.y, o = adjust_lon(n - this.long0), l, u, h, c = Math.sin(r), f = Math.cos(r);
  if (this.es) {
    var m = f * o, g = Math.pow(m, 2), y = this.ep2 * Math.pow(f, 2), w = Math.pow(y, 2), E = Math.abs(f) > EPSLN ? Math.tan(r) : 0, x = Math.pow(E, 2), D = Math.pow(x, 2);
    l = 1 - this.es * Math.pow(c, 2), m = m / Math.sqrt(l);
    var F = pj_mlfn(r, c, f, this.en);
    u = this.a * (this.k0 * m * (1 + g / 6 * (1 - x + y + g / 20 * (5 - 18 * x + D + 14 * y - 58 * x * y + g / 42 * (61 + 179 * D - D * x - 479 * x))))) + this.x0, h = this.a * (this.k0 * (F - this.ml0 + c * o * m / 2 * (1 + g / 12 * (5 - x + 9 * y + 4 * w + g / 30 * (61 + D - 58 * x + 270 * y - 330 * x * y + g / 56 * (1385 + 543 * D - D * x - 3111 * x)))))) + this.y0;
  } else {
    var v = f * Math.sin(o);
    if (Math.abs(Math.abs(v) - 1) < EPSLN)
      return 93;
    if (u = 0.5 * this.a * this.k0 * Math.log((1 + v) / (1 - v)) + this.x0, h = f * Math.cos(o) / Math.sqrt(1 - Math.pow(v, 2)), v = Math.abs(h), v >= 1) {
      if (v - 1 > EPSLN)
        return 93;
      h = 0;
    } else
      h = Math.acos(h);
    r < 0 && (h = -h), h = this.a * this.k0 * (h - this.lat0) + this.y0;
  }
  return e.x = u, e.y = h, e;
}
function inverse$t(e) {
  var n, r, o, l, u = (e.x - this.x0) * (1 / this.a), h = (e.y - this.y0) * (1 / this.a);
  if (this.es)
    if (n = this.ml0 + h / this.k0, r = pj_inv_mlfn(n, this.es, this.en), Math.abs(r) < HALF_PI) {
      var g = Math.sin(r), y = Math.cos(r), w = Math.abs(y) > EPSLN ? Math.tan(r) : 0, E = this.ep2 * Math.pow(y, 2), x = Math.pow(E, 2), D = Math.pow(w, 2), F = Math.pow(D, 2);
      n = 1 - this.es * Math.pow(g, 2);
      var k = u * Math.sqrt(n) / this.k0, N = Math.pow(k, 2);
      n = n * w, o = r - n * N / (1 - this.es) * 0.5 * (1 - N / 12 * (5 + 3 * D - 9 * E * D + E - 4 * x - N / 30 * (61 + 90 * D - 252 * E * D + 45 * F + 46 * E - N / 56 * (1385 + 3633 * D + 4095 * F + 1574 * F * D)))), l = adjust_lon(this.long0 + k * (1 - N / 6 * (1 + 2 * D + E - N / 20 * (5 + 28 * D + 24 * F + 8 * E * D + 6 * E - N / 42 * (61 + 662 * D + 1320 * F + 720 * F * D)))) / y);
    } else
      o = HALF_PI * sign(h), l = 0;
  else {
    var c = Math.exp(u / this.k0), f = 0.5 * (c - 1 / c), v = this.lat0 + h / this.k0, m = Math.cos(v);
    n = Math.sqrt((1 - Math.pow(m, 2)) / (1 + Math.pow(f, 2))), o = Math.asin(n), h < 0 && (o = -o), f === 0 && m === 0 ? l = 0 : l = adjust_lon(Math.atan2(f, m) + this.long0);
  }
  return e.x = l, e.y = o, e;
}
var names$u = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const tmerc = {
  init: init$u,
  forward: forward$t,
  inverse: inverse$t,
  names: names$u
};
function sinh(e) {
  var n = Math.exp(e);
  return n = (n - 1 / n) / 2, n;
}
function hypot(e, n) {
  e = Math.abs(e), n = Math.abs(n);
  var r = Math.max(e, n), o = Math.min(e, n) / (r || 1);
  return r * Math.sqrt(1 + Math.pow(o, 2));
}
function log1py(e) {
  var n = 1 + e, r = n - 1;
  return r === 0 ? e : e * Math.log(n) / r;
}
function asinhy(e) {
  var n = Math.abs(e);
  return n = log1py(n * (1 + n / (hypot(1, n) + 1))), e < 0 ? -n : n;
}
function gatg(e, n) {
  for (var r = 2 * Math.cos(2 * n), o = e.length - 1, l = e[o], u = 0, h; --o >= 0; )
    h = -u + r * l + e[o], u = l, l = h;
  return n + h * Math.sin(2 * n);
}
function clens(e, n) {
  for (var r = 2 * Math.cos(n), o = e.length - 1, l = e[o], u = 0, h; --o >= 0; )
    h = -u + r * l + e[o], u = l, l = h;
  return Math.sin(n) * h;
}
function cosh(e) {
  var n = Math.exp(e);
  return n = (n + 1 / n) / 2, n;
}
function clens_cmplx(e, n, r) {
  for (var o = Math.sin(n), l = Math.cos(n), u = sinh(r), h = cosh(r), c = 2 * l * h, f = -2 * o * u, v = e.length - 1, m = e[v], g = 0, y = 0, w = 0, E, x; --v >= 0; )
    E = y, x = g, y = m, g = w, m = -E + c * y - f * g + e[v], w = -x + f * y + c * g;
  return c = o * h, f = l * u, [c * m - f * w, c * w + f * m];
}
function init$t() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (tmerc.init.apply(this), this.forward = tmerc.forward, this.inverse = tmerc.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var e = this.es / (1 + Math.sqrt(1 - this.es)), n = e / (2 - e), r = n;
  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675)))))), this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725)))))), r = r * n, this.cgb[1] = r * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945))))), this.cbg[1] = r * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945))))), r = r * n, this.cgb[2] = r * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835)))), this.cbg[2] = r * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835)))), r = r * n, this.cgb[3] = r * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175))), this.cbg[3] = r * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175))), r = r * n, this.cgb[4] = r * (4174 / 315 + n * (-144838 / 6237)), this.cbg[4] = r * (-734 / 315 + n * (109598 / 31185)), r = r * n, this.cgb[5] = r * (601676 / 22275), this.cbg[5] = r * (444337 / 155925), r = Math.pow(n, 2), this.Qn = this.k0 / (1 + n) * (1 + r * (1 / 4 + r * (1 / 64 + r / 256))), this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800)))))), this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800)))))), this.utg[1] = r * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720))))), this.gtu[1] = r * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360))))), r = r * n, this.utg[2] = r * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720)))), this.gtu[2] = r * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440)))), r = r * n, this.utg[3] = r * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600))), this.gtu[3] = r * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600))), r = r * n, this.utg[4] = r * (-4583 / 161280 + n * (108847 / 3991680)), this.gtu[4] = r * (34729 / 80640 + n * (-3418889 / 1995840)), r = r * n, this.utg[5] = r * (-20648693 / 638668800), this.gtu[5] = r * (212378941 / 319334400);
  var o = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (o + clens(this.gtu, 2 * o));
}
function forward$s(e) {
  var n = adjust_lon(e.x - this.long0), r = e.y;
  r = gatg(this.cbg, r);
  var o = Math.sin(r), l = Math.cos(r), u = Math.sin(n), h = Math.cos(n);
  r = Math.atan2(o, h * l), n = Math.atan2(u * l, hypot(o, l * h)), n = asinhy(Math.tan(n));
  var c = clens_cmplx(this.gtu, 2 * r, 2 * n);
  r = r + c[0], n = n + c[1];
  var f, v;
  return Math.abs(n) <= 2.623395162778 ? (f = this.a * (this.Qn * n) + this.x0, v = this.a * (this.Qn * r + this.Zb) + this.y0) : (f = 1 / 0, v = 1 / 0), e.x = f, e.y = v, e;
}
function inverse$s(e) {
  var n = (e.x - this.x0) * (1 / this.a), r = (e.y - this.y0) * (1 / this.a);
  r = (r - this.Zb) / this.Qn, n = n / this.Qn;
  var o, l;
  if (Math.abs(n) <= 2.623395162778) {
    var u = clens_cmplx(this.utg, 2 * r, 2 * n);
    r = r + u[0], n = n + u[1], n = Math.atan(sinh(n));
    var h = Math.sin(r), c = Math.cos(r), f = Math.sin(n), v = Math.cos(n);
    r = Math.atan2(h * v, hypot(f, v * c)), n = Math.atan2(f, v * c), o = adjust_lon(n + this.long0), l = gatg(this.cgb, r);
  } else
    o = 1 / 0, l = 1 / 0;
  return e.x = o, e.y = l, e;
}
var names$t = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
const etmerc = {
  init: init$t,
  forward: forward$s,
  inverse: inverse$s,
  names: names$t
};
function adjust_zone(e, n) {
  if (e === void 0) {
    if (e = Math.floor((adjust_lon(n) + Math.PI) * 30 / Math.PI) + 1, e < 0)
      return 0;
    if (e > 60)
      return 60;
  }
  return e;
}
var dependsOn = "etmerc";
function init$s() {
  var e = adjust_zone(this.zone, this.long0);
  if (e === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(e) - 183) * D2R$1, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, etmerc.init.apply(this), this.forward = etmerc.forward, this.inverse = etmerc.inverse;
}
var names$s = ["Universal Transverse Mercator System", "utm"];
const utm = {
  init: init$s,
  names: names$s,
  dependsOn
};
function srat(e, n) {
  return Math.pow((1 - e) / (1 + e), n);
}
var MAX_ITER$2 = 20;
function init$r() {
  var e = Math.sin(this.lat0), n = Math.cos(this.lat0);
  n *= n, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * e * e), this.C = Math.sqrt(1 + this.es * n * n / (1 - this.es)), this.phic0 = Math.asin(e / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * e, this.ratexp));
}
function forward$r(e) {
  var n = e.x, r = e.y;
  return e.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * r + FORTPI), this.C) * srat(this.e * Math.sin(r), this.ratexp)) - HALF_PI, e.x = this.C * n, e;
}
function inverse$r(e) {
  for (var n = 1e-14, r = e.x / this.C, o = e.y, l = Math.pow(Math.tan(0.5 * o + FORTPI) / this.K, 1 / this.C), u = MAX_ITER$2; u > 0 && (o = 2 * Math.atan(l * srat(this.e * Math.sin(e.y), -0.5 * this.e)) - HALF_PI, !(Math.abs(o - e.y) < n)); --u)
    e.y = o;
  return u ? (e.x = r, e.y = o, e) : null;
}
var names$r = ["gauss"];
const gauss = {
  init: init$r,
  forward: forward$r,
  inverse: inverse$r,
  names: names$r
};
function init$q() {
  gauss.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function forward$q(e) {
  var n, r, o, l;
  return e.x = adjust_lon(e.x - this.long0), gauss.forward.apply(this, [e]), n = Math.sin(e.y), r = Math.cos(e.y), o = Math.cos(e.x), l = this.k0 * this.R2 / (1 + this.sinc0 * n + this.cosc0 * r * o), e.x = l * r * Math.sin(e.x), e.y = l * (this.cosc0 * n - this.sinc0 * r * o), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function inverse$q(e) {
  var n, r, o, l, u;
  if (e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, e.x /= this.k0, e.y /= this.k0, u = hypot(e.x, e.y)) {
    var h = 2 * Math.atan2(u, this.R2);
    n = Math.sin(h), r = Math.cos(h), l = Math.asin(r * this.sinc0 + e.y * n * this.cosc0 / u), o = Math.atan2(e.x * n, u * this.cosc0 * r - e.y * this.sinc0 * n);
  } else
    l = this.phic0, o = 0;
  return e.x = o, e.y = l, gauss.inverse.apply(this, [e]), e.x = adjust_lon(e.x + this.long0), e;
}
var names$q = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const sterea = {
  init: init$q,
  forward: forward$q,
  inverse: inverse$q,
  names: names$q
};
function ssfn_(e, n, r) {
  return n *= r, Math.tan(0.5 * (HALF_PI + e)) * Math.pow((1 - n) / (1 + n), 0.5 * r);
}
function init$p() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && (this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= EPSLN && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && Math.abs(Math.cos(this.lat_ts)) > EPSLN && (this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function forward$p(e) {
  var n = e.x, r = e.y, o = Math.sin(r), l = Math.cos(r), u, h, c, f, v, m, g = adjust_lon(n - this.long0);
  return Math.abs(Math.abs(n - this.long0) - Math.PI) <= EPSLN && Math.abs(r + this.lat0) <= EPSLN ? (e.x = NaN, e.y = NaN, e) : this.sphere ? (u = 2 * this.k0 / (1 + this.sinlat0 * o + this.coslat0 * l * Math.cos(g)), e.x = this.a * u * l * Math.sin(g) + this.x0, e.y = this.a * u * (this.coslat0 * o - this.sinlat0 * l * Math.cos(g)) + this.y0, e) : (h = 2 * Math.atan(this.ssfn_(r, o, this.e)) - HALF_PI, f = Math.cos(h), c = Math.sin(h), Math.abs(this.coslat0) <= EPSLN ? (v = tsfnz(this.e, r * this.con, this.con * o), m = 2 * this.a * this.k0 * v / this.cons, e.x = this.x0 + m * Math.sin(n - this.long0), e.y = this.y0 - this.con * m * Math.cos(n - this.long0), e) : (Math.abs(this.sinlat0) < EPSLN ? (u = 2 * this.a * this.k0 / (1 + f * Math.cos(g)), e.y = u * c) : (u = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * c + this.cosX0 * f * Math.cos(g))), e.y = u * (this.cosX0 * c - this.sinX0 * f * Math.cos(g)) + this.y0), e.x = u * f * Math.sin(g) + this.x0, e));
}
function inverse$p(e) {
  e.x -= this.x0, e.y -= this.y0;
  var n, r, o, l, u, h = Math.sqrt(e.x * e.x + e.y * e.y);
  if (this.sphere) {
    var c = 2 * Math.atan(h / (2 * this.a * this.k0));
    return n = this.long0, r = this.lat0, h <= EPSLN ? (e.x = n, e.y = r, e) : (r = Math.asin(Math.cos(c) * this.sinlat0 + e.y * Math.sin(c) * this.coslat0 / h), Math.abs(this.coslat0) < EPSLN ? this.lat0 > 0 ? n = adjust_lon(this.long0 + Math.atan2(e.x, -1 * e.y)) : n = adjust_lon(this.long0 + Math.atan2(e.x, e.y)) : n = adjust_lon(this.long0 + Math.atan2(e.x * Math.sin(c), h * this.coslat0 * Math.cos(c) - e.y * this.sinlat0 * Math.sin(c))), e.x = n, e.y = r, e);
  } else if (Math.abs(this.coslat0) <= EPSLN) {
    if (h <= EPSLN)
      return r = this.lat0, n = this.long0, e.x = n, e.y = r, e;
    e.x *= this.con, e.y *= this.con, o = h * this.cons / (2 * this.a * this.k0), r = this.con * phi2z(this.e, o), n = this.con * adjust_lon(this.con * this.long0 + Math.atan2(e.x, -1 * e.y));
  } else
    l = 2 * Math.atan(h * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), n = this.long0, h <= EPSLN ? u = this.X0 : (u = Math.asin(Math.cos(l) * this.sinX0 + e.y * Math.sin(l) * this.cosX0 / h), n = adjust_lon(this.long0 + Math.atan2(e.x * Math.sin(l), h * this.cosX0 * Math.cos(l) - e.y * this.sinX0 * Math.sin(l)))), r = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + u)));
  return e.x = n, e.y = r, e;
}
var names$p = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
const stere = {
  init: init$p,
  forward: forward$p,
  inverse: inverse$p,
  names: names$p,
  ssfn_
};
function init$o() {
  var e = this.lat0;
  this.lambda0 = this.long0;
  var n = Math.sin(e), r = this.a, o = this.rf, l = 1 / o, u = 2 * l - Math.pow(l, 2), h = this.e = Math.sqrt(u);
  this.R = this.k0 * r * Math.sqrt(1 - u) / (1 - u * Math.pow(n, 2)), this.alpha = Math.sqrt(1 + u / (1 - u) * Math.pow(Math.cos(e), 4)), this.b0 = Math.asin(n / this.alpha);
  var c = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), f = Math.log(Math.tan(Math.PI / 4 + e / 2)), v = Math.log((1 + h * n) / (1 - h * n));
  this.K = c - this.alpha * f + this.alpha * h / 2 * v;
}
function forward$o(e) {
  var n = Math.log(Math.tan(Math.PI / 4 - e.y / 2)), r = this.e / 2 * Math.log((1 + this.e * Math.sin(e.y)) / (1 - this.e * Math.sin(e.y))), o = -this.alpha * (n + r) + this.K, l = 2 * (Math.atan(Math.exp(o)) - Math.PI / 4), u = this.alpha * (e.x - this.lambda0), h = Math.atan(Math.sin(u) / (Math.sin(this.b0) * Math.tan(l) + Math.cos(this.b0) * Math.cos(u))), c = Math.asin(Math.cos(this.b0) * Math.sin(l) - Math.sin(this.b0) * Math.cos(l) * Math.cos(u));
  return e.y = this.R / 2 * Math.log((1 + Math.sin(c)) / (1 - Math.sin(c))) + this.y0, e.x = this.R * h + this.x0, e;
}
function inverse$o(e) {
  for (var n = e.x - this.x0, r = e.y - this.y0, o = n / this.R, l = 2 * (Math.atan(Math.exp(r / this.R)) - Math.PI / 4), u = Math.asin(Math.cos(this.b0) * Math.sin(l) + Math.sin(this.b0) * Math.cos(l) * Math.cos(o)), h = Math.atan(Math.sin(o) / (Math.cos(this.b0) * Math.cos(o) - Math.sin(this.b0) * Math.tan(l))), c = this.lambda0 + h / this.alpha, f = 0, v = u, m = -1e3, g = 0; Math.abs(v - m) > 1e-7; ) {
    if (++g > 20)
      return;
    f = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + u / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(v)) / 2)), m = v, v = 2 * Math.atan(Math.exp(f)) - Math.PI / 2;
  }
  return e.x = c, e.y = v, e;
}
var names$o = ["somerc"];
const somerc = {
  init: init$o,
  forward: forward$o,
  inverse: inverse$o,
  names: names$o
};
var TOL = 1e-7;
function isTypeA(e) {
  var n = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], r = typeof e.PROJECTION == "object" ? Object.keys(e.PROJECTION)[0] : e.PROJECTION;
  return "no_uoff" in e || "no_off" in e || n.indexOf(r) !== -1;
}
function init$n() {
  var e, n, r, o, l, u, h, c, f, v, m = 0, g, y = 0, w = 0, E = 0, x = 0, D = 0, F = 0;
  this.no_off = isTypeA(this), this.no_rot = "no_rot" in this;
  var k = !1;
  "alpha" in this && (k = !0);
  var N = !1;
  if ("rectified_grid_angle" in this && (N = !0), k && (F = this.alpha), N && (m = this.rectified_grid_angle * D2R$1), k || N)
    y = this.longc;
  else if (w = this.long1, x = this.lat1, E = this.long2, D = this.lat2, Math.abs(x - D) <= TOL || (e = Math.abs(x)) <= TOL || Math.abs(e - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(D) - HALF_PI) <= TOL)
    throw new Error();
  var H = 1 - this.es;
  n = Math.sqrt(H), Math.abs(this.lat0) > EPSLN ? (c = Math.sin(this.lat0), r = Math.cos(this.lat0), e = 1 - this.es * c * c, this.B = r * r, this.B = Math.sqrt(1 + this.es * this.B * this.B / H), this.A = this.B * this.k0 * n / e, o = this.B * n / (r * Math.sqrt(e)), l = o * o - 1, l <= 0 ? l = 0 : (l = Math.sqrt(l), this.lat0 < 0 && (l = -l)), this.E = l += o, this.E *= Math.pow(tsfnz(this.e, this.lat0, c), this.B)) : (this.B = 1 / n, this.A = this.k0, this.E = o = l = 1), k || N ? (k ? (g = Math.asin(Math.sin(F) / o), N || (m = F)) : (g = m, F = Math.asin(o * Math.sin(g))), this.lam0 = y - Math.asin(0.5 * (l - 1 / l) * Math.tan(g)) / this.B) : (u = Math.pow(tsfnz(this.e, x, Math.sin(x)), this.B), h = Math.pow(tsfnz(this.e, D, Math.sin(D)), this.B), l = this.E / u, f = (h - u) / (h + u), v = this.E * this.E, v = (v - h * u) / (v + h * u), e = w - E, e < -Math.pi ? E -= TWO_PI : e > Math.pi && (E += TWO_PI), this.lam0 = adjust_lon(0.5 * (w + E) - Math.atan(v * Math.tan(0.5 * this.B * (w - E)) / f) / this.B), g = Math.atan(2 * Math.sin(this.B * adjust_lon(w - this.lam0)) / (l - 1 / l)), m = F = Math.asin(o * Math.sin(g))), this.singam = Math.sin(g), this.cosgam = Math.cos(g), this.sinrot = Math.sin(m), this.cosrot = Math.cos(m), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(o * o - 1) / Math.cos(F))), this.lat0 < 0 && (this.u_0 = -this.u_0)), l = 0.5 * g, this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - l)), this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + l));
}
function forward$n(e) {
  var n = {}, r, o, l, u, h, c, f, v;
  if (e.x = e.x - this.lam0, Math.abs(Math.abs(e.y) - HALF_PI) > EPSLN) {
    if (h = this.E / Math.pow(tsfnz(this.e, e.y, Math.sin(e.y)), this.B), c = 1 / h, r = 0.5 * (h - c), o = 0.5 * (h + c), u = Math.sin(this.B * e.x), l = (r * this.singam - u * this.cosgam) / o, Math.abs(Math.abs(l) - 1) < EPSLN)
      throw new Error();
    v = 0.5 * this.ArB * Math.log((1 - l) / (1 + l)), c = Math.cos(this.B * e.x), Math.abs(c) < TOL ? f = this.A * e.x : f = this.ArB * Math.atan2(r * this.cosgam + u * this.singam, c);
  } else
    v = e.y > 0 ? this.v_pole_n : this.v_pole_s, f = this.ArB * e.y;
  return this.no_rot ? (n.x = f, n.y = v) : (f -= this.u_0, n.x = v * this.cosrot + f * this.sinrot, n.y = f * this.cosrot - v * this.sinrot), n.x = this.a * n.x + this.x0, n.y = this.a * n.y + this.y0, n;
}
function inverse$n(e) {
  var n, r, o, l, u, h, c, f = {};
  if (e.x = (e.x - this.x0) * (1 / this.a), e.y = (e.y - this.y0) * (1 / this.a), this.no_rot ? (r = e.y, n = e.x) : (r = e.x * this.cosrot - e.y * this.sinrot, n = e.y * this.cosrot + e.x * this.sinrot + this.u_0), o = Math.exp(-this.BrA * r), l = 0.5 * (o - 1 / o), u = 0.5 * (o + 1 / o), h = Math.sin(this.BrA * n), c = (h * this.cosgam + l * this.singam) / u, Math.abs(Math.abs(c) - 1) < EPSLN)
    f.x = 0, f.y = c < 0 ? -HALF_PI : HALF_PI;
  else {
    if (f.y = this.E / Math.sqrt((1 + c) / (1 - c)), f.y = phi2z(this.e, Math.pow(f.y, 1 / this.B)), f.y === 1 / 0)
      throw new Error();
    f.x = -this.rB * Math.atan2(l * this.cosgam - h * this.singam, Math.cos(this.BrA * n));
  }
  return f.x += this.lam0, f;
}
var names$n = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const omerc = {
  init: init$n,
  forward: forward$n,
  inverse: inverse$n,
  names: names$n
};
function init$m() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < EPSLN)) {
    var e = this.b / this.a;
    this.e = Math.sqrt(1 - e * e);
    var n = Math.sin(this.lat1), r = Math.cos(this.lat1), o = msfnz(this.e, n, r), l = tsfnz(this.e, this.lat1, n), u = Math.sin(this.lat2), h = Math.cos(this.lat2), c = msfnz(this.e, u, h), f = tsfnz(this.e, this.lat2, u), v = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > EPSLN ? this.ns = Math.log(o / c) / Math.log(l / f) : this.ns = n, isNaN(this.ns) && (this.ns = n), this.f0 = o / (this.ns * Math.pow(l, this.ns)), this.rh = this.a * this.f0 * Math.pow(v, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function forward$m(e) {
  var n = e.x, r = e.y;
  Math.abs(2 * Math.abs(r) - Math.PI) <= EPSLN && (r = sign(r) * (HALF_PI - 2 * EPSLN));
  var o = Math.abs(Math.abs(r) - HALF_PI), l, u;
  if (o > EPSLN)
    l = tsfnz(this.e, r, Math.sin(r)), u = this.a * this.f0 * Math.pow(l, this.ns);
  else {
    if (o = r * this.ns, o <= 0)
      return null;
    u = 0;
  }
  var h = this.ns * adjust_lon(n - this.long0);
  return e.x = this.k0 * (u * Math.sin(h)) + this.x0, e.y = this.k0 * (this.rh - u * Math.cos(h)) + this.y0, e;
}
function inverse$m(e) {
  var n, r, o, l, u, h = (e.x - this.x0) / this.k0, c = this.rh - (e.y - this.y0) / this.k0;
  this.ns > 0 ? (n = Math.sqrt(h * h + c * c), r = 1) : (n = -Math.sqrt(h * h + c * c), r = -1);
  var f = 0;
  if (n !== 0 && (f = Math.atan2(r * h, r * c)), n !== 0 || this.ns > 0) {
    if (r = 1 / this.ns, o = Math.pow(n / (this.a * this.f0), r), l = phi2z(this.e, o), l === -9999)
      return null;
  } else
    l = -HALF_PI;
  return u = adjust_lon(f / this.ns + this.long0), e.x = u, e.y = l, e;
}
var names$m = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const lcc = {
  init: init$m,
  forward: forward$m,
  inverse: inverse$m,
  names: names$m
};
function init$l() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function forward$l(e) {
  var n, r, o, l, u, h, c, f = e.x, v = e.y, m = adjust_lon(f - this.long0);
  return n = Math.pow((1 + this.e * Math.sin(v)) / (1 - this.e * Math.sin(v)), this.alfa * this.e / 2), r = 2 * (Math.atan(this.k * Math.pow(Math.tan(v / 2 + this.s45), this.alfa) / n) - this.s45), o = -m * this.alfa, l = Math.asin(Math.cos(this.ad) * Math.sin(r) + Math.sin(this.ad) * Math.cos(r) * Math.cos(o)), u = Math.asin(Math.cos(r) * Math.sin(o) / Math.cos(l)), h = this.n * u, c = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(l / 2 + this.s45), this.n), e.y = c * Math.cos(h) / 1, e.x = c * Math.sin(h) / 1, this.czech || (e.y *= -1, e.x *= -1), e;
}
function inverse$l(e) {
  var n, r, o, l, u, h, c, f, v = e.x;
  e.x = e.y, e.y = v, this.czech || (e.y *= -1, e.x *= -1), h = Math.sqrt(e.x * e.x + e.y * e.y), u = Math.atan2(e.y, e.x), l = u / Math.sin(this.s0), o = 2 * (Math.atan(Math.pow(this.ro0 / h, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), n = Math.asin(Math.cos(this.ad) * Math.sin(o) - Math.sin(this.ad) * Math.cos(o) * Math.cos(l)), r = Math.asin(Math.cos(o) * Math.sin(l) / Math.cos(n)), e.x = this.long0 - r / this.alfa, c = n, f = 0;
  var m = 0;
  do
    e.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(n / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(c)) / (1 - this.e * Math.sin(c)), this.e / 2)) - this.s45), Math.abs(c - e.y) < 1e-10 && (f = 1), c = e.y, m += 1;
  while (f === 0 && m < 15);
  return m >= 15 ? null : e;
}
var names$l = ["Krovak", "krovak"];
const krovak = {
  init: init$l,
  forward: forward$l,
  inverse: inverse$l,
  names: names$l
};
function mlfn(e, n, r, o, l) {
  return e * l - n * Math.sin(2 * l) + r * Math.sin(4 * l) - o * Math.sin(6 * l);
}
function e0fn(e) {
  return 1 - 0.25 * e * (1 + e / 16 * (3 + 1.25 * e));
}
function e1fn(e) {
  return 0.375 * e * (1 + 0.25 * e * (1 + 0.46875 * e));
}
function e2fn(e) {
  return 0.05859375 * e * e * (1 + 0.75 * e);
}
function e3fn(e) {
  return e * e * e * (35 / 3072);
}
function gN(e, n, r) {
  var o = n * r;
  return e / Math.sqrt(1 - o * o);
}
function adjust_lat(e) {
  return Math.abs(e) < HALF_PI ? e : e - sign(e) * Math.PI;
}
function imlfn(e, n, r, o, l) {
  var u, h;
  u = e / n;
  for (var c = 0; c < 15; c++)
    if (h = (e - (n * u - r * Math.sin(2 * u) + o * Math.sin(4 * u) - l * Math.sin(6 * u))) / (n - 2 * r * Math.cos(2 * u) + 4 * o * Math.cos(4 * u) - 6 * l * Math.cos(6 * u)), u += h, Math.abs(h) <= 1e-10)
      return u;
  return NaN;
}
function init$k() {
  this.sphere || (this.e0 = e0fn(this.es), this.e1 = e1fn(this.es), this.e2 = e2fn(this.es), this.e3 = e3fn(this.es), this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function forward$k(e) {
  var n, r, o = e.x, l = e.y;
  if (o = adjust_lon(o - this.long0), this.sphere)
    n = this.a * Math.asin(Math.cos(l) * Math.sin(o)), r = this.a * (Math.atan2(Math.tan(l), Math.cos(o)) - this.lat0);
  else {
    var u = Math.sin(l), h = Math.cos(l), c = gN(this.a, this.e, u), f = Math.tan(l) * Math.tan(l), v = o * Math.cos(l), m = v * v, g = this.es * h * h / (1 - this.es), y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, l);
    n = c * v * (1 - m * f * (1 / 6 - (8 - f + 8 * g) * m / 120)), r = y - this.ml0 + c * u / h * m * (0.5 + (5 - f + 6 * g) * m / 24);
  }
  return e.x = n + this.x0, e.y = r + this.y0, e;
}
function inverse$k(e) {
  e.x -= this.x0, e.y -= this.y0;
  var n = e.x / this.a, r = e.y / this.a, o, l;
  if (this.sphere) {
    var u = r + this.lat0;
    o = Math.asin(Math.sin(u) * Math.cos(n)), l = Math.atan2(Math.tan(n), Math.cos(u));
  } else {
    var h = this.ml0 / this.a + r, c = imlfn(h, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(c) - HALF_PI) <= EPSLN)
      return e.x = this.long0, e.y = HALF_PI, r < 0 && (e.y *= -1), e;
    var f = gN(this.a, this.e, Math.sin(c)), v = f * f * f / this.a / this.a * (1 - this.es), m = Math.pow(Math.tan(c), 2), g = n * this.a / f, y = g * g;
    o = c - f * Math.tan(c) / v * g * g * (0.5 - (1 + 3 * m) * g * g / 24), l = g * (1 - y * (m / 3 + (1 + 3 * m) * m * y / 15)) / Math.cos(c);
  }
  return e.x = adjust_lon(l + this.long0), e.y = adjust_lat(o), e;
}
var names$k = ["Cassini", "Cassini_Soldner", "cass"];
const cass = {
  init: init$k,
  forward: forward$k,
  inverse: inverse$k,
  names: names$k
};
function qsfnz(e, n) {
  var r;
  return e > 1e-7 ? (r = e * n, (1 - e * e) * (n / (1 - r * r) - 0.5 / e * Math.log((1 - r) / (1 + r)))) : 2 * n;
}
var S_POLE = 1, N_POLE = 2, EQUIT = 3, OBLIQ = 4;
function init$j() {
  var e = Math.abs(this.lat0);
  if (Math.abs(e - HALF_PI) < EPSLN ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(e) < EPSLN ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var n;
    switch (this.qp = qsfnz(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = authset(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), n = Math.sin(this.lat0), this.sinb1 = qsfnz(this.e, n) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * n * n) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function forward$j(e) {
  var n, r, o, l, u, h, c, f, v, m, g = e.x, y = e.y;
  if (g = adjust_lon(g - this.long0), this.sphere) {
    if (u = Math.sin(y), m = Math.cos(y), o = Math.cos(g), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (r = this.mode === this.EQUIT ? 1 + m * o : 1 + this.sinph0 * u + this.cosph0 * m * o, r <= EPSLN)
        return null;
      r = Math.sqrt(2 / r), n = r * m * Math.sin(g), r *= this.mode === this.EQUIT ? u : this.cosph0 * u - this.sinph0 * m * o;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (o = -o), Math.abs(y + this.lat0) < EPSLN)
        return null;
      r = FORTPI - y * 0.5, r = 2 * (this.mode === this.S_POLE ? Math.cos(r) : Math.sin(r)), n = r * Math.sin(g), r *= o;
    }
  } else {
    switch (c = 0, f = 0, v = 0, o = Math.cos(g), l = Math.sin(g), u = Math.sin(y), h = qsfnz(this.e, u), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (c = h / this.qp, f = Math.sqrt(1 - c * c)), this.mode) {
      case this.OBLIQ:
        v = 1 + this.sinb1 * c + this.cosb1 * f * o;
        break;
      case this.EQUIT:
        v = 1 + f * o;
        break;
      case this.N_POLE:
        v = HALF_PI + y, h = this.qp - h;
        break;
      case this.S_POLE:
        v = y - HALF_PI, h = this.qp + h;
        break;
    }
    if (Math.abs(v) < EPSLN)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        v = Math.sqrt(2 / v), this.mode === this.OBLIQ ? r = this.ymf * v * (this.cosb1 * c - this.sinb1 * f * o) : r = (v = Math.sqrt(2 / (1 + f * o))) * c * this.ymf, n = this.xmf * v * f * l;
        break;
      case this.N_POLE:
      case this.S_POLE:
        h >= 0 ? (n = (v = Math.sqrt(h)) * l, r = o * (this.mode === this.S_POLE ? v : -v)) : n = r = 0;
        break;
    }
  }
  return e.x = this.a * n + this.x0, e.y = this.a * r + this.y0, e;
}
function inverse$j(e) {
  e.x -= this.x0, e.y -= this.y0;
  var n = e.x / this.a, r = e.y / this.a, o, l, u, h, c, f, v;
  if (this.sphere) {
    var m = 0, g, y = 0;
    if (g = Math.sqrt(n * n + r * r), l = g * 0.5, l > 1)
      return null;
    switch (l = 2 * Math.asin(l), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (y = Math.sin(l), m = Math.cos(l)), this.mode) {
      case this.EQUIT:
        l = Math.abs(g) <= EPSLN ? 0 : Math.asin(r * y / g), n *= y, r = m * g;
        break;
      case this.OBLIQ:
        l = Math.abs(g) <= EPSLN ? this.lat0 : Math.asin(m * this.sinph0 + r * y * this.cosph0 / g), n *= y * this.cosph0, r = (m - Math.sin(l) * this.sinph0) * g;
        break;
      case this.N_POLE:
        r = -r, l = HALF_PI - l;
        break;
      case this.S_POLE:
        l -= HALF_PI;
        break;
    }
    o = r === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(n, r);
  } else {
    if (v = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (n /= this.dd, r *= this.dd, f = Math.sqrt(n * n + r * r), f < EPSLN)
        return e.x = this.long0, e.y = this.lat0, e;
      h = 2 * Math.asin(0.5 * f / this.rq), u = Math.cos(h), n *= h = Math.sin(h), this.mode === this.OBLIQ ? (v = u * this.sinb1 + r * h * this.cosb1 / f, c = this.qp * v, r = f * this.cosb1 * u - r * this.sinb1 * h) : (v = r * h / f, c = this.qp * v, r = f * u);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (r = -r), c = n * n + r * r, !c)
        return e.x = this.long0, e.y = this.lat0, e;
      v = 1 - c / this.qp, this.mode === this.S_POLE && (v = -v);
    }
    o = Math.atan2(n, r), l = authlat(Math.asin(v), this.apa);
  }
  return e.x = adjust_lon(this.long0 + o), e.y = l, e;
}
var P00 = 0.3333333333333333, P01 = 0.17222222222222222, P02 = 0.10257936507936508, P10 = 0.06388888888888888, P11 = 0.0664021164021164, P20 = 0.016415012942191543;
function authset(e) {
  var n, r = [];
  return r[0] = e * P00, n = e * e, r[0] += n * P01, r[1] = n * P10, n *= e, r[0] += n * P02, r[1] += n * P11, r[2] = n * P20, r;
}
function authlat(e, n) {
  var r = e + e;
  return e + n[0] * Math.sin(r) + n[1] * Math.sin(r + r) + n[2] * Math.sin(r + r + r);
}
var names$j = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const laea = {
  init: init$j,
  forward: forward$j,
  inverse: inverse$j,
  names: names$j,
  S_POLE,
  N_POLE,
  EQUIT,
  OBLIQ
};
function asinz(e) {
  return Math.abs(e) > 1 && (e = e > 1 ? 1 : -1), Math.asin(e);
}
function init$i() {
  Math.abs(this.lat1 + this.lat2) < EPSLN || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po), this.qs1 = qsfnz(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po), this.qs2 = qsfnz(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = qsfnz(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > EPSLN ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function forward$i(e) {
  var n = e.x, r = e.y;
  this.sin_phi = Math.sin(r), this.cos_phi = Math.cos(r);
  var o = qsfnz(this.e3, this.sin_phi), l = this.a * Math.sqrt(this.c - this.ns0 * o) / this.ns0, u = this.ns0 * adjust_lon(n - this.long0), h = l * Math.sin(u) + this.x0, c = this.rh - l * Math.cos(u) + this.y0;
  return e.x = h, e.y = c, e;
}
function inverse$i(e) {
  var n, r, o, l, u, h;
  return e.x -= this.x0, e.y = this.rh - e.y + this.y0, this.ns0 >= 0 ? (n = Math.sqrt(e.x * e.x + e.y * e.y), o = 1) : (n = -Math.sqrt(e.x * e.x + e.y * e.y), o = -1), l = 0, n !== 0 && (l = Math.atan2(o * e.x, o * e.y)), o = n * this.ns0 / this.a, this.sphere ? h = Math.asin((this.c - o * o) / (2 * this.ns0)) : (r = (this.c - o * o) / this.ns0, h = this.phi1z(this.e3, r)), u = adjust_lon(l / this.ns0 + this.long0), e.x = u, e.y = h, e;
}
function phi1z(e, n) {
  var r, o, l, u, h, c = asinz(0.5 * n);
  if (e < EPSLN)
    return c;
  for (var f = e * e, v = 1; v <= 25; v++)
    if (r = Math.sin(c), o = Math.cos(c), l = e * r, u = 1 - l * l, h = 0.5 * u * u / o * (n / (1 - f) - r / u + 0.5 / e * Math.log((1 - l) / (1 + l))), c = c + h, Math.abs(h) <= 1e-7)
      return c;
  return null;
}
var names$i = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const aea = {
  init: init$i,
  forward: forward$i,
  inverse: inverse$i,
  names: names$i,
  phi1z
};
function init$h() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function forward$h(e) {
  var n, r, o, l, u, h, c, f, v = e.x, m = e.y;
  return o = adjust_lon(v - this.long0), n = Math.sin(m), r = Math.cos(m), l = Math.cos(o), h = this.sin_p14 * n + this.cos_p14 * r * l, u = 1, h > 0 || Math.abs(h) <= EPSLN ? (c = this.x0 + this.a * u * r * Math.sin(o) / h, f = this.y0 + this.a * u * (this.cos_p14 * n - this.sin_p14 * r * l) / h) : (c = this.x0 + this.infinity_dist * r * Math.sin(o), f = this.y0 + this.infinity_dist * (this.cos_p14 * n - this.sin_p14 * r * l)), e.x = c, e.y = f, e;
}
function inverse$h(e) {
  var n, r, o, l, u, h;
  return e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, e.x /= this.k0, e.y /= this.k0, (n = Math.sqrt(e.x * e.x + e.y * e.y)) ? (l = Math.atan2(n, this.rc), r = Math.sin(l), o = Math.cos(l), h = asinz(o * this.sin_p14 + e.y * r * this.cos_p14 / n), u = Math.atan2(e.x * r, n * this.cos_p14 * o - e.y * this.sin_p14 * r), u = adjust_lon(this.long0 + u)) : (h = this.phic0, u = 0), e.x = u, e.y = h, e;
}
var names$h = ["gnom"];
const gnom = {
  init: init$h,
  forward: forward$h,
  inverse: inverse$h,
  names: names$h
};
function iqsfnz(e, n) {
  var r = 1 - (1 - e * e) / (2 * e) * Math.log((1 - e) / (1 + e));
  if (Math.abs(Math.abs(n) - r) < 1e-6)
    return n < 0 ? -1 * HALF_PI : HALF_PI;
  for (var o = Math.asin(0.5 * n), l, u, h, c, f = 0; f < 30; f++)
    if (u = Math.sin(o), h = Math.cos(o), c = e * u, l = Math.pow(1 - c * c, 2) / (2 * h) * (n / (1 - e * e) - u / (1 - c * c) + 0.5 / e * Math.log((1 - c) / (1 + c))), o += l, Math.abs(l) <= 1e-10)
      return o;
  return NaN;
}
function init$g() {
  this.sphere || (this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function forward$g(e) {
  var n = e.x, r = e.y, o, l, u = adjust_lon(n - this.long0);
  if (this.sphere)
    o = this.x0 + this.a * u * Math.cos(this.lat_ts), l = this.y0 + this.a * Math.sin(r) / Math.cos(this.lat_ts);
  else {
    var h = qsfnz(this.e, Math.sin(r));
    o = this.x0 + this.a * this.k0 * u, l = this.y0 + this.a * h * 0.5 / this.k0;
  }
  return e.x = o, e.y = l, e;
}
function inverse$g(e) {
  e.x -= this.x0, e.y -= this.y0;
  var n, r;
  return this.sphere ? (n = adjust_lon(this.long0 + e.x / this.a / Math.cos(this.lat_ts)), r = Math.asin(e.y / this.a * Math.cos(this.lat_ts))) : (r = iqsfnz(this.e, 2 * e.y * this.k0 / this.a), n = adjust_lon(this.long0 + e.x / (this.a * this.k0))), e.x = n, e.y = r, e;
}
var names$g = ["cea"];
const cea = {
  init: init$g,
  forward: forward$g,
  inverse: inverse$g,
  names: names$g
};
function init$f() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function forward$f(e) {
  var n = e.x, r = e.y, o = adjust_lon(n - this.long0), l = adjust_lat(r - this.lat0);
  return e.x = this.x0 + this.a * o * this.rc, e.y = this.y0 + this.a * l, e;
}
function inverse$f(e) {
  var n = e.x, r = e.y;
  return e.x = adjust_lon(this.long0 + (n - this.x0) / (this.a * this.rc)), e.y = adjust_lat(this.lat0 + (r - this.y0) / this.a), e;
}
var names$f = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const eqc = {
  init: init$f,
  forward: forward$f,
  inverse: inverse$f,
  names: names$f
};
var MAX_ITER$1 = 20;
function init$e() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = e0fn(this.es), this.e1 = e1fn(this.es), this.e2 = e2fn(this.es), this.e3 = e3fn(this.es), this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward$e(e) {
  var n = e.x, r = e.y, o, l, u, h = adjust_lon(n - this.long0);
  if (u = h * Math.sin(r), this.sphere)
    Math.abs(r) <= EPSLN ? (o = this.a * h, l = -1 * this.a * this.lat0) : (o = this.a * Math.sin(u) / Math.tan(r), l = this.a * (adjust_lat(r - this.lat0) + (1 - Math.cos(u)) / Math.tan(r)));
  else if (Math.abs(r) <= EPSLN)
    o = this.a * h, l = -1 * this.ml0;
  else {
    var c = gN(this.a, this.e, Math.sin(r)) / Math.tan(r);
    o = c * Math.sin(u), l = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, r) - this.ml0 + c * (1 - Math.cos(u));
  }
  return e.x = o + this.x0, e.y = l + this.y0, e;
}
function inverse$e(e) {
  var n, r, o, l, u, h, c, f, v;
  if (o = e.x - this.x0, l = e.y - this.y0, this.sphere)
    if (Math.abs(l + this.a * this.lat0) <= EPSLN)
      n = adjust_lon(o / this.a + this.long0), r = 0;
    else {
      h = this.lat0 + l / this.a, c = o * o / this.a / this.a + h * h, f = h;
      var m;
      for (u = MAX_ITER$1; u; --u)
        if (m = Math.tan(f), v = -1 * (h * (f * m + 1) - f - 0.5 * (f * f + c) * m) / ((f - h) / m - 1), f += v, Math.abs(v) <= EPSLN) {
          r = f;
          break;
        }
      n = adjust_lon(this.long0 + Math.asin(o * Math.tan(f) / this.a) / Math.sin(r));
    }
  else if (Math.abs(l + this.ml0) <= EPSLN)
    r = 0, n = adjust_lon(this.long0 + o / this.a);
  else {
    h = (this.ml0 + l) / this.a, c = o * o / this.a / this.a + h * h, f = h;
    var g, y, w, E, x;
    for (u = MAX_ITER$1; u; --u)
      if (x = this.e * Math.sin(f), g = Math.sqrt(1 - x * x) * Math.tan(f), y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, f), w = this.e0 - 2 * this.e1 * Math.cos(2 * f) + 4 * this.e2 * Math.cos(4 * f) - 6 * this.e3 * Math.cos(6 * f), E = y / this.a, v = (h * (g * E + 1) - E - 0.5 * g * (E * E + c)) / (this.es * Math.sin(2 * f) * (E * E + c - 2 * h * E) / (4 * g) + (h - E) * (g * w - 2 / Math.sin(2 * f)) - w), f -= v, Math.abs(v) <= EPSLN) {
        r = f;
        break;
      }
    g = Math.sqrt(1 - this.es * Math.pow(Math.sin(r), 2)) * Math.tan(r), n = adjust_lon(this.long0 + Math.asin(o * g / this.a) / Math.sin(r));
  }
  return e.x = n, e.y = r, e;
}
var names$e = ["Polyconic", "poly"];
const poly = {
  init: init$e,
  forward: forward$e,
  inverse: inverse$e,
  names: names$e
};
function init$d() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function forward$d(e) {
  var n, r = e.x, o = e.y, l = o - this.lat0, u = r - this.long0, h = l / SEC_TO_RAD * 1e-5, c = u, f = 1, v = 0;
  for (n = 1; n <= 10; n++)
    f = f * h, v = v + this.A[n] * f;
  var m = v, g = c, y = 1, w = 0, E, x, D = 0, F = 0;
  for (n = 1; n <= 6; n++)
    E = y * m - w * g, x = w * m + y * g, y = E, w = x, D = D + this.B_re[n] * y - this.B_im[n] * w, F = F + this.B_im[n] * y + this.B_re[n] * w;
  return e.x = F * this.a + this.x0, e.y = D * this.a + this.y0, e;
}
function inverse$d(e) {
  var n, r = e.x, o = e.y, l = r - this.x0, u = o - this.y0, h = u / this.a, c = l / this.a, f = 1, v = 0, m, g, y = 0, w = 0;
  for (n = 1; n <= 6; n++)
    m = f * h - v * c, g = v * h + f * c, f = m, v = g, y = y + this.C_re[n] * f - this.C_im[n] * v, w = w + this.C_im[n] * f + this.C_re[n] * v;
  for (var E = 0; E < this.iterations; E++) {
    var x = y, D = w, F, k, N = h, H = c;
    for (n = 2; n <= 6; n++)
      F = x * y - D * w, k = D * y + x * w, x = F, D = k, N = N + (n - 1) * (this.B_re[n] * x - this.B_im[n] * D), H = H + (n - 1) * (this.B_im[n] * x + this.B_re[n] * D);
    x = 1, D = 0;
    var R = this.B_re[1], j = this.B_im[1];
    for (n = 2; n <= 6; n++)
      F = x * y - D * w, k = D * y + x * w, x = F, D = k, R = R + n * (this.B_re[n] * x - this.B_im[n] * D), j = j + n * (this.B_im[n] * x + this.B_re[n] * D);
    var S = R * R + j * j;
    y = (N * R + H * j) / S, w = (H * R - N * j) / S;
  }
  var tt = y, nt = w, ft = 1, pt = 0;
  for (n = 1; n <= 9; n++)
    ft = ft * tt, pt = pt + this.D[n] * ft;
  var ct = this.lat0 + pt * SEC_TO_RAD * 1e5, Nt = this.long0 + nt;
  return e.x = Nt, e.y = ct, e;
}
var names$d = ["New_Zealand_Map_Grid", "nzmg"];
const nzmg = {
  init: init$d,
  forward: forward$d,
  inverse: inverse$d,
  names: names$d
};
function init$c() {
}
function forward$c(e) {
  var n = e.x, r = e.y, o = adjust_lon(n - this.long0), l = this.x0 + this.a * o, u = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + r / 2.5)) * 1.25;
  return e.x = l, e.y = u, e;
}
function inverse$c(e) {
  e.x -= this.x0, e.y -= this.y0;
  var n = adjust_lon(this.long0 + e.x / this.a), r = 2.5 * (Math.atan(Math.exp(0.8 * e.y / this.a)) - Math.PI / 4);
  return e.x = n, e.y = r, e;
}
var names$c = ["Miller_Cylindrical", "mill"];
const mill = {
  init: init$c,
  forward: forward$c,
  inverse: inverse$c,
  names: names$c
};
var MAX_ITER = 20;
function init$b() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = pj_enfn(this.es);
}
function forward$b(e) {
  var n, r, o = e.x, l = e.y;
  if (o = adjust_lon(o - this.long0), this.sphere) {
    if (!this.m)
      l = this.n !== 1 ? Math.asin(this.n * Math.sin(l)) : l;
    else
      for (var u = this.n * Math.sin(l), h = MAX_ITER; h; --h) {
        var c = (this.m * l + Math.sin(l) - u) / (this.m + Math.cos(l));
        if (l -= c, Math.abs(c) < EPSLN)
          break;
      }
    n = this.a * this.C_x * o * (this.m + Math.cos(l)), r = this.a * this.C_y * l;
  } else {
    var f = Math.sin(l), v = Math.cos(l);
    r = this.a * pj_mlfn(l, f, v, this.en), n = this.a * o * v / Math.sqrt(1 - this.es * f * f);
  }
  return e.x = n, e.y = r, e;
}
function inverse$b(e) {
  var n, r, o, l;
  return e.x -= this.x0, o = e.x / this.a, e.y -= this.y0, n = e.y / this.a, this.sphere ? (n /= this.C_y, o = o / (this.C_x * (this.m + Math.cos(n))), this.m ? n = asinz((this.m * n + Math.sin(n)) / this.n) : this.n !== 1 && (n = asinz(Math.sin(n) / this.n)), o = adjust_lon(o + this.long0), n = adjust_lat(n)) : (n = pj_inv_mlfn(e.y / this.a, this.es, this.en), l = Math.abs(n), l < HALF_PI ? (l = Math.sin(n), r = this.long0 + e.x * Math.sqrt(1 - this.es * l * l) / (this.a * Math.cos(n)), o = adjust_lon(r)) : l - EPSLN < HALF_PI && (o = this.long0)), e.x = o, e.y = n, e;
}
var names$b = ["Sinusoidal", "sinu"];
const sinu = {
  init: init$b,
  forward: forward$b,
  inverse: inverse$b,
  names: names$b
};
function init$a() {
}
function forward$a(e) {
  for (var n = e.x, r = e.y, o = adjust_lon(n - this.long0), l = r, u = Math.PI * Math.sin(r); ; ) {
    var h = -(l + Math.sin(l) - u) / (1 + Math.cos(l));
    if (l += h, Math.abs(h) < EPSLN)
      break;
  }
  l /= 2, Math.PI / 2 - Math.abs(r) < EPSLN && (o = 0);
  var c = 0.900316316158 * this.a * o * Math.cos(l) + this.x0, f = 1.4142135623731 * this.a * Math.sin(l) + this.y0;
  return e.x = c, e.y = f, e;
}
function inverse$a(e) {
  var n, r;
  e.x -= this.x0, e.y -= this.y0, r = e.y / (1.4142135623731 * this.a), Math.abs(r) > 0.999999999999 && (r = 0.999999999999), n = Math.asin(r);
  var o = adjust_lon(this.long0 + e.x / (0.900316316158 * this.a * Math.cos(n)));
  o < -Math.PI && (o = -Math.PI), o > Math.PI && (o = Math.PI), r = (2 * n + Math.sin(2 * n)) / Math.PI, Math.abs(r) > 1 && (r = 1);
  var l = Math.asin(r);
  return e.x = o, e.y = l, e;
}
var names$a = ["Mollweide", "moll"];
const moll = {
  init: init$a,
  forward: forward$a,
  inverse: inverse$a,
  names: names$a
};
function init$9() {
  Math.abs(this.lat1 + this.lat2) < EPSLN || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = e0fn(this.es), this.e1 = e1fn(this.es), this.e2 = e2fn(this.es), this.e3 = e3fn(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = msfnz(this.e, this.sinphi, this.cosphi), this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < EPSLN ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = msfnz(this.e, this.sinphi, this.cosphi), this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function forward$9(e) {
  var n = e.x, r = e.y, o;
  if (this.sphere)
    o = this.a * (this.g - r);
  else {
    var l = mlfn(this.e0, this.e1, this.e2, this.e3, r);
    o = this.a * (this.g - l);
  }
  var u = this.ns * adjust_lon(n - this.long0), h = this.x0 + o * Math.sin(u), c = this.y0 + this.rh - o * Math.cos(u);
  return e.x = h, e.y = c, e;
}
function inverse$9(e) {
  e.x -= this.x0, e.y = this.rh - e.y + this.y0;
  var n, r, o, l;
  this.ns >= 0 ? (r = Math.sqrt(e.x * e.x + e.y * e.y), n = 1) : (r = -Math.sqrt(e.x * e.x + e.y * e.y), n = -1);
  var u = 0;
  if (r !== 0 && (u = Math.atan2(n * e.x, n * e.y)), this.sphere)
    return l = adjust_lon(this.long0 + u / this.ns), o = adjust_lat(this.g - r / this.a), e.x = l, e.y = o, e;
  var h = this.g - r / this.a;
  return o = imlfn(h, this.e0, this.e1, this.e2, this.e3), l = adjust_lon(this.long0 + u / this.ns), e.x = l, e.y = o, e;
}
var names$9 = ["Equidistant_Conic", "eqdc"];
const eqdc = {
  init: init$9,
  forward: forward$9,
  inverse: inverse$9,
  names: names$9
};
function init$8() {
  this.R = this.a;
}
function forward$8(e) {
  var n = e.x, r = e.y, o = adjust_lon(n - this.long0), l, u;
  Math.abs(r) <= EPSLN && (l = this.x0 + this.R * o, u = this.y0);
  var h = asinz(2 * Math.abs(r / Math.PI));
  (Math.abs(o) <= EPSLN || Math.abs(Math.abs(r) - HALF_PI) <= EPSLN) && (l = this.x0, r >= 0 ? u = this.y0 + Math.PI * this.R * Math.tan(0.5 * h) : u = this.y0 + Math.PI * this.R * -Math.tan(0.5 * h));
  var c = 0.5 * Math.abs(Math.PI / o - o / Math.PI), f = c * c, v = Math.sin(h), m = Math.cos(h), g = m / (v + m - 1), y = g * g, w = g * (2 / v - 1), E = w * w, x = Math.PI * this.R * (c * (g - E) + Math.sqrt(f * (g - E) * (g - E) - (E + f) * (y - E))) / (E + f);
  o < 0 && (x = -x), l = this.x0 + x;
  var D = f + g;
  return x = Math.PI * this.R * (w * D - c * Math.sqrt((E + f) * (f + 1) - D * D)) / (E + f), r >= 0 ? u = this.y0 + x : u = this.y0 - x, e.x = l, e.y = u, e;
}
function inverse$8(e) {
  var n, r, o, l, u, h, c, f, v, m, g, y, w;
  return e.x -= this.x0, e.y -= this.y0, g = Math.PI * this.R, o = e.x / g, l = e.y / g, u = o * o + l * l, h = -Math.abs(l) * (1 + u), c = h - 2 * l * l + o * o, f = -2 * h + 1 + 2 * l * l + u * u, w = l * l / f + (2 * c * c * c / f / f / f - 9 * h * c / f / f) / 27, v = (h - c * c / 3 / f) / f, m = 2 * Math.sqrt(-v / 3), g = 3 * w / v / m, Math.abs(g) > 1 && (g >= 0 ? g = 1 : g = -1), y = Math.acos(g) / 3, e.y >= 0 ? r = (-m * Math.cos(y + Math.PI / 3) - c / 3 / f) * Math.PI : r = -(-m * Math.cos(y + Math.PI / 3) - c / 3 / f) * Math.PI, Math.abs(o) < EPSLN ? n = this.long0 : n = adjust_lon(this.long0 + Math.PI * (u - 1 + Math.sqrt(1 + 2 * (o * o - l * l) + u * u)) / 2 / o), e.x = n, e.y = r, e;
}
var names$8 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const vandg = {
  init: init$8,
  forward: forward$8,
  inverse: inverse$8,
  names: names$8
};
function init$7() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}
function forward$7(e) {
  var n = e.x, r = e.y, o = Math.sin(e.y), l = Math.cos(e.y), u = adjust_lon(n - this.long0), h, c, f, v, m, g, y, w, E, x, D, F, k, N, H, R, j, S, tt, nt, ft, pt, ct;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= EPSLN ? (e.x = this.x0 + this.a * (HALF_PI - r) * Math.sin(u), e.y = this.y0 - this.a * (HALF_PI - r) * Math.cos(u), e) : Math.abs(this.sin_p12 + 1) <= EPSLN ? (e.x = this.x0 + this.a * (HALF_PI + r) * Math.sin(u), e.y = this.y0 + this.a * (HALF_PI + r) * Math.cos(u), e) : (S = this.sin_p12 * o + this.cos_p12 * l * Math.cos(u), R = Math.acos(S), j = R ? R / Math.sin(R) : 1, e.x = this.x0 + this.a * j * l * Math.sin(u), e.y = this.y0 + this.a * j * (this.cos_p12 * o - this.sin_p12 * l * Math.cos(u)), e) : (h = e0fn(this.es), c = e1fn(this.es), f = e2fn(this.es), v = e3fn(this.es), Math.abs(this.sin_p12 - 1) <= EPSLN ? (m = this.a * mlfn(h, c, f, v, HALF_PI), g = this.a * mlfn(h, c, f, v, r), e.x = this.x0 + (m - g) * Math.sin(u), e.y = this.y0 - (m - g) * Math.cos(u), e) : Math.abs(this.sin_p12 + 1) <= EPSLN ? (m = this.a * mlfn(h, c, f, v, HALF_PI), g = this.a * mlfn(h, c, f, v, r), e.x = this.x0 + (m + g) * Math.sin(u), e.y = this.y0 + (m + g) * Math.cos(u), e) : (y = o / l, w = gN(this.a, this.e, this.sin_p12), E = gN(this.a, this.e, o), x = Math.atan((1 - this.es) * y + this.es * w * this.sin_p12 / (E * l)), D = Math.atan2(Math.sin(u), this.cos_p12 * Math.tan(x) - this.sin_p12 * Math.cos(u)), D === 0 ? tt = Math.asin(this.cos_p12 * Math.sin(x) - this.sin_p12 * Math.cos(x)) : Math.abs(Math.abs(D) - Math.PI) <= EPSLN ? tt = -Math.asin(this.cos_p12 * Math.sin(x) - this.sin_p12 * Math.cos(x)) : tt = Math.asin(Math.sin(u) * Math.cos(x) / Math.sin(D)), F = this.e * this.sin_p12 / Math.sqrt(1 - this.es), k = this.e * this.cos_p12 * Math.cos(D) / Math.sqrt(1 - this.es), N = F * k, H = k * k, nt = tt * tt, ft = nt * tt, pt = ft * tt, ct = pt * tt, R = w * tt * (1 - nt * H * (1 - H) / 6 + ft / 8 * N * (1 - 2 * H) + pt / 120 * (H * (4 - 7 * H) - 3 * F * F * (1 - 7 * H)) - ct / 48 * N), e.x = this.x0 + R * Math.sin(D), e.y = this.y0 + R * Math.cos(D), e));
}
function inverse$7(e) {
  e.x -= this.x0, e.y -= this.y0;
  var n, r, o, l, u, h, c, f, v, m, g, y, w, E, x, D, F, k, N, H, R, j, S, tt;
  return this.sphere ? (n = Math.sqrt(e.x * e.x + e.y * e.y), n > 2 * HALF_PI * this.a ? void 0 : (r = n / this.a, o = Math.sin(r), l = Math.cos(r), u = this.long0, Math.abs(n) <= EPSLN ? h = this.lat0 : (h = asinz(l * this.sin_p12 + e.y * o * this.cos_p12 / n), c = Math.abs(this.lat0) - HALF_PI, Math.abs(c) <= EPSLN ? this.lat0 >= 0 ? u = adjust_lon(this.long0 + Math.atan2(e.x, -e.y)) : u = adjust_lon(this.long0 - Math.atan2(-e.x, e.y)) : u = adjust_lon(this.long0 + Math.atan2(e.x * o, n * this.cos_p12 * l - e.y * this.sin_p12 * o))), e.x = u, e.y = h, e)) : (f = e0fn(this.es), v = e1fn(this.es), m = e2fn(this.es), g = e3fn(this.es), Math.abs(this.sin_p12 - 1) <= EPSLN ? (y = this.a * mlfn(f, v, m, g, HALF_PI), n = Math.sqrt(e.x * e.x + e.y * e.y), w = y - n, h = imlfn(w / this.a, f, v, m, g), u = adjust_lon(this.long0 + Math.atan2(e.x, -1 * e.y)), e.x = u, e.y = h, e) : Math.abs(this.sin_p12 + 1) <= EPSLN ? (y = this.a * mlfn(f, v, m, g, HALF_PI), n = Math.sqrt(e.x * e.x + e.y * e.y), w = n - y, h = imlfn(w / this.a, f, v, m, g), u = adjust_lon(this.long0 + Math.atan2(e.x, e.y)), e.x = u, e.y = h, e) : (n = Math.sqrt(e.x * e.x + e.y * e.y), D = Math.atan2(e.x, e.y), E = gN(this.a, this.e, this.sin_p12), F = Math.cos(D), k = this.e * this.cos_p12 * F, N = -k * k / (1 - this.es), H = 3 * this.es * (1 - N) * this.sin_p12 * this.cos_p12 * F / (1 - this.es), R = n / E, j = R - N * (1 + N) * Math.pow(R, 3) / 6 - H * (1 + 3 * N) * Math.pow(R, 4) / 24, S = 1 - N * j * j / 2 - R * j * j * j / 6, x = Math.asin(this.sin_p12 * Math.cos(j) + this.cos_p12 * Math.sin(j) * F), u = adjust_lon(this.long0 + Math.asin(Math.sin(D) * Math.sin(j) / Math.cos(x))), tt = Math.sin(x), h = Math.atan2((tt - this.es * S * this.sin_p12) * Math.tan(x), tt * (1 - this.es)), e.x = u, e.y = h, e));
}
var names$7 = ["Azimuthal_Equidistant", "aeqd"];
const aeqd = {
  init: init$7,
  forward: forward$7,
  inverse: inverse$7,
  names: names$7
};
function init$6() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function forward$6(e) {
  var n, r, o, l, u, h, c, f, v = e.x, m = e.y;
  return o = adjust_lon(v - this.long0), n = Math.sin(m), r = Math.cos(m), l = Math.cos(o), h = this.sin_p14 * n + this.cos_p14 * r * l, u = 1, (h > 0 || Math.abs(h) <= EPSLN) && (c = this.a * u * r * Math.sin(o), f = this.y0 + this.a * u * (this.cos_p14 * n - this.sin_p14 * r * l)), e.x = c, e.y = f, e;
}
function inverse$6(e) {
  var n, r, o, l, u, h, c;
  return e.x -= this.x0, e.y -= this.y0, n = Math.sqrt(e.x * e.x + e.y * e.y), r = asinz(n / this.a), o = Math.sin(r), l = Math.cos(r), h = this.long0, Math.abs(n) <= EPSLN ? (c = this.lat0, e.x = h, e.y = c, e) : (c = asinz(l * this.sin_p14 + e.y * o * this.cos_p14 / n), u = Math.abs(this.lat0) - HALF_PI, Math.abs(u) <= EPSLN ? (this.lat0 >= 0 ? h = adjust_lon(this.long0 + Math.atan2(e.x, -e.y)) : h = adjust_lon(this.long0 - Math.atan2(-e.x, e.y)), e.x = h, e.y = c, e) : (h = adjust_lon(this.long0 + Math.atan2(e.x * o, n * this.cos_p14 * l - e.y * this.sin_p14 * o)), e.x = h, e.y = c, e));
}
var names$6 = ["ortho"];
const ortho = {
  init: init$6,
  forward: forward$6,
  inverse: inverse$6,
  names: names$6
};
var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function init$5() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= HALF_PI - FORTPI / 2 ? this.face = FACE_ENUM.TOP : this.lat0 <= -(HALF_PI - FORTPI / 2) ? this.face = FACE_ENUM.BOTTOM : Math.abs(this.long0) <= FORTPI ? this.face = FACE_ENUM.FRONT : Math.abs(this.long0) <= HALF_PI + FORTPI ? this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT : this.face = FACE_ENUM.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function forward$5(e) {
  var n = { x: 0, y: 0 }, r, o, l, u, h, c, f = { value: 0 };
  if (e.x -= this.long0, this.es !== 0 ? r = Math.atan(this.one_minus_f_squared * Math.tan(e.y)) : r = e.y, o = e.x, this.face === FACE_ENUM.TOP)
    u = HALF_PI - r, o >= FORTPI && o <= HALF_PI + FORTPI ? (f.value = AREA_ENUM.AREA_0, l = o - HALF_PI) : o > HALF_PI + FORTPI || o <= -(HALF_PI + FORTPI) ? (f.value = AREA_ENUM.AREA_1, l = o > 0 ? o - SPI : o + SPI) : o > -(HALF_PI + FORTPI) && o <= -FORTPI ? (f.value = AREA_ENUM.AREA_2, l = o + HALF_PI) : (f.value = AREA_ENUM.AREA_3, l = o);
  else if (this.face === FACE_ENUM.BOTTOM)
    u = HALF_PI + r, o >= FORTPI && o <= HALF_PI + FORTPI ? (f.value = AREA_ENUM.AREA_0, l = -o + HALF_PI) : o < FORTPI && o >= -FORTPI ? (f.value = AREA_ENUM.AREA_1, l = -o) : o < -FORTPI && o >= -(HALF_PI + FORTPI) ? (f.value = AREA_ENUM.AREA_2, l = -o - HALF_PI) : (f.value = AREA_ENUM.AREA_3, l = o > 0 ? -o + SPI : -o - SPI);
  else {
    var v, m, g, y, w, E, x;
    this.face === FACE_ENUM.RIGHT ? o = qsc_shift_lon_origin(o, +HALF_PI) : this.face === FACE_ENUM.BACK ? o = qsc_shift_lon_origin(o, +SPI) : this.face === FACE_ENUM.LEFT && (o = qsc_shift_lon_origin(o, -HALF_PI)), y = Math.sin(r), w = Math.cos(r), E = Math.sin(o), x = Math.cos(o), v = w * x, m = w * E, g = y, this.face === FACE_ENUM.FRONT ? (u = Math.acos(v), l = qsc_fwd_equat_face_theta(u, g, m, f)) : this.face === FACE_ENUM.RIGHT ? (u = Math.acos(m), l = qsc_fwd_equat_face_theta(u, g, -v, f)) : this.face === FACE_ENUM.BACK ? (u = Math.acos(-v), l = qsc_fwd_equat_face_theta(u, g, -m, f)) : this.face === FACE_ENUM.LEFT ? (u = Math.acos(-m), l = qsc_fwd_equat_face_theta(u, g, v, f)) : (u = l = 0, f.value = AREA_ENUM.AREA_0);
  }
  return c = Math.atan(12 / SPI * (l + Math.acos(Math.sin(l) * Math.cos(FORTPI)) - HALF_PI)), h = Math.sqrt((1 - Math.cos(u)) / (Math.cos(c) * Math.cos(c)) / (1 - Math.cos(Math.atan(1 / Math.cos(l))))), f.value === AREA_ENUM.AREA_1 ? c += HALF_PI : f.value === AREA_ENUM.AREA_2 ? c += SPI : f.value === AREA_ENUM.AREA_3 && (c += 1.5 * SPI), n.x = h * Math.cos(c), n.y = h * Math.sin(c), n.x = n.x * this.a + this.x0, n.y = n.y * this.a + this.y0, e.x = n.x, e.y = n.y, e;
}
function inverse$5(e) {
  var n = { lam: 0, phi: 0 }, r, o, l, u, h, c, f, v, m, g = { value: 0 };
  if (e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, o = Math.atan(Math.sqrt(e.x * e.x + e.y * e.y)), r = Math.atan2(e.y, e.x), e.x >= 0 && e.x >= Math.abs(e.y) ? g.value = AREA_ENUM.AREA_0 : e.y >= 0 && e.y >= Math.abs(e.x) ? (g.value = AREA_ENUM.AREA_1, r -= HALF_PI) : e.x < 0 && -e.x >= Math.abs(e.y) ? (g.value = AREA_ENUM.AREA_2, r = r < 0 ? r + SPI : r - SPI) : (g.value = AREA_ENUM.AREA_3, r += HALF_PI), m = SPI / 12 * Math.tan(r), h = Math.sin(m) / (Math.cos(m) - 1 / Math.sqrt(2)), c = Math.atan(h), l = Math.cos(r), u = Math.tan(o), f = 1 - l * l * u * u * (1 - Math.cos(Math.atan(1 / Math.cos(c)))), f < -1 ? f = -1 : f > 1 && (f = 1), this.face === FACE_ENUM.TOP)
    v = Math.acos(f), n.phi = HALF_PI - v, g.value === AREA_ENUM.AREA_0 ? n.lam = c + HALF_PI : g.value === AREA_ENUM.AREA_1 ? n.lam = c < 0 ? c + SPI : c - SPI : g.value === AREA_ENUM.AREA_2 ? n.lam = c - HALF_PI : n.lam = c;
  else if (this.face === FACE_ENUM.BOTTOM)
    v = Math.acos(f), n.phi = v - HALF_PI, g.value === AREA_ENUM.AREA_0 ? n.lam = -c + HALF_PI : g.value === AREA_ENUM.AREA_1 ? n.lam = -c : g.value === AREA_ENUM.AREA_2 ? n.lam = -c - HALF_PI : n.lam = c < 0 ? -c - SPI : -c + SPI;
  else {
    var y, w, E;
    y = f, m = y * y, m >= 1 ? E = 0 : E = Math.sqrt(1 - m) * Math.sin(c), m += E * E, m >= 1 ? w = 0 : w = Math.sqrt(1 - m), g.value === AREA_ENUM.AREA_1 ? (m = w, w = -E, E = m) : g.value === AREA_ENUM.AREA_2 ? (w = -w, E = -E) : g.value === AREA_ENUM.AREA_3 && (m = w, w = E, E = -m), this.face === FACE_ENUM.RIGHT ? (m = y, y = -w, w = m) : this.face === FACE_ENUM.BACK ? (y = -y, w = -w) : this.face === FACE_ENUM.LEFT && (m = y, y = w, w = -m), n.phi = Math.acos(-E) - HALF_PI, n.lam = Math.atan2(w, y), this.face === FACE_ENUM.RIGHT ? n.lam = qsc_shift_lon_origin(n.lam, -HALF_PI) : this.face === FACE_ENUM.BACK ? n.lam = qsc_shift_lon_origin(n.lam, -SPI) : this.face === FACE_ENUM.LEFT && (n.lam = qsc_shift_lon_origin(n.lam, +HALF_PI));
  }
  if (this.es !== 0) {
    var x, D, F;
    x = n.phi < 0 ? 1 : 0, D = Math.tan(n.phi), F = this.b / Math.sqrt(D * D + this.one_minus_f_squared), n.phi = Math.atan(Math.sqrt(this.a * this.a - F * F) / (this.one_minus_f * F)), x && (n.phi = -n.phi);
  }
  return n.lam += this.long0, e.x = n.lam, e.y = n.phi, e;
}
function qsc_fwd_equat_face_theta(e, n, r, o) {
  var l;
  return e < EPSLN ? (o.value = AREA_ENUM.AREA_0, l = 0) : (l = Math.atan2(n, r), Math.abs(l) <= FORTPI ? o.value = AREA_ENUM.AREA_0 : l > FORTPI && l <= HALF_PI + FORTPI ? (o.value = AREA_ENUM.AREA_1, l -= HALF_PI) : l > HALF_PI + FORTPI || l <= -(HALF_PI + FORTPI) ? (o.value = AREA_ENUM.AREA_2, l = l >= 0 ? l - SPI : l + SPI) : (o.value = AREA_ENUM.AREA_3, l += HALF_PI)), l;
}
function qsc_shift_lon_origin(e, n) {
  var r = e + n;
  return r < -SPI ? r += TWO_PI : r > +SPI && (r -= TWO_PI), r;
}
var names$5 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const qsc = {
  init: init$5,
  forward: forward$5,
  inverse: inverse$5,
  names: names$5
};
var COEFS_X = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], COEFS_Y = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], FXC = 0.8487, FYC = 1.3523, C1 = R2D / 5, RC1 = 1 / C1, NODES = 18, poly3_val = function(e, n) {
  return e[0] + n * (e[1] + n * (e[2] + n * e[3]));
}, poly3_der = function(e, n) {
  return e[1] + n * (2 * e[2] + n * 3 * e[3]);
};
function newton_rapshon(e, n, r, o) {
  for (var l = n; o; --o) {
    var u = e(l);
    if (l -= u, Math.abs(u) < r)
      break;
  }
  return l;
}
function init$4() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function forward$4(e) {
  var n = adjust_lon(e.x - this.long0), r = Math.abs(e.y), o = Math.floor(r * C1);
  o < 0 ? o = 0 : o >= NODES && (o = NODES - 1), r = R2D * (r - RC1 * o);
  var l = {
    x: poly3_val(COEFS_X[o], r) * n,
    y: poly3_val(COEFS_Y[o], r)
  };
  return e.y < 0 && (l.y = -l.y), l.x = l.x * this.a * FXC + this.x0, l.y = l.y * this.a * FYC + this.y0, l;
}
function inverse$4(e) {
  var n = {
    x: (e.x - this.x0) / (this.a * FXC),
    y: Math.abs(e.y - this.y0) / (this.a * FYC)
  };
  if (n.y >= 1)
    n.x /= COEFS_X[NODES][0], n.y = e.y < 0 ? -HALF_PI : HALF_PI;
  else {
    var r = Math.floor(n.y * NODES);
    for (r < 0 ? r = 0 : r >= NODES && (r = NODES - 1); ; )
      if (COEFS_Y[r][0] > n.y)
        --r;
      else if (COEFS_Y[r + 1][0] <= n.y)
        ++r;
      else
        break;
    var o = COEFS_Y[r], l = 5 * (n.y - o[0]) / (COEFS_Y[r + 1][0] - o[0]);
    l = newton_rapshon(function(u) {
      return (poly3_val(o, u) - n.y) / poly3_der(o, u);
    }, l, EPSLN, 100), n.x /= poly3_val(COEFS_X[r], l), n.y = (5 * r + l) * D2R$1, e.y < 0 && (n.y = -n.y);
  }
  return n.x = adjust_lon(n.x + this.long0), n;
}
var names$4 = ["Robinson", "robin"];
const robin = {
  init: init$4,
  forward: forward$4,
  inverse: inverse$4,
  names: names$4
};
function init$3() {
  this.name = "geocent";
}
function forward$3(e) {
  var n = geodeticToGeocentric(e, this.es, this.a);
  return n;
}
function inverse$3(e) {
  var n = geocentricToGeodetic(e, this.es, this.a, this.b);
  return n;
}
var names$3 = ["Geocentric", "geocentric", "geocent", "Geocent"];
const geocent = {
  init: init$3,
  forward: forward$3,
  inverse: inverse$3,
  names: names$3
};
var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, params = {
  h: { def: 1e5, num: !0 },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: !0, degrees: !0 },
  // default is North
  tilt: { def: 0, num: !0, degrees: !0 },
  // default is Nadir
  long0: { def: 0, num: !0 },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: !0 }
  // default is Equator, conversion to rad is automatic
};
function init$2() {
  if (Object.keys(params).forEach((function(r) {
    if (typeof this[r] > "u")
      this[r] = params[r].def;
    else {
      if (params[r].num && isNaN(this[r]))
        throw new Error("Invalid parameter value, must be numeric " + r + " = " + this[r]);
      params[r].num && (this[r] = parseFloat(this[r]));
    }
    params[r].degrees && (this[r] = this[r] * D2R$1);
  }).bind(this)), Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN ? this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE : Math.abs(this.lat0) < EPSLN ? this.mode = mode.EQUIT : (this.mode = mode.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var e = this.tilt, n = this.azi;
  this.cg = Math.cos(n), this.sg = Math.sin(n), this.cw = Math.cos(e), this.sw = Math.sin(e);
}
function forward$2(e) {
  e.x -= this.long0;
  var n = Math.sin(e.y), r = Math.cos(e.y), o = Math.cos(e.x), l, u;
  switch (this.mode) {
    case mode.OBLIQ:
      u = this.sinph0 * n + this.cosph0 * r * o;
      break;
    case mode.EQUIT:
      u = r * o;
      break;
    case mode.S_POLE:
      u = -n;
      break;
    case mode.N_POLE:
      u = n;
      break;
  }
  switch (u = this.pn1 / (this.p - u), l = u * r * Math.sin(e.x), this.mode) {
    case mode.OBLIQ:
      u *= this.cosph0 * n - this.sinph0 * r * o;
      break;
    case mode.EQUIT:
      u *= n;
      break;
    case mode.N_POLE:
      u *= -(r * o);
      break;
    case mode.S_POLE:
      u *= r * o;
      break;
  }
  var h, c;
  return h = u * this.cg + l * this.sg, c = 1 / (h * this.sw * this.h1 + this.cw), l = (l * this.cg - u * this.sg) * this.cw * c, u = h * c, e.x = l * this.a, e.y = u * this.a, e;
}
function inverse$2(e) {
  e.x /= this.a, e.y /= this.a;
  var n = { x: e.x, y: e.y }, r, o, l;
  l = 1 / (this.pn1 - e.y * this.sw), r = this.pn1 * e.x * l, o = this.pn1 * e.y * this.cw * l, e.x = r * this.cg + o * this.sg, e.y = o * this.cg - r * this.sg;
  var u = hypot(e.x, e.y);
  if (Math.abs(u) < EPSLN)
    n.x = 0, n.y = e.y;
  else {
    var h, c;
    switch (c = 1 - u * u * this.pfact, c = (this.p - Math.sqrt(c)) / (this.pn1 / u + u / this.pn1), h = Math.sqrt(1 - c * c), this.mode) {
      case mode.OBLIQ:
        n.y = Math.asin(h * this.sinph0 + e.y * c * this.cosph0 / u), e.y = (h - this.sinph0 * Math.sin(n.y)) * u, e.x *= c * this.cosph0;
        break;
      case mode.EQUIT:
        n.y = Math.asin(e.y * c / u), e.y = h * u, e.x *= c;
        break;
      case mode.N_POLE:
        n.y = Math.asin(h), e.y = -e.y;
        break;
      case mode.S_POLE:
        n.y = -Math.asin(h);
        break;
    }
    n.x = Math.atan2(e.x, e.y);
  }
  return e.x = n.x + this.long0, e.y = n.y, e;
}
var names$2 = ["Tilted_Perspective", "tpers"];
const tpers = {
  init: init$2,
  forward: forward$2,
  inverse: inverse$2,
  names: names$2
};
function init$1() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var e = 1 - this.es, n = 1 / e;
    this.radius_p = Math.sqrt(e), this.radius_p2 = e, this.radius_p_inv2 = n, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function forward$1(e) {
  var n = e.x, r = e.y, o, l, u, h;
  if (n = n - this.long0, this.shape === "ellipse") {
    r = Math.atan(this.radius_p2 * Math.tan(r));
    var c = this.radius_p / hypot(this.radius_p * Math.cos(r), Math.sin(r));
    if (l = c * Math.cos(n) * Math.cos(r), u = c * Math.sin(n) * Math.cos(r), h = c * Math.sin(r), (this.radius_g - l) * l - u * u - h * h * this.radius_p_inv2 < 0)
      return e.x = Number.NaN, e.y = Number.NaN, e;
    o = this.radius_g - l, this.flip_axis ? (e.x = this.radius_g_1 * Math.atan(u / hypot(h, o)), e.y = this.radius_g_1 * Math.atan(h / o)) : (e.x = this.radius_g_1 * Math.atan(u / o), e.y = this.radius_g_1 * Math.atan(h / hypot(u, o)));
  } else
    this.shape === "sphere" && (o = Math.cos(r), l = Math.cos(n) * o, u = Math.sin(n) * o, h = Math.sin(r), o = this.radius_g - l, this.flip_axis ? (e.x = this.radius_g_1 * Math.atan(u / hypot(h, o)), e.y = this.radius_g_1 * Math.atan(h / o)) : (e.x = this.radius_g_1 * Math.atan(u / o), e.y = this.radius_g_1 * Math.atan(h / hypot(u, o))));
  return e.x = e.x * this.a, e.y = e.y * this.a, e;
}
function inverse$1(e) {
  var n = -1, r = 0, o = 0, l, u, h, c;
  if (e.x = e.x / this.a, e.y = e.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (o = Math.tan(e.y / this.radius_g_1), r = Math.tan(e.x / this.radius_g_1) * hypot(1, o)) : (r = Math.tan(e.x / this.radius_g_1), o = Math.tan(e.y / this.radius_g_1) * hypot(1, r));
    var f = o / this.radius_p;
    if (l = r * r + f * f + n * n, u = 2 * this.radius_g * n, h = u * u - 4 * l * this.C, h < 0)
      return e.x = Number.NaN, e.y = Number.NaN, e;
    c = (-u - Math.sqrt(h)) / (2 * l), n = this.radius_g + c * n, r *= c, o *= c, e.x = Math.atan2(r, n), e.y = Math.atan(o * Math.cos(e.x) / n), e.y = Math.atan(this.radius_p_inv2 * Math.tan(e.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (o = Math.tan(e.y / this.radius_g_1), r = Math.tan(e.x / this.radius_g_1) * Math.sqrt(1 + o * o)) : (r = Math.tan(e.x / this.radius_g_1), o = Math.tan(e.y / this.radius_g_1) * Math.sqrt(1 + r * r)), l = r * r + o * o + n * n, u = 2 * this.radius_g * n, h = u * u - 4 * l * this.C, h < 0)
      return e.x = Number.NaN, e.y = Number.NaN, e;
    c = (-u - Math.sqrt(h)) / (2 * l), n = this.radius_g + c * n, r *= c, o *= c, e.x = Math.atan2(r, n), e.y = Math.atan(o * Math.cos(e.x) / n);
  }
  return e.x = e.x + this.long0, e;
}
var names$1 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const geos = {
  init: init$1,
  forward: forward$1,
  inverse: inverse$1,
  names: names$1
};
var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = Math.sqrt(3) / 2;
function init() {
  this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}
function forward(e) {
  var n = adjust_lon(e.x - this.long0), r = e.y, o = Math.asin(M * Math.sin(r)), l = o * o, u = l * l * l;
  return e.x = n * Math.cos(o) / (M * (A1 + 3 * A2 * l + u * (7 * A3 + 9 * A4 * l))), e.y = o * (A1 + A2 * l + u * (A3 + A4 * l)), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function inverse(e) {
  e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a;
  var n = 1e-9, r = 12, o = e.y, l, u, h, c, f, v;
  for (v = 0; v < r && (l = o * o, u = l * l * l, h = o * (A1 + A2 * l + u * (A3 + A4 * l)) - e.y, c = A1 + 3 * A2 * l + u * (7 * A3 + 9 * A4 * l), o -= f = h / c, !(Math.abs(f) < n)); ++v)
    ;
  return l = o * o, u = l * l * l, e.x = M * e.x * (A1 + 3 * A2 * l + u * (7 * A3 + 9 * A4 * l)) / Math.cos(o), e.y = Math.asin(Math.sin(o) / M), e.x = adjust_lon(e.x + this.long0), e;
}
var names = ["eqearth", "Equal Earth", "Equal_Earth"];
const eqearth = {
  init,
  forward,
  inverse,
  names
};
function includedProjections(e) {
  e.Proj.projections.add(tmerc), e.Proj.projections.add(etmerc), e.Proj.projections.add(utm), e.Proj.projections.add(sterea), e.Proj.projections.add(stere), e.Proj.projections.add(somerc), e.Proj.projections.add(omerc), e.Proj.projections.add(lcc), e.Proj.projections.add(krovak), e.Proj.projections.add(cass), e.Proj.projections.add(laea), e.Proj.projections.add(aea), e.Proj.projections.add(gnom), e.Proj.projections.add(cea), e.Proj.projections.add(eqc), e.Proj.projections.add(poly), e.Proj.projections.add(nzmg), e.Proj.projections.add(mill), e.Proj.projections.add(sinu), e.Proj.projections.add(moll), e.Proj.projections.add(eqdc), e.Proj.projections.add(vandg), e.Proj.projections.add(aeqd), e.Proj.projections.add(ortho), e.Proj.projections.add(qsc), e.Proj.projections.add(robin), e.Proj.projections.add(geocent), e.Proj.projections.add(tpers), e.Proj.projections.add(geos), e.Proj.projections.add(eqearth);
}
proj4.defaultDatum = "WGS84";
proj4.Proj = Projection;
proj4.WGS84 = new proj4.Proj("WGS84");
proj4.Point = Point;
proj4.toPoint = common;
proj4.defs = defs;
proj4.nadgrid = nadgrid;
proj4.transform = transform;
proj4.mgrs = mgrs;
proj4.version = "__VERSION__";
includedProjections(proj4);
class CGCS200GKProZoon {
  constructor() {
    this._zoonepsg = {
      13: "EPSG:4491",
      14: "EPSG:4492",
      15: "EPSG:4493",
      16: "EPSG:4494",
      17: "EPSG:4495",
      18: "EPSG:4496",
      19: "EPSG:4497",
      20: "EPSG:4498",
      21: "EPSG:4499",
      22: "EPSG:4500",
      23: "EPSG:4501"
    }, this._proj4jsdesstr = {
      "EPSG:4501": "+proj=tmerc +lat_0=0 +lon_0=135 +k=1 +x_0=23500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs",
      "EPSG:4500": "+proj=tmerc +lat_0=0 +lon_0=129 +k=1 +x_0=22500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs",
      "EPSG:4499": "+proj=tmerc +lat_0=0 +lon_0=123 +k=1 +x_0=21500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs",
      "EPSG:4498": "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=20500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs",
      "EPSG:4497": "+proj=tmerc +lat_0=0 +lon_0=111 +k=1 +x_0=19500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs",
      "EPSG:4496": "+proj=tmerc +lat_0=0 +lon_0=105 +k=1 +x_0=18500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs",
      "EPSG:4495": "+proj=tmerc +lat_0=0 +lon_0=99 +k=1 +x_0=17500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs",
      "EPSG:4494": "+proj=tmerc +lat_0=0 +lon_0=93 +k=1 +x_0=16500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs",
      "EPSG:4493": "+proj=tmerc +lat_0=0 +lon_0=87 +k=1 +x_0=15500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs",
      "EPSG:4492": "+proj=tmerc +lat_0=0 +lon_0=81 +k=1 +x_0=14500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs",
      "EPSG:4491": "+proj=tmerc +lat_0=0 +lon_0=75 +k=1 +x_0=13500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs"
    }, this.init();
  }
  init() {
    Object.keys(this._proj4jsdesstr).forEach((r) => {
      typeof proj4.defs[r] > "u" && proj4.defs(r, this._proj4jsdesstr[r]);
    });
  }
  getLngZoon(n) {
    if (n)
      return Math.floor((n + 3) / 6) + 1;
  }
  geo2pro(n, r, o, l) {
    if (n && r && o && l)
      return proj4(o, l, [n, r]);
  }
  pro2geo(n, r, o, l) {
    if (n && r && o && l)
      return proj4(l, o, [n, r]);
  }
  getproepsgfromlng(n) {
    let r = this.getLngZoon(n);
    if (typeof r < "u")
      return this._zoonepsg[r];
  }
  getproepsgfromx(n) {
    if (typeof n < "u")
      return this._zoonepsg[Math.floor(n / 1e6)];
  }
  getZoons() {
    return Object.keys(this._zoonepsg);
  }
  getepsgs() {
    return Object.keys(this._proj4jsdesstr);
  }
}
class KiloMetersGridLayer extends FeatureLayer {
  constructor(n, r = null) {
    super(n, new FeatureLayerOptions()), this._lnglinesFeature = null, this._lngtexts = null, this._latlinesFeature = null, this._lattexts = null, this._zoom = this._map._map.getZoom(), this._projection = new CGCS200GKProZoon(), this._initialize();
  }
  static getInstance(n) {
    if (!KiloMetersGridLayer._instance) {
      let r = new FeatureLayerOptions("经纬网格");
      KiloMetersGridLayer._instance = new KiloMetersGridLayer(n, r);
    }
    return KiloMetersGridLayer._instance;
  }
  _initialize() {
    super._initialize(), this._lons = [], this._lats = [], this._points = [], this._texts = [], this._textPoints = [], this._constructLines(), this._latlinesFeature = new Feature(FeatureType.MultiLines);
    var n = new FeatureStyle({ lineColor: "#555555", lineWidth: 1 });
    this._latlinesFeature.setStyle(n), this._latlinesFeature.setPoints(this._points), this.addFeature(this._latlinesFeature), this._multiTextFeature = new Feature(FeatureType.MultiText), this._multiTextFeature.setTexts(this._texts), this._multiTextFeature.setPoints(this._textPoints), this.addFeature(this._multiTextFeature), this.hide();
  }
  _constructLines() {
    let n = this._map._map.getBounds();
    const r = this._map.getZoom();
    if (this._points = [], this._textPoints = [], this._texts = [], r >= 9) {
      var o = {
        9: 5e4,
        10: 3e4,
        11: 2e4,
        12: 1e4,
        13: 5e3,
        14: 2e3,
        15: 1e3,
        16: 500,
        17: 300,
        18: 200,
        19: 100,
        20: 100,
        21: 100
      }, l = n.getCenter();
      if (l.lng > 71 && l.lng < 135) {
        var u = n.getWest() - (l.lng - n.getWest()), h = n.getEast() + (l.lng - n.getWest()), c = n.getSouth() - (l.lat - n.getSouth()), f = n.getNorth() + (l.lat - n.getSouth());
        let j = "EPSG:4326", S = this._projection.getproepsgfromlng(l.lng);
        if (typeof S == null)
          return;
        for (var v = this._projection.geo2pro(l.lng, l.lat, j, S), m = Math.floor(v[0] / o[r]), g = Math.floor(v[1] / o[r]), y = l.lng, w = m, E = [], x = []; y > u; )
          y = this._projection.pro2geo(w * o[r], g * o[r], j, S)[0], x.unshift(w * o[r]), E.unshift(y), w--;
        var D = l.lng;
        for (w = m; D < h; )
          w++, D = this._projection.pro2geo(w * o[r], g * o[r], j, S)[0], x.push(w * o[r]), E.push(D);
        for (var F = l.lat, k = g, N = [], H = []; F > c; )
          F = this._projection.pro2geo(m * o[r], k * o[r], j, S)[1], H.unshift(k * o[r]), N.unshift(F), k--;
        var R = l.lat;
        for (k = g; R < f; )
          k++, R = this._projection.pro2geo(m * o[r], k * o[r], j, S)[1], H.push(k * o[r]), N.push(R);
        N.forEach((tt, nt) => {
          this._points.push(new GeoPoint3D(E[0], tt)), this._points.push(new GeoPoint3D(E[E.length - 1], tt));
          let ft = "";
          nt == Math.floor(N.length / 2) ? ft = `${H[nt] / 1e3}` : ft = `${H[nt] / 1e3 - Math.floor(H[nt] / 1e3 / 100) * 100}`, this._map._map.getZoom() >= 17 && (ft = `${Number(ft).toFixed(1)}`), this._texts.push(ft), this._textPoints.push(new GeoPoint3D(n.getWest(), tt));
        }), E.forEach((tt, nt) => {
          this._points.push(new GeoPoint3D(tt, N[0])), this._points.push(new GeoPoint3D(tt, N[N.length - 1]));
          let ft = "";
          nt == Math.floor(E.length / 2) ? ft = `${x[nt] / 1e3}` : ft = `${x[nt] / 1e3 - Math.floor(x[nt] / 1e3 / 100) * 100}`, this._map._map.getZoom() >= 17 && (ft = `${Number(ft).toFixed(1)}`), this._texts.push(ft), this._textPoints.push(new GeoPoint3D(tt, n.getNorth()));
        });
      }
    }
  }
  redraw() {
    super.redraw(), this._constructLines(), this._latlinesFeature && this._latlinesFeature.setPoints(this._points), this._multiTextFeature && (this._multiTextFeature.setTexts(this._texts), this._multiTextFeature.setPoints(this._textPoints));
  }
}
(function(e) {
  e.easyui = { indexOfArray: function(n, r, o) {
    for (var l = 0, u = n.length; l < u; l++)
      if (o == null) {
        if (n[l] == r)
          return l;
      } else if (n[l][r] == o)
        return l;
    return -1;
  }, removeArrayItem: function(n, r, o) {
    if (typeof r == "string") {
      for (var l = 0, u = n.length; l < u; l++)
        if (n[l][r] == o) {
          n.splice(l, 1);
          return;
        }
    } else {
      var h = this.indexOfArray(n, r);
      h != -1 && n.splice(h, 1);
    }
  }, addArrayItem: function(n, r, o) {
    var l = this.indexOfArray(n, r, o ? o[r] : void 0);
    l == -1 ? n.push(o || r) : n[l] = o || r;
  }, getArrayItem: function(n, r, o) {
    var l = this.indexOfArray(n, r, o);
    return l == -1 ? null : n[l];
  }, forEach: function(n, r, o) {
    for (var l = [], u = 0; u < n.length; u++)
      l.push(n[u]);
    for (; l.length; ) {
      var h = l.shift();
      if (o(h) == !1)
        return;
      if (r && h.children)
        for (var u = h.children.length - 1; u >= 0; u--)
          l.unshift(h.children[u]);
    }
  } }, e.parser = { auto: !0, onComplete: function(n) {
  }, plugins: ["draggable", "droppable", "resizable", "pagination", "tooltip", "linkbutton", "menu", "menubutton", "splitbutton", "switchbutton", "progressbar", "tree", "textbox", "passwordbox", "filebox", "combo", "combobox", "combotree", "combogrid", "combotreegrid", "tagbox", "numberbox", "validatebox", "searchbox", "spinner", "numberspinner", "timespinner", "datetimespinner", "calendar", "datebox", "datetimebox", "slider", "layout", "panel", "datagrid", "propertygrid", "treegrid", "datalist", "tabs", "accordion", "window", "dialog", "form"], parse: function(n) {
    for (var r = [], o = 0; o < e.parser.plugins.length; o++) {
      var l = e.parser.plugins[o], u = e(".easyui-" + l, n);
      u.length && (u[l] ? u.each(function() {
        e(this)[l](e.data(this, "options") || {});
      }) : r.push({ name: l, jq: u }));
    }
    if (r.length && window.easyloader) {
      for (var h = [], o = 0; o < r.length; o++)
        h.push(r[o].name);
      easyloader.load(h, function() {
        for (var c = 0; c < r.length; c++) {
          var f = r[c].name, v = r[c].jq;
          v.each(function() {
            e(this)[f](e.data(this, "options") || {});
          });
        }
        e.parser.onComplete.call(e.parser, n);
      });
    } else
      e.parser.onComplete.call(e.parser, n);
  }, parseValue: function(n, r, o, l) {
    l = l || 0;
    var u = e.trim(String(r || "")), h = u.substr(u.length - 1, 1);
    return h == "%" ? (u = parseFloat(u.substr(0, u.length - 1)), n.toLowerCase().indexOf("width") >= 0 ? u = Math.floor((o.width() - l) * u / 100) : u = Math.floor((o.height() - l) * u / 100)) : u = parseInt(u) || void 0, u;
  }, parseOptions: function(n, r) {
    var o = e(n), l = {}, u = e.trim(o.attr("data-options"));
    if (u && (u.substring(0, 1) != "{" && (u = "{" + u + "}"), l = new Function("return " + u)()), e.map(["width", "height", "left", "top", "minWidth", "maxWidth", "minHeight", "maxHeight"], function(g) {
      var y = e.trim(n.style[g] || "");
      y && (y.indexOf("%") == -1 && (y = parseInt(y), isNaN(y) && (y = void 0)), l[g] = y);
    }), r) {
      for (var h = {}, c = 0; c < r.length; c++) {
        var f = r[c];
        if (typeof f == "string")
          h[f] = o.attr(f);
        else
          for (var v in f) {
            var m = f[v];
            m == "boolean" ? h[v] = o.attr(v) ? o.attr(v) == "true" : void 0 : m == "number" && (h[v] = o.attr(v) == "0" ? 0 : parseFloat(o.attr(v)) || void 0);
          }
      }
      e.extend(l, h);
    }
    return l;
  } }, e(function() {
    var n = e('<div style="position:absolute;top:-1000px;width:100px;height:100px;padding:5px"></div>').appendTo("body");
    e._boxModel = n.outerWidth() != 100, n.remove(), n = e('<div style="position:fixed"></div>').appendTo("body"), e._positionFixed = n.css("position") == "fixed", n.remove(), !window.easyloader && e.parser.auto && e.parser.parse();
  }), e.fn._outerWidth = function(n) {
    return n == null ? this[0] == window ? this.width() || document.body.clientWidth : this.outerWidth() || 0 : this._size("width", n);
  }, e.fn._outerHeight = function(n) {
    return n == null ? this[0] == window ? this.height() || document.body.clientHeight : this.outerHeight() || 0 : this._size("height", n);
  }, e.fn._scrollLeft = function(n) {
    return n == null ? this.scrollLeft() : this.each(function() {
      e(this).scrollLeft(n);
    });
  }, e.fn._propAttr = e.fn.prop || e.fn.attr, e.fn._size = function(n, r) {
    if (typeof n == "string")
      return n == "clear" ? this.each(function() {
        e(this).css({ width: "", minWidth: "", maxWidth: "", height: "", minHeight: "", maxHeight: "" });
      }) : n == "fit" ? this.each(function() {
        o(this, this.tagName == "BODY" ? e("body") : e(this).parent(), !0);
      }) : n == "unfit" ? this.each(function() {
        o(this, e(this).parent(), !1);
      }) : r == null ? u(this[0], n) : this.each(function() {
        u(this, n, r);
      });
    return this.each(function() {
      r = r || e(this).parent(), e.extend(n, o(this, r, n.fit) || {});
      var h = l(this, "width", r, n), c = l(this, "height", r, n);
      h || c ? e(this).addClass("easyui-fluid") : e(this).removeClass("easyui-fluid");
    });
    function o(h, c, f) {
      if (!c.length)
        return !1;
      var v = e(h)[0], m = c[0], g = m.fcount || 0;
      return f ? (v.fitted || (v.fitted = !0, m.fcount = g + 1, e(m).addClass("panel-noscroll"), m.tagName == "BODY" && e("html").addClass("panel-fit")), { width: e(m).width() || 1, height: e(m).height() || 1 }) : (v.fitted && (v.fitted = !1, m.fcount = g - 1, m.fcount == 0 && (e(m).removeClass("panel-noscroll"), m.tagName == "BODY" && e("html").removeClass("panel-fit"))), !1);
    }
    function l(h, c, f, v) {
      var m = e(h), g = c, y = g.substr(0, 1).toUpperCase() + g.substr(1), w = e.parser.parseValue("min" + y, v["min" + y], f), E = e.parser.parseValue("max" + y, v["max" + y], f), x = e.parser.parseValue(g, v[g], f), D = String(v[g] || "").indexOf("%") >= 0;
      if (isNaN(x))
        m._size(g, ""), m._size("min" + y, w), m._size("max" + y, E);
      else {
        var F = Math.min(Math.max(x, w || 0), E || 99999);
        D || (v[g] = F), m._size("min" + y, ""), m._size("max" + y, ""), m._size(g, F);
      }
      return D || v.fit;
    }
    function u(h, c, f) {
      var v = e(h);
      if (f == null)
        return f = parseInt(h.style[c]), isNaN(f) ? void 0 : (e._boxModel && (f += m()), f);
      f === "" ? v.css(c, "") : (e._boxModel && (f -= m(), f < 0 && (f = 0)), v.css(c, f + "px"));
      function m() {
        return c.toLowerCase().indexOf("width") >= 0 ? v.outerWidth() - v.width() : v.outerHeight() - v.height();
      }
    }
  };
})($);
(function(e) {
  var n = null, r = !1;
  function o(c) {
    c.touches.length == 1 && (r ? (clearTimeout(dblClickTimer), r = !1, h(c, "dblclick")) : (r = !0, dblClickTimer = setTimeout(function() {
      r = !1;
    }, 500)), n = setTimeout(function() {
      h(c, "contextmenu", 3);
    }, 1e3), h(c, "mousedown"), (e.fn.draggable.isDragging || e.fn.resizable.isResizing) && c.preventDefault());
  }
  function l(c) {
    c.touches.length == 1 && (n && clearTimeout(n), h(c, "mousemove"), (e.fn.draggable.isDragging || e.fn.resizable.isResizing) && c.preventDefault());
  }
  function u(c) {
    n && clearTimeout(n), h(c, "mouseup"), (e.fn.draggable.isDragging || e.fn.resizable.isResizing) && c.preventDefault();
  }
  function h(c, f, v) {
    var m = new e.Event(f);
    m.pageX = c.changedTouches[0].pageX, m.pageY = c.changedTouches[0].pageY, m.which = v || 1, e(c.target).trigger(m);
  }
  document.addEventListener && (document.addEventListener("touchstart", o, !0), document.addEventListener("touchmove", l, !0), document.addEventListener("touchend", u, !0));
})($);
(function(e) {
  function n(c) {
    var f = e.data(c.data.target, "draggable"), v = f.options, m = f.proxy, g = c.data, y = g.startLeft + c.pageX - g.startX, w = g.startTop + c.pageY - g.startY;
    m && (m.parent()[0] == document.body ? (v.deltaX != null && v.deltaX != null ? y = c.pageX + v.deltaX : y = c.pageX - c.data.offsetWidth, v.deltaY != null && v.deltaY != null ? w = c.pageY + v.deltaY : w = c.pageY - c.data.offsetHeight) : (v.deltaX != null && v.deltaX != null && (y += c.data.offsetWidth + v.deltaX), v.deltaY != null && v.deltaY != null && (w += c.data.offsetHeight + v.deltaY))), c.data.parent != document.body && (y += e(c.data.parent).scrollLeft(), w += e(c.data.parent).scrollTop()), v.axis == "h" ? g.left = y : (v.axis == "v" || (g.left = y), g.top = w);
  }
  function r(c) {
    var f = e.data(c.data.target, "draggable"), v = f.options, m = f.proxy;
    m || (m = e(c.data.target)), m.css({ left: c.data.left, top: c.data.top }), e("body").css("cursor", v.cursor);
  }
  function o(c) {
    if (!e.fn.draggable.isDragging)
      return !1;
    var f = e.data(c.data.target, "draggable"), v = f.options, m = e(".droppable:visible").filter(function() {
      return c.data.target != this;
    }).filter(function() {
      var y = e.data(this, "droppable").options.accept;
      return y ? e(y).filter(function() {
        return this == c.data.target;
      }).length > 0 : !0;
    });
    f.droppables = m;
    var g = f.proxy;
    return g || (v.proxy ? (v.proxy == "clone" ? g = e(c.data.target).clone().insertAfter(c.data.target) : g = v.proxy.call(c.data.target, c.data.target), f.proxy = g) : g = e(c.data.target)), g.css("position", "absolute"), n(c), r(c), v.onStartDrag.call(c.data.target, c), !1;
  }
  function l(c) {
    if (!e.fn.draggable.isDragging)
      return !1;
    var f = e.data(c.data.target, "draggable");
    n(c), f.options.onDrag.call(c.data.target, c) != !1 && r(c);
    var v = c.data.target;
    return f.droppables.each(function() {
      var m = e(this);
      if (!m.droppable("options").disabled) {
        var g = m.offset();
        c.pageX > g.left && c.pageX < g.left + m.outerWidth() && c.pageY > g.top && c.pageY < g.top + m.outerHeight() ? (this.entered || (e(this).trigger("_dragenter", [v]), this.entered = !0), e(this).trigger("_dragover", [v])) : this.entered && (e(this).trigger("_dragleave", [v]), this.entered = !1);
      }
    }), !1;
  }
  function u(c) {
    if (!e.fn.draggable.isDragging)
      return h(), !1;
    l(c);
    var f = e.data(c.data.target, "draggable"), v = f.proxy, m = f.options;
    if (m.revert)
      if (E() == !0)
        e(c.data.target).css({ position: c.data.startPosition, left: c.data.startLeft, top: c.data.startTop });
      else if (v) {
        var g, y;
        v.parent()[0] == document.body ? (g = c.data.startX - c.data.offsetWidth, y = c.data.startY - c.data.offsetHeight) : (g = c.data.startLeft, y = c.data.startTop), v.animate({ left: g, top: y }, function() {
          w();
        });
      } else
        e(c.data.target).animate({ left: c.data.startLeft, top: c.data.startTop }, function() {
          e(c.data.target).css("position", c.data.startPosition);
        });
    else
      e(c.data.target).css({ position: "absolute", left: c.data.left, top: c.data.top }), E();
    m.onStopDrag.call(c.data.target, c), h();
    function w() {
      v && v.remove(), f.proxy = null;
    }
    function E() {
      var x = !1;
      return f.droppables.each(function() {
        var D = e(this);
        if (!D.droppable("options").disabled) {
          var F = D.offset();
          if (c.pageX > F.left && c.pageX < F.left + D.outerWidth() && c.pageY > F.top && c.pageY < F.top + D.outerHeight())
            return m.revert && e(c.data.target).css({ position: c.data.startPosition, left: c.data.startLeft, top: c.data.startTop }), e(this).trigger("_drop", [c.data.target]), w(), x = !0, this.entered = !1, !1;
        }
      }), !x && !m.revert && w(), x;
    }
    return !1;
  }
  function h() {
    e.fn.draggable.timer && (clearTimeout(e.fn.draggable.timer), e.fn.draggable.timer = void 0), e(document).unbind(".draggable"), e.fn.draggable.isDragging = !1, setTimeout(function() {
      e("body").css("cursor", "");
    }, 100);
  }
  e.fn.draggable = function(c, f) {
    return typeof c == "string" ? e.fn.draggable.methods[c](this, f) : this.each(function() {
      var v, m = e.data(this, "draggable");
      m ? (m.handle.unbind(".draggable"), v = e.extend(m.options, c)) : v = e.extend({}, e.fn.draggable.defaults, e.fn.draggable.parseOptions(this), c || {});
      var g = v.handle ? typeof v.handle == "string" ? e(v.handle, this) : v.handle : e(this);
      if (e.data(this, "draggable", { options: v, handle: g }), v.disabled) {
        e(this).css("cursor", "");
        return;
      }
      g.unbind(".draggable").bind("mousemove.draggable", { target: this }, function(w) {
        if (!e.fn.draggable.isDragging) {
          var E = e.data(w.data.target, "draggable").options;
          y(w) ? e(this).css("cursor", E.cursor) : e(this).css("cursor", "");
        }
      }).bind("mouseleave.draggable", { target: this }, function(w) {
        e(this).css("cursor", "");
      }).bind("mousedown.draggable", { target: this }, function(w) {
        if (y(w) != !1) {
          e(this).css("cursor", "");
          var E = e(w.data.target).position(), x = e(w.data.target).offset(), D = { startPosition: e(w.data.target).css("position"), startLeft: E.left, startTop: E.top, left: E.left, top: E.top, startX: w.pageX, startY: w.pageY, width: e(w.data.target).outerWidth(), height: e(w.data.target).outerHeight(), offsetWidth: w.pageX - x.left, offsetHeight: w.pageY - x.top, target: w.data.target, parent: e(w.data.target).parent()[0] };
          e.extend(w.data, D);
          var F = e.data(w.data.target, "draggable").options;
          if (F.onBeforeDrag.call(w.data.target, w) != !1)
            return e(document).bind("mousedown.draggable", w.data, o), e(document).bind("mousemove.draggable", w.data, l), e(document).bind("mouseup.draggable", w.data, u), e.fn.draggable.timer = setTimeout(function() {
              e.fn.draggable.isDragging = !0, o(w);
            }, F.delay), !1;
        }
      });
      function y(w) {
        var E = e.data(w.data.target, "draggable"), x = E.handle, D = e(x).offset(), F = e(x).outerWidth(), k = e(x).outerHeight(), N = w.pageY - D.top, H = D.left + F - w.pageX, R = D.top + k - w.pageY, j = w.pageX - D.left;
        return Math.min(N, H, R, j) > E.options.edge;
      }
    });
  }, e.fn.draggable.methods = { options: function(c) {
    return e.data(c[0], "draggable").options;
  }, proxy: function(c) {
    return e.data(c[0], "draggable").proxy;
  }, enable: function(c) {
    return c.each(function() {
      e(this).draggable({ disabled: !1 });
    });
  }, disable: function(c) {
    return c.each(function() {
      e(this).draggable({ disabled: !0 });
    });
  } }, e.fn.draggable.parseOptions = function(c) {
    var f = e(c);
    return e.extend({}, e.parser.parseOptions(c, ["cursor", "handle", "axis", { revert: "boolean", deltaX: "number", deltaY: "number", edge: "number", delay: "number" }]), { disabled: f.attr("disabled") ? !0 : void 0 });
  }, e.fn.draggable.defaults = { proxy: null, revert: !1, cursor: "move", deltaX: null, deltaY: null, handle: null, disabled: !1, edge: 0, axis: null, delay: 100, onBeforeDrag: function(c) {
  }, onStartDrag: function(c) {
  }, onDrag: function(c) {
  }, onStopDrag: function(c) {
  } }, e.fn.draggable.isDragging = !1;
})($);
(function(e) {
  function n(r) {
    e(r).addClass("droppable"), e(r).bind("_dragenter", function(o, l) {
      e.data(r, "droppable").options.onDragEnter.apply(r, [o, l]);
    }), e(r).bind("_dragleave", function(o, l) {
      e.data(r, "droppable").options.onDragLeave.apply(r, [o, l]);
    }), e(r).bind("_dragover", function(o, l) {
      e.data(r, "droppable").options.onDragOver.apply(r, [o, l]);
    }), e(r).bind("_drop", function(o, l) {
      e.data(r, "droppable").options.onDrop.apply(r, [o, l]);
    });
  }
  e.fn.droppable = function(r, o) {
    return typeof r == "string" ? e.fn.droppable.methods[r](this, o) : (r = r || {}, this.each(function() {
      var l = e.data(this, "droppable");
      l ? e.extend(l.options, r) : (n(this), e.data(this, "droppable", { options: e.extend({}, e.fn.droppable.defaults, e.fn.droppable.parseOptions(this), r) }));
    }));
  }, e.fn.droppable.methods = { options: function(r) {
    return e.data(r[0], "droppable").options;
  }, enable: function(r) {
    return r.each(function() {
      e(this).droppable({ disabled: !1 });
    });
  }, disable: function(r) {
    return r.each(function() {
      e(this).droppable({ disabled: !0 });
    });
  } }, e.fn.droppable.parseOptions = function(r) {
    var o = e(r);
    return e.extend({}, e.parser.parseOptions(r, ["accept"]), { disabled: o.attr("disabled") ? !0 : void 0 });
  }, e.fn.droppable.defaults = { accept: null, disabled: !1, onDragEnter: function(r, o) {
  }, onDragOver: function(r, o) {
  }, onDragLeave: function(r, o) {
  }, onDrop: function(r, o) {
  } };
})($);
(function(e) {
  e.fn.resizable = function(n, r) {
    if (typeof n == "string")
      return e.fn.resizable.methods[n](this, r);
    function o(f) {
      var v = f.data, m = e.data(v.target, "resizable").options;
      if (v.dir.indexOf("e") != -1) {
        var g = v.startWidth + f.pageX - v.startX;
        g = Math.min(Math.max(g, m.minWidth), m.maxWidth), v.width = g;
      }
      if (v.dir.indexOf("s") != -1) {
        var y = v.startHeight + f.pageY - v.startY;
        y = Math.min(Math.max(y, m.minHeight), m.maxHeight), v.height = y;
      }
      if (v.dir.indexOf("w") != -1) {
        var g = v.startWidth - f.pageX + v.startX;
        g = Math.min(Math.max(g, m.minWidth), m.maxWidth), v.width = g, v.left = v.startLeft + v.startWidth - v.width;
      }
      if (v.dir.indexOf("n") != -1) {
        var y = v.startHeight - f.pageY + v.startY;
        y = Math.min(Math.max(y, m.minHeight), m.maxHeight), v.height = y, v.top = v.startTop + v.startHeight - v.height;
      }
    }
    function l(f) {
      var v = f.data, m = e(v.target);
      m.css({ left: v.left, top: v.top }), m.outerWidth() != v.width && m._outerWidth(v.width), m.outerHeight() != v.height && m._outerHeight(v.height);
    }
    function u(f) {
      return e.fn.resizable.isResizing = !0, e.data(f.data.target, "resizable").options.onStartResize.call(f.data.target, f), !1;
    }
    function h(f) {
      return o(f), e.data(f.data.target, "resizable").options.onResize.call(f.data.target, f) != !1 && l(f), !1;
    }
    function c(f) {
      return e.fn.resizable.isResizing = !1, o(f), l(f), e.data(f.data.target, "resizable").options.onStopResize.call(f.data.target, f), e(document).unbind(".resizable"), e("body").css("cursor", ""), !1;
    }
    return this.each(function() {
      var f = null, v = e.data(this, "resizable");
      if (v ? (e(this).unbind(".resizable"), f = e.extend(v.options, n || {})) : (f = e.extend({}, e.fn.resizable.defaults, e.fn.resizable.parseOptions(this), n || {}), e.data(this, "resizable", { options: f })), f.disabled == !0)
        return;
      e(this).bind("mousemove.resizable", { target: this }, function(g) {
        if (!e.fn.resizable.isResizing) {
          var y = m(g);
          y == "" ? e(g.data.target).css("cursor", "") : e(g.data.target).css("cursor", y + "-resize");
        }
      }).bind("mouseleave.resizable", { target: this }, function(g) {
        e(g.data.target).css("cursor", "");
      }).bind("mousedown.resizable", { target: this }, function(g) {
        var y = m(g);
        if (y == "")
          return;
        function w(x) {
          var D = parseInt(e(g.data.target).css(x));
          return isNaN(D) ? 0 : D;
        }
        var E = { target: g.data.target, dir: y, startLeft: w("left"), startTop: w("top"), left: w("left"), top: w("top"), startX: g.pageX, startY: g.pageY, startWidth: e(g.data.target).outerWidth(), startHeight: e(g.data.target).outerHeight(), width: e(g.data.target).outerWidth(), height: e(g.data.target).outerHeight(), deltaWidth: e(g.data.target).outerWidth() - e(g.data.target).width(), deltaHeight: e(g.data.target).outerHeight() - e(g.data.target).height() };
        e(document).bind("mousedown.resizable", E, u), e(document).bind("mousemove.resizable", E, h), e(document).bind("mouseup.resizable", E, c), e("body").css("cursor", y + "-resize");
      });
      function m(g) {
        var y = e(g.data.target), w = "", E = y.offset(), x = y.outerWidth(), D = y.outerHeight(), F = f.edge;
        g.pageY > E.top && g.pageY < E.top + F ? w += "n" : g.pageY < E.top + D && g.pageY > E.top + D - F && (w += "s"), g.pageX > E.left && g.pageX < E.left + F ? w += "w" : g.pageX < E.left + x && g.pageX > E.left + x - F && (w += "e");
        for (var k = f.handles.split(","), N = 0; N < k.length; N++) {
          var H = k[N].replace(/(^\s*)|(\s*$)/g, "");
          if (H == "all" || H == w)
            return w;
        }
        return "";
      }
    });
  }, e.fn.resizable.methods = { options: function(n) {
    return e.data(n[0], "resizable").options;
  }, enable: function(n) {
    return n.each(function() {
      e(this).resizable({ disabled: !1 });
    });
  }, disable: function(n) {
    return n.each(function() {
      e(this).resizable({ disabled: !0 });
    });
  } }, e.fn.resizable.parseOptions = function(n) {
    var r = e(n);
    return e.extend({}, e.parser.parseOptions(n, ["handles", { minWidth: "number", minHeight: "number", maxWidth: "number", maxHeight: "number", edge: "number" }]), { disabled: r.attr("disabled") ? !0 : void 0 });
  }, e.fn.resizable.defaults = { disabled: !1, handles: "n, e, s, w, ne, se, sw, nw, all", minWidth: 10, minHeight: 10, maxWidth: 1e4, maxHeight: 1e4, edge: 5, onStartResize: function(n) {
  }, onResize: function(n) {
  }, onStopResize: function(n) {
  } }, e.fn.resizable.isResizing = !1;
})($);
(function(e) {
  function n(u, h) {
    var c = e.data(u, "linkbutton").options;
    if (h && e.extend(c, h), c.width || c.height || c.fit) {
      var f = e(u), v = f.parent(), m = f.is(":visible");
      if (!m) {
        var g = e('<div style="display:none"></div>').insertBefore(u), y = { position: f.css("position"), display: f.css("display"), left: f.css("left") };
        f.appendTo("body"), f.css({ position: "absolute", display: "inline-block", left: -2e4 });
      }
      f._size(c, v);
      var w = f.find(".l-btn-left");
      w.css("margin-top", 0), w.css("margin-top", parseInt((f.height() - w.height()) / 2) + "px"), m || (f.insertAfter(g), f.css(y), g.remove());
    }
  }
  function r(u) {
    var h = e.data(u, "linkbutton").options, c = e(u).empty();
    c.addClass("l-btn").removeClass("l-btn-plain l-btn-selected l-btn-plain-selected l-btn-outline"), c.removeClass("l-btn-small l-btn-medium l-btn-large").addClass("l-btn-" + h.size), h.plain && c.addClass("l-btn-plain"), h.outline && c.addClass("l-btn-outline"), h.selected && c.addClass(h.plain ? "l-btn-selected l-btn-plain-selected" : "l-btn-selected"), c.attr("group", h.group || ""), c.attr("id", h.id || "");
    var f = e('<span class="l-btn-left"></span>').appendTo(c);
    h.text ? e('<span class="l-btn-text"></span>').html(h.text).appendTo(f) : e('<span class="l-btn-text l-btn-empty">&nbsp;</span>').appendTo(f), h.iconCls && (e('<span class="l-btn-icon">&nbsp;</span>').addClass(h.iconCls).appendTo(f), f.addClass("l-btn-icon-" + h.iconAlign)), c.unbind(".linkbutton").bind("focus.linkbutton", function() {
      h.disabled || e(this).addClass("l-btn-focus");
    }).bind("blur.linkbutton", function() {
      e(this).removeClass("l-btn-focus");
    }).bind("click.linkbutton", function() {
      h.disabled || (h.toggle && (h.selected ? e(this).linkbutton("unselect") : e(this).linkbutton("select")), h.onClick.call(this));
    }), o(u, h.selected), l(u, h.disabled);
  }
  function o(u, h) {
    var c = e.data(u, "linkbutton").options;
    h ? (c.group && e('a.l-btn[group="' + c.group + '"]').each(function() {
      var f = e(this).linkbutton("options");
      f.toggle && (e(this).removeClass("l-btn-selected l-btn-plain-selected"), f.selected = !1);
    }), e(u).addClass(c.plain ? "l-btn-selected l-btn-plain-selected" : "l-btn-selected"), c.selected = !0) : c.group || (e(u).removeClass("l-btn-selected l-btn-plain-selected"), c.selected = !1);
  }
  function l(u, h) {
    var c = e.data(u, "linkbutton"), f = c.options;
    if (e(u).removeClass("l-btn-disabled l-btn-plain-disabled"), h) {
      f.disabled = !0;
      var v = e(u).attr("href");
      v && (c.href = v, e(u).attr("href", "javascript:;")), u.onclick && (c.onclick = u.onclick, u.onclick = null), f.plain ? e(u).addClass("l-btn-disabled l-btn-plain-disabled") : e(u).addClass("l-btn-disabled");
    } else
      f.disabled = !1, c.href && e(u).attr("href", c.href), c.onclick && (u.onclick = c.onclick);
  }
  e.fn.linkbutton = function(u, h) {
    return typeof u == "string" ? e.fn.linkbutton.methods[u](this, h) : (u = u || {}, this.each(function() {
      var c = e.data(this, "linkbutton");
      c ? e.extend(c.options, u) : (e.data(this, "linkbutton", { options: e.extend({}, e.fn.linkbutton.defaults, e.fn.linkbutton.parseOptions(this), u) }), e(this).removeAttr("disabled"), e(this).bind("_resize", function(f, v) {
        return (e(this).hasClass("easyui-fluid") || v) && n(this), !1;
      })), r(this), n(this);
    }));
  }, e.fn.linkbutton.methods = { options: function(u) {
    return e.data(u[0], "linkbutton").options;
  }, resize: function(u, h) {
    return u.each(function() {
      n(this, h);
    });
  }, enable: function(u) {
    return u.each(function() {
      l(this, !1);
    });
  }, disable: function(u) {
    return u.each(function() {
      l(this, !0);
    });
  }, select: function(u) {
    return u.each(function() {
      o(this, !0);
    });
  }, unselect: function(u) {
    return u.each(function() {
      o(this, !1);
    });
  } }, e.fn.linkbutton.parseOptions = function(u) {
    var h = e(u);
    return e.extend({}, e.parser.parseOptions(u, ["id", "iconCls", "iconAlign", "group", "size", "text", { plain: "boolean", toggle: "boolean", selected: "boolean", outline: "boolean" }]), { disabled: h.attr("disabled") ? !0 : void 0, text: e.trim(h.html()) || void 0, iconCls: h.attr("icon") || h.attr("iconCls") });
  }, e.fn.linkbutton.defaults = { id: null, disabled: !1, toggle: !1, selected: !1, outline: !1, group: null, plain: !1, text: "", iconCls: null, iconAlign: "left", size: "small", onClick: function() {
  } };
})($);
(function($) {
  function _ab(_ac) {
    var _ad = $.data(_ac, "pagination"), _ae = _ad.options, bb = _ad.bb = {}, _af = $(_ac).addClass("pagination").html('<table cellspacing="0" cellpadding="0" border="0"><tr></tr></table>'), tr = _af.find("tr"), aa = $.extend([], _ae.layout);
    _ae.showPageList || _b0(aa, "list"), _ae.showPageInfo || _b0(aa, "info"), _ae.showRefresh || _b0(aa, "refresh"), aa[0] == "sep" && aa.shift(), aa[aa.length - 1] == "sep" && aa.pop();
    for (var _b1 = 0; _b1 < aa.length; _b1++) {
      var _b2 = aa[_b1];
      if (_b2 == "list") {
        var ps = $('<select class="pagination-page-list"></select>');
        ps.bind("change", function() {
          _ae.pageSize = parseInt($(this).val()), _ae.onChangePageSize.call(_ac, _ae.pageSize), _b8(_ac, _ae.pageNumber);
        });
        for (var i = 0; i < _ae.pageList.length; i++)
          $("<option></option>").text(_ae.pageList[i]).appendTo(ps);
        $("<td></td>").append(ps).appendTo(tr);
      } else
        _b2 == "sep" ? $('<td><div class="pagination-btn-separator"></div></td>').appendTo(tr) : _b2 == "first" ? bb.first = _b3("first") : _b2 == "prev" ? bb.prev = _b3("prev") : _b2 == "next" ? bb.next = _b3("next") : _b2 == "last" ? bb.last = _b3("last") : _b2 == "manual" ? ($('<span style="padding-left:6px;"></span>').html(_ae.beforePageText).appendTo(tr).wrap("<td></td>"), bb.num = $('<input class="pagination-num" type="text" value="1" size="2">').appendTo(tr).wrap("<td></td>"), bb.num.unbind(".pagination").bind("keydown.pagination", function(e) {
          if (e.keyCode == 13) {
            var n = parseInt($(this).val()) || 1;
            return _b8(_ac, n), !1;
          }
        }), bb.after = $('<span style="padding-right:6px;"></span>').appendTo(tr).wrap("<td></td>")) : _b2 == "refresh" ? bb.refresh = _b3("refresh") : _b2 == "links" ? $('<td class="pagination-links"></td>').appendTo(tr) : _b2 == "info" && (_b1 == aa.length - 1 ? ($('<div class="pagination-info"></div>').appendTo(_af), $('<div style="clear:both;"></div>').appendTo(_af)) : $('<td><div class="pagination-info"></div></td>').appendTo(tr));
    }
    if (_ae.buttons)
      if ($('<td><div class="pagination-btn-separator"></div></td>').appendTo(tr), $.isArray(_ae.buttons))
        for (var i = 0; i < _ae.buttons.length; i++) {
          var btn = _ae.buttons[i];
          if (btn == "-")
            $('<td><div class="pagination-btn-separator"></div></td>').appendTo(tr);
          else {
            var td = $("<td></td>").appendTo(tr), a = $('<a href="javascript:;"></a>').appendTo(td);
            a[0].onclick = eval(btn.handler || function() {
            }), a.linkbutton($.extend({}, btn, { plain: !0 }));
          }
        }
      else {
        var td = $("<td></td>").appendTo(tr);
        $(_ae.buttons).appendTo(td).show();
      }
    function _b3(e) {
      var n = _ae.nav[e], r = $('<a href="javascript:;"></a>').appendTo(tr);
      return r.wrap("<td></td>"), r.linkbutton({ iconCls: n.iconCls, plain: !0 }).unbind(".pagination").bind("click.pagination", function() {
        n.handler.call(_ac);
      }), r;
    }
    function _b0(e, n) {
      var r = $.inArray(n, e);
      return r >= 0 && e.splice(r, 1), e;
    }
  }
  function _b8(e, n) {
    var r = $.data(e, "pagination").options;
    _bc(e, { pageNumber: n }), r.onSelectPage.call(e, r.pageNumber, r.pageSize);
  }
  function _bc(e, n) {
    var r = $.data(e, "pagination"), o = r.options, l = r.bb;
    $.extend(o, n || {});
    var u = $(e).find("select.pagination-page-list");
    u.length && (u.val(o.pageSize + ""), o.pageSize = parseInt(u.val()));
    var h = Math.ceil(o.total / o.pageSize) || 1;
    o.pageNumber < 1 && (o.pageNumber = 1), o.pageNumber > h && (o.pageNumber = h), o.total == 0 && (o.pageNumber = 0, h = 0), l.num && l.num.val(o.pageNumber), l.after && l.after.html(o.afterPageText.replace(/{pages}/, h));
    var c = $(e).find("td.pagination-links");
    if (c.length) {
      c.empty();
      var f = o.pageNumber - Math.floor(o.links / 2);
      f < 1 && (f = 1);
      var v = f + o.links - 1;
      v > h && (v = h), f = v - o.links + 1, f < 1 && (f = 1);
      for (var m = f; m <= v; m++) {
        var g = $('<a class="pagination-link" href="javascript:;"></a>').appendTo(c);
        g.linkbutton({ plain: !0, text: m }), m == o.pageNumber ? g.linkbutton("select") : g.unbind(".pagination").bind("click.pagination", { pageNumber: m }, function(w) {
          _b8(e, w.data.pageNumber);
        });
      }
    }
    var y = o.displayMsg;
    y = y.replace(/{from}/, o.total == 0 ? 0 : o.pageSize * (o.pageNumber - 1) + 1), y = y.replace(/{to}/, Math.min(o.pageSize * o.pageNumber, o.total)), y = y.replace(/{total}/, o.total), $(e).find("div.pagination-info").html(y), l.first && l.first.linkbutton({ disabled: !o.total || o.pageNumber == 1 }), l.prev && l.prev.linkbutton({ disabled: !o.total || o.pageNumber == 1 }), l.next && l.next.linkbutton({ disabled: o.pageNumber == h }), l.last && l.last.linkbutton({ disabled: o.pageNumber == h }), _c5(e, o.loading);
  }
  function _c5(e, n) {
    var r = $.data(e, "pagination"), o = r.options;
    o.loading = n, o.showRefresh && r.bb.refresh && r.bb.refresh.linkbutton({ iconCls: o.loading ? "pagination-loading" : "pagination-load" });
  }
  $.fn.pagination = function(e, n) {
    return typeof e == "string" ? $.fn.pagination.methods[e](this, n) : (e = e || {}, this.each(function() {
      var r, o = $.data(this, "pagination");
      o ? r = $.extend(o.options, e) : (r = $.extend({}, $.fn.pagination.defaults, $.fn.pagination.parseOptions(this), e), $.data(this, "pagination", { options: r })), _ab(this), _bc(this);
    }));
  }, $.fn.pagination.methods = { options: function(e) {
    return $.data(e[0], "pagination").options;
  }, loading: function(e) {
    return e.each(function() {
      _c5(this, !0);
    });
  }, loaded: function(e) {
    return e.each(function() {
      _c5(this, !1);
    });
  }, refresh: function(e, n) {
    return e.each(function() {
      _bc(this, n);
    });
  }, select: function(e, n) {
    return e.each(function() {
      _b8(this, n);
    });
  } }, $.fn.pagination.parseOptions = function(_d0) {
    var t = $(_d0);
    return $.extend({}, $.parser.parseOptions(_d0, [{ total: "number", pageSize: "number", pageNumber: "number", links: "number" }, { loading: "boolean", showPageList: "boolean", showPageInfo: "boolean", showRefresh: "boolean" }]), { pageList: t.attr("pageList") ? eval(t.attr("pageList")) : void 0 });
  }, $.fn.pagination.defaults = { total: 1, pageSize: 10, pageNumber: 1, pageList: [10, 20, 30, 50], loading: !1, buttons: null, showPageList: !0, showPageInfo: !0, showRefresh: !0, links: 10, layout: ["list", "sep", "first", "prev", "sep", "manual", "sep", "next", "last", "sep", "refresh", "info"], onSelectPage: function(e, n) {
  }, onBeforeRefresh: function(e, n) {
  }, onRefresh: function(e, n) {
  }, onChangePageSize: function(e) {
  }, beforePageText: "Page", afterPageText: "of {pages}", displayMsg: "Displaying {from} to {to} of {total} items", nav: { first: { iconCls: "pagination-first", handler: function() {
    var e = $(this).pagination("options");
    e.pageNumber > 1 && $(this).pagination("select", 1);
  } }, prev: { iconCls: "pagination-prev", handler: function() {
    var e = $(this).pagination("options");
    e.pageNumber > 1 && $(this).pagination("select", e.pageNumber - 1);
  } }, next: { iconCls: "pagination-next", handler: function() {
    var e = $(this).pagination("options"), n = Math.ceil(e.total / e.pageSize);
    e.pageNumber < n && $(this).pagination("select", e.pageNumber + 1);
  } }, last: { iconCls: "pagination-last", handler: function() {
    var e = $(this).pagination("options"), n = Math.ceil(e.total / e.pageSize);
    e.pageNumber < n && $(this).pagination("select", n);
  } }, refresh: { iconCls: "pagination-refresh", handler: function() {
    var e = $(this).pagination("options");
    e.onBeforeRefresh.call(this, e.pageNumber, e.pageSize) != !1 && ($(this).pagination("select", e.pageNumber), e.onRefresh.call(this, e.pageNumber, e.pageSize));
  } } } };
})($);
(function(e) {
  function n(J) {
    var et = e(J);
    return et.addClass("tree"), et;
  }
  function r(J) {
    var et = e.data(J, "tree").options;
    e(J).unbind().bind("mouseover", function(at) {
      var gt = e(at.target), wt = gt.closest("div.tree-node");
      wt.length && (wt.addClass("tree-node-hover"), gt.hasClass("tree-hit") && (gt.hasClass("tree-expanded") ? gt.addClass("tree-expanded-hover") : gt.addClass("tree-collapsed-hover")), at.stopPropagation());
    }).bind("mouseout", function(at) {
      var gt = e(at.target), wt = gt.closest("div.tree-node");
      wt.length && (wt.removeClass("tree-node-hover"), gt.hasClass("tree-hit") && (gt.hasClass("tree-expanded") ? gt.removeClass("tree-expanded-hover") : gt.removeClass("tree-collapsed-hover")), at.stopPropagation());
    }).bind("click", function(at) {
      var gt = e(at.target), wt = gt.closest("div.tree-node");
      if (wt.length) {
        if (gt.hasClass("tree-hit"))
          return D(J, wt[0]), !1;
        if (gt.hasClass("tree-checkbox"))
          return u(J, wt[0]), !1;
        rt(J, wt[0]), et.onClick.call(J, Mt(J, wt[0])), at.stopPropagation();
      }
    }).bind("dblclick", function(at) {
      var gt = e(at.target).closest("div.tree-node");
      gt.length && (rt(J, gt[0]), et.onDblClick.call(J, Mt(J, gt[0])), at.stopPropagation());
    }).bind("contextmenu", function(at) {
      var gt = e(at.target).closest("div.tree-node");
      gt.length && (et.onContextMenu.call(J, at, Mt(J, gt[0])), at.stopPropagation());
    });
  }
  function o(J) {
    var et = e.data(J, "tree").options;
    et.dnd = !1;
    var at = e(J).find("div.tree-node");
    at.draggable("disable"), at.css("cursor", "pointer");
  }
  function l(J) {
    var et = e.data(J, "tree"), at = et.options, gt = et.tree;
    et.disabledNodes = [], at.dnd = !0, gt.find("div.tree-node").draggable({ disabled: !1, revert: !0, cursor: "pointer", proxy: function(Gt) {
      var Yt = e('<div class="tree-node-proxy"></div>').appendTo("body");
      return Yt.html('<span class="tree-dnd-icon tree-dnd-no">&nbsp;</span>' + e(Gt).find(".tree-title").html()), Yt.hide(), Yt;
    }, deltaX: 15, deltaY: 15, onBeforeDrag: function(Gt) {
      if (at.onBeforeDrag.call(J, Mt(J, this)) == !1 || e(Gt.target).hasClass("tree-hit") || e(Gt.target).hasClass("tree-checkbox") || Gt.which != 1)
        return !1;
      var Yt = e(this).find("span.tree-indent");
      Yt.length && (Gt.data.offsetWidth -= Yt.length * Yt.width());
    }, onStartDrag: function(Gt) {
      e(this).next("ul").find("div.tree-node").each(function() {
        e(this).droppable("disable"), et.disabledNodes.push(this);
      }), e(this).draggable("proxy").css({ left: -1e4, top: -1e4 }), at.onStartDrag.call(J, Mt(J, this));
      var Yt = Mt(J, this);
      Yt.id == null && (Yt.id = "easyui_tree_node_id_temp", tt(J, Yt)), et.draggingNodeId = Yt.id;
    }, onDrag: function(Gt) {
      var Yt = Gt.pageX, he = Gt.pageY, Pe = Gt.data.startX, ce = Gt.data.startY, di = Math.sqrt((Yt - Pe) * (Yt - Pe) + (he - ce) * (he - ce));
      di > 3 && e(this).draggable("proxy").show(), this.pageY = Gt.pageY;
    }, onStopDrag: function() {
      for (var Gt = 0; Gt < et.disabledNodes.length; Gt++)
        e(et.disabledNodes[Gt]).droppable("enable");
      et.disabledNodes = [];
      var Yt = G(J, et.draggingNodeId);
      Yt && Yt.id == "easyui_tree_node_id_temp" && (Yt.id = "", tt(J, Yt)), at.onStopDrag.call(J, Yt);
    } }).droppable({ accept: "div.tree-node", onDragEnter: function(Gt, Yt) {
      at.onDragEnter.call(J, this, wt(Yt)) == !1 && (Et(Yt, !1), e(this).removeClass("tree-node-append tree-node-top tree-node-bottom"), e(this).droppable("disable"), et.disabledNodes.push(this));
    }, onDragOver: function(Gt, Yt) {
      if (!e(this).droppable("options").disabled) {
        var he = Yt.pageY, Pe = e(this).offset().top, ce = Pe + e(this).outerHeight();
        Et(Yt, !0), e(this).removeClass("tree-node-append tree-node-top tree-node-bottom"), he > Pe + (ce - Pe) / 2 ? ce - he < 5 ? e(this).addClass("tree-node-bottom") : e(this).addClass("tree-node-append") : he - Pe < 5 ? e(this).addClass("tree-node-top") : e(this).addClass("tree-node-append"), at.onDragOver.call(J, this, wt(Yt)) == !1 && (Et(Yt, !1), e(this).removeClass("tree-node-append tree-node-top tree-node-bottom"), e(this).droppable("disable"), et.disabledNodes.push(this));
      }
    }, onDragLeave: function(Gt, Yt) {
      Et(Yt, !1), e(this).removeClass("tree-node-append tree-node-top tree-node-bottom"), at.onDragLeave.call(J, this, wt(Yt));
    }, onDrop: function(Gt, Yt) {
      var he = this, Pe, ce;
      if (e(this).hasClass("tree-node-append") ? (Pe = qt, ce = "append") : (Pe = Jt, ce = e(this).hasClass("tree-node-top") ? "top" : "bottom"), at.onBeforeDrop.call(J, he, wt(Yt), ce) == !1) {
        e(this).removeClass("tree-node-append tree-node-top tree-node-bottom");
        return;
      }
      Pe(Yt, he, ce), e(this).removeClass("tree-node-append tree-node-top tree-node-bottom");
    } });
    function wt(Gt, Yt) {
      return e(Gt).closest("ul.tree").tree(Yt ? "pop" : "getData", Gt);
    }
    function Et(Gt, Yt) {
      var he = e(Gt).draggable("proxy").find("span.tree-dnd-icon");
      he.removeClass("tree-dnd-yes tree-dnd-no").addClass(Yt ? "tree-dnd-yes" : "tree-dnd-no");
    }
    function qt(Gt, Yt) {
      Mt(J, Yt).state == "closed" ? E(J, Yt, function() {
        he();
      }) : he();
      function he() {
        var Pe = wt(Gt, !0);
        e(J).tree("append", { parent: Yt, data: [Pe] }), at.onDrop.call(J, Yt, Pe, "append");
      }
    }
    function Jt(Gt, Yt, he) {
      var Pe = {};
      he == "top" ? Pe.before = Yt : Pe.after = Yt;
      var ce = wt(Gt, !0);
      Pe.data = ce, e(J).tree("insert", Pe), at.onDrop.call(J, Yt, ce, he);
    }
  }
  function u(J, et, at, gt) {
    var wt = e.data(J, "tree"), Et = wt.options;
    if (Et.checkbox) {
      var qt = Mt(J, et);
      if (qt.checkState) {
        var Jt = e(et).find(".tree-checkbox");
        if (at == null && (Jt.hasClass("tree-checkbox1") ? at = !1 : Jt.hasClass("tree-checkbox0") ? at = !0 : (qt._checked == null && (qt._checked = e(et).find(".tree-checkbox").hasClass("tree-checkbox1")), at = !qt._checked)), qt._checked = at, at) {
          if (Jt.hasClass("tree-checkbox1"))
            return;
        } else if (Jt.hasClass("tree-checkbox0"))
          return;
        !gt && Et.onBeforeCheck.call(J, qt, at) == !1 || (Et.cascadeCheck ? (h(J, qt, at), f(J, qt)) : c(J, qt, at ? "1" : "0"), gt || Et.onCheck.call(J, qt, at));
      }
    }
  }
  function h(J, et, at) {
    var gt = e.data(J, "tree").options, wt = at ? 1 : 0;
    if (c(J, et, wt), gt.deepCheck)
      e.easyui.forEach(et.children || [], !0, function(Gt) {
        c(J, Gt, wt);
      });
    else {
      var Et = [];
      et.children && et.children.length && Et.push(et), e.easyui.forEach(et.children || [], !0, function(Gt) {
        Gt.hidden || (c(J, Gt, wt), Gt.children && Gt.children.length && Et.push(Gt));
      });
      for (var qt = Et.length - 1; qt >= 0; qt--) {
        var Jt = Et[qt];
        c(J, Jt, v(Jt));
      }
    }
  }
  function c(J, et, at) {
    var gt = e.data(J, "tree").options;
    if (!(!et.checkState || at == null) && !(et.hidden && !gt.deepCheck)) {
      var wt = e("#" + et.domId).find(".tree-checkbox");
      et.checkState = ["unchecked", "checked", "indeterminate"][at], et.checked = et.checkState == "checked", wt.removeClass("tree-checkbox0 tree-checkbox1 tree-checkbox2"), wt.addClass("tree-checkbox" + at);
    }
  }
  function f(J, et) {
    var at = ct(J, e("#" + et.domId)[0]);
    at && (c(J, at, v(at)), f(J, at));
  }
  function v(J) {
    var et = 0, at = 0, gt = 0;
    if (e.easyui.forEach(J.children || [], !1, function(Et) {
      Et.checkState && (gt++, Et.checkState == "checked" ? at++ : Et.checkState == "unchecked" && et++);
    }), gt != 0) {
      var wt = 0;
      return et == gt ? wt = 0 : at == gt ? wt = 1 : wt = 2, wt;
    }
  }
  function m(J, et) {
    var at = e.data(J, "tree").options;
    if (at.checkbox) {
      var gt = e(et), wt = gt.find(".tree-checkbox"), Et = Mt(J, et);
      if (at.view.hasCheckbox(J, Et))
        if (wt.length || (Et.checkState = Et.checkState || "unchecked", e('<span class="tree-checkbox"></span>').insertBefore(gt.find(".tree-title"))), Et.checkState == "checked")
          u(J, et, !0, !0);
        else if (Et.checkState == "unchecked")
          u(J, et, !1, !0);
        else {
          var qt = v(Et);
          qt === 0 ? u(J, et, !1, !0) : qt === 1 && u(J, et, !0, !0);
        }
      else
        wt.remove(), Et.checkState = void 0, Et.checked = void 0, f(J, Et);
    }
  }
  function g(J, et, at, gt, wt) {
    var Et = e.data(J, "tree"), qt = Et.options, Jt = e(et).prevAll("div.tree-node:first");
    at = qt.loadFilter.call(J, at, Jt[0]);
    var Gt = Y(J, "domId", Jt.attr("id"));
    gt ? Gt ? Gt.children ? Gt.children = Gt.children.concat(at) : Gt.children = at : Et.data = Et.data.concat(at) : (Gt ? Gt.children = at : Et.data = at, e(et).empty()), qt.view.render.call(qt.view, J, et, at), qt.dnd && l(J), Gt && tt(J, Gt);
    for (var Yt = 0; Yt < Et.tmpIds.length; Yt++)
      u(J, e("#" + Et.tmpIds[Yt])[0], !0, !0);
    Et.tmpIds = [], setTimeout(function() {
      y(J, J);
    }, 0), wt || qt.onLoadSuccess.call(J, Gt, at);
  }
  function y(J, et, at) {
    var gt = e.data(J, "tree").options;
    if (gt.lines)
      e(J).addClass("tree-lines");
    else {
      e(J).removeClass("tree-lines");
      return;
    }
    if (!at) {
      at = !0, e(J).find("span.tree-indent").removeClass("tree-line tree-join tree-joinbottom"), e(J).find("div.tree-node").removeClass("tree-node-last tree-root-first tree-root-one");
      var wt = e(J).tree("getRoots");
      wt.length > 1 ? e(wt[0].target).addClass("tree-root-first") : wt.length == 1 && e(wt[0].target).addClass("tree-root-one");
    }
    e(et).children("li").each(function() {
      var Gt = e(this).children("div.tree-node"), Yt = Gt.next("ul");
      Yt.length ? (e(this).next().length && Jt(Gt), y(J, Yt, at)) : qt(Gt);
    });
    var Et = e(et).children("li:last").children("div.tree-node").addClass("tree-node-last");
    Et.children("span.tree-join").removeClass("tree-join").addClass("tree-joinbottom");
    function qt(Gt, Yt) {
      var he = Gt.find("span.tree-icon");
      he.prev("span.tree-indent").addClass("tree-join");
    }
    function Jt(Gt) {
      var Yt = Gt.find("span.tree-indent, span.tree-hit").length;
      Gt.next().find("div.tree-node").each(function() {
        e(this).children("span:eq(" + (Yt - 1) + ")").addClass("tree-line");
      });
    }
  }
  function w(J, et, at, gt) {
    var wt = e.data(J, "tree").options;
    at = e.extend({}, wt.queryParams, at || {});
    var Et = null;
    if (J != et) {
      var qt = e(et).prev();
      Et = Mt(J, qt[0]);
    }
    if (wt.onBeforeLoad.call(J, Et, at) != !1) {
      var Jt = e(et).prev().children("span.tree-folder");
      Jt.addClass("tree-loading");
      var Gt = wt.loader.call(J, at, function(Yt) {
        Jt.removeClass("tree-loading"), g(J, et, Yt), gt && gt();
      }, function() {
        Jt.removeClass("tree-loading"), wt.onLoadError.apply(J, arguments), gt && gt();
      });
      Gt == !1 && Jt.removeClass("tree-loading");
    }
  }
  function E(J, et, at) {
    var gt = e.data(J, "tree").options, wt = e(et).children("span.tree-hit");
    if (wt.length != 0 && !wt.hasClass("tree-expanded")) {
      var Et = Mt(J, et);
      if (gt.onBeforeExpand.call(J, Et) != !1) {
        wt.removeClass("tree-collapsed tree-collapsed-hover").addClass("tree-expanded"), wt.next().addClass("tree-folder-open");
        var qt = e(et).next();
        if (qt.length)
          gt.animate ? qt.slideDown("normal", function() {
            Et.state = "open", gt.onExpand.call(J, Et), at && at();
          }) : (qt.css("display", "block"), Et.state = "open", gt.onExpand.call(J, Et), at && at());
        else {
          var Jt = e('<ul style="display:none"></ul>').insertAfter(et);
          w(J, Jt[0], { id: Et.id }, function() {
            Jt.is(":empty") && Jt.remove(), gt.animate ? Jt.slideDown("normal", function() {
              Et.state = "open", gt.onExpand.call(J, Et), at && at();
            }) : (Jt.css("display", "block"), Et.state = "open", gt.onExpand.call(J, Et), at && at());
          });
        }
      }
    }
  }
  function x(J, et) {
    var at = e.data(J, "tree").options, gt = e(et).children("span.tree-hit");
    if (gt.length != 0 && !gt.hasClass("tree-collapsed")) {
      var wt = Mt(J, et);
      if (at.onBeforeCollapse.call(J, wt) != !1) {
        gt.removeClass("tree-expanded tree-expanded-hover").addClass("tree-collapsed"), gt.next().removeClass("tree-folder-open");
        var Et = e(et).next();
        at.animate ? Et.slideUp("normal", function() {
          wt.state = "closed", at.onCollapse.call(J, wt);
        }) : (Et.css("display", "none"), wt.state = "closed", at.onCollapse.call(J, wt));
      }
    }
  }
  function D(J, et) {
    var at = e(et).children("span.tree-hit");
    at.length != 0 && (at.hasClass("tree-expanded") ? x(J, et) : E(J, et));
  }
  function F(J, et) {
    var at = pt(J, et);
    et && at.unshift(Mt(J, et));
    for (var gt = 0; gt < at.length; gt++)
      E(J, at[gt].target);
  }
  function k(J, et) {
    for (var at = [], gt = ct(J, et); gt; )
      at.unshift(gt), gt = ct(J, gt.target);
    for (var wt = 0; wt < at.length; wt++)
      E(J, at[wt].target);
  }
  function N(J, et) {
    for (var at = e(J).parent(); at[0].tagName != "BODY" && at.css("overflow-y") != "auto"; )
      at = at.parent();
    var gt = e(et), wt = gt.offset().top;
    if (at[0].tagName != "BODY") {
      var Et = at.offset().top;
      wt < Et ? at.scrollTop(at.scrollTop() + wt - Et) : wt + gt.outerHeight() > Et + at.outerHeight() - 18 && at.scrollTop(at.scrollTop() + wt + gt.outerHeight() - Et - at.outerHeight() + 18);
    } else
      at.scrollTop(wt);
  }
  function H(J, et) {
    var at = pt(J, et);
    et && at.unshift(Mt(J, et));
    for (var gt = 0; gt < at.length; gt++)
      x(J, at[gt].target);
  }
  function R(J, et) {
    var at = e(et.parent), gt = et.data;
    if (gt && (gt = e.isArray(gt) ? gt : [gt], !!gt.length)) {
      var wt;
      if (at.length == 0)
        wt = e(J);
      else {
        if (ht(J, at[0])) {
          var Et = at.find("span.tree-icon");
          Et.removeClass("tree-file").addClass("tree-folder tree-folder-open");
          var qt = e('<span class="tree-hit tree-expanded"></span>').insertBefore(Et);
          qt.prev().length && qt.prev().remove();
        }
        wt = at.next(), wt.length || (wt = e("<ul></ul>").insertAfter(at));
      }
      g(J, wt[0], gt, !0, !0);
    }
  }
  function j(J, et) {
    var at = et.before || et.after, gt = ct(J, at), wt = et.data;
    if (wt && (wt = e.isArray(wt) ? wt : [wt], !!wt.length)) {
      R(J, { parent: gt ? gt.target : null, data: wt });
      for (var Et = gt ? gt.children : e(J).tree("getRoots"), qt = 0; qt < Et.length; qt++)
        if (Et[qt].domId == e(at).attr("id")) {
          for (var Jt = wt.length - 1; Jt >= 0; Jt--)
            Et.splice(et.before ? qt : qt + 1, 0, wt[Jt]);
          Et.splice(Et.length - wt.length, wt.length);
          break;
        }
      for (var Gt = e(), qt = 0; qt < wt.length; qt++)
        Gt = Gt.add(e("#" + wt[qt].domId).parent());
      et.before ? Gt.insertBefore(e(at).parent()) : Gt.insertAfter(e(at).parent());
    }
  }
  function S(J, et) {
    var at = wt(et);
    if (e(et).parent().remove(), at) {
      if (!at.children || !at.children.length) {
        var gt = e(at.target);
        gt.find(".tree-icon").removeClass("tree-folder").addClass("tree-file"), gt.find(".tree-hit").remove(), e('<span class="tree-indent"></span>').prependTo(gt), gt.next().remove();
      }
      tt(J, at);
    }
    y(J, J);
    function wt(Et) {
      for (var qt = e(Et).attr("id"), Jt = ct(J, Et), Gt = Jt ? Jt.children : e.data(J, "tree").data, Yt = 0; Yt < Gt.length; Yt++)
        if (Gt[Yt].domId == qt) {
          Gt.splice(Yt, 1);
          break;
        }
      return Jt;
    }
  }
  function tt(J, et) {
    var at = e.data(J, "tree").options, gt = e(et.target), wt = Mt(J, et.target);
    wt.iconCls && gt.find(".tree-icon").removeClass(wt.iconCls), e.extend(wt, et), gt.find(".tree-title").html(at.formatter.call(J, wt)), wt.iconCls && gt.find(".tree-icon").addClass(wt.iconCls), m(J, et.target);
  }
  function nt(J, et) {
    if (et) {
      for (var at = ct(J, et); at; )
        et = at.target, at = ct(J, et);
      return Mt(J, et);
    } else {
      var gt = ft(J);
      return gt.length ? gt[0] : null;
    }
  }
  function ft(J) {
    for (var et = e.data(J, "tree").data, at = 0; at < et.length; at++)
      it(et[at]);
    return et;
  }
  function pt(J, et) {
    var at = [], gt = Mt(J, et), wt = gt ? gt.children || [] : e.data(J, "tree").data;
    return e.easyui.forEach(wt, !0, function(Et) {
      at.push(it(Et));
    }), at;
  }
  function ct(J, et) {
    var at = e(et).closest("ul").prevAll("div.tree-node:first");
    return Mt(J, at[0]);
  }
  function Nt(J, et) {
    et = et || "checked", e.isArray(et) || (et = [et]);
    var at = [];
    return e.easyui.forEach(e.data(J, "tree").data, !0, function(gt) {
      gt.checkState && e.easyui.indexOfArray(et, gt.checkState) != -1 && at.push(it(gt));
    }), at;
  }
  function kt(J) {
    var et = e(J).find("div.tree-node-selected");
    return et.length ? Mt(J, et[0]) : null;
  }
  function Rt(J, et) {
    var at = Mt(J, et);
    return at && at.children && e.easyui.forEach(at.children, !0, function(gt) {
      it(gt);
    }), at;
  }
  function Mt(J, et) {
    return Y(J, "domId", e(et).attr("id"));
  }
  function G(J, et) {
    return Y(J, "id", et);
  }
  function Y(J, et, at) {
    var gt = e.data(J, "tree").data, wt = null;
    return e.easyui.forEach(gt, !0, function(Et) {
      if (Et[et] == at)
        return wt = it(Et), !1;
    }), wt;
  }
  function it(J) {
    return J.target = e("#" + J.domId)[0], J;
  }
  function rt(J, et) {
    var at = e.data(J, "tree").options, gt = Mt(J, et);
    at.onBeforeSelect.call(J, gt) != !1 && (e(J).find("div.tree-node-selected").removeClass("tree-node-selected"), e(et).addClass("tree-node-selected"), at.onSelect.call(J, gt));
  }
  function ht(J, et) {
    return e(et).children("span.tree-hit").length == 0;
  }
  function bt(J, et) {
    var at = e.data(J, "tree").options, gt = Mt(J, et);
    if (at.onBeforeEdit.call(J, gt) != !1) {
      e(et).css("position", "relative");
      var wt = e(et).find(".tree-title"), Et = wt.outerWidth();
      wt.empty();
      var qt = e('<input class="tree-editor">').appendTo(wt);
      qt.val(gt.text).focus(), qt.width(Et + 20), qt._outerHeight(18), qt.bind("click", function(Jt) {
        return !1;
      }).bind("mousedown", function(Jt) {
        Jt.stopPropagation();
      }).bind("mousemove", function(Jt) {
        Jt.stopPropagation();
      }).bind("keydown", function(Jt) {
        if (Jt.keyCode == 13)
          return yt(J, et), !1;
        if (Jt.keyCode == 27)
          return St(J, et), !1;
      }).bind("blur", function(Jt) {
        Jt.stopPropagation(), yt(J, et);
      });
    }
  }
  function yt(J, et) {
    var at = e.data(J, "tree").options;
    e(et).css("position", "");
    var gt = e(et).find("input.tree-editor"), wt = gt.val();
    gt.remove();
    var Et = Mt(J, et);
    Et.text = wt, tt(J, Et), at.onAfterEdit.call(J, Et);
  }
  function St(J, et) {
    var at = e.data(J, "tree").options;
    e(et).css("position", ""), e(et).find("input.tree-editor").remove();
    var gt = Mt(J, et);
    tt(J, gt), at.onCancelEdit.call(J, gt);
  }
  function Ft(J, et) {
    var at = e.data(J, "tree"), gt = at.options, wt = {};
    e.easyui.forEach(at.data, !0, function(Jt) {
      gt.filter.call(J, et, Jt) ? (e("#" + Jt.domId).removeClass("tree-node-hidden"), wt[Jt.domId] = 1, Jt.hidden = !1) : (e("#" + Jt.domId).addClass("tree-node-hidden"), Jt.hidden = !0);
    });
    for (var Et in wt)
      qt(Et);
    function qt(Jt) {
      for (var Gt = e(J).tree("getParent", e("#" + Jt)[0]); Gt; )
        e(Gt.target).removeClass("tree-node-hidden"), Gt.hidden = !1, Gt = e(J).tree("getParent", Gt.target);
    }
  }
  e.fn.tree = function(at, et) {
    if (typeof at == "string")
      return e.fn.tree.methods[at](this, et);
    var at = at || {};
    return this.each(function() {
      var gt = e.data(this, "tree"), wt;
      if (gt)
        wt = e.extend(gt.options, at), gt.options = wt;
      else {
        wt = e.extend({}, e.fn.tree.defaults, e.fn.tree.parseOptions(this), at), e.data(this, "tree", { options: wt, tree: n(this), data: [], tmpIds: [] });
        var Et = e.fn.tree.parseData(this);
        Et.length && g(this, this, Et);
      }
      r(this), wt.data && g(this, this, e.extend(!0, [], wt.data)), w(this, this);
    });
  }, e.fn.tree.methods = { options: function(J) {
    return e.data(J[0], "tree").options;
  }, loadData: function(J, et) {
    return J.each(function() {
      g(this, this, et);
    });
  }, getNode: function(J, et) {
    return Mt(J[0], et);
  }, getData: function(J, et) {
    return Rt(J[0], et);
  }, reload: function(J, et) {
    return J.each(function() {
      if (et) {
        var at = e(et), gt = at.children("span.tree-hit");
        gt.removeClass("tree-expanded tree-expanded-hover").addClass("tree-collapsed"), at.next().remove(), E(this, et);
      } else
        e(this).empty(), w(this, this);
    });
  }, getRoot: function(J, et) {
    return nt(J[0], et);
  }, getRoots: function(J) {
    return ft(J[0]);
  }, getParent: function(J, et) {
    return ct(J[0], et);
  }, getChildren: function(J, et) {
    return pt(J[0], et);
  }, getChecked: function(J, et) {
    return Nt(J[0], et);
  }, getSelected: function(J) {
    return kt(J[0]);
  }, isLeaf: function(J, et) {
    return ht(J[0], et);
  }, find: function(J, et) {
    return G(J[0], et);
  }, select: function(J, et) {
    return J.each(function() {
      rt(this, et);
    });
  }, check: function(J, et) {
    return J.each(function() {
      u(this, et, !0);
    });
  }, uncheck: function(J, et) {
    return J.each(function() {
      u(this, et, !1);
    });
  }, collapse: function(J, et) {
    return J.each(function() {
      x(this, et);
    });
  }, expand: function(J, et) {
    return J.each(function() {
      E(this, et);
    });
  }, collapseAll: function(J, et) {
    return J.each(function() {
      H(this, et);
    });
  }, expandAll: function(J, et) {
    return J.each(function() {
      F(this, et);
    });
  }, expandTo: function(J, et) {
    return J.each(function() {
      k(this, et);
    });
  }, scrollTo: function(J, et) {
    return J.each(function() {
      N(this, et);
    });
  }, toggle: function(J, et) {
    return J.each(function() {
      D(this, et);
    });
  }, append: function(J, et) {
    return J.each(function() {
      R(this, et);
    });
  }, insert: function(J, et) {
    return J.each(function() {
      j(this, et);
    });
  }, remove: function(J, et) {
    return J.each(function() {
      S(this, et);
    });
  }, pop: function(J, et) {
    var at = J.tree("getData", et);
    return J.tree("remove", et), at;
  }, update: function(J, et) {
    return J.each(function() {
      tt(this, e.extend({}, et, { checkState: et.checked ? "checked" : et.checked === !1 ? "unchecked" : void 0 }));
    });
  }, enableDnd: function(J) {
    return J.each(function() {
      l(this);
    });
  }, disableDnd: function(J) {
    return J.each(function() {
      o(this);
    });
  }, beginEdit: function(J, et) {
    return J.each(function() {
      bt(this, et);
    });
  }, endEdit: function(J, et) {
    return J.each(function() {
      yt(this, et);
    });
  }, cancelEdit: function(J, et) {
    return J.each(function() {
      St(this, et);
    });
  }, doFilter: function(J, et) {
    return J.each(function() {
      Ft(this, et);
    });
  } }, e.fn.tree.parseOptions = function(J) {
    return e(J), e.extend({}, e.parser.parseOptions(J, ["url", "method", { checkbox: "boolean", cascadeCheck: "boolean", onlyLeafCheck: "boolean" }, { animate: "boolean", lines: "boolean", dnd: "boolean" }]));
  }, e.fn.tree.parseData = function(J) {
    var et = [];
    return at(et, e(J)), et;
    function at(gt, wt) {
      wt.children("li").each(function() {
        var Et = e(this), qt = e.extend({}, e.parser.parseOptions(this, ["id", "iconCls", "state"]), { checked: Et.attr("checked") ? !0 : void 0 });
        qt.text = Et.children("span").html(), qt.text || (qt.text = Et.html());
        var Jt = Et.children("ul");
        Jt.length && (qt.children = [], at(qt.children, Jt)), gt.push(qt);
      });
    }
  };
  var zt = 1, Zt = { render: function(J, et, at) {
    var gt = e.data(J, "tree"), wt = gt.options, Et = e(et).prev(".tree-node"), qt = Et.length ? e(J).tree("getNode", Et[0]) : null, Jt = Et.find("span.tree-indent, span.tree-hit").length, Gt = Yt.call(this, Jt, at);
    e(et).append(Gt.join(""));
    function Yt(he, Pe) {
      for (var ce = [], di = 0; di < Pe.length; di++) {
        var fe = Pe[di];
        fe.state != "open" && fe.state != "closed" && (fe.state = "open"), fe.domId = "_easyui_tree_" + zt++, ce.push("<li>"), ce.push('<div id="' + fe.domId + '" class="tree-node">');
        for (var st = 0; st < he; st++)
          ce.push('<span class="tree-indent"></span>');
        if (fe.state == "closed" ? (ce.push('<span class="tree-hit tree-collapsed"></span>'), ce.push('<span class="tree-icon tree-folder ' + (fe.iconCls ? fe.iconCls : "") + '"></span>')) : fe.children && fe.children.length ? (ce.push('<span class="tree-hit tree-expanded"></span>'), ce.push('<span class="tree-icon tree-folder tree-folder-open ' + (fe.iconCls ? fe.iconCls : "") + '"></span>')) : (ce.push('<span class="tree-indent"></span>'), ce.push('<span class="tree-icon tree-file ' + (fe.iconCls ? fe.iconCls : "") + '"></span>')), this.hasCheckbox(J, fe)) {
          var xt = 0;
          qt && qt.checkState == "checked" && wt.cascadeCheck ? (xt = 1, fe.checked = !0) : fe.checked && e.easyui.addArrayItem(gt.tmpIds, fe.domId), fe.checkState = xt ? "checked" : "unchecked", ce.push('<span class="tree-checkbox tree-checkbox' + xt + '"></span>');
        } else
          fe.checkState = void 0, fe.checked = void 0;
        if (ce.push('<span class="tree-title">' + wt.formatter.call(J, fe) + "</span>"), ce.push("</div>"), fe.children && fe.children.length) {
          var mt = Yt.call(this, he + 1, fe.children);
          ce.push('<ul style="display:' + (fe.state == "closed" ? "none" : "block") + '">'), ce = ce.concat(mt), ce.push("</ul>");
        }
        ce.push("</li>");
      }
      return ce;
    }
  }, hasCheckbox: function(J, et) {
    var at = e.data(J, "tree"), gt = at.options;
    if (gt.checkbox) {
      if (e.isFunction(gt.checkbox))
        return !!gt.checkbox.call(J, et);
      if (gt.onlyLeafCheck) {
        if (et.state == "open" && !(et.children && et.children.length))
          return !0;
      } else
        return !0;
    }
    return !1;
  } };
  e.fn.tree.defaults = { url: null, method: "post", animate: !1, checkbox: !1, cascadeCheck: !0, onlyLeafCheck: !1, lines: !1, dnd: !1, data: null, queryParams: {}, formatter: function(J) {
    return J.text;
  }, filter: function(J, et) {
    var at = [];
    e.map(e.isArray(J) ? J : [J], function(Et) {
      Et = e.trim(Et), Et && at.push(Et);
    });
    for (var gt = 0; gt < at.length; gt++) {
      var wt = et.text.toLowerCase().indexOf(at[gt].toLowerCase());
      if (wt >= 0)
        return !0;
    }
    return !at.length;
  }, loader: function(J, et, at) {
    var gt = e(this).tree("options");
    if (!gt.url)
      return !1;
    e.ajax({ type: gt.method, url: gt.url, data: J, dataType: "json", success: function(wt) {
      et(wt);
    }, error: function() {
      at.apply(this, arguments);
    } });
  }, loadFilter: function(J, et) {
    return J;
  }, view: Zt, onBeforeLoad: function(J, et) {
  }, onLoadSuccess: function(J, et) {
  }, onLoadError: function() {
  }, onClick: function(J) {
  }, onDblClick: function(J) {
  }, onBeforeExpand: function(J) {
  }, onExpand: function(J) {
  }, onBeforeCollapse: function(J) {
  }, onCollapse: function(J) {
  }, onBeforeCheck: function(J, et) {
  }, onCheck: function(J, et) {
  }, onBeforeSelect: function(J) {
  }, onSelect: function(J) {
  }, onContextMenu: function(J, et) {
  }, onBeforeDrag: function(J) {
  }, onStartDrag: function(J) {
  }, onStopDrag: function(J) {
  }, onDragEnter: function(J, et) {
  }, onDragOver: function(J, et) {
  }, onDragLeave: function(J, et) {
  }, onBeforeDrop: function(J, et, at) {
  }, onDrop: function(J, et, at) {
  }, onBeforeEdit: function(J) {
  }, onAfterEdit: function(J) {
  }, onCancelEdit: function(J) {
  } };
})($);
(function(e) {
  function n(o) {
    return e(o).addClass("progressbar"), e(o).html('<div class="progressbar-text"></div><div class="progressbar-value"><div class="progressbar-text"></div></div>'), e(o).bind("_resize", function(l, u) {
      return (e(this).hasClass("easyui-fluid") || u) && r(o), !1;
    }), e(o);
  }
  function r(o, l) {
    var u = e.data(o, "progressbar").options, h = e.data(o, "progressbar").bar;
    l && (u.width = l), h._size(u), h.find("div.progressbar-text").css("width", h.width()), h.find("div.progressbar-text,div.progressbar-value").css({ height: h.height() + "px", lineHeight: h.height() + "px" });
  }
  e.fn.progressbar = function(o, l) {
    if (typeof o == "string") {
      var u = e.fn.progressbar.methods[o];
      if (u)
        return u(this, l);
    }
    return o = o || {}, this.each(function() {
      var h = e.data(this, "progressbar");
      h ? e.extend(h.options, o) : h = e.data(this, "progressbar", { options: e.extend({}, e.fn.progressbar.defaults, e.fn.progressbar.parseOptions(this), o), bar: n(this) }), e(this).progressbar("setValue", h.options.value), r(this);
    });
  }, e.fn.progressbar.methods = { options: function(o) {
    return e.data(o[0], "progressbar").options;
  }, resize: function(o, l) {
    return o.each(function() {
      r(this, l);
    });
  }, getValue: function(o) {
    return e.data(o[0], "progressbar").options.value;
  }, setValue: function(o, l) {
    return l < 0 && (l = 0), l > 100 && (l = 100), o.each(function() {
      var u = e.data(this, "progressbar").options, h = u.text.replace(/{value}/, l), c = u.value;
      u.value = l, e(this).find("div.progressbar-value").width(l + "%"), e(this).find("div.progressbar-text").html(h), c != l && u.onChange.call(this, l, c);
    });
  } }, e.fn.progressbar.parseOptions = function(o) {
    return e.extend({}, e.parser.parseOptions(o, ["width", "height", "text", { value: "number" }]));
  }, e.fn.progressbar.defaults = { width: "auto", height: 22, value: 0, text: "{value}%", onChange: function(o, l) {
  } };
})($);
(function(e) {
  function n(v) {
    e(v).addClass("tooltip-f");
  }
  function r(v) {
    var m = e.data(v, "tooltip").options;
    e(v).unbind(".tooltip").bind(m.showEvent + ".tooltip", function(g) {
      e(v).tooltip("show", g);
    }).bind(m.hideEvent + ".tooltip", function(g) {
      e(v).tooltip("hide", g);
    }).bind("mousemove.tooltip", function(g) {
      m.trackMouse && (m.trackMouseX = g.pageX, m.trackMouseY = g.pageY, e(v).tooltip("reposition"));
    });
  }
  function o(v) {
    var m = e.data(v, "tooltip");
    m.showTimer && (clearTimeout(m.showTimer), m.showTimer = null), m.hideTimer && (clearTimeout(m.hideTimer), m.hideTimer = null);
  }
  function l(v) {
    var m = e.data(v, "tooltip");
    if (!m || !m.tip)
      return;
    var g = m.options, y = m.tip, w = { left: -1e5, top: -1e5 };
    if (e(v).is(":visible")) {
      if (w = x(g.position), g.position == "top" && w.top < 0 ? w = x("bottom") : g.position == "bottom" && w.top + y._outerHeight() > e(window)._outerHeight() + e(document).scrollTop() && (w = x("top")), w.left < 0)
        g.position == "left" ? w = x("right") : (e(v).tooltip("arrow").css("left", y._outerWidth() / 2 + w.left), w.left = 0);
      else if (w.left + y._outerWidth() > e(window)._outerWidth() + e(document)._scrollLeft())
        if (g.position == "right")
          w = x("left");
        else {
          var E = w.left;
          w.left = e(window)._outerWidth() + e(document)._scrollLeft() - y._outerWidth(), e(v).tooltip("arrow").css("left", y._outerWidth() / 2 - (w.left - E));
        }
    }
    y.css({ left: w.left, top: w.top, zIndex: g.zIndex != null ? g.zIndex : e.fn.window ? e.fn.window.defaults.zIndex++ : "" }), g.onPosition.call(v, w.left, w.top);
    function x(D) {
      g.position = D || "bottom", y.removeClass("tooltip-top tooltip-bottom tooltip-left tooltip-right").addClass("tooltip-" + g.position);
      var F, k, N = e.isFunction(g.deltaX) ? g.deltaX.call(v, g.position) : g.deltaX, H = e.isFunction(g.deltaY) ? g.deltaY.call(v, g.position) : g.deltaY;
      if (g.trackMouse)
        R = e(), F = g.trackMouseX + N, k = g.trackMouseY + H;
      else {
        var R = e(v);
        F = R.offset().left + N, k = R.offset().top + H;
      }
      switch (g.position) {
        case "right":
          F += R._outerWidth() + 12 + (g.trackMouse ? 12 : 0), k -= (y._outerHeight() - R._outerHeight()) / 2;
          break;
        case "left":
          F -= y._outerWidth() + 12 + (g.trackMouse ? 12 : 0), k -= (y._outerHeight() - R._outerHeight()) / 2;
          break;
        case "top":
          F -= (y._outerWidth() - R._outerWidth()) / 2, k -= y._outerHeight() + 12 + (g.trackMouse ? 12 : 0);
          break;
        case "bottom":
          F -= (y._outerWidth() - R._outerWidth()) / 2, k += R._outerHeight() + 12 + (g.trackMouse ? 12 : 0);
          break;
      }
      return { left: F, top: k };
    }
  }
  function u(v, m) {
    var g = e.data(v, "tooltip"), y = g.options, w = g.tip;
    w || (w = e('<div tabindex="-1" class="tooltip"><div class="tooltip-content"></div><div class="tooltip-arrow-outer"></div><div class="tooltip-arrow"></div></div>').appendTo("body"), g.tip = w, c(v)), o(v), g.showTimer = setTimeout(function() {
      e(v).tooltip("reposition"), w.show(), y.onShow.call(v, m);
      var E = w.children(".tooltip-arrow-outer"), x = w.children(".tooltip-arrow"), D = "border-" + y.position + "-color";
      E.add(x).css({ borderTopColor: "", borderBottomColor: "", borderLeftColor: "", borderRightColor: "" }), E.css(D, w.css(D)), x.css(D, w.css("backgroundColor"));
    }, y.showDelay);
  }
  function h(v, m) {
    var g = e.data(v, "tooltip");
    g && g.tip && (o(v), g.hideTimer = setTimeout(function() {
      g.tip.hide(), g.options.onHide.call(v, m);
    }, g.options.hideDelay));
  }
  function c(v, m) {
    var g = e.data(v, "tooltip"), y = g.options;
    if (m && (y.content = m), !!g.tip) {
      var w = typeof y.content == "function" ? y.content.call(v) : y.content;
      g.tip.children(".tooltip-content").html(w), y.onUpdate.call(v, w);
    }
  }
  function f(v) {
    var m = e.data(v, "tooltip");
    if (m) {
      o(v);
      var g = m.options;
      m.tip && m.tip.remove(), g._title && e(v).attr("title", g._title), e.removeData(v, "tooltip"), e(v).unbind(".tooltip").removeClass("tooltip-f"), g.onDestroy.call(v);
    }
  }
  e.fn.tooltip = function(v, m) {
    return typeof v == "string" ? e.fn.tooltip.methods[v](this, m) : (v = v || {}, this.each(function() {
      var g = e.data(this, "tooltip");
      g ? e.extend(g.options, v) : (e.data(this, "tooltip", { options: e.extend({}, e.fn.tooltip.defaults, e.fn.tooltip.parseOptions(this), v) }), n(this)), r(this), c(this);
    }));
  }, e.fn.tooltip.methods = { options: function(v) {
    return e.data(v[0], "tooltip").options;
  }, tip: function(v) {
    return e.data(v[0], "tooltip").tip;
  }, arrow: function(v) {
    return v.tooltip("tip").children(".tooltip-arrow-outer,.tooltip-arrow");
  }, show: function(v, m) {
    return v.each(function() {
      u(this, m);
    });
  }, hide: function(v, m) {
    return v.each(function() {
      h(this, m);
    });
  }, update: function(v, m) {
    return v.each(function() {
      c(this, m);
    });
  }, reposition: function(v) {
    return v.each(function() {
      l(this);
    });
  }, destroy: function(v) {
    return v.each(function() {
      f(this);
    });
  } }, e.fn.tooltip.parseOptions = function(v) {
    var m = e(v), g = e.extend({}, e.parser.parseOptions(v, ["position", "showEvent", "hideEvent", "content", { trackMouse: "boolean", deltaX: "number", deltaY: "number", showDelay: "number", hideDelay: "number" }]), { _title: m.attr("title") });
    return m.attr("title", ""), g.content || (g.content = g._title), g;
  }, e.fn.tooltip.defaults = { position: "bottom", content: null, trackMouse: !1, deltaX: 0, deltaY: 0, showEvent: "mouseenter", hideEvent: "mouseleave", showDelay: 200, hideDelay: 100, onShow: function(v) {
  }, onHide: function(v) {
  }, onUpdate: function(v) {
  }, onPosition: function(v, m) {
  }, onDestroy: function() {
  } };
})($);
(function($) {
  $.fn._remove = function() {
    return this.each(function() {
      $(this).remove();
      try {
        this.outerHTML = "";
      } catch {
      }
    });
  };
  function _210(e) {
    e._remove();
  }
  function _211(e, n) {
    var r = $.data(e, "panel"), o = r.options, l = r.panel, u = l.children(".panel-header"), h = l.children(".panel-body"), c = l.children(".panel-footer"), f = o.halign == "left" || o.halign == "right";
    if (n && $.extend(o, { width: n.width, height: n.height, minWidth: n.minWidth, maxWidth: n.maxWidth, minHeight: n.minHeight, maxHeight: n.maxHeight, left: n.left, top: n.top }), l._size(o), f || u._outerWidth(l.width()), h._outerWidth(l.width()), isNaN(parseInt(o.height))) {
      h.css("height", "");
      var y = $.parser.parseValue("minHeight", o.minHeight, l.parent()), w = $.parser.parseValue("maxHeight", o.maxHeight, l.parent()), E = u._outerHeight() + c._outerHeight() + l._outerHeight() - l.height();
      h._size("minHeight", y ? y - E : ""), h._size("maxHeight", w ? w - E : "");
    } else if (f) {
      if (o.header)
        var v = $(o.header)._outerWidth();
      else {
        u.css("width", "");
        var v = u._outerWidth();
      }
      var m = u.find(".panel-title");
      v += Math.min(m._outerWidth(), m._outerHeight());
      var g = l.height();
      u._outerWidth(v)._outerHeight(g), m._outerWidth(u.height()), h._outerWidth(l.width() - v - c._outerWidth())._outerHeight(g), c._outerHeight(g), h.css({ left: "", right: "" }).css(o.halign, u.position()[o.halign] + v + "px"), o.panelCssWidth = l.css("width"), o.collapsed && l._outerWidth(v + c._outerWidth());
    } else
      h._outerHeight(l.height() - u._outerHeight() - c._outerHeight());
    l.css({ height: f ? void 0 : "", minHeight: "", maxHeight: "", left: o.left, top: o.top }), o.onResize.apply(e, [o.width, o.height]), $(e).panel("doLayout");
  }
  function _21e(e, n) {
    var r = $.data(e, "panel"), o = r.options, l = r.panel;
    n && (n.left != null && (o.left = n.left), n.top != null && (o.top = n.top)), l.css({ left: o.left, top: o.top }), l.find(".tooltip-f").each(function() {
      $(this).tooltip("reposition");
    }), o.onMove.apply(e, [o.left, o.top]);
  }
  function _223(e) {
    $(e).addClass("panel-body")._size("clear");
    var n = $('<div class="panel"></div>').insertBefore(e);
    return n[0].appendChild(e), n.bind("_resize", function(r, o) {
      return ($(this).hasClass("easyui-fluid") || o) && _211(e), !1;
    }), n;
  }
  function _227(_228) {
    var _229 = $.data(_228, "panel"), opts = _229.options, _22a = _229.panel;
    _22a.css(opts.style), _22a.addClass(opts.cls), _22a.removeClass("panel-hleft panel-hright").addClass("panel-h" + opts.halign), _22b(), _22c();
    var _22d = $(_228).panel("header"), body = $(_228).panel("body"), _22e = $(_228).siblings(".panel-footer");
    opts.border ? (_22d.removeClass("panel-header-noborder"), body.removeClass("panel-body-noborder"), _22e.removeClass("panel-footer-noborder")) : (_22d.addClass("panel-header-noborder"), body.addClass("panel-body-noborder"), _22e.addClass("panel-footer-noborder")), _22d.addClass(opts.headerCls), body.addClass(opts.bodyCls), $(_228).attr("id", opts.id || ""), opts.content && ($(_228).panel("clear"), $(_228).html(opts.content), $.parser.parse($(_228)));
    function _22b() {
      if (opts.noheader || !opts.title && !opts.header)
        _210(_22a.children(".panel-header")), _22a.children(".panel-body").addClass("panel-body-noheader");
      else {
        if (opts.header)
          $(opts.header).addClass("panel-header").prependTo(_22a);
        else {
          var _22f = _22a.children(".panel-header");
          _22f.length || (_22f = $('<div class="panel-header"></div>').prependTo(_22a)), $.isArray(opts.tools) || _22f.find("div.panel-tool .panel-tool-a").appendTo(opts.tools), _22f.empty();
          var _230 = $('<div class="panel-title"></div>').html(opts.title).appendTo(_22f);
          opts.iconCls && (_230.addClass("panel-with-icon"), $('<div class="panel-icon"></div>').addClass(opts.iconCls).appendTo(_22f)), (opts.halign == "left" || opts.halign == "right") && _230.addClass("panel-title-" + opts.titleDirection);
          var tool = $('<div class="panel-tool"></div>').appendTo(_22f);
          tool.bind("click", function(e) {
            e.stopPropagation();
          }), opts.tools && ($.isArray(opts.tools) ? $.map(opts.tools, function(t) {
            _231(tool, t.iconCls, eval(t.handler));
          }) : $(opts.tools).children().each(function() {
            $(this).addClass($(this).attr("iconCls")).addClass("panel-tool-a").appendTo(tool);
          })), opts.collapsible && _231(tool, "panel-tool-collapse", function() {
            opts.collapsed == !0 ? _251(_228, !0) : _242(_228, !0);
          }), opts.minimizable && _231(tool, "panel-tool-min", function() {
            _257(_228);
          }), opts.maximizable && _231(tool, "panel-tool-max", function() {
            opts.maximized == !0 ? _25a(_228) : _241(_228);
          }), opts.closable && _231(tool, "panel-tool-close", function() {
            _243(_228);
          });
        }
        _22a.children("div.panel-body").removeClass("panel-body-noheader");
      }
    }
    function _231(e, n, r) {
      var o = $('<a href="javascript:;"></a>').addClass(n).appendTo(e);
      o.bind("click", r);
    }
    function _22c() {
      opts.footer ? ($(opts.footer).addClass("panel-footer").appendTo(_22a), $(_228).addClass("panel-body-nobottom")) : (_22a.children(".panel-footer").remove(), $(_228).removeClass("panel-body-nobottom"));
    }
  }
  function _233(e, n) {
    var r = $.data(e, "panel"), o = r.options;
    if (l && (o.queryParams = n), !!o.href && (!r.isLoaded || !o.cache)) {
      var l = $.extend({}, o.queryParams);
      if (o.onBeforeLoad.call(e, l) == !1)
        return;
      r.isLoaded = !1, o.loadingMessage && ($(e).panel("clear"), $(e).html($('<div class="panel-loading"></div>').html(o.loadingMessage))), o.loader.call(e, l, function(u) {
        var h = o.extractor.call(e, u);
        $(e).panel("clear"), $(e).html(h), $.parser.parse($(e)), o.onLoad.apply(e, arguments), r.isLoaded = !0;
      }, function() {
        o.onLoadError.apply(e, arguments);
      });
    }
  }
  function _239(e) {
    var n = $(e);
    n.find(".combo-f").each(function() {
      $(this).combo("destroy");
    }), n.find(".m-btn").each(function() {
      $(this).menubutton("destroy");
    }), n.find(".s-btn").each(function() {
      $(this).splitbutton("destroy");
    }), n.find(".tooltip-f").each(function() {
      $(this).tooltip("destroy");
    }), n.children("div").each(function() {
      $(this)._size("unfit");
    }), n.empty();
  }
  function _23b(e) {
    $(e).panel("doLayout", !0);
  }
  function _23d(e, n) {
    var r = $.data(e, "panel").options, o = $.data(e, "panel").panel;
    if (n != !0 && r.onBeforeOpen.call(e) == !1)
      return;
    if (o.stop(!0, !0), $.isFunction(r.openAnimation))
      r.openAnimation.call(e, l);
    else
      switch (r.openAnimation) {
        case "slide":
          o.slideDown(r.openDuration, l);
          break;
        case "fade":
          o.fadeIn(r.openDuration, l);
          break;
        case "show":
          o.show(r.openDuration, l);
          break;
        default:
          o.show(), l();
      }
    function l() {
      r.closed = !1, r.minimized = !1;
      var u = o.children(".panel-header").find("a.panel-tool-restore");
      u.length && (r.maximized = !0), r.onOpen.call(e), r.maximized == !0 && (r.maximized = !1, _241(e)), r.collapsed == !0 && (r.collapsed = !1, _242(e)), r.collapsed || (_233(e), _23b(e));
    }
  }
  function _243(e, n) {
    var r = $.data(e, "panel"), o = r.options, l = r.panel;
    if (n != !0 && o.onBeforeClose.call(e) == !1)
      return;
    if (l.find(".tooltip-f").each(function() {
      $(this).tooltip("hide");
    }), l.stop(!0, !0), l._size("unfit"), $.isFunction(o.closeAnimation))
      o.closeAnimation.call(e, u);
    else
      switch (o.closeAnimation) {
        case "slide":
          l.slideUp(o.closeDuration, u);
          break;
        case "fade":
          l.fadeOut(o.closeDuration, u);
          break;
        case "hide":
          l.hide(o.closeDuration, u);
          break;
        default:
          l.hide(), u();
      }
    function u() {
      o.closed = !0, o.onClose.call(e);
    }
  }
  function _248(e, n) {
    var r = $.data(e, "panel"), o = r.options, l = r.panel;
    n != !0 && o.onBeforeDestroy.call(e) == !1 || ($(e).panel("clear").panel("clear", "footer"), _210(l), o.onDestroy.call(e));
  }
  function _242(e, n) {
    var r = $.data(e, "panel").options, o = $.data(e, "panel").panel, l = o.children(".panel-body"), u = o.children(".panel-header"), h = u.find("a.panel-tool-collapse");
    if (r.collapsed == !0 || (l.stop(!0, !0), r.onBeforeCollapse.call(e) == !1))
      return;
    h.addClass("panel-tool-expand"), n == !0 ? r.halign == "left" || r.halign == "right" ? o.animate({ width: u._outerWidth() + o.children(".panel-footer")._outerWidth() }, function() {
      c();
    }) : l.slideUp("normal", function() {
      c();
    }) : ((r.halign == "left" || r.halign == "right") && o._outerWidth(u._outerWidth() + o.children(".panel-footer")._outerWidth()), c());
    function c() {
      l.hide(), r.collapsed = !0, r.onCollapse.call(e);
    }
  }
  function _251(e, n) {
    var r = $.data(e, "panel").options, o = $.data(e, "panel").panel, l = o.children(".panel-body"), u = o.children(".panel-header").find("a.panel-tool-collapse");
    if (r.collapsed == !1 || (l.stop(!0, !0), r.onBeforeExpand.call(e) == !1))
      return;
    u.removeClass("panel-tool-expand"), n == !0 ? r.halign == "left" || r.halign == "right" ? (l.show(), o.animate({ width: r.panelCssWidth }, function() {
      h();
    })) : l.slideDown("normal", function() {
      h();
    }) : ((r.halign == "left" || r.halign == "right") && o.css("width", r.panelCssWidth), h());
    function h() {
      l.show(), r.collapsed = !1, r.onExpand.call(e), _233(e), _23b(e);
    }
  }
  function _241(e) {
    var n = $.data(e, "panel").options, r = $.data(e, "panel").panel, o = r.children(".panel-header").find("a.panel-tool-max");
    n.maximized != !0 && (o.addClass("panel-tool-restore"), $.data(e, "panel").original || ($.data(e, "panel").original = { width: n.width, height: n.height, left: n.left, top: n.top, fit: n.fit }), n.left = 0, n.top = 0, n.fit = !0, _211(e), n.minimized = !1, n.maximized = !0, n.onMaximize.call(e));
  }
  function _257(e) {
    var n = $.data(e, "panel").options, r = $.data(e, "panel").panel;
    r._size("unfit"), r.hide(), n.minimized = !0, n.maximized = !1, n.onMinimize.call(e);
  }
  function _25a(e) {
    var n = $.data(e, "panel").options, r = $.data(e, "panel").panel, o = r.children(".panel-header").find("a.panel-tool-max");
    n.maximized != !1 && (r.show(), o.removeClass("panel-tool-restore"), $.extend(n, $.data(e, "panel").original), _211(e), n.minimized = !1, n.maximized = !1, $.data(e, "panel").original = null, n.onRestore.call(e));
  }
  function _25d(e, n) {
    $.data(e, "panel").options.title = n, $(e).panel("header").find("div.panel-title").html(n);
  }
  var _260 = null;
  $(window).unbind(".panel").bind("resize.panel", function() {
    _260 && clearTimeout(_260), _260 = setTimeout(function() {
      var e = $("body.layout");
      e.length ? (e.layout("resize"), $("body").children(".easyui-fluid:visible").each(function() {
        $(this).triggerHandler("_resize");
      })) : $("body").panel("doLayout"), _260 = null;
    }, 100);
  }), $.fn.panel = function(e, n) {
    return typeof e == "string" ? $.fn.panel.methods[e](this, n) : (e = e || {}, this.each(function() {
      var r = $.data(this, "panel"), o;
      r ? (o = $.extend(r.options, e), r.isLoaded = !1) : (o = $.extend({}, $.fn.panel.defaults, $.fn.panel.parseOptions(this), e), $(this).attr("title", ""), r = $.data(this, "panel", { options: o, panel: _223(this), isLoaded: !1 })), _227(this), $(this).show(), o.doSize == !0 && (r.panel.css("display", "block"), _211(this)), o.closed == !0 || o.minimized == !0 ? r.panel.hide() : _23d(this);
    }));
  }, $.fn.panel.methods = { options: function(e) {
    return $.data(e[0], "panel").options;
  }, panel: function(e) {
    return $.data(e[0], "panel").panel;
  }, header: function(e) {
    return $.data(e[0], "panel").panel.children(".panel-header");
  }, footer: function(e) {
    return e.panel("panel").children(".panel-footer");
  }, body: function(e) {
    return $.data(e[0], "panel").panel.children(".panel-body");
  }, setTitle: function(e, n) {
    return e.each(function() {
      _25d(this, n);
    });
  }, open: function(e, n) {
    return e.each(function() {
      _23d(this, n);
    });
  }, close: function(e, n) {
    return e.each(function() {
      _243(this, n);
    });
  }, destroy: function(e, n) {
    return e.each(function() {
      _248(this, n);
    });
  }, clear: function(e, n) {
    return e.each(function() {
      _239(n == "footer" ? $(this).panel("footer") : this);
    });
  }, refresh: function(e, n) {
    return e.each(function() {
      var r = $.data(this, "panel");
      r.isLoaded = !1, n && (typeof n == "string" ? r.options.href = n : r.options.queryParams = n), _233(this);
    });
  }, resize: function(e, n) {
    return e.each(function() {
      _211(this, n);
    });
  }, doLayout: function(e, n) {
    return e.each(function() {
      r(this, "body"), r($(this).siblings(".panel-footer")[0], "footer");
      function r(o, l) {
        if (o) {
          var u = o == $("body")[0], h = $(o).find("div.panel:visible,div.accordion:visible,div.tabs-container:visible,div.layout:visible,.easyui-fluid:visible").filter(function(c, f) {
            var v = $(f).parents(".panel-" + l + ":first");
            return u ? v.length == 0 : v[0] == o;
          });
          h.each(function() {
            $(this).triggerHandler("_resize", [n || !1]);
          });
        }
      }
    });
  }, move: function(e, n) {
    return e.each(function() {
      _21e(this, n);
    });
  }, maximize: function(e) {
    return e.each(function() {
      _241(this);
    });
  }, minimize: function(e) {
    return e.each(function() {
      _257(this);
    });
  }, restore: function(e) {
    return e.each(function() {
      _25a(this);
    });
  }, collapse: function(e, n) {
    return e.each(function() {
      _242(this, n);
    });
  }, expand: function(e, n) {
    return e.each(function() {
      _251(this, n);
    });
  } }, $.fn.panel.parseOptions = function(e) {
    var n = $(e), r = n.children(".panel-header,header"), o = n.children(".panel-footer,footer");
    return $.extend({}, $.parser.parseOptions(e, ["id", "width", "height", "left", "top", "title", "iconCls", "cls", "headerCls", "bodyCls", "tools", "href", "method", "header", "footer", "halign", "titleDirection", { cache: "boolean", fit: "boolean", border: "boolean", noheader: "boolean" }, { collapsible: "boolean", minimizable: "boolean", maximizable: "boolean" }, { closable: "boolean", collapsed: "boolean", minimized: "boolean", maximized: "boolean", closed: "boolean" }, "openAnimation", "closeAnimation", { openDuration: "number", closeDuration: "number" }]), { loadingMessage: n.attr("loadingMessage") != null ? n.attr("loadingMessage") : void 0, header: r.length ? r.removeClass("panel-header") : void 0, footer: o.length ? o.removeClass("panel-footer") : void 0 });
  }, $.fn.panel.defaults = { id: null, title: null, iconCls: null, width: "auto", height: "auto", left: null, top: null, cls: null, headerCls: null, bodyCls: null, style: {}, href: null, cache: !0, fit: !1, border: !0, doSize: !0, noheader: !1, content: null, halign: "top", titleDirection: "down", collapsible: !1, minimizable: !1, maximizable: !1, closable: !1, collapsed: !1, minimized: !1, maximized: !1, closed: !1, openAnimation: !1, openDuration: 400, closeAnimation: !1, closeDuration: 400, tools: null, footer: null, header: null, queryParams: {}, method: "get", href: null, loadingMessage: "Loading...", loader: function(e, n, r) {
    var o = $(this).panel("options");
    if (!o.href)
      return !1;
    $.ajax({ type: o.method, url: o.href, cache: !1, data: e, dataType: "html", success: function(l) {
      n(l);
    }, error: function() {
      r.apply(this, arguments);
    } });
  }, extractor: function(e) {
    var n = /<body[^>]*>((.|[\n\r])*)<\/body>/im, r = n.exec(e);
    return r ? r[1] : e;
  }, onBeforeLoad: function(e) {
  }, onLoad: function() {
  }, onLoadError: function() {
  }, onBeforeOpen: function() {
  }, onOpen: function() {
  }, onBeforeClose: function() {
  }, onClose: function() {
  }, onBeforeDestroy: function() {
  }, onDestroy: function() {
  }, onResize: function(e, n) {
  }, onMove: function(e, n) {
  }, onMaximize: function() {
  }, onRestore: function() {
  }, onMinimize: function() {
  }, onBeforeCollapse: function() {
  }, onBeforeExpand: function() {
  }, onCollapse: function() {
  }, onExpand: function() {
  } };
})($);
(function(e) {
  function n(c, f) {
    var v = e.data(c, "window");
    f && (f.left != null && (v.options.left = f.left), f.top != null && (v.options.top = f.top)), e(c).panel("move", v.options), v.shadow && v.shadow.css({ left: v.options.left, top: v.options.top });
  }
  function r(c, f) {
    var v = e.data(c, "window").options, m = e(c).window("panel"), g = m._outerWidth();
    if (v.inline) {
      var y = m.parent();
      v.left = Math.ceil((y.width() - g) / 2 + y.scrollLeft());
    } else
      v.left = Math.ceil((e(window)._outerWidth() - g) / 2 + e(document).scrollLeft());
    f && n(c);
  }
  function o(c, f) {
    var v = e.data(c, "window").options, m = e(c).window("panel"), g = m._outerHeight();
    if (v.inline) {
      var y = m.parent();
      v.top = Math.ceil((y.height() - g) / 2 + y.scrollTop());
    } else
      v.top = Math.ceil((e(window)._outerHeight() - g) / 2 + e(document).scrollTop());
    f && n(c);
  }
  function l(c) {
    var f = e.data(c, "window"), v = f.options, m = e(c).panel(e.extend({}, f.options, { border: !1, doSize: !0, closed: !0, cls: "window " + (v.border ? v.border == "thin" ? "window-thinborder " : "" : "window-thinborder window-noborder ") + (v.cls || ""), headerCls: "window-header " + (v.headerCls || ""), bodyCls: "window-body " + (v.noheader ? "window-body-noheader " : " ") + (v.bodyCls || ""), onBeforeDestroy: function() {
      if (v.onBeforeDestroy.call(c) == !1)
        return !1;
      f.shadow && f.shadow.remove(), f.mask && f.mask.remove();
    }, onClose: function() {
      f.shadow && f.shadow.hide(), f.mask && f.mask.hide(), v.onClose.call(c);
    }, onOpen: function() {
      f.mask && f.mask.css(e.extend({ display: "block", zIndex: e.fn.window.defaults.zIndex++ }, e.fn.window.getMaskSize(c))), f.shadow && f.shadow.css({ display: "block", zIndex: e.fn.window.defaults.zIndex++, left: v.left, top: v.top, width: f.window._outerWidth(), height: f.window._outerHeight() }), f.window.css("z-index", e.fn.window.defaults.zIndex++), v.onOpen.call(c);
    }, onResize: function(y, w) {
      var E = e(this).panel("options");
      e.extend(v, { width: E.width, height: E.height, left: E.left, top: E.top }), f.shadow && f.shadow.css({ left: v.left, top: v.top, width: f.window._outerWidth(), height: f.window._outerHeight() }), v.onResize.call(c, y, w);
    }, onMinimize: function() {
      f.shadow && f.shadow.hide(), f.mask && f.mask.hide(), f.options.onMinimize.call(c);
    }, onBeforeCollapse: function() {
      if (v.onBeforeCollapse.call(c) == !1)
        return !1;
      f.shadow && f.shadow.hide();
    }, onExpand: function() {
      f.shadow && f.shadow.show(), v.onExpand.call(c);
    } }));
    f.window = m.panel("panel"), f.mask && f.mask.remove(), v.modal && (f.mask = e('<div class="window-mask" style="display:none"></div>').insertAfter(f.window)), f.shadow && f.shadow.remove(), v.shadow && (f.shadow = e('<div class="window-shadow" style="display:none"></div>').insertAfter(f.window));
    var g = v.closed;
    v.left == null && r(c), v.top == null && o(c), n(c), g || m.window("open");
  }
  function u(c, f, v, m) {
    var g = this, y = e.data(g, "window"), w = y.options;
    if (!w.constrain)
      return {};
    if (e.isFunction(w.constrain))
      return w.constrain.call(g, c, f, v, m);
    var E = e(g).window("window"), x = w.inline ? E.parent() : e(window);
    return c < 0 && (c = 0), f < x.scrollTop() && (f = x.scrollTop()), c + v > x.width() && (v == E.outerWidth() ? c = x.width() - v : v = x.width() - c), f - x.scrollTop() + m > x.height() && (m == E.outerHeight() ? f = x.height() - m + x.scrollTop() : m = x.height() - f + x.scrollTop()), { left: c, top: f, width: v, height: m };
  }
  function h(c) {
    var f = e.data(c, "window");
    f.window.draggable({ handle: ">div.panel-header>div.panel-title", disabled: f.options.draggable == !1, onBeforeDrag: function(y) {
      f.mask && f.mask.css("z-index", e.fn.window.defaults.zIndex++), f.shadow && f.shadow.css("z-index", e.fn.window.defaults.zIndex++), f.window.css("z-index", e.fn.window.defaults.zIndex++);
    }, onStartDrag: function(y) {
      v(y);
    }, onDrag: function(y) {
      return m(y), !1;
    }, onStopDrag: function(y) {
      g(y, "move");
    } }), f.window.resizable({ disabled: f.options.resizable == !1, onStartResize: function(y) {
      v(y);
    }, onResize: function(y) {
      return m(y), !1;
    }, onStopResize: function(y) {
      g(y, "resize");
    } });
    function v(y) {
      f.pmask && f.pmask.remove(), f.pmask = e('<div class="window-proxy-mask"></div>').insertAfter(f.window), f.pmask.css({ display: "none", zIndex: e.fn.window.defaults.zIndex++, left: y.data.left, top: y.data.top, width: f.window._outerWidth(), height: f.window._outerHeight() }), f.proxy && f.proxy.remove(), f.proxy = e('<div class="window-proxy"></div>').insertAfter(f.window), f.proxy.css({ display: "none", zIndex: e.fn.window.defaults.zIndex++, left: y.data.left, top: y.data.top }), f.proxy._outerWidth(y.data.width)._outerHeight(y.data.height), f.proxy.hide(), setTimeout(function() {
        f.pmask && f.pmask.show(), f.proxy && f.proxy.show();
      }, 500);
    }
    function m(y) {
      e.extend(y.data, u.call(c, y.data.left, y.data.top, y.data.width, y.data.height)), f.pmask.show(), f.proxy.css({ display: "block", left: y.data.left, top: y.data.top }), f.proxy._outerWidth(y.data.width), f.proxy._outerHeight(y.data.height);
    }
    function g(y, w) {
      e.extend(y.data, u.call(c, y.data.left, y.data.top, y.data.width + 0.1, y.data.height + 0.1)), e(c).window(w, y.data), f.pmask.remove(), f.pmask = null, f.proxy.remove(), f.proxy = null;
    }
  }
  e(function() {
    e._positionFixed || e(window).resize(function() {
      e("body>div.window-mask:visible").css({ width: "", height: "" }), setTimeout(function() {
        e("body>div.window-mask:visible").css(e.fn.window.getMaskSize());
      }, 50);
    });
  }), e.fn.window = function(c, f) {
    if (typeof c == "string") {
      var v = e.fn.window.methods[c];
      return v ? v(this, f) : this.panel(c, f);
    }
    return c = c || {}, this.each(function() {
      var m = e.data(this, "window");
      m ? e.extend(m.options, c) : (m = e.data(this, "window", { options: e.extend({}, e.fn.window.defaults, e.fn.window.parseOptions(this), c) }), m.options.inline || document.body.appendChild(this)), l(this), h(this);
    });
  }, e.fn.window.methods = { options: function(c) {
    var f = c.panel("options"), v = e.data(c[0], "window").options;
    return e.extend(v, { closed: f.closed, collapsed: f.collapsed, minimized: f.minimized, maximized: f.maximized });
  }, window: function(c) {
    return e.data(c[0], "window").window;
  }, move: function(c, f) {
    return c.each(function() {
      n(this, f);
    });
  }, hcenter: function(c) {
    return c.each(function() {
      r(this, !0);
    });
  }, vcenter: function(c) {
    return c.each(function() {
      o(this, !0);
    });
  }, center: function(c) {
    return c.each(function() {
      r(this), o(this), n(this);
    });
  } }, e.fn.window.getMaskSize = function(c) {
    var f = e(c).data("window");
    return f && f.options.inline ? {} : e._positionFixed ? { position: "fixed" } : { width: e(document).width(), height: e(document).height() };
  }, e.fn.window.parseOptions = function(c) {
    return e.extend({}, e.fn.panel.parseOptions(c), e.parser.parseOptions(c, [{ draggable: "boolean", resizable: "boolean", shadow: "boolean", modal: "boolean", inline: "boolean" }]));
  }, e.fn.window.defaults = e.extend({}, e.fn.panel.defaults, { zIndex: 9e3, draggable: !0, resizable: !0, shadow: !0, modal: !1, border: !0, inline: !1, title: "New Window", collapsible: !0, minimizable: !0, maximizable: !0, closable: !0, closed: !1, constrain: !1 });
})($);
(function($) {
  function _2a7(_2a8) {
    var opts = $.data(_2a8, "dialog").options;
    opts.inited = !1, $(_2a8).window($.extend({}, opts, { onResize: function(e, n) {
      opts.inited && (_2ad(this), opts.onResize.call(this, e, n));
    } }));
    var win = $(_2a8).window("window");
    if (opts.toolbar)
      if ($.isArray(opts.toolbar)) {
        $(_2a8).siblings("div.dialog-toolbar").remove();
        for (var _2a9 = $('<div class="dialog-toolbar"><table cellspacing="0" cellpadding="0"><tr></tr></table></div>').appendTo(win), tr = _2a9.find("tr"), i = 0; i < opts.toolbar.length; i++) {
          var btn = opts.toolbar[i];
          if (btn == "-")
            $('<td><div class="dialog-tool-separator"></div></td>').appendTo(tr);
          else {
            var td = $("<td></td>").appendTo(tr), tool = $('<a href="javascript:;"></a>').appendTo(td);
            tool[0].onclick = eval(btn.handler || function() {
            }), tool.linkbutton($.extend({}, btn, { plain: !0 }));
          }
        }
      } else
        $(opts.toolbar).addClass("dialog-toolbar").appendTo(win), $(opts.toolbar).show();
    else
      $(_2a8).siblings("div.dialog-toolbar").remove();
    if (opts.buttons)
      if ($.isArray(opts.buttons)) {
        $(_2a8).siblings("div.dialog-button").remove();
        for (var _2aa = $('<div class="dialog-button"></div>').appendTo(win), i = 0; i < opts.buttons.length; i++) {
          var p = opts.buttons[i], _2ab = $('<a href="javascript:;"></a>').appendTo(_2aa);
          p.handler && (_2ab[0].onclick = p.handler), _2ab.linkbutton(p);
        }
      } else
        $(opts.buttons).addClass("dialog-button").appendTo(win), $(opts.buttons).show();
    else
      $(_2a8).siblings("div.dialog-button").remove();
    opts.inited = !0;
    var _2ac = opts.closed;
    win.show(), $(_2a8).window("resize"), _2ac && win.hide();
  }
  function _2ad(e, n) {
    var r = $(e), o = r.dialog("options"), l = o.noheader, u = r.siblings(".dialog-toolbar"), h = r.siblings(".dialog-button");
    u.insertBefore(e).css({ borderTopWidth: l ? 1 : 0, top: l ? u.length : 0 }), h.insertAfter(e), u.add(h)._outerWidth(r._outerWidth()).find(".easyui-fluid:visible").each(function() {
      $(this).triggerHandler("_resize");
    });
    var c = u._outerHeight() + h._outerHeight();
    if (!isNaN(parseInt(o.height)))
      r._outerHeight(r._outerHeight() - c);
    else {
      var f = r._size("min-height");
      f && r._size("min-height", f - c);
      var v = r._size("max-height");
      v && r._size("max-height", v - c);
    }
    var m = $.data(e, "window").shadow;
    if (m) {
      var g = r.panel("panel");
      m.css({ width: g._outerWidth(), height: g._outerHeight() });
    }
  }
  $.fn.dialog = function(e, n) {
    if (typeof e == "string") {
      var r = $.fn.dialog.methods[e];
      return r ? r(this, n) : this.window(e, n);
    }
    return e = e || {}, this.each(function() {
      var o = $.data(this, "dialog");
      o ? $.extend(o.options, e) : $.data(this, "dialog", { options: $.extend({}, $.fn.dialog.defaults, $.fn.dialog.parseOptions(this), e) }), _2a7(this);
    });
  }, $.fn.dialog.methods = { options: function(e) {
    var n = $.data(e[0], "dialog").options, r = e.panel("options");
    return $.extend(n, { width: r.width, height: r.height, left: r.left, top: r.top, closed: r.closed, collapsed: r.collapsed, minimized: r.minimized, maximized: r.maximized }), n;
  }, dialog: function(e) {
    return e.window("window");
  } }, $.fn.dialog.parseOptions = function(e) {
    var n = $(e);
    return $.extend({}, $.fn.window.parseOptions(e), $.parser.parseOptions(e, ["toolbar", "buttons"]), { toolbar: n.children(".dialog-toolbar").length ? n.children(".dialog-toolbar").removeClass("dialog-toolbar") : void 0, buttons: n.children(".dialog-button").length ? n.children(".dialog-button").removeClass("dialog-button") : void 0 });
  }, $.fn.dialog.defaults = $.extend({}, $.fn.window.defaults, { title: "New Dialog", collapsible: !1, minimizable: !1, maximizable: !1, resizable: !1, toolbar: null, buttons: null });
})($);
(function(e) {
  function n() {
    e(document).unbind(".messager").bind("keydown.messager", function(h) {
      if (h.keyCode == 27)
        e("body").children("div.messager-window").children("div.messager-body").each(function() {
          e(this).dialog("close");
        });
      else if (h.keyCode == 9) {
        var c = e("body").children("div.messager-window");
        if (!c.length)
          return;
        for (var f = c.find(".messager-input,.messager-button .l-btn"), v = 0; v < f.length; v++)
          if (e(f[v]).is(":focus"))
            return e(f[v >= f.length - 1 ? 0 : v + 1]).focus(), !1;
      } else if (h.keyCode == 13) {
        var m = e(h.target).closest("input.messager-input");
        if (m.length) {
          var g = m.closest(".messager-body");
          u(g, m.val());
        }
      }
    });
  }
  function r() {
    e(document).unbind(".messager");
  }
  function o(h) {
    var c = e.extend({}, e.messager.defaults, { modal: !1, shadow: !1, draggable: !1, resizable: !1, closed: !0, style: { left: "", top: "", right: 0, zIndex: e.fn.window.defaults.zIndex++, bottom: -document.body.scrollTop - document.documentElement.scrollTop }, title: "", width: 250, height: 100, minHeight: 0, showType: "slide", showSpeed: 600, content: h.msg, timeout: 4e3 }, h), f = e('<div class="messager-body"></div>').appendTo("body");
    return f.dialog(e.extend({}, c, { noheader: !c.title, openAnimation: c.showType, closeAnimation: c.showType == "show" ? "hide" : c.showType, openDuration: c.showSpeed, closeDuration: c.showSpeed, onOpen: function() {
      f.dialog("dialog").hover(function() {
        c.timer && clearTimeout(c.timer);
      }, function() {
        v();
      }), v();
      function v() {
        c.timeout > 0 && (c.timer = setTimeout(function() {
          f.length && f.data("dialog") && f.dialog("close");
        }, c.timeout));
      }
      h.onOpen ? h.onOpen.call(this) : c.onOpen.call(this);
    }, onClose: function() {
      c.timer && clearTimeout(c.timer), h.onClose ? h.onClose.call(this) : c.onClose.call(this), f.dialog("destroy");
    } })), f.dialog("dialog").css(c.style), f.dialog("open"), f;
  }
  function l(h) {
    n();
    var c = e('<div class="messager-body"></div>').appendTo("body");
    c.dialog(e.extend({}, h, { noheader: !h.title, onClose: function() {
      r(), h.onClose && h.onClose.call(this), setTimeout(function() {
        c.dialog("destroy");
      }, 100);
    } }));
    var f = c.dialog("dialog").addClass("messager-window");
    return f.find(".dialog-button").addClass("messager-button").find("a:first").focus(), c;
  }
  function u(h, c) {
    h.dialog("close"), h.dialog("options").fn(c);
  }
  e.messager = { show: function(h) {
    return o(h);
  }, alert: function(h, c, f, v) {
    var m = typeof h == "object" ? h : { title: h, msg: c, icon: f, fn: v }, g = m.icon ? "messager-icon messager-" + m.icon : "";
    m = e.extend({}, e.messager.defaults, { content: '<div class="' + g + '"></div><div>' + m.msg + '</div><div style="clear:both;"/>' }, m), m.buttons || (m.buttons = [{ text: m.ok, onClick: function() {
      u(y);
    } }]);
    var y = l(m);
    return y;
  }, confirm: function(h, c, f) {
    var v = typeof h == "object" ? h : { title: h, msg: c, fn: f };
    v = e.extend({}, e.messager.defaults, { content: '<div class="messager-icon messager-question"></div><div>' + v.msg + '</div><div style="clear:both;"/>' }, v), v.buttons || (v.buttons = [{ text: v.ok, onClick: function() {
      u(m, !0);
    } }, { text: v.cancel, onClick: function() {
      u(m, !1);
    } }]);
    var m = l(v);
    return m;
  }, prompt: function(h, c, f) {
    var v = typeof h == "object" ? h : { title: h, msg: c, fn: f };
    v = e.extend({}, e.messager.defaults, { content: '<div class="messager-icon messager-question"></div><div>' + v.msg + '</div><br/><div style="clear:both;"/><div><input class="messager-input" type="text"/></div>' }, v), v.buttons || (v.buttons = [{ text: v.ok, onClick: function() {
      u(m, m.find(".messager-input").val());
    } }, { text: v.cancel, onClick: function() {
      u(m);
    } }]);
    var m = l(v);
    return m.find(".messager-input").focus(), m;
  }, progress: function(h) {
    var c = { bar: function() {
      return e("body>div.messager-window").find("div.messager-p-bar");
    }, close: function() {
      var y = e("body>div.messager-window>div.messager-body:has(div.messager-progress)");
      y.length && y.dialog("close");
    } };
    if (typeof h == "string") {
      var f = c[h];
      return f();
    }
    h = h || {};
    var v = e.extend({}, { title: "", minHeight: 0, content: void 0, msg: "", text: void 0, interval: 300 }, h), m = l(e.extend({}, e.messager.defaults, { content: '<div class="messager-progress"><div class="messager-p-msg">' + v.msg + '</div><div class="messager-p-bar"></div></div>', closable: !1, doSize: !1 }, v, { onClose: function() {
      this.timer && clearInterval(this.timer), h.onClose ? h.onClose.call(this) : e.messager.defaults.onClose.call(this);
    } })), g = m.find("div.messager-p-bar");
    return g.progressbar({ text: v.text }), m.dialog("resize"), v.interval && (m[0].timer = setInterval(function() {
      var y = g.progressbar("getValue");
      y += 10, y > 100 && (y = 0), g.progressbar("setValue", y);
    }, v.interval)), m;
  } }, e.messager.defaults = e.extend({}, e.fn.dialog.defaults, { ok: "Ok", cancel: "Cancel", width: 300, height: "auto", minHeight: 150, modal: !0, collapsible: !1, minimizable: !1, maximizable: !1, resizable: !1, fn: function() {
  } });
})($);
(function(e) {
  function n(D, F) {
    var k = e.data(D, "accordion"), N = k.options, H = k.panels, R = e(D), j = N.halign == "left" || N.halign == "right";
    R.children(".panel-last").removeClass("panel-last"), R.children(".panel:last").addClass("panel-last"), F && e.extend(N, { width: F.width, height: F.height }), R._size(N);
    var S = 0, tt = "auto", nt = R.find(">.panel>.accordion-header");
    nt.length && (j ? (e(H[0]).panel("resize", { width: R.width(), height: R.height() }), S = e(nt[0])._outerWidth()) : S = e(nt[0]).css("height", "")._outerHeight()), isNaN(parseInt(N.height)) || (j ? tt = R.width() - S * nt.length : tt = R.height() - S * nt.length), ft(!0, tt - ft(!1));
    function ft(pt, ct) {
      for (var Nt = 0, kt = 0; kt < H.length; kt++) {
        var Rt = H[kt];
        if (j)
          var Mt = Rt.panel("header")._outerWidth(S);
        else
          var Mt = Rt.panel("header")._outerHeight(S);
        if (Rt.panel("options").collapsible == pt) {
          var G = isNaN(ct) ? void 0 : ct + S * Mt.length;
          j ? (Rt.panel("resize", { height: R.height(), width: pt ? G : void 0 }), Nt += Rt.panel("panel")._outerWidth() - S * Mt.length) : (Rt.panel("resize", { width: R.width(), height: pt ? G : void 0 }), Nt += Rt.panel("panel").outerHeight() - S * Mt.length);
        }
      }
      return Nt;
    }
  }
  function r(D, F, k, N) {
    for (var H = e.data(D, "accordion").panels, R = [], j = 0; j < H.length; j++) {
      var S = H[j];
      if (F)
        S.panel("options")[F] == k && R.push(S);
      else if (S[0] == e(k)[0])
        return j;
    }
    return F ? N ? R : R.length ? R[0] : null : -1;
  }
  function o(D) {
    return r(D, "collapsed", !1, !0);
  }
  function l(D) {
    var F = o(D);
    return F.length ? F[0] : null;
  }
  function u(D, F) {
    return r(D, null, F);
  }
  function h(D, F) {
    var k = e.data(D, "accordion").panels;
    return typeof F == "number" ? F < 0 || F >= k.length ? null : k[F] : r(D, "title", F);
  }
  function c(D) {
    var F = e.data(D, "accordion").options, k = e(D);
    F.border ? k.removeClass("accordion-noborder") : k.addClass("accordion-noborder");
  }
  function f(D) {
    var F = e.data(D, "accordion"), k = e(D);
    k.addClass("accordion"), F.panels = [], k.children("div").each(function() {
      var N = e.extend({}, e.parser.parseOptions(this), { selected: e(this).attr("selected") ? !0 : void 0 }), H = e(this);
      F.panels.push(H), v(D, H, N);
    }), k.bind("_resize", function(N, H) {
      return (e(this).hasClass("easyui-fluid") || H) && n(D), !1;
    });
  }
  function v(D, F, k) {
    var N = e.data(D, "accordion").options;
    F.panel(e.extend({}, { collapsible: !0, minimizable: !1, maximizable: !1, closable: !1, doSize: !1, collapsed: !0, headerCls: "accordion-header", bodyCls: "accordion-body", halign: N.halign }, k, { onBeforeExpand: function() {
      if (k.onBeforeExpand && k.onBeforeExpand.call(this) == !1)
        return !1;
      if (!N.multiple)
        for (var tt = e.grep(o(D), function(pt) {
          return pt.panel("options").collapsible;
        }), nt = 0; nt < tt.length; nt++)
          g(D, u(D, tt[nt]));
      var ft = e(this).panel("header");
      ft.addClass("accordion-header-selected"), ft.find(".accordion-collapse").removeClass("accordion-expand");
    }, onExpand: function() {
      e(D).find(">.panel-last>.accordion-header").removeClass("accordion-header-border"), k.onExpand && k.onExpand.call(this), N.onSelect.call(D, e(this).panel("options").title, u(D, this));
    }, onBeforeCollapse: function() {
      if (k.onBeforeCollapse && k.onBeforeCollapse.call(this) == !1)
        return !1;
      e(D).find(">.panel-last>.accordion-header").addClass("accordion-header-border");
      var tt = e(this).panel("header");
      tt.removeClass("accordion-header-selected"), tt.find(".accordion-collapse").addClass("accordion-expand");
    }, onCollapse: function() {
      isNaN(parseInt(N.height)) && e(D).find(">.panel-last>.accordion-header").removeClass("accordion-header-border"), k.onCollapse && k.onCollapse.call(this), N.onUnselect.call(D, e(this).panel("options").title, u(D, this));
    } }));
    var H = F.panel("header"), R = H.children("div.panel-tool");
    R.children("a.panel-tool-collapse").hide();
    var j = e('<a href="javascript:;"></a>').addClass("accordion-collapse accordion-expand").appendTo(R);
    j.bind("click", function() {
      return S(F), !1;
    }), F.panel("options").collapsible ? j.show() : j.hide(), (N.halign == "left" || N.halign == "right") && j.hide(), H.click(function() {
      return S(F), !1;
    });
    function S(tt) {
      var nt = tt.panel("options");
      if (nt.collapsible) {
        var ft = u(D, tt);
        nt.collapsed ? m(D, ft) : g(D, ft);
      }
    }
  }
  function m(D, F) {
    var k = h(D, F);
    if (k) {
      w(D);
      var N = e.data(D, "accordion").options;
      k.panel("expand", N.animate);
    }
  }
  function g(D, F) {
    var k = h(D, F);
    if (k) {
      w(D);
      var N = e.data(D, "accordion").options;
      k.panel("collapse", N.animate);
    }
  }
  function y(D) {
    var F = e.data(D, "accordion").options;
    e(D).find(">.panel-last>.accordion-header").addClass("accordion-header-border");
    var k = r(D, "selected", !0);
    N(k ? u(D, k) : F.selected);
    function N(H) {
      var R = F.animate;
      F.animate = !1, m(D, H), F.animate = R;
    }
  }
  function w(D) {
    for (var F = e.data(D, "accordion").panels, k = 0; k < F.length; k++)
      F[k].stop(!0, !0);
  }
  function E(D, F) {
    var k = e.data(D, "accordion"), N = k.options, H = k.panels;
    F.selected == null && (F.selected = !0), w(D);
    var R = e("<div></div>").appendTo(D);
    H.push(R), v(D, R, F), n(D), N.onAdd.call(D, F.title, H.length - 1), F.selected && m(D, H.length - 1);
  }
  function x(D, F) {
    var k = e.data(D, "accordion"), N = k.options, H = k.panels;
    w(D);
    var R = h(D, F), j = R.panel("options").title, S = u(D, R);
    if (R && N.onBeforeRemove.call(D, j, S) != !1) {
      if (H.splice(S, 1), R.panel("destroy"), H.length) {
        n(D);
        var tt = l(D);
        tt || m(D, 0);
      }
      N.onRemove.call(D, j, S);
    }
  }
  e.fn.accordion = function(D, F) {
    return typeof D == "string" ? e.fn.accordion.methods[D](this, F) : (D = D || {}, this.each(function() {
      var k = e.data(this, "accordion");
      k ? e.extend(k.options, D) : (e.data(this, "accordion", { options: e.extend({}, e.fn.accordion.defaults, e.fn.accordion.parseOptions(this), D), accordion: e(this).addClass("accordion"), panels: [] }), f(this)), c(this), n(this), y(this);
    }));
  }, e.fn.accordion.methods = { options: function(D) {
    return e.data(D[0], "accordion").options;
  }, panels: function(D) {
    return e.data(D[0], "accordion").panels;
  }, resize: function(D, F) {
    return D.each(function() {
      n(this, F);
    });
  }, getSelections: function(D) {
    return o(D[0]);
  }, getSelected: function(D) {
    return l(D[0]);
  }, getPanel: function(D, F) {
    return h(D[0], F);
  }, getPanelIndex: function(D, F) {
    return u(D[0], F);
  }, select: function(D, F) {
    return D.each(function() {
      m(this, F);
    });
  }, unselect: function(D, F) {
    return D.each(function() {
      g(this, F);
    });
  }, add: function(D, F) {
    return D.each(function() {
      E(this, F);
    });
  }, remove: function(D, F) {
    return D.each(function() {
      x(this, F);
    });
  } }, e.fn.accordion.parseOptions = function(D) {
    return e(D), e.extend({}, e.parser.parseOptions(D, ["width", "height", "halign", { fit: "boolean", border: "boolean", animate: "boolean", multiple: "boolean", selected: "number" }]));
  }, e.fn.accordion.defaults = { width: "auto", height: "auto", fit: !1, border: !0, animate: !0, multiple: !1, selected: 0, halign: "top", onSelect: function(D, F) {
  }, onUnselect: function(D, F) {
  }, onAdd: function(D, F) {
  }, onBeforeRemove: function(D, F) {
  }, onRemove: function(D, F) {
  } };
})($);
(function($) {
  function _329(e) {
    var n = 0;
    return $(e).children().each(function() {
      n += $(this).outerWidth(!0);
    }), n;
  }
  function _32a(e) {
    var n = $.data(e, "tabs").options;
    if (!(n.tabPosition == "left" || n.tabPosition == "right" || !n.showHeader)) {
      var r = $(e).children("div.tabs-header"), o = r.children("div.tabs-tool:not(.tabs-tool-hidden)"), l = r.children("div.tabs-scroller-left"), u = r.children("div.tabs-scroller-right"), h = r.children("div.tabs-wrap"), c = r.outerHeight();
      n.plain && (c -= c - r.height()), o._outerHeight(c);
      var f = _329(r.find("ul.tabs")), v = r.width() - o._outerWidth();
      f > v ? (l.add(u).show()._outerHeight(c), n.toolPosition == "left" ? (o.css({ left: l.outerWidth(), right: "" }), h.css({ marginLeft: l.outerWidth() + o._outerWidth(), marginRight: u._outerWidth(), width: v - l.outerWidth() - u.outerWidth() })) : (o.css({ left: "", right: u.outerWidth() }), h.css({ marginLeft: l.outerWidth(), marginRight: u.outerWidth() + o._outerWidth(), width: v - l.outerWidth() - u.outerWidth() }))) : (l.add(u).hide(), n.toolPosition == "left" ? (o.css({ left: 0, right: "" }), h.css({ marginLeft: o._outerWidth(), marginRight: 0, width: v })) : (o.css({ left: "", right: 0 }), h.css({ marginLeft: 0, marginRight: o._outerWidth(), width: v })));
    }
  }
  function _332(_333) {
    var opts = $.data(_333, "tabs").options, _334 = $(_333).children("div.tabs-header");
    if (opts.tools)
      if (typeof opts.tools == "string")
        $(opts.tools).addClass("tabs-tool").appendTo(_334), $(opts.tools).show();
      else {
        _334.children("div.tabs-tool").remove();
        for (var _335 = $('<div class="tabs-tool"><table cellspacing="0" cellpadding="0" style="height:100%"><tr></tr></table></div>').appendTo(_334), tr = _335.find("tr"), i = 0; i < opts.tools.length; i++) {
          var td = $("<td></td>").appendTo(tr), tool = $('<a href="javascript:;"></a>').appendTo(td);
          tool[0].onclick = eval(opts.tools[i].handler || function() {
          }), tool.linkbutton($.extend({}, opts.tools[i], { plain: !0 }));
        }
      }
    else
      _334.children("div.tabs-tool").remove();
  }
  function _336(e, n) {
    var r = $.data(e, "tabs"), o = r.options, l = $(e);
    if (!o.doSize)
      return;
    n && $.extend(o, { width: n.width, height: n.height }), l._size(o);
    var u = l.children("div.tabs-header"), h = l.children("div.tabs-panels"), c = u.find("div.tabs-wrap"), f = c.find(".tabs");
    if (f.children("li").removeClass("tabs-first tabs-last"), f.children("li:first").addClass("tabs-first"), f.children("li:last").addClass("tabs-last"), o.tabPosition == "left" || o.tabPosition == "right" ? (u._outerWidth(o.showHeader ? o.headerWidth : 0), h._outerWidth(l.width() - u.outerWidth()), u.add(h)._size("height", isNaN(parseInt(o.height)) ? "" : l.height()), c._outerWidth(u.width()), f._outerWidth(c.width()).css("height", "")) : (u.children("div.tabs-scroller-left,div.tabs-scroller-right,div.tabs-tool:not(.tabs-tool-hidden)").css("display", o.showHeader ? "block" : "none"), u._outerWidth(l.width()).css("height", ""), o.showHeader ? (u.css("background-color", ""), c.css("height", "")) : (u.css("background-color", "transparent"), u._outerHeight(0), c._outerHeight(0)), f._outerHeight(o.tabHeight).css("width", ""), f._outerHeight(f.outerHeight() - f.height() - 1 + o.tabHeight).css("width", ""), h._size("height", isNaN(parseInt(o.height)) ? "" : l.height() - u.outerHeight()), h._size("width", l.width())), r.tabs.length) {
      var v = f.outerWidth(!0) - f.width(), m = f.children("li:first"), g = m.outerWidth(!0) - m.width(), y = u.width() - u.children(".tabs-tool:not(.tabs-tool-hidden)")._outerWidth(), w = Math.floor((y - v - g * r.tabs.length) / r.tabs.length);
      if ($.map(r.tabs, function(D) {
        x(D, o.justified && $.inArray(o.tabPosition, ["top", "bottom"]) >= 0 ? w : void 0);
      }), o.justified && $.inArray(o.tabPosition, ["top", "bottom"]) >= 0) {
        var E = y - v - _329(f);
        x(r.tabs[r.tabs.length - 1], w + E);
      }
    }
    _32a(e);
    function x(D, H) {
      var k = D.panel("options"), N = k.tab.find("a.tabs-inner"), H = H || parseInt(k.tabWidth || o.tabWidth || void 0);
      H ? N._outerWidth(H) : N.css("width", ""), N._outerHeight(o.tabHeight), N.css("lineHeight", N.height() + "px"), N.find(".easyui-fluid:visible").triggerHandler("_resize");
    }
  }
  function _342(e) {
    var n = $.data(e, "tabs").options, r = _344(e);
    if (r) {
      var o = $(e).children("div.tabs-panels"), l = n.width == "auto" ? "auto" : o.width(), u = n.height == "auto" ? "auto" : o.height();
      r.panel("resize", { width: l, height: u });
    }
  }
  function _348(e) {
    $.data(e, "tabs").tabs;
    var n = $(e).addClass("tabs-container"), r = $('<div class="tabs-panels"></div>').insertBefore(n);
    n.children("div").each(function() {
      r[0].appendChild(this);
    }), n[0].appendChild(r[0]), $('<div class="tabs-header"><div class="tabs-scroller-left"></div><div class="tabs-scroller-right"></div><div class="tabs-wrap"><ul class="tabs"></ul></div></div>').prependTo(e), n.children("div.tabs-panels").children("div").each(function(o) {
      var l = $.extend({}, $.parser.parseOptions(this), { disabled: $(this).attr("disabled") ? !0 : void 0, selected: $(this).attr("selected") ? !0 : void 0 });
      _357(e, l, $(this));
    }), n.children("div.tabs-header").find(".tabs-scroller-left, .tabs-scroller-right").hover(function() {
      $(this).addClass("tabs-scroller-over");
    }, function() {
      $(this).removeClass("tabs-scroller-over");
    }), n.bind("_resize", function(o, l) {
      return ($(this).hasClass("easyui-fluid") || l) && (_336(e), _342(e)), !1;
    });
  }
  function _34c(e) {
    var n = $.data(e, "tabs"), r = n.options;
    $(e).children("div.tabs-header").unbind().bind("click", function(l) {
      if ($(l.target).hasClass("tabs-scroller-left"))
        $(e).tabs("scrollBy", -r.scrollIncrement);
      else if ($(l.target).hasClass("tabs-scroller-right"))
        $(e).tabs("scrollBy", r.scrollIncrement);
      else {
        var u = $(l.target).closest("li");
        if (u.hasClass("tabs-disabled"))
          return !1;
        var h = $(l.target).closest("a.tabs-close");
        if (h.length)
          _370(e, o(u));
        else if (u.length) {
          var c = o(u), f = n.tabs[c].panel("options");
          f.collapsible ? f.closed ? _367(e, c) : _384(e, c) : _367(e, c);
        }
        return !1;
      }
    }).bind("contextmenu", function(l) {
      var u = $(l.target).closest("li");
      u.hasClass("tabs-disabled") || u.length && r.onContextMenu.call(e, l, u.find("span.tabs-title").html(), o(u));
    });
    function o(l) {
      var u = 0;
      return l.parent().children("li").each(function(h) {
        if (l[0] == this)
          return u = h, !1;
      }), u;
    }
  }
  function _353(e) {
    var n = $.data(e, "tabs").options, r = $(e).children("div.tabs-header"), o = $(e).children("div.tabs-panels");
    r.removeClass("tabs-header-top tabs-header-bottom tabs-header-left tabs-header-right"), o.removeClass("tabs-panels-top tabs-panels-bottom tabs-panels-left tabs-panels-right"), n.tabPosition == "top" ? r.insertBefore(o) : n.tabPosition == "bottom" ? (r.insertAfter(o), r.addClass("tabs-header-bottom"), o.addClass("tabs-panels-top")) : n.tabPosition == "left" ? (r.addClass("tabs-header-left"), o.addClass("tabs-panels-right")) : n.tabPosition == "right" && (r.addClass("tabs-header-right"), o.addClass("tabs-panels-left")), n.plain == !0 ? r.addClass("tabs-header-plain") : r.removeClass("tabs-header-plain"), r.removeClass("tabs-header-narrow").addClass(n.narrow ? "tabs-header-narrow" : "");
    var l = r.find(".tabs");
    l.removeClass("tabs-pill").addClass(n.pill ? "tabs-pill" : ""), l.removeClass("tabs-narrow").addClass(n.narrow ? "tabs-narrow" : ""), l.removeClass("tabs-justified").addClass(n.justified ? "tabs-justified" : ""), n.border == !0 ? (r.removeClass("tabs-header-noborder"), o.removeClass("tabs-panels-noborder")) : (r.addClass("tabs-header-noborder"), o.addClass("tabs-panels-noborder")), n.doSize = !0;
  }
  function _357(e, n, r) {
    n = n || {};
    var o = $.data(e, "tabs"), l = o.tabs;
    (n.index == null || n.index > l.length) && (n.index = l.length), n.index < 0 && (n.index = 0);
    var u = $(e).children("div.tabs-header").find("ul.tabs"), h = $(e).children("div.tabs-panels"), c = $('<li><a href="javascript:;" class="tabs-inner"><span class="tabs-title"></span><span class="tabs-icon"></span></a></li>');
    r || (r = $("<div></div>")), n.index >= l.length ? (c.appendTo(u), r.appendTo(h), l.push(r)) : (c.insertBefore(u.children("li:eq(" + n.index + ")")), r.insertBefore(h.children("div.panel:eq(" + n.index + ")")), l.splice(n.index, 0, r)), r.panel($.extend({}, n, { tab: c, border: !1, noheader: !0, closed: !0, doSize: !1, iconCls: n.icon ? n.icon : void 0, onLoad: function() {
      n.onLoad && n.onLoad.call(this, arguments), o.options.onLoad.call(e, $(this));
    }, onBeforeOpen: function() {
      if (n.onBeforeOpen && n.onBeforeOpen.call(this) == !1)
        return !1;
      var f = $(e).tabs("getSelected");
      if (f)
        if (f[0] != this) {
          if ($(e).tabs("unselect", _362(e, f)), f = $(e).tabs("getSelected"), f)
            return !1;
        } else
          return _342(e), !1;
      var v = $(this).panel("options");
      v.tab.addClass("tabs-selected");
      var m = $(e).find(">div.tabs-header>div.tabs-wrap"), g = v.tab.position().left, y = g + v.tab.outerWidth();
      if (g < 0 || y > m.width()) {
        var w = g - (m.width() - v.tab.width()) / 2;
        $(e).tabs("scrollBy", w);
      } else
        $(e).tabs("scrollBy", 0);
      var E = $(this).panel("panel");
      E.css("display", "block"), _342(e), E.css("display", "none");
    }, onOpen: function() {
      n.onOpen && n.onOpen.call(this);
      var f = $(this).panel("options");
      o.selectHis.push(f.title), o.options.onSelect.call(e, f.title, _362(e, this));
    }, onBeforeClose: function() {
      if (n.onBeforeClose && n.onBeforeClose.call(this) == !1)
        return !1;
      $(this).panel("options").tab.removeClass("tabs-selected");
    }, onClose: function() {
      n.onClose && n.onClose.call(this);
      var f = $(this).panel("options");
      o.options.onUnselect.call(e, f.title, _362(e, this));
    } })), $(e).tabs("update", { tab: r, options: r.panel("options"), type: "header" });
  }
  function _363(e, n) {
    var r = $.data(e, "tabs"), o = r.options;
    n.selected == null && (n.selected = !0), _357(e, n), o.onAdd.call(e, n.title, n.index), n.selected && _367(e, n.index);
  }
  function _368(e, n) {
    n.type = n.type || "all";
    var r = $.data(e, "tabs").selectHis, o = n.tab, l = o.panel("options"), u = l.title;
    if ($.extend(l, n.options, { iconCls: n.options.icon ? n.options.icon : void 0 }), (n.type == "all" || n.type == "body") && o.panel(), n.type == "all" || n.type == "header") {
      var h = l.tab;
      if (l.header)
        h.find(".tabs-inner").html($(l.header));
      else {
        var c = h.find("span.tabs-title"), f = h.find("span.tabs-icon");
        if (c.html(l.title), f.attr("class", "tabs-icon"), h.find("a.tabs-close").remove(), l.closable ? (c.addClass("tabs-closable"), $('<a href="javascript:;" class="tabs-close"></a>').appendTo(h)) : c.removeClass("tabs-closable"), l.iconCls ? (c.addClass("tabs-with-icon"), f.addClass(l.iconCls)) : c.removeClass("tabs-with-icon"), l.tools) {
          var v = h.find("span.tabs-p-tool");
          if (!v.length)
            var v = $('<span class="tabs-p-tool"></span>').insertAfter(h.find("a.tabs-inner"));
          if ($.isArray(l.tools)) {
            v.empty();
            for (var m = 0; m < l.tools.length; m++) {
              var g = $('<a href="javascript:;"></a>').appendTo(v);
              g.addClass(l.tools[m].iconCls), l.tools[m].handler && g.bind("click", { handler: l.tools[m].handler }, function(w) {
                $(this).parents("li").hasClass("tabs-disabled") || w.data.handler.call(this);
              });
            }
          } else
            $(l.tools).children().appendTo(v);
          var y = v.children().length * 12;
          l.closable ? (y += 8, v.css("right", "")) : (y -= 3, v.css("right", "5px")), c.css("padding-right", y + "px");
        } else
          h.find("span.tabs-p-tool").remove(), c.css("padding-right", "");
      }
      if (u != l.title)
        for (var m = 0; m < r.length; m++)
          r[m] == u && (r[m] = l.title);
    }
    l.disabled ? l.tab.addClass("tabs-disabled") : l.tab.removeClass("tabs-disabled"), _336(e), $.data(e, "tabs").options.onUpdate.call(e, l.title, _362(e, o));
  }
  function _370(e, n) {
    var r = $.data(e, "tabs").options, o = $.data(e, "tabs").tabs, l = $.data(e, "tabs").selectHis;
    if (_374(e, n)) {
      var c = _375(e, n), u = c.panel("options").title, h = _362(e, c);
      if (r.onBeforeClose.call(e, u, h) != !1) {
        var c = _375(e, n, !0);
        c.panel("options").tab.remove(), c.panel("destroy"), r.onClose.call(e, u, h), _336(e);
        for (var f = 0; f < l.length; f++)
          l[f] == u && (l.splice(f, 1), f--);
        var v = l.pop();
        v ? _367(e, v) : o.length && _367(e, 0);
      }
    }
  }
  function _375(e, n, r) {
    var o = $.data(e, "tabs").tabs, l = null;
    if (typeof n == "number")
      n >= 0 && n < o.length && (l = o[n], r && o.splice(n, 1));
    else {
      for (var u = $("<span></span>"), h = 0; h < o.length; h++) {
        var c = o[h];
        if (u.html(c.panel("options").title), u.text() == n) {
          l = c, r && o.splice(h, 1);
          break;
        }
      }
      u.remove();
    }
    return l;
  }
  function _362(e, n) {
    for (var r = $.data(e, "tabs").tabs, o = 0; o < r.length; o++)
      if (r[o][0] == $(n)[0])
        return o;
    return -1;
  }
  function _344(e) {
    for (var n = $.data(e, "tabs").tabs, r = 0; r < n.length; r++) {
      var o = n[r];
      if (o.panel("options").tab.hasClass("tabs-selected"))
        return o;
    }
    return null;
  }
  function _37e(e) {
    for (var n = $.data(e, "tabs"), r = n.tabs, o = 0; o < r.length; o++) {
      var l = r[o].panel("options");
      if (l.selected && !l.disabled) {
        _367(e, o);
        return;
      }
    }
    _367(e, n.options.selected);
  }
  function _367(e, n) {
    var r = _375(e, n);
    r && !r.is(":visible") && (_383(e), r.panel("options").disabled || r.panel("open"));
  }
  function _384(e, n) {
    var r = _375(e, n);
    r && r.is(":visible") && (_383(e), r.panel("close"));
  }
  function _383(e) {
    $(e).children("div.tabs-panels").each(function() {
      $(this).stop(!0, !0);
    });
  }
  function _374(e, n) {
    return _375(e, n) != null;
  }
  function _38a(e, n) {
    var r = $.data(e, "tabs").options;
    r.showHeader = n, $(e).tabs("resize");
  }
  function _38d(e, n) {
    var r = $(e).find(">.tabs-header>.tabs-tool");
    n ? r.removeClass("tabs-tool-hidden").show() : r.addClass("tabs-tool-hidden").hide(), $(e).tabs("resize").tabs("scrollBy", 0);
  }
  $.fn.tabs = function(e, n) {
    return typeof e == "string" ? $.fn.tabs.methods[e](this, n) : (e = e || {}, this.each(function() {
      var r = $.data(this, "tabs");
      r ? $.extend(r.options, e) : ($.data(this, "tabs", { options: $.extend({}, $.fn.tabs.defaults, $.fn.tabs.parseOptions(this), e), tabs: [], selectHis: [] }), _348(this)), _332(this), _353(this), _336(this), _34c(this), _37e(this);
    }));
  }, $.fn.tabs.methods = { options: function(e) {
    var n = e[0], r = $.data(n, "tabs").options, o = _344(n);
    return r.selected = o ? _362(n, o) : -1, r;
  }, tabs: function(e) {
    return $.data(e[0], "tabs").tabs;
  }, resize: function(e, n) {
    return e.each(function() {
      _336(this, n), _342(this);
    });
  }, add: function(e, n) {
    return e.each(function() {
      _363(this, n);
    });
  }, close: function(e, n) {
    return e.each(function() {
      _370(this, n);
    });
  }, getTab: function(e, n) {
    return _375(e[0], n);
  }, getTabIndex: function(e, n) {
    return _362(e[0], n);
  }, getSelected: function(e) {
    return _344(e[0]);
  }, select: function(e, n) {
    return e.each(function() {
      _367(this, n);
    });
  }, unselect: function(e, n) {
    return e.each(function() {
      _384(this, n);
    });
  }, exists: function(e, n) {
    return _374(e[0], n);
  }, update: function(e, n) {
    return e.each(function() {
      _368(this, n);
    });
  }, enableTab: function(e, n) {
    return e.each(function() {
      var r = $(this).tabs("getTab", n).panel("options");
      r.tab.removeClass("tabs-disabled"), r.disabled = !1;
    });
  }, disableTab: function(e, n) {
    return e.each(function() {
      var r = $(this).tabs("getTab", n).panel("options");
      r.tab.addClass("tabs-disabled"), r.disabled = !0;
    });
  }, showHeader: function(e) {
    return e.each(function() {
      _38a(this, !0);
    });
  }, hideHeader: function(e) {
    return e.each(function() {
      _38a(this, !1);
    });
  }, showTool: function(e) {
    return e.each(function() {
      _38d(this, !0);
    });
  }, hideTool: function(e) {
    return e.each(function() {
      _38d(this, !1);
    });
  }, scrollBy: function(e, n) {
    return e.each(function() {
      var r = $(this).tabs("options"), o = $(this).find(">div.tabs-header>div.tabs-wrap"), l = Math.min(o._scrollLeft() + n, u());
      o.animate({ scrollLeft: l }, r.scrollDuration);
      function u() {
        var h = 0, c = o.children("ul");
        return c.children("li").each(function() {
          h += $(this).outerWidth(!0);
        }), h - o.width() + (c.outerWidth() - c.width());
      }
    });
  } }, $.fn.tabs.parseOptions = function(e) {
    return $.extend({}, $.parser.parseOptions(e, ["tools", "toolPosition", "tabPosition", { fit: "boolean", border: "boolean", plain: "boolean" }, { headerWidth: "number", tabWidth: "number", tabHeight: "number", selected: "number" }, { showHeader: "boolean", justified: "boolean", narrow: "boolean", pill: "boolean" }]));
  }, $.fn.tabs.defaults = { width: "auto", height: "auto", headerWidth: 150, tabWidth: "auto", tabHeight: 27, selected: 0, showHeader: !0, plain: !1, fit: !1, border: !0, justified: !1, narrow: !1, pill: !1, tools: null, toolPosition: "right", tabPosition: "top", scrollIncrement: 100, scrollDuration: 400, onLoad: function(e) {
  }, onSelect: function(e, n) {
  }, onUnselect: function(e, n) {
  }, onBeforeClose: function(e, n) {
  }, onClose: function(e, n) {
  }, onAdd: function(e, n) {
  }, onUpdate: function(e, n) {
  }, onContextMenu: function(e, n, r) {
  } };
})($);
(function(e) {
  var n = !1;
  function r(g, y) {
    var w = e.data(g, "layout"), E = w.options, x = w.panels, D = e(g);
    y && e.extend(E, { width: y.width, height: y.height }), g.tagName.toLowerCase() == "body" ? D._size("fit") : D._size(E);
    var F = { top: 0, left: 0, width: D.width(), height: D.height() };
    k(f(x.expandNorth) ? x.expandNorth : x.north, "n"), k(f(x.expandSouth) ? x.expandSouth : x.south, "s"), N(f(x.expandEast) ? x.expandEast : x.east, "e"), N(f(x.expandWest) ? x.expandWest : x.west, "w"), x.center.panel("resize", F);
    function k(H, R) {
      if (!(!H.length || !f(H))) {
        var j = H.panel("options");
        H.panel("resize", { width: D.width(), height: j.height });
        var S = H.panel("panel").outerHeight();
        H.panel("move", { left: 0, top: R == "n" ? 0 : D.height() - S }), F.height -= S, R == "n" && (F.top += S, !j.split && j.border && F.top--), !j.split && j.border && F.height++;
      }
    }
    function N(H, R) {
      if (!(!H.length || !f(H))) {
        var j = H.panel("options");
        H.panel("resize", { width: j.width, height: F.height });
        var S = H.panel("panel").outerWidth();
        H.panel("move", { left: R == "e" ? D.width() - S : 0, top: F.top }), F.width -= S, R == "w" && (F.left += S, !j.split && j.border && F.left--), !j.split && j.border && F.width++;
      }
    }
  }
  function o(g) {
    var y = e(g);
    y.addClass("layout");
    function w(D) {
      var F = e.fn.layout.parsePanelOptions(D);
      "north,south,east,west,center".indexOf(F.region) >= 0 && l(g, F, D);
    }
    var E = y.layout("options"), x = E.onAdd;
    E.onAdd = function() {
    }, y.find(">div,>form>div").each(function() {
      w(this);
    }), E.onAdd = x, y.append('<div class="layout-split-proxy-h"></div><div class="layout-split-proxy-v"></div>'), y.bind("_resize", function(D, F) {
      return (e(this).hasClass("easyui-fluid") || F) && r(g), !1;
    });
  }
  function l(g, y, w) {
    y.region = y.region || "center";
    var E = e.data(g, "layout").panels, x = e(g), D = y.region;
    if (E[D].length)
      return;
    var F = e(w);
    F.length || (F = e("<div></div>").appendTo(x));
    var k = e.extend({}, e.fn.layout.paneldefaults, { width: F.length ? parseInt(F[0].style.width) || F.outerWidth() : "auto", height: F.length ? parseInt(F[0].style.height) || F.outerHeight() : "auto", doSize: !1, collapsible: !0, onOpen: function() {
      var j = e(this).panel("header").children("div.panel-tool");
      j.children("a.panel-tool-collapse").hide();
      var S = { north: "up", south: "down", east: "right", west: "left" };
      if (S[D]) {
        var tt = "layout-button-" + S[D], nt = j.children("a." + tt);
        nt.length || (nt = e('<a href="javascript:;"></a>').addClass(tt).appendTo(j), nt.bind("click", { dir: D }, function(ft) {
          return h(g, ft.data.dir), !1;
        })), e(this).panel("options").collapsible ? nt.show() : nt.hide();
      }
    } }, y, { cls: (y.cls || "") + " layout-panel layout-panel-" + D, bodyCls: (y.bodyCls || "") + " layout-body" });
    F.panel(k), E[D] = F;
    var N = { north: "s", south: "n", east: "w", west: "e" }, H = F.panel("panel");
    F.panel("options").split && H.addClass("layout-split-" + D), H.resizable(e.extend({}, { handles: N[D] || "", disabled: !F.panel("options").split, onStartResize: function(j) {
      if (n = !0, D == "north" || D == "south")
        var S = e(">div.layout-split-proxy-v", g);
      else
        var S = e(">div.layout-split-proxy-h", g);
      var tt = { display: "block" };
      D == "north" ? (tt.top = parseInt(H.css("top")) + H.outerHeight() - S.height(), tt.left = parseInt(H.css("left")), tt.width = H.outerWidth(), tt.height = S.height()) : D == "south" ? (tt.top = parseInt(H.css("top")), tt.left = parseInt(H.css("left")), tt.width = H.outerWidth(), tt.height = S.height()) : D == "east" ? (tt.top = parseInt(H.css("top")) || 0, tt.left = parseInt(H.css("left")) || 0, tt.width = S.width(), tt.height = H.outerHeight()) : D == "west" && (tt.top = parseInt(H.css("top")) || 0, tt.left = H.outerWidth() - S.width(), tt.width = S.width(), tt.height = H.outerHeight()), S.css(tt), e('<div class="layout-mask"></div>').css({ left: 0, top: 0, width: x.width(), height: x.height() }).appendTo(x);
    }, onResize: function(j) {
      if (D == "north" || D == "south") {
        var S = R(this);
        e(this).resizable("options").maxHeight = S;
        var tt = e(">div.layout-split-proxy-v", g), nt = D == "north" ? j.data.height - tt.height() : e(g).height() - j.data.height;
        tt.css("top", nt);
      } else {
        var ft = R(this);
        e(this).resizable("options").maxWidth = ft;
        var tt = e(">div.layout-split-proxy-h", g), pt = D == "west" ? j.data.width - tt.width() : e(g).width() - j.data.width;
        tt.css("left", pt);
      }
      return !1;
    }, onStopResize: function(j) {
      x.children("div.layout-split-proxy-v,div.layout-split-proxy-h").hide(), F.panel("resize", j.data), r(g), n = !1, x.find(">div.layout-mask").remove();
    } }, y)), x.layout("options").onAdd.call(g, D);
    function R(j) {
      var S = "expand" + D.substring(0, 1).toUpperCase() + D.substring(1), tt = E.center, nt = D == "north" || D == "south" ? "minHeight" : "minWidth", ft = D == "north" || D == "south" ? "maxHeight" : "maxWidth", pt = D == "north" || D == "south" ? "_outerHeight" : "_outerWidth", ct = e.parser.parseValue(ft, E[D].panel("options")[ft], e(g)), Nt = e.parser.parseValue(nt, tt.panel("options")[nt], e(g)), kt = tt.panel("panel")[pt]() - Nt;
      return f(E[S]) ? kt += E[S][pt]() - 1 : kt += e(j)[pt](), kt > ct && (kt = ct), kt;
    }
  }
  function u(g, y) {
    var w = e.data(g, "layout").panels;
    if (w[y].length) {
      w[y].panel("destroy"), w[y] = e();
      var E = "expand" + y.substring(0, 1).toUpperCase() + y.substring(1);
      w[E] && (w[E].panel("destroy"), w[E] = void 0), e(g).layout("options").onRemove.call(g, y);
    }
  }
  function h(g, y, w) {
    w == null && (w = "normal");
    var E = e.data(g, "layout").panels, x = E[y], D = x.panel("options");
    if (D.onBeforeCollapse.call(x) == !1)
      return;
    var F = "expand" + y.substring(0, 1).toUpperCase() + y.substring(1);
    if (!E[F]) {
      E[F] = H(y);
      var k = E[F].panel("panel");
      D.expandMode ? k.bind("click", function() {
        if (D.expandMode == "dock")
          c(g, y);
        else {
          x.panel("expand", !1).panel("open");
          var j = R();
          x.panel("resize", j.collapse), x.panel("panel").animate(j.expand, function() {
            e(this).unbind(".layout").bind("mouseleave.layout", { region: y }, function(S) {
              n != !0 && (e("body>div.combo-p>div.combo-panel:visible").length || h(g, S.data.region));
            }), e(g).layout("options").onExpand.call(g, y);
          });
        }
        return !1;
      }) : k.css("cursor", "default");
    }
    var N = R();
    f(E[F]) || E.center.panel("resize", N.resizeC), x.panel("panel").animate(N.collapse, w, function() {
      x.panel("collapse", !1).panel("close"), E[F].panel("open").panel("resize", N.expandP), e(this).unbind(".layout"), e(g).layout("options").onCollapse.call(g, y);
    });
    function H(j) {
      var S = { east: "left", west: "right", north: "down", south: "up" }, tt = D.region == "north" || D.region == "south", nt = "layout-button-" + S[j], ft = e("<div></div>").appendTo(g);
      if (ft.panel(e.extend({}, e.fn.layout.paneldefaults, { cls: "layout-expand layout-expand-" + j, title: "&nbsp;", titleDirection: D.titleDirection, iconCls: D.hideCollapsedContent ? null : D.iconCls, closed: !0, minWidth: 0, minHeight: 0, doSize: !1, region: D.region, collapsedSize: D.collapsedSize, noheader: !tt && D.hideExpandTool, tools: tt && D.hideExpandTool ? null : [{ iconCls: nt, handler: function() {
        return c(g, y), !1;
      } }], onResize: function() {
        var ct = e(this).children(".layout-expand-title");
        if (ct.length) {
          ct._outerWidth(e(this).height());
          var Nt = (e(this).width() - Math.min(ct._outerWidth(), ct._outerHeight())) / 2, kt = Math.max(ct._outerWidth(), ct._outerHeight());
          ct.hasClass("layout-expand-title-down") && (Nt += Math.min(ct._outerWidth(), ct._outerHeight()), kt = 0), ct.css({ left: Nt + "px", top: kt + "px" });
        }
      } })), !D.hideCollapsedContent) {
        var pt = typeof D.collapsedContent == "function" ? D.collapsedContent.call(ft[0], D.title) : D.collapsedContent;
        tt ? ft.panel("setTitle", pt) : ft.html(pt);
      }
      return ft.panel("panel").hover(function() {
        e(this).addClass("layout-expand-over");
      }, function() {
        e(this).removeClass("layout-expand-over");
      }), ft;
    }
    function R() {
      var j = e(g), S = E.center.panel("options"), tt = D.collapsedSize;
      if (y == "east") {
        var nt = x.panel("panel")._outerWidth(), ft = S.width + nt - tt;
        return (D.split || !D.border) && ft++, { resizeC: { width: ft }, expand: { left: j.width() - nt }, expandP: { top: S.top, left: j.width() - tt, width: tt, height: S.height }, collapse: { left: j.width(), top: S.top, height: S.height } };
      } else if (y == "west") {
        var nt = x.panel("panel")._outerWidth(), ft = S.width + nt - tt;
        return (D.split || !D.border) && ft++, { resizeC: { width: ft, left: tt - 1 }, expand: { left: 0 }, expandP: { left: 0, top: S.top, width: tt, height: S.height }, collapse: { left: -nt, top: S.top, height: S.height } };
      } else if (y == "north") {
        var pt = x.panel("panel")._outerHeight(), ct = S.height;
        return f(E.expandNorth) || (ct += pt - tt + (D.split || !D.border ? 1 : 0)), E.east.add(E.west).add(E.expandEast).add(E.expandWest).panel("resize", { top: tt - 1, height: ct }), { resizeC: { top: tt - 1, height: ct }, expand: { top: 0 }, expandP: { top: 0, left: 0, width: j.width(), height: tt }, collapse: { top: -pt, width: j.width() } };
      } else if (y == "south") {
        var pt = x.panel("panel")._outerHeight(), ct = S.height;
        return f(E.expandSouth) || (ct += pt - tt + (D.split || !D.border ? 1 : 0)), E.east.add(E.west).add(E.expandEast).add(E.expandWest).panel("resize", { height: ct }), { resizeC: { height: ct }, expand: { top: j.height() - pt }, expandP: { top: j.height() - tt, left: 0, width: j.width(), height: tt }, collapse: { top: j.height(), width: j.width() } };
      }
    }
  }
  function c(g, y) {
    var w = e.data(g, "layout").panels, E = w[y], x = E.panel("options");
    if (x.onBeforeExpand.call(E) == !1)
      return;
    var D = "expand" + y.substring(0, 1).toUpperCase() + y.substring(1);
    if (w[D]) {
      w[D].panel("close"), E.panel("panel").stop(!0, !0), E.panel("expand", !1).panel("open");
      var F = k();
      E.panel("resize", F.collapse), E.panel("panel").animate(F.expand, function() {
        r(g), e(g).layout("options").onExpand.call(g, y);
      });
    }
    function k() {
      var N = e(g), H = w.center.panel("options");
      if (y == "east" && w.expandEast)
        return { collapse: { left: N.width(), top: H.top, height: H.height }, expand: { left: N.width() - E.panel("panel")._outerWidth() } };
      if (y == "west" && w.expandWest)
        return { collapse: { left: -E.panel("panel")._outerWidth(), top: H.top, height: H.height }, expand: { left: 0 } };
      if (y == "north" && w.expandNorth)
        return { collapse: { top: -E.panel("panel")._outerHeight(), width: N.width() }, expand: { top: 0 } };
      if (y == "south" && w.expandSouth)
        return { collapse: { top: N.height(), width: N.width() }, expand: { top: N.height() - E.panel("panel")._outerHeight() } };
    }
  }
  function f(g) {
    return g && g.length ? g.panel("panel").is(":visible") : !1;
  }
  function v(g) {
    var y = e.data(g, "layout"), w = y.options, E = y.panels, x = w.onCollapse;
    w.onCollapse = function() {
    }, D("east"), D("west"), D("north"), D("south"), w.onCollapse = x;
    function D(F) {
      var k = E[F];
      k.length && k.panel("options").collapsed && h(g, F, 0);
    }
  }
  function m(g, y, w) {
    var E = e(g).layout("panel", y);
    E.panel("options").split = w;
    var x = "layout-split-" + y, D = E.panel("panel").removeClass(x);
    w && D.addClass(x), D.resizable({ disabled: !w }), r(g);
  }
  e.fn.layout = function(g, y) {
    return typeof g == "string" ? e.fn.layout.methods[g](this, y) : (g = g || {}, this.each(function() {
      var w = e.data(this, "layout");
      if (w)
        e.extend(w.options, g);
      else {
        var E = e.extend({}, e.fn.layout.defaults, e.fn.layout.parseOptions(this), g);
        e.data(this, "layout", { options: E, panels: { center: e(), north: e(), south: e(), east: e(), west: e() } }), o(this);
      }
      r(this), v(this);
    }));
  }, e.fn.layout.methods = { options: function(g) {
    return e.data(g[0], "layout").options;
  }, resize: function(g, y) {
    return g.each(function() {
      r(this, y);
    });
  }, panel: function(g, y) {
    return e.data(g[0], "layout").panels[y];
  }, collapse: function(g, y) {
    return g.each(function() {
      h(this, y);
    });
  }, expand: function(g, y) {
    return g.each(function() {
      c(this, y);
    });
  }, add: function(g, y) {
    return g.each(function() {
      l(this, y), r(this), e(this).layout("panel", y.region).panel("options").collapsed && h(this, y.region, 0);
    });
  }, remove: function(g, y) {
    return g.each(function() {
      u(this, y), r(this);
    });
  }, split: function(g, y) {
    return g.each(function() {
      m(this, y, !0);
    });
  }, unsplit: function(g, y) {
    return g.each(function() {
      m(this, y, !1);
    });
  } }, e.fn.layout.parseOptions = function(g) {
    return e.extend({}, e.parser.parseOptions(g, [{ fit: "boolean" }]));
  }, e.fn.layout.defaults = { fit: !1, onExpand: function(g) {
  }, onCollapse: function(g) {
  }, onAdd: function(g) {
  }, onRemove: function(g) {
  } }, e.fn.layout.parsePanelOptions = function(g) {
    return e(g), e.extend({}, e.fn.panel.parseOptions(g), e.parser.parseOptions(g, ["region", { split: "boolean", collpasedSize: "number", minWidth: "number", minHeight: "number", maxWidth: "number", maxHeight: "number" }]));
  }, e.fn.layout.paneldefaults = e.extend({}, e.fn.panel.defaults, { region: null, split: !1, collapsedSize: 28, expandMode: "float", hideExpandTool: !1, hideCollapsedContent: !0, collapsedContent: function(g) {
    var y = e(this), w = y.panel("options");
    if (w.region == "north" || w.region == "south")
      return g;
    var E = [];
    return w.iconCls && E.push('<div class="panel-icon ' + w.iconCls + '"></div>'), E.push('<div class="panel-title layout-expand-title'), E.push(" layout-expand-title-" + w.titleDirection), E.push(w.iconCls ? " layout-expand-with-icon" : ""), E.push('">'), E.push(g), E.push("</div>"), E.join("");
  }, minWidth: 10, minHeight: 10, maxWidth: 1e4, maxHeight: 1e4 });
})($);
(function($) {
  $(function() {
    $(document).unbind(".menu").bind("mousedown.menu", function(e) {
      var n = $(e.target).closest("div.menu,div.combo-p");
      n.length || ($("body>div.menu-top:visible").not(".menu-inline").menu("hide"), _416($("body>div.menu:visible").not(".menu-inline")));
    });
  });
  function init(e) {
    var n = $.data(e, "menu").options;
    $(e).addClass("menu-top"), n.inline ? $(e).addClass("menu-inline") : $(e).appendTo("body"), $(e).bind("_resize", function(u, h) {
      return ($(this).hasClass("easyui-fluid") || h) && $(e).menu("resize", e), !1;
    });
    for (var r = l($(e)), o = 0; o < r.length; o++)
      _41d(e, r[o]);
    function l(u) {
      var h = [];
      return u.addClass("menu"), h.push(u), u.hasClass("menu-content") || u.children("div").each(function() {
        var c = $(this).children("div");
        if (c.length) {
          c.appendTo("body"), this.submenu = c;
          var f = l(c);
          h = h.concat(f);
        }
      }), h;
    }
  }
  function _41d(e, n) {
    var r = $(n).addClass("menu");
    r.data("menu") || r.data("menu", { options: $.parser.parseOptions(r[0], ["width", "height"]) }), r.hasClass("menu-content") || (r.children("div").each(function() {
      _41f(e, this);
    }), $('<div class="menu-line"></div>').prependTo(r)), _420(e, r), r.hasClass("menu-inline") || r.hide(), _421(e, r);
  }
  function _41f(_422, div, _423) {
    var item = $(div), _424 = $.extend({}, $.parser.parseOptions(item[0], ["id", "name", "iconCls", "href", { separator: "boolean" }]), { disabled: item.attr("disabled") ? !0 : void 0, text: $.trim(item.html()), onclick: item[0].onclick }, _423 || {});
    _424.onclick = _424.onclick || _424.handler || null, item.data("menuitem", { options: _424 }), _424.separator && item.addClass("menu-sep"), item.hasClass("menu-sep") || (item.addClass("menu-item"), item.empty().append($('<div class="menu-text"></div>').html(_424.text)), _424.iconCls && $('<div class="menu-icon"></div>').addClass(_424.iconCls).appendTo(item), _424.id && item.attr("id", _424.id), _424.onclick && (typeof _424.onclick == "string" ? item.attr("onclick", _424.onclick) : item[0].onclick = eval(_424.onclick)), _424.disabled && _425(_422, item[0], !0), item[0].submenu && $('<div class="menu-rightarrow"></div>').appendTo(item));
  }
  function _420(e, n) {
    var r = $.data(e, "menu").options, o = n.attr("style") || "", l = n.is(":visible");
    n.css({ display: "block", left: -1e4, height: "auto", overflow: "hidden" }), n.find(".menu-item").each(function() {
      $(this)._outerHeight(r.itemHeight), $(this).find(".menu-text").css({ height: r.itemHeight - 2 + "px", lineHeight: r.itemHeight - 2 + "px" });
    }), n.removeClass("menu-noline").addClass(r.noline ? "menu-noline" : "");
    var u = n.data("menu").options, h = u.width, c = u.height;
    isNaN(parseInt(h)) && (h = 0, n.find("div.menu-text").each(function() {
      h < $(this).outerWidth() && (h = $(this).outerWidth());
    }), h = h ? h + 40 : "");
    var f = n.outerHeight();
    if (isNaN(parseInt(c)))
      if (c = f, n.hasClass("menu-top") && r.alignTo) {
        var v = $(r.alignTo), m = v.offset().top - $(document).scrollTop(), g = $(window)._outerHeight() + $(document).scrollTop() - v.offset().top - v._outerHeight();
        c = Math.min(c, Math.max(m, g));
      } else
        c > $(window)._outerHeight() && (c = $(window).height());
    n.attr("style", o), n.show(), n._size($.extend({}, u, { width: h, height: c, minWidth: u.minWidth || r.minWidth, maxWidth: u.maxWidth || r.maxWidth })), n.find(".easyui-fluid").triggerHandler("_resize", [!0]), n.css("overflow", n.outerHeight() < f ? "auto" : "hidden"), n.children("div.menu-line")._outerHeight(f - 2), l || n.hide();
  }
  function _421(e, n) {
    var r = $.data(e, "menu"), o = r.options;
    n.unbind(".menu");
    for (var l in o.events)
      n.bind(l + ".menu", { target: e }, o.events[l]);
  }
  function _430(e) {
    var n = e.data.target, r = $.data(n, "menu");
    r.timer && (clearTimeout(r.timer), r.timer = null);
  }
  function _433(e) {
    var n = e.data.target, r = $.data(n, "menu");
    r.options.hideOnUnhover && (r.timer = setTimeout(function() {
      _436(n, $(n).hasClass("menu-inline"));
    }, r.options.duration));
  }
  function _437(e) {
    var n = e.data.target, r = $(e.target).closest(".menu-item");
    if (r.length) {
      if (r.siblings().each(function() {
        this.submenu && _416(this.submenu), $(this).removeClass("menu-active");
      }), r.addClass("menu-active"), r.hasClass("menu-item-disabled")) {
        r.addClass("menu-active-disabled");
        return;
      }
      var o = r[0].submenu;
      o && $(n).menu("show", { menu: o, parent: r });
    }
  }
  function _43a(e) {
    var n = $(e.target).closest(".menu-item");
    if (n.length) {
      n.removeClass("menu-active menu-active-disabled");
      var r = n[0].submenu;
      r ? e.pageX >= parseInt(r.css("left")) ? n.addClass("menu-active") : _416(r) : n.removeClass("menu-active");
    }
  }
  function _43c(e) {
    var n = e.data.target, r = $(e.target).closest(".menu-item");
    if (r.length) {
      var o = $(n).data("menu").options, l = r.data("menuitem").options;
      if (l.disabled)
        return;
      r[0].submenu || (_436(n, o.inline), l.href && (location.href = l.href)), r.trigger("mouseenter"), o.onClick.call(n, $(n).menu("getItem", r[0]));
    }
  }
  function _436(e, n) {
    var r = $.data(e, "menu");
    return r && $(e).is(":visible") && (_416($(e)), n ? $(e).show() : r.options.onHide.call(e)), !1;
  }
  function _442(e, n) {
    n = n || {};
    var r, o, l = $.data(e, "menu").options, u = $(n.menu || e);
    if ($(e).menu("resize", u[0]), u.hasClass("menu-top")) {
      if ($.extend(l, n), r = l.left, o = l.top, l.alignTo) {
        var h = $(l.alignTo);
        r = h.offset().left, o = h.offset().top + h._outerHeight(), l.align == "right" && (r += h.outerWidth() - u.outerWidth());
      }
      r + u.outerWidth() > $(window)._outerWidth() + $(document)._scrollLeft() && (r = $(window)._outerWidth() + $(document).scrollLeft() - u.outerWidth() - 5), r < 0 && (r = 0), o = f(o, l.alignTo);
    } else {
      var c = n.parent;
      r = c.offset().left + c.outerWidth() - 2, r + u.outerWidth() + 5 > $(window)._outerWidth() + $(document).scrollLeft() && (r = c.offset().left - u.outerWidth() + 2), o = f(c.offset().top - 3);
    }
    function f(v, m) {
      return v + u.outerHeight() > $(window)._outerHeight() + $(document).scrollTop() && (m ? v = $(m).offset().top - u._outerHeight() : v = $(window)._outerHeight() + $(document).scrollTop() - u.outerHeight()), v < 0 && (v = 0), v;
    }
    u.css(l.position.call(e, u[0], r, o)), u.show(0, function() {
      u[0].shadow || (u[0].shadow = $('<div class="menu-shadow"></div>').insertAfter(u)), u[0].shadow.css({ display: u.hasClass("menu-inline") ? "none" : "block", zIndex: $.fn.menu.defaults.zIndex++, left: u.css("left"), top: u.css("top"), width: u.outerWidth(), height: u.outerHeight() }), u.css("z-index", $.fn.menu.defaults.zIndex++), u.hasClass("menu-top") && l.onShow.call(e);
    });
  }
  function _416(e) {
    e && e.length && (n(e), e.find("div.menu-item").each(function() {
      this.submenu && _416(this.submenu), $(this).removeClass("menu-active");
    }));
    function n(r) {
      r.stop(!0, !0), r[0].shadow && r[0].shadow.hide(), r.hide();
    }
  }
  function _449(e, n) {
    var r = null, o = $("<div></div>");
    function l(u) {
      u.children("div.menu-item").each(function() {
        var h = $(e).menu("getItem", this), c = o.empty().html(h.text).text();
        n == $.trim(c) ? r = h : this.submenu && !r && l(this.submenu);
      });
    }
    return l($(e)), o.remove(), r;
  }
  function _425(e, n, r) {
    var o = $(n);
    if (o.hasClass("menu-item")) {
      var l = o.data("menuitem").options;
      l.disabled = r, r ? (o.addClass("menu-item-disabled"), o[0].onclick = null) : (o.removeClass("menu-item-disabled"), o[0].onclick = l.onclick);
    }
  }
  function _44f(e, n) {
    $.data(e, "menu").options;
    var r = $(e);
    if (n.parent) {
      if (!n.parent.submenu) {
        var o = $("<div></div>").appendTo("body");
        n.parent.submenu = o, $('<div class="menu-rightarrow"></div>').appendTo(n.parent), _41d(e, o);
      }
      r = n.parent.submenu;
    }
    var l = $("<div></div>").appendTo(r);
    _41f(e, l, n);
  }
  function _453(e, n) {
    function r(o) {
      if (o.submenu) {
        o.submenu.children("div.menu-item").each(function() {
          r(this);
        });
        var l = o.submenu[0].shadow;
        l && l.remove(), o.submenu.remove();
      }
      $(o).remove();
    }
    r(n);
  }
  function _458(e, n, r) {
    var o = $(n).parent();
    r ? $(n).show() : $(n).hide(), _420(e, o);
  }
  function _45c(e) {
    $(e).children("div.menu-item").each(function() {
      _453(e, this);
    }), e.shadow && e.shadow.remove(), $(e).remove();
  }
  $.fn.menu = function(e, n) {
    return typeof e == "string" ? $.fn.menu.methods[e](this, n) : (e = e || {}, this.each(function() {
      var r = $.data(this, "menu");
      r ? $.extend(r.options, e) : (r = $.data(this, "menu", { options: $.extend({}, $.fn.menu.defaults, $.fn.menu.parseOptions(this), e) }), init(this)), $(this).css({ left: r.options.left, top: r.options.top });
    }));
  }, $.fn.menu.methods = { options: function(e) {
    return $.data(e[0], "menu").options;
  }, show: function(e, n) {
    return e.each(function() {
      _442(this, n);
    });
  }, hide: function(e) {
    return e.each(function() {
      _436(this);
    });
  }, destroy: function(e) {
    return e.each(function() {
      _45c(this);
    });
  }, setText: function(e, n) {
    return e.each(function() {
      var r = $(n.target).data("menuitem").options;
      r.text = n.text, $(n.target).children("div.menu-text").html(n.text);
    });
  }, setIcon: function(e, n) {
    return e.each(function() {
      var r = $(n.target).data("menuitem").options;
      r.iconCls = n.iconCls, $(n.target).children("div.menu-icon").remove(), n.iconCls && $('<div class="menu-icon"></div>').addClass(n.iconCls).appendTo(n.target);
    });
  }, getItem: function(e, n) {
    var r = $(n).data("menuitem").options;
    return $.extend({}, r, { target: $(n)[0] });
  }, findItem: function(e, n) {
    return _449(e[0], n);
  }, appendItem: function(e, n) {
    return e.each(function() {
      _44f(this, n);
    });
  }, removeItem: function(e, n) {
    return e.each(function() {
      _453(this, n);
    });
  }, enableItem: function(e, n) {
    return e.each(function() {
      _425(this, n, !1);
    });
  }, disableItem: function(e, n) {
    return e.each(function() {
      _425(this, n, !0);
    });
  }, showItem: function(e, n) {
    return e.each(function() {
      _458(this, n, !0);
    });
  }, hideItem: function(e, n) {
    return e.each(function() {
      _458(this, n, !1);
    });
  }, resize: function(e, n) {
    return e.each(function() {
      _420(this, $(n || this));
    });
  } }, $.fn.menu.parseOptions = function(e) {
    return $.extend({}, $.parser.parseOptions(e, [{ minWidth: "number", itemHeight: "number", duration: "number", hideOnUnhover: "boolean" }, { fit: "boolean", inline: "boolean", noline: "boolean" }]));
  }, $.fn.menu.defaults = { zIndex: 11e4, left: 0, top: 0, alignTo: null, align: "left", minWidth: 120, itemHeight: 22, duration: 100, hideOnUnhover: !0, inline: !1, fit: !1, noline: !1, events: { mouseenter: _430, mouseleave: _433, mouseover: _437, mouseout: _43a, click: _43c }, position: function(e, n, r) {
    return { left: n, top: r };
  }, onShow: function() {
  }, onHide: function() {
  }, onClick: function(e) {
  } };
})($);
(function(e) {
  function n(l) {
    var u = e.data(l, "menubutton").options, h = e(l);
    if (h.linkbutton(u), u.hasDownArrow) {
      h.removeClass(u.cls.btn1 + " " + u.cls.btn2).addClass("m-btn"), h.removeClass("m-btn-small m-btn-medium m-btn-large").addClass("m-btn-" + u.size);
      var c = h.find(".l-btn-left");
      e("<span></span>").addClass(u.cls.arrow).appendTo(c), e("<span></span>").addClass("m-btn-line").appendTo(c);
    }
    if (e(l).menubutton("resize"), u.menu) {
      e(u.menu).menu({ duration: u.duration });
      var f = e(u.menu).menu("options"), v = f.onShow, m = f.onHide;
      e.extend(f, { onShow: function() {
        var g = e(this).menu("options"), y = e(g.alignTo), w = y.menubutton("options");
        y.addClass(w.plain == !0 ? w.cls.btn2 : w.cls.btn1), v.call(this);
      }, onHide: function() {
        var g = e(this).menu("options"), y = e(g.alignTo), w = y.menubutton("options");
        y.removeClass(w.plain == !0 ? w.cls.btn2 : w.cls.btn1), m.call(this);
      } });
    }
  }
  function r(l) {
    var u = e.data(l, "menubutton").options, h = e(l), c = h.find("." + u.cls.trigger);
    c.length || (c = h), c.unbind(".menubutton");
    var f = null;
    c.bind("click.menubutton", function() {
      if (!v())
        return o(l), !1;
    }).bind("mouseenter.menubutton", function() {
      if (!v())
        return f = setTimeout(function() {
          o(l);
        }, u.duration), !1;
    }).bind("mouseleave.menubutton", function() {
      f && clearTimeout(f), e(u.menu).triggerHandler("mouseleave");
    });
    function v() {
      return e(l).linkbutton("options").disabled;
    }
  }
  function o(l) {
    var u = e(l).menubutton("options");
    if (!(u.disabled || !u.menu)) {
      e("body>div.menu-top").menu("hide");
      var h = e(l), c = e(u.menu);
      c.length && (c.menu("options").alignTo = h, c.menu("show", { alignTo: h, align: u.menuAlign })), h.blur();
    }
  }
  e.fn.menubutton = function(l, u) {
    if (typeof l == "string") {
      var h = e.fn.menubutton.methods[l];
      return h ? h(this, u) : this.linkbutton(l, u);
    }
    return l = l || {}, this.each(function() {
      var c = e.data(this, "menubutton");
      c ? e.extend(c.options, l) : (e.data(this, "menubutton", { options: e.extend({}, e.fn.menubutton.defaults, e.fn.menubutton.parseOptions(this), l) }), e(this).removeAttr("disabled")), n(this), r(this);
    });
  }, e.fn.menubutton.methods = { options: function(l) {
    var u = l.linkbutton("options");
    return e.extend(e.data(l[0], "menubutton").options, { toggle: u.toggle, selected: u.selected, disabled: u.disabled });
  }, destroy: function(l) {
    return l.each(function() {
      var u = e(this).menubutton("options");
      u.menu && e(u.menu).menu("destroy"), e(this).remove();
    });
  } }, e.fn.menubutton.parseOptions = function(l) {
    return e(l), e.extend({}, e.fn.linkbutton.parseOptions(l), e.parser.parseOptions(l, ["menu", { plain: "boolean", hasDownArrow: "boolean", duration: "number" }]));
  }, e.fn.menubutton.defaults = e.extend({}, e.fn.linkbutton.defaults, { plain: !0, hasDownArrow: !0, menu: null, menuAlign: "left", duration: 100, cls: { btn1: "m-btn-active", btn2: "m-btn-plain-active", arrow: "m-btn-downarrow", trigger: "m-btn" } });
})($);
(function(e) {
  function n(r) {
    var o = e.data(r, "splitbutton").options;
    e(r).menubutton(o), e(r).addClass("s-btn");
  }
  e.fn.splitbutton = function(r, o) {
    if (typeof r == "string") {
      var l = e.fn.splitbutton.methods[r];
      return l ? l(this, o) : this.menubutton(r, o);
    }
    return r = r || {}, this.each(function() {
      var u = e.data(this, "splitbutton");
      u ? e.extend(u.options, r) : (e.data(this, "splitbutton", { options: e.extend({}, e.fn.splitbutton.defaults, e.fn.splitbutton.parseOptions(this), r) }), e(this).removeAttr("disabled")), n(this);
    });
  }, e.fn.splitbutton.methods = { options: function(r) {
    var o = r.menubutton("options"), l = e.data(r[0], "splitbutton").options;
    return e.extend(l, { disabled: o.disabled, toggle: o.toggle, selected: o.selected }), l;
  } }, e.fn.splitbutton.parseOptions = function(r) {
    return e(r), e.extend({}, e.fn.linkbutton.parseOptions(r), e.parser.parseOptions(r, ["menu", { plain: "boolean", duration: "number" }]));
  }, e.fn.splitbutton.defaults = e.extend({}, e.fn.linkbutton.defaults, { plain: !0, menu: null, duration: 100, cls: { btn1: "m-btn-active s-btn-active", btn2: "m-btn-plain-active s-btn-plain-active", arrow: "m-btn-downarrow", trigger: "m-btn-line" } });
})($);
(function(e) {
  function n(f) {
    var v = e('<span class="switchbutton"><span class="switchbutton-inner"><span class="switchbutton-on"></span><span class="switchbutton-handle"></span><span class="switchbutton-off"></span><input class="switchbutton-value" type="checkbox"></span></span>').insertAfter(f), m = e(f);
    m.addClass("switchbutton-f").hide();
    var g = m.attr("name");
    return g && (m.removeAttr("name").attr("switchbuttonName", g), v.find(".switchbutton-value").attr("name", g)), v.bind("_resize", function(y, w) {
      return (e(this).hasClass("easyui-fluid") || w) && r(f), !1;
    }), v;
  }
  function r(f, v) {
    var m = e.data(f, "switchbutton"), g = m.options, y = m.switchbutton;
    v && e.extend(g, v);
    var w = y.is(":visible");
    w || y.appendTo("body"), y._size(g);
    var E = y.width(), x = y.height(), E = y.outerWidth(), x = y.outerHeight(), D = parseInt(g.handleWidth) || y.height(), F = E * 2 - D;
    y.find(".switchbutton-inner").css({ width: F + "px", height: x + "px", lineHeight: x + "px" }), y.find(".switchbutton-handle")._outerWidth(D)._outerHeight(x).css({ marginLeft: -D / 2 + "px" }), y.find(".switchbutton-on").css({ width: E - D / 2 + "px", textIndent: (g.reversed ? "" : "-") + D / 2 + "px" }), y.find(".switchbutton-off").css({ width: E - D / 2 + "px", textIndent: (g.reversed ? "-" : "") + D / 2 + "px" }), g.marginWidth = E - D, l(f, g.checked, !1), w || y.insertAfter(f);
  }
  function o(f) {
    var v = e.data(f, "switchbutton"), m = v.options, g = v.switchbutton, y = g.find(".switchbutton-inner"), w = y.find(".switchbutton-on").html(m.onText), E = y.find(".switchbutton-off").html(m.offText), x = y.find(".switchbutton-handle").html(m.handleText);
    m.reversed ? (E.prependTo(y), w.insertAfter(x)) : (w.prependTo(y), E.insertAfter(x)), g.find(".switchbutton-value")._propAttr("checked", m.checked), g.removeClass("switchbutton-disabled").addClass(m.disabled ? "switchbutton-disabled" : ""), g.removeClass("switchbutton-reversed").addClass(m.reversed ? "switchbutton-reversed" : ""), l(f, m.checked), h(f, m.readonly), e(f).switchbutton("setValue", m.value);
  }
  function l(f, v, m) {
    var g = e.data(f, "switchbutton"), y = g.options;
    y.checked = v;
    var w = g.switchbutton.find(".switchbutton-inner"), E = w.find(".switchbutton-on"), x = y.reversed ? y.checked ? y.marginWidth : 0 : y.checked ? 0 : y.marginWidth, D = E.css("float").toLowerCase(), F = {};
    F["margin-" + D] = -x + "px", m ? w.animate(F, 200) : w.css(F);
    var k = w.find(".switchbutton-value"), N = k.is(":checked");
    e(f).add(k)._propAttr("checked", y.checked), N != y.checked && y.onChange.call(f, y.checked);
  }
  function u(f, v) {
    var m = e.data(f, "switchbutton"), g = m.options, y = m.switchbutton, w = y.find(".switchbutton-value");
    v ? (g.disabled = !0, e(f).add(w).attr("disabled", "disabled"), y.addClass("switchbutton-disabled")) : (g.disabled = !1, e(f).add(w).removeAttr("disabled"), y.removeClass("switchbutton-disabled"));
  }
  function h(f, v) {
    var m = e.data(f, "switchbutton"), g = m.options;
    g.readonly = v ?? !0, m.switchbutton.removeClass("switchbutton-readonly").addClass(g.readonly ? "switchbutton-readonly" : "");
  }
  function c(f) {
    var v = e.data(f, "switchbutton"), m = v.options;
    v.switchbutton.unbind(".switchbutton").bind("click.switchbutton", function() {
      !m.disabled && !m.readonly && l(f, !m.checked, !0);
    });
  }
  e.fn.switchbutton = function(f, v) {
    return typeof f == "string" ? e.fn.switchbutton.methods[f](this, v) : (f = f || {}, this.each(function() {
      var m = e.data(this, "switchbutton");
      m ? e.extend(m.options, f) : m = e.data(this, "switchbutton", { options: e.extend({}, e.fn.switchbutton.defaults, e.fn.switchbutton.parseOptions(this), f), switchbutton: n(this) }), m.options.originalChecked = m.options.checked, o(this), r(this), c(this);
    }));
  }, e.fn.switchbutton.methods = { options: function(f) {
    var v = f.data("switchbutton");
    return e.extend(v.options, { value: v.switchbutton.find(".switchbutton-value").val() });
  }, resize: function(f, v) {
    return f.each(function() {
      r(this, v);
    });
  }, enable: function(f) {
    return f.each(function() {
      u(this, !1);
    });
  }, disable: function(f) {
    return f.each(function() {
      u(this, !0);
    });
  }, readonly: function(f, v) {
    return f.each(function() {
      h(this, v);
    });
  }, check: function(f) {
    return f.each(function() {
      l(this, !0);
    });
  }, uncheck: function(f) {
    return f.each(function() {
      l(this, !1);
    });
  }, clear: function(f) {
    return f.each(function() {
      l(this, !1);
    });
  }, reset: function(f) {
    return f.each(function() {
      var v = e(this).switchbutton("options");
      l(this, v.originalChecked);
    });
  }, setValue: function(f, v) {
    return f.each(function() {
      e(this).val(v), e.data(this, "switchbutton").switchbutton.find(".switchbutton-value").val(v);
    });
  } }, e.fn.switchbutton.parseOptions = function(f) {
    var v = e(f);
    return e.extend({}, e.parser.parseOptions(f, ["onText", "offText", "handleText", { handleWidth: "number", reversed: "boolean" }]), { value: v.val() || void 0, checked: v.attr("checked") ? !0 : void 0, disabled: v.attr("disabled") ? !0 : void 0, readonly: v.attr("readonly") ? !0 : void 0 });
  }, e.fn.switchbutton.defaults = { handleWidth: "auto", width: 60, height: 26, checked: !1, disabled: !1, readonly: !1, reversed: !1, onText: "ON", offText: "OFF", handleText: "", value: "on", onChange: function(f) {
  } };
})($);
(function($) {
  function init(e) {
    $(e).addClass("validatebox-text");
  }
  function _4b7(e) {
    var n = $.data(e, "validatebox");
    n.validating = !1, n.vtimer && clearTimeout(n.vtimer), n.ftimer && clearTimeout(n.ftimer), $(e).tooltip("destroy"), $(e).unbind(), $(e).remove();
  }
  function _4ba(e) {
    var n = $.data(e, "validatebox").options;
    if ($(e).unbind(".validatebox"), !(n.novalidate || n.disabled))
      for (var r in n.events)
        $(e).bind(r + ".validatebox", { target: e }, n.events[r]);
  }
  function _4bd(e) {
    var n = e.data.target, r = $.data(n, "validatebox"), o = r.options;
    $(n).attr("readonly") || (r.validating = !0, r.value = o.val(n), function() {
      if ($(n).is(":visible") || (r.validating = !1), r.validating) {
        var l = o.val(n);
        r.value != l ? (r.value = l, r.vtimer && clearTimeout(r.vtimer), r.vtimer = setTimeout(function() {
          $(n).validatebox("validate");
        }, o.delay)) : r.message && o.err(n, r.message), r.ftimer = setTimeout(arguments.callee, o.interval);
      }
    }());
  }
  function _4c1(e) {
    var n = e.data.target, r = $.data(n, "validatebox"), o = r.options;
    r.validating = !1, r.vtimer && (clearTimeout(r.vtimer), r.vtimer = void 0), r.ftimer && (clearTimeout(r.ftimer), r.ftimer = void 0), o.validateOnBlur && setTimeout(function() {
      $(n).validatebox("validate");
    }, 0), o.err(n, r.message, "hide");
  }
  function _4c4(e) {
    var n = e.data.target, r = $.data(n, "validatebox");
    r.options.err(n, r.message, "show");
  }
  function _4c7(e) {
    var n = e.data.target, r = $.data(n, "validatebox");
    r.validating || r.options.err(n, r.message, "hide");
  }
  function _4ca(e, n, r) {
    var o = $.data(e, "validatebox"), l = o.options, u = $(e);
    r == "hide" || !n ? u.tooltip("hide") : (u.is(":focus") && o.validating || r == "show") && u.tooltip($.extend({}, l.tipOptions, { content: n, position: l.tipPosition, deltaX: l.deltaX, deltaY: l.deltaY })).tooltip("show");
  }
  function _4cf(_4d0) {
    var _4d1 = $.data(_4d0, "validatebox"), opts = _4d1.options, box = $(_4d0);
    opts.onBeforeValidate.call(_4d0);
    var _4d2 = _4d3();
    return _4d2 ? box.removeClass("validatebox-invalid") : box.addClass("validatebox-invalid"), opts.err(_4d0, _4d1.message), opts.onValidate.call(_4d0, _4d2), _4d2;
    function _4d4(e) {
      _4d1.message = e;
    }
    function _4d5(_4d6, _4d7) {
      var _4d8 = opts.val(_4d0), _4d9 = /([a-zA-Z_]+)(.*)/.exec(_4d6), rule = opts.rules[_4d9[1]];
      if (rule && _4d8) {
        var _4da = _4d7 || opts.validParams || eval(_4d9[2]);
        if (!rule.validator.call(_4d0, _4d8, _4da)) {
          var _4db = rule.message;
          if (_4da)
            for (var i = 0; i < _4da.length; i++)
              _4db = _4db.replace(new RegExp("\\{" + i + "\\}", "g"), _4da[i]);
          return _4d4(opts.invalidMessage || _4db), !1;
        }
      }
      return !0;
    }
    function _4d3() {
      if (_4d4(""), !opts._validateOnCreate)
        return setTimeout(function() {
          opts._validateOnCreate = !0;
        }, 0), !0;
      if (opts.novalidate || opts.disabled)
        return !0;
      if (opts.required && opts.val(_4d0) == "")
        return _4d4(opts.missingMessage), !1;
      if (opts.validType)
        if ($.isArray(opts.validType)) {
          for (var e = 0; e < opts.validType.length; e++)
            if (!_4d5(opts.validType[e]))
              return !1;
        } else if (typeof opts.validType == "string") {
          if (!_4d5(opts.validType))
            return !1;
        } else
          for (var n in opts.validType) {
            var r = opts.validType[n];
            if (!_4d5(n, r))
              return !1;
          }
      return !0;
    }
  }
  function _4de(e, n) {
    var r = $.data(e, "validatebox").options;
    n != null && (r.disabled = n), r.disabled ? $(e).addClass("validatebox-disabled").attr("disabled", "disabled") : $(e).removeClass("validatebox-disabled").removeAttr("disabled");
  }
  function _4e1(e, n) {
    var r = $.data(e, "validatebox").options;
    r.readonly = n ?? !0, r.readonly || !r.editable ? ($(e).triggerHandler("blur.validatebox"), $(e).addClass("validatebox-readonly").attr("readonly", "readonly")) : $(e).removeClass("validatebox-readonly").removeAttr("readonly");
  }
  $.fn.validatebox = function(e, n) {
    return typeof e == "string" ? $.fn.validatebox.methods[e](this, n) : (e = e || {}, this.each(function() {
      var r = $.data(this, "validatebox");
      r ? $.extend(r.options, e) : (init(this), r = $.data(this, "validatebox", { options: $.extend({}, $.fn.validatebox.defaults, $.fn.validatebox.parseOptions(this), e) })), r.options._validateOnCreate = r.options.validateOnCreate, _4de(this, r.options.disabled), _4e1(this, r.options.readonly), _4ba(this), _4cf(this);
    }));
  }, $.fn.validatebox.methods = { options: function(e) {
    return $.data(e[0], "validatebox").options;
  }, destroy: function(e) {
    return e.each(function() {
      _4b7(this);
    });
  }, validate: function(e) {
    return e.each(function() {
      _4cf(this);
    });
  }, isValid: function(e) {
    return _4cf(e[0]);
  }, enableValidation: function(e) {
    return e.each(function() {
      $(this).validatebox("options").novalidate = !1, _4ba(this), _4cf(this);
    });
  }, disableValidation: function(e) {
    return e.each(function() {
      $(this).validatebox("options").novalidate = !0, _4ba(this), _4cf(this);
    });
  }, resetValidation: function(e) {
    return e.each(function() {
      var n = $(this).validatebox("options");
      n._validateOnCreate = n.validateOnCreate, _4cf(this);
    });
  }, enable: function(e) {
    return e.each(function() {
      _4de(this, !1), _4ba(this), _4cf(this);
    });
  }, disable: function(e) {
    return e.each(function() {
      _4de(this, !0), _4ba(this), _4cf(this);
    });
  }, readonly: function(e, n) {
    return e.each(function() {
      _4e1(this, n), _4ba(this), _4cf(this);
    });
  } }, $.fn.validatebox.parseOptions = function(e) {
    var n = $(e);
    return $.extend({}, $.parser.parseOptions(e, ["validType", "missingMessage", "invalidMessage", "tipPosition", { delay: "number", interval: "number", deltaX: "number" }, { editable: "boolean", validateOnCreate: "boolean", validateOnBlur: "boolean" }]), { required: n.attr("required") ? !0 : void 0, disabled: n.attr("disabled") ? !0 : void 0, readonly: n.attr("readonly") ? !0 : void 0, novalidate: n.attr("novalidate") != null ? !0 : void 0 });
  }, $.fn.validatebox.defaults = { required: !1, validType: null, validParams: null, delay: 200, interval: 200, missingMessage: "This field is required.", invalidMessage: null, tipPosition: "right", deltaX: 0, deltaY: 0, novalidate: !1, editable: !0, disabled: !1, readonly: !1, validateOnCreate: !0, validateOnBlur: !1, events: { focus: _4bd, blur: _4c1, mouseenter: _4c4, mouseleave: _4c7, click: function(e) {
    var n = $(e.data.target);
    (n.attr("type") == "checkbox" || n.attr("type") == "radio") && n.focus().validatebox("validate");
  } }, val: function(e) {
    return $(e).val();
  }, err: function(e, n, r) {
    _4ca(e, n, r);
  }, tipOptions: { showEvent: "none", hideEvent: "none", showDelay: 0, hideDelay: 0, zIndex: "", onShow: function() {
    $(this).tooltip("tip").css({ color: "#000", borderColor: "#CC9933", backgroundColor: "#FFFFCC" });
  }, onHide: function() {
    $(this).tooltip("destroy");
  } }, rules: { email: { validator: function(e) {
    return /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i.test(e);
  }, message: "Please enter a valid email address." }, url: { validator: function(e) {
    return /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(e);
  }, message: "Please enter a valid URL." }, length: { validator: function(e, n) {
    var r = $.trim(e).length;
    return r >= n[0] && r <= n[1];
  }, message: "Please enter a value between {0} and {1}." }, remote: { validator: function(e, n) {
    var r = {};
    r[n[1]] = e;
    var o = $.ajax({ url: n[0], dataType: "json", data: r, async: !1, cache: !1, type: "post" }).responseText;
    return o == "true";
  }, message: "Please fix this field." } }, onBeforeValidate: function() {
  }, onValidate: function(e) {
  } };
})($);
(function(e) {
  var n = 0;
  function r(m) {
    e(m).addClass("textbox-f").hide();
    var g = e('<span class="textbox"><input class="textbox-text" autocomplete="off"><input type="hidden" class="textbox-value"></span>').insertAfter(m), y = e(m).attr("name");
    return y && (g.find("input.textbox-value").attr("name", y), e(m).removeAttr("name").attr("textboxName", y)), g;
  }
  function o(m) {
    var g = e.data(m, "textbox"), y = g.options, w = g.textbox, E = "_easyui_textbox_input" + ++n;
    w.addClass(y.cls), w.find(".textbox-text").remove(), y.multiline ? e('<textarea id="' + E + '" class="textbox-text" autocomplete="off"></textarea>').prependTo(w) : e('<input id="' + E + '" type="' + y.type + '" class="textbox-text" autocomplete="off">').prependTo(w), e("#" + E).attr("tabindex", e(m).attr("tabindex") || "").css("text-align", m.style.textAlign || ""), w.find(".textbox-addon").remove();
    var x = y.icons ? e.extend(!0, [], y.icons) : [];
    if (y.iconCls && x.push({ iconCls: y.iconCls, disabled: !0 }), x.length) {
      var D = e('<span class="textbox-addon"></span>').prependTo(w);
      D.addClass("textbox-addon-" + y.iconAlign);
      for (var F = 0; F < x.length; F++)
        D.append('<a href="javascript:;" class="textbox-icon ' + x[F].iconCls + '" icon-index="' + F + '" tabindex="-1"></a>');
    }
    if (w.find(".textbox-button").remove(), y.buttonText || y.buttonIcon) {
      var k = e('<a href="javascript:;" class="textbox-button"></a>').prependTo(w);
      k.addClass("textbox-button-" + y.buttonAlign).linkbutton({ text: y.buttonText, iconCls: y.buttonIcon, onClick: function() {
        var N = e(this).parent().prev();
        N.textbox("options").onClickButton.call(N[0]);
      } });
    }
    y.label ? typeof y.label == "object" ? (g.label = e(y.label), g.label.attr("for", E)) : (e(g.label).remove(), g.label = e('<label class="textbox-label"></label>').html(y.label), g.label.css("textAlign", y.labelAlign).attr("for", E), y.labelPosition == "after" ? g.label.insertAfter(w) : g.label.insertBefore(m), g.label.removeClass("textbox-label-left textbox-label-right textbox-label-top"), g.label.addClass("textbox-label-" + y.labelPosition)) : e(g.label).remove(), h(m), f(m, y.disabled), v(m, y.readonly);
  }
  function l(m) {
    var g = e.data(m, "textbox"), y = g.textbox;
    y.find(".textbox-text").validatebox("destroy"), y.remove(), e(g.label).remove(), e(m).remove();
  }
  function u(m, g) {
    var y = e.data(m, "textbox"), w = y.options, E = y.textbox, x = E.parent();
    if (g && (typeof g == "object" ? e.extend(w, g) : w.width = g), isNaN(parseInt(w.width))) {
      var D = e(m).clone();
      D.css("visibility", "hidden"), D.insertAfter(m), w.width = D.outerWidth(), D.remove();
    }
    var F = E.is(":visible");
    F || E.appendTo("body");
    var k = E.find(".textbox-text"), N = E.find(".textbox-button"), H = E.find(".textbox-addon"), R = H.find(".textbox-icon");
    w.height == "auto" && k.css({ margin: "", paddingTop: "", paddingBottom: "", height: "", lineHeight: "" }), E._size(w, x), w.label && w.labelPosition && (w.labelPosition == "top" ? (y.label._size({ width: w.labelWidth == "auto" ? E.outerWidth() : w.labelWidth }, E), w.height != "auto" && E._size("height", E.outerHeight() - y.label.outerHeight())) : (y.label._size({ width: w.labelWidth, height: E.outerHeight() }, E), w.multiline || y.label.css("lineHeight", y.label.height() + "px"), E._size("width", E.outerWidth() - y.label.outerWidth()))), w.buttonAlign == "left" || w.buttonAlign == "right" ? N.linkbutton("resize", { height: E.height() }) : N.linkbutton("resize", { width: "100%" });
    var j = E.width() - R.length * w.iconWidth - nt("left") - nt("right"), S = w.height == "auto" ? k.outerHeight() : E.height() - nt("top") - nt("bottom");
    H.css(w.iconAlign, nt(w.iconAlign) + "px"), H.css("top", nt("top") + "px"), R.css({ width: w.iconWidth + "px", height: S + "px" }), k.css({ paddingLeft: m.style.paddingLeft || "", paddingRight: m.style.paddingRight || "", marginLeft: tt("left"), marginRight: tt("right"), marginTop: nt("top"), marginBottom: nt("bottom") }), w.multiline ? (k.css({ paddingTop: m.style.paddingTop || "", paddingBottom: m.style.paddingBottom || "" }), k._outerHeight(S)) : k.css({ paddingTop: 0, paddingBottom: 0, height: S + "px", lineHeight: S + "px" }), k._outerWidth(j), w.onResizing.call(m, w.width, w.height), F || E.insertAfter(m), w.onResize.call(m, w.width, w.height);
    function tt(ft) {
      return (w.iconAlign == ft ? H._outerWidth() : 0) + nt(ft);
    }
    function nt(ft) {
      var pt = 0;
      return N.filter(".textbox-button-" + ft).each(function() {
        ft == "left" || ft == "right" ? pt += e(this).outerWidth() : pt += e(this).outerHeight();
      }), pt;
    }
  }
  function h(m) {
    var g = e(m).textbox("options"), y = e(m).textbox("textbox");
    y.validatebox(e.extend({}, g, { deltaX: function(w) {
      return e(m).textbox("getTipX", w);
    }, deltaY: function(w) {
      return e(m).textbox("getTipY", w);
    }, onBeforeValidate: function() {
      g.onBeforeValidate.call(m);
      var w = e(this);
      w.is(":focus") || w.val() !== g.value && (g.oldInputValue = w.val(), w.val(g.value));
    }, onValidate: function(w) {
      var E = e(this);
      g.oldInputValue != null && (E.val(g.oldInputValue), g.oldInputValue = void 0);
      var x = E.parent();
      w ? x.removeClass("textbox-invalid") : x.addClass("textbox-invalid"), g.onValidate.call(m, w);
    } }));
  }
  function c(m) {
    var g = e.data(m, "textbox"), y = g.options, w = g.textbox, E = w.find(".textbox-text");
    if (E.attr("placeholder", y.prompt), E.unbind(".textbox"), e(g.label).unbind(".textbox"), !y.disabled && !y.readonly) {
      g.label && e(g.label).bind("click.textbox", function(k) {
        y.hasFocusMe || (E.focus(), e(m).textbox("setSelectionRange", { start: 0, end: E.val().length }));
      }), E.bind("blur.textbox", function(k) {
        w.hasClass("textbox-focused") && (y.value = e(this).val(), y.value == "" ? e(this).val(y.prompt).addClass("textbox-prompt") : e(this).removeClass("textbox-prompt"), w.removeClass("textbox-focused"));
      }).bind("focus.textbox", function(k) {
        y.hasFocusMe = !0, !w.hasClass("textbox-focused") && (e(this).val() != y.value && e(this).val(y.value), e(this).removeClass("textbox-prompt"), w.addClass("textbox-focused"));
      });
      for (var x in y.inputEvents)
        E.bind(x + ".textbox", { target: m }, y.inputEvents[x]);
    }
    var D = w.find(".textbox-addon");
    D.unbind().bind("click", { target: m }, function(k) {
      var N = e(k.target).closest("a.textbox-icon:not(.textbox-icon-disabled)");
      if (N.length) {
        var H = parseInt(N.attr("icon-index")), R = y.icons[H];
        R && R.handler && R.handler.call(N[0], k), y.onClickIcon.call(m, H);
      }
    }), D.find(".textbox-icon").each(function(k) {
      var N = y.icons[k], H = e(this);
      !N || N.disabled || y.disabled || y.readonly ? H.addClass("textbox-icon-disabled") : H.removeClass("textbox-icon-disabled");
    });
    var F = w.find(".textbox-button");
    F.linkbutton(y.disabled || y.readonly ? "disable" : "enable"), w.unbind(".textbox").bind("_resize.textbox", function(k, N) {
      return (e(this).hasClass("easyui-fluid") || N) && u(m), !1;
    });
  }
  function f(m, g) {
    var y = e.data(m, "textbox"), w = y.options, E = y.textbox, x = E.find(".textbox-text"), D = e(m).add(E.find(".textbox-value"));
    w.disabled = g, w.disabled ? (x.blur(), x.validatebox("disable"), E.addClass("textbox-disabled"), D.attr("disabled", "disabled"), e(y.label).addClass("textbox-label-disabled")) : (x.validatebox("enable"), E.removeClass("textbox-disabled"), D.removeAttr("disabled"), e(y.label).removeClass("textbox-label-disabled"));
  }
  function v(m, g) {
    var y = e.data(m, "textbox"), w = y.options, E = y.textbox, x = E.find(".textbox-text");
    w.readonly = g ?? !0, w.readonly && x.triggerHandler("blur.textbox"), x.validatebox("readonly", w.readonly), E.removeClass("textbox-readonly").addClass(w.readonly ? "textbox-readonly" : "");
  }
  e.fn.textbox = function(m, g) {
    if (typeof m == "string") {
      var y = e.fn.textbox.methods[m];
      return y ? y(this, g) : this.each(function() {
        var w = e(this).textbox("textbox");
        w.validatebox(m, g);
      });
    }
    return m = m || {}, this.each(function() {
      var w = e.data(this, "textbox");
      w ? (e.extend(w.options, m), m.value != null && (w.options.originalValue = m.value)) : (w = e.data(this, "textbox", { options: e.extend({}, e.fn.textbox.defaults, e.fn.textbox.parseOptions(this), m), textbox: r(this) }), w.options.originalValue = w.options.value), o(this), c(this), w.options.doSize && u(this);
      var E = w.options.value;
      w.options.value = "", e(this).textbox("initValue", E);
    });
  }, e.fn.textbox.methods = { options: function(m) {
    return e.data(m[0], "textbox").options;
  }, cloneFrom: function(m, g) {
    return m.each(function() {
      var y = e(this);
      if (!y.data("textbox")) {
        e(g).data("textbox") || e(g).textbox();
        var w = e.extend(!0, {}, e(g).textbox("options")), E = y.attr("name") || "";
        y.addClass("textbox-f").hide(), y.removeAttr("name").attr("textboxName", E);
        var x = e(g).next().clone().insertAfter(y), D = "_easyui_textbox_input" + ++n;
        x.find(".textbox-value").attr("name", E), x.find(".textbox-text").attr("id", D);
        var F = e(e(g).textbox("label")).clone();
        F.length && (F.attr("for", D), w.labelPosition == "after" ? F.insertAfter(y.next()) : F.insertBefore(y)), e.data(this, "textbox", { options: w, textbox: x, label: F.length ? F : void 0 });
        var k = e(g).textbox("button");
        k.length && y.textbox("button").linkbutton(e.extend(!0, {}, k.linkbutton("options"))), c(this), h(this);
      }
    });
  }, textbox: function(m) {
    return e.data(m[0], "textbox").textbox.find(".textbox-text");
  }, button: function(m) {
    return e.data(m[0], "textbox").textbox.find(".textbox-button");
  }, label: function(m) {
    return e.data(m[0], "textbox").label;
  }, destroy: function(m) {
    return m.each(function() {
      l(this);
    });
  }, resize: function(m, g) {
    return m.each(function() {
      u(this, g);
    });
  }, disable: function(m) {
    return m.each(function() {
      f(this, !0), c(this);
    });
  }, enable: function(m) {
    return m.each(function() {
      f(this, !1), c(this);
    });
  }, readonly: function(m, g) {
    return m.each(function() {
      v(this, g), c(this);
    });
  }, isValid: function(m) {
    return m.textbox("textbox").validatebox("isValid");
  }, clear: function(m) {
    return m.each(function() {
      e(this).textbox("setValue", "");
    });
  }, setText: function(m, g) {
    return m.each(function() {
      var y = e(this).textbox("options"), w = e(this).textbox("textbox");
      g = g == null ? "" : String(g), e(this).textbox("getText") != g && w.val(g), y.value = g, w.is(":focus") || (g ? w.removeClass("textbox-prompt") : w.val(y.prompt).addClass("textbox-prompt")), e(this).textbox("validate");
    });
  }, initValue: function(m, g) {
    return m.each(function() {
      var y = e.data(this, "textbox");
      e(this).textbox("setText", g), y.textbox.find(".textbox-value").val(g), e(this).val(g);
    });
  }, setValue: function(m, g) {
    return m.each(function() {
      var y = e.data(this, "textbox").options, w = e(this).textbox("getValue");
      e(this).textbox("initValue", g), w != g && (y.onChange.call(this, g, w), e(this).closest("form").trigger("_change", [this]));
    });
  }, getText: function(m) {
    var g = m.textbox("textbox");
    return g.is(":focus") ? g.val() : m.textbox("options").value;
  }, getValue: function(m) {
    return m.data("textbox").textbox.find(".textbox-value").val();
  }, reset: function(m) {
    return m.each(function() {
      var g = e(this).textbox("options");
      e(this).textbox("textbox").val(g.originalValue), e(this).textbox("setValue", g.originalValue);
    });
  }, getIcon: function(m, g) {
    return m.data("textbox").textbox.find(".textbox-icon:eq(" + g + ")");
  }, getTipX: function(m, D) {
    var y = m.data("textbox"), w = y.options, E = y.textbox, x = E.find(".textbox-text"), D = D || w.tipPosition, F = E.offset(), k = x.offset(), N = E.outerWidth(), H = x.outerWidth();
    return D == "right" ? N - H - k.left + F.left : D == "left" ? F.left - k.left : (N - H - k.left + F.left) / 2 - (k.left - F.left) / 2;
  }, getTipY: function(m, D) {
    var y = m.data("textbox"), w = y.options, E = y.textbox, x = E.find(".textbox-text"), D = D || w.tipPosition, F = E.offset(), k = x.offset(), N = E.outerHeight(), H = x.outerHeight();
    return D == "left" || D == "right" ? (N - H - k.top + F.top) / 2 - (k.top - F.top) / 2 : D == "bottom" ? N - H - k.top + F.top : F.top - k.top;
  }, getSelectionStart: function(m) {
    return m.textbox("getSelectionRange").start;
  }, getSelectionRange: function(m) {
    var g = m.textbox("textbox")[0], y = 0, w = 0;
    if (typeof g.selectionStart == "number")
      y = g.selectionStart, w = g.selectionEnd;
    else if (g.createTextRange) {
      var E = document.selection.createRange(), x = g.createTextRange();
      x.setEndPoint("EndToStart", E), y = x.text.length, w = y + E.text.length;
    }
    return { start: y, end: w };
  }, setSelectionRange: function(m, g) {
    return m.each(function() {
      var y = e(this).textbox("textbox")[0], w = g.start, E = g.end;
      if (y.setSelectionRange)
        y.setSelectionRange(w, E);
      else if (y.createTextRange) {
        var x = y.createTextRange();
        x.collapse(), x.moveEnd("character", E), x.moveStart("character", w), x.select();
      }
    });
  } }, e.fn.textbox.parseOptions = function(m) {
    var g = e(m);
    return e.extend({}, e.fn.validatebox.parseOptions(m), e.parser.parseOptions(m, ["prompt", "iconCls", "iconAlign", "buttonText", "buttonIcon", "buttonAlign", "label", "labelPosition", "labelAlign", { multiline: "boolean", iconWidth: "number", labelWidth: "number" }]), { value: g.val() || void 0, type: g.attr("type") ? g.attr("type") : void 0 });
  }, e.fn.textbox.defaults = e.extend({}, e.fn.validatebox.defaults, { doSize: !0, width: "auto", height: "auto", cls: null, prompt: "", value: "", type: "text", multiline: !1, icons: [], iconCls: null, iconAlign: "right", iconWidth: 18, buttonText: "", buttonIcon: null, buttonAlign: "right", label: null, labelWidth: "auto", labelPosition: "before", labelAlign: "left", inputEvents: { blur: function(m) {
    var g = e(m.data.target), y = g.textbox("options");
    g.textbox("getValue") != y.value && g.textbox("setValue", y.value);
  }, keydown: function(m) {
    if (m.keyCode == 13) {
      var g = e(m.data.target);
      g.textbox("setValue", g.textbox("getText"));
    }
  } }, onChange: function(m, g) {
  }, onResizing: function(m, g) {
  }, onResize: function(m, g) {
  }, onClickButton: function() {
  }, onClickIcon: function(m) {
  } });
})($);
(function(e) {
  function n(h) {
    var c = e.data(h, "passwordbox"), f = c.options, v = e.extend(!0, [], f.icons);
    f.showEye && v.push({ iconCls: "passwordbox-open", handler: function(m) {
      f.revealed = !f.revealed, o(h);
    } }), e(h).addClass("passwordbox-f").textbox(e.extend({}, f, { icons: v })), o(h);
  }
  function r(h, c, f) {
    var v = e(h), m = v.passwordbox("options");
    if (m.revealed) {
      v.textbox("setValue", c);
      return;
    }
    for (var g = unescape(m.passwordChar), y = c.split(""), w = v.passwordbox("getValue").split(""), E = 0; E < y.length; E++) {
      var x = y[E];
      x != w[E] && x != g && w.splice(E, 0, x);
    }
    var D = v.passwordbox("getSelectionStart");
    y.length < w.length && w.splice(D, w.length - y.length, "");
    for (var E = 0; E < y.length; E++)
      (f || E != D - 1) && (y[E] = g);
    v.textbox("setValue", w.join("")), v.textbox("setText", y.join("")), v.textbox("setSelectionRange", { start: D, end: D });
  }
  function o(h, c) {
    var f = e(h), v = f.passwordbox("options"), m = f.next().find(".passwordbox-open"), g = unescape(v.passwordChar);
    c = c ?? f.textbox("getValue"), f.textbox("setValue", c), f.textbox("setText", v.revealed ? c : c.replace(/./ig, g)), v.revealed ? m.addClass("passwordbox-close") : m.removeClass("passwordbox-close");
  }
  function l(h) {
    var c = h.data.target, f = e(h.data.target), v = f.data("passwordbox"), m = f.data("passwordbox").options;
    v.checking = !0, v.value = f.passwordbox("getText"), function() {
      if (v.checking) {
        var g = f.passwordbox("getText");
        v.value != g && (v.value = g, v.lastTimer && (clearTimeout(v.lastTimer), v.lastTimer = void 0), r(c, g), v.lastTimer = setTimeout(function() {
          r(c, f.passwordbox("getText"), !0), v.lastTimer = void 0;
        }, m.lastDelay)), setTimeout(arguments.callee, m.checkInterval);
      }
    }();
  }
  function u(h) {
    var c = h.data.target, f = e(c).data("passwordbox");
    f.checking = !1, f.lastTimer && (clearTimeout(f.lastTimer), f.lastTimer = void 0), o(c);
  }
  e.fn.passwordbox = function(h, c) {
    if (typeof h == "string") {
      var f = e.fn.passwordbox.methods[h];
      return f ? f(this, c) : this.textbox(h, c);
    }
    return h = h || {}, this.each(function() {
      var v = e.data(this, "passwordbox");
      v ? e.extend(v.options, h) : v = e.data(this, "passwordbox", { options: e.extend({}, e.fn.passwordbox.defaults, e.fn.passwordbox.parseOptions(this), h) }), n(this);
    });
  }, e.fn.passwordbox.methods = { options: function(h) {
    return e.data(h[0], "passwordbox").options;
  }, setValue: function(h, c) {
    return h.each(function() {
      o(this, c);
    });
  }, clear: function(h) {
    return h.each(function() {
      o(this, "");
    });
  }, reset: function(h) {
    return h.each(function() {
      e(this).textbox("reset"), o(this);
    });
  }, showPassword: function(h) {
    return h.each(function() {
      var c = e(this).passwordbox("options");
      c.revealed = !0, o(this);
    });
  }, hidePassword: function(h) {
    return h.each(function() {
      var c = e(this).passwordbox("options");
      c.revealed = !1, o(this);
    });
  } }, e.fn.passwordbox.parseOptions = function(h) {
    return e.extend({}, e.fn.textbox.parseOptions(h), e.parser.parseOptions(h, ["passwordChar", { checkInterval: "number", lastDelay: "number", revealed: "boolean", showEye: "boolean" }]));
  }, e.fn.passwordbox.defaults = e.extend({}, e.fn.textbox.defaults, { passwordChar: "%u25CF", checkInterval: 200, lastDelay: 500, revealed: !1, showEye: !0, inputEvents: { focus: l, blur: u }, val: function(h) {
    return e(h).parent().prev().passwordbox("getValue");
  } });
})($);
(function(e) {
  var n = 0;
  function r(l) {
    var u = e.data(l, "filebox"), h = u.options;
    h.fileboxId = "filebox_file_id_" + ++n, e(l).addClass("filebox-f").textbox(h), e(l).textbox("textbox").attr("readonly", "readonly"), u.filebox = e(l).next().addClass("filebox");
    var c = o(l), f = e(l).filebox("button");
    f.length && (e('<label class="filebox-label" for="' + h.fileboxId + '"></label>').appendTo(f), f.linkbutton("options").disabled ? c.attr("disabled", "disabled") : c.removeAttr("disabled"));
  }
  function o(l) {
    var u = e.data(l, "filebox"), h = u.options;
    u.filebox.find(".textbox-value").remove(), h.oldValue = "";
    var c = e('<input type="file" class="textbox-value">').appendTo(u.filebox);
    return c.attr("id", h.fileboxId).attr("name", e(l).attr("textboxName") || ""), c.attr("accept", h.accept), c.attr("capture", h.capture), h.multiple && c.attr("multiple", "multiple"), c.change(function() {
      var f = this.value;
      this.files && (f = e.map(this.files, function(v) {
        return v.name;
      }).join(h.separator)), e(l).filebox("setText", f), h.onChange.call(l, f, h.oldValue), h.oldValue = f;
    }), c;
  }
  e.fn.filebox = function(l, u) {
    if (typeof l == "string") {
      var h = e.fn.filebox.methods[l];
      return h ? h(this, u) : this.textbox(l, u);
    }
    return l = l || {}, this.each(function() {
      var c = e.data(this, "filebox");
      c ? e.extend(c.options, l) : e.data(this, "filebox", { options: e.extend({}, e.fn.filebox.defaults, e.fn.filebox.parseOptions(this), l) }), r(this);
    });
  }, e.fn.filebox.methods = { options: function(l) {
    var u = l.textbox("options");
    return e.extend(e.data(l[0], "filebox").options, { width: u.width, value: u.value, originalValue: u.originalValue, disabled: u.disabled, readonly: u.readonly });
  }, clear: function(l) {
    return l.each(function() {
      e(this).textbox("clear"), o(this);
    });
  }, reset: function(l) {
    return l.each(function() {
      e(this).filebox("clear");
    });
  }, setValue: function(l) {
    return l;
  }, setValues: function(l) {
    return l;
  } }, e.fn.filebox.parseOptions = function(l) {
    var u = e(l);
    return e.extend({}, e.fn.textbox.parseOptions(l), e.parser.parseOptions(l, ["accept", "capture", "separator"]), { multiple: u.attr("multiple") ? !0 : void 0 });
  }, e.fn.filebox.defaults = e.extend({}, e.fn.textbox.defaults, { buttonIcon: null, buttonText: "Choose File", buttonAlign: "right", inputEvents: {}, accept: "", capture: "", separator: ",", multiple: !1 });
})($);
(function($) {
  function _571(e) {
    var n = $.data(e, "searchbox"), r = n.options, o = $.extend(!0, [], r.icons);
    o.push({ iconCls: "searchbox-button", handler: function(f) {
      var v = $(f.data.target), m = v.searchbox("options");
      m.searcher.call(f.data.target, v.searchbox("getValue"), v.searchbox("getName"));
    } }), u();
    var l = h();
    $(e).addClass("searchbox-f").textbox($.extend({}, r, { icons: o, buttonText: l ? l.text : "" })), $(e).attr("searchboxName", $(e).attr("textboxName")), n.searchbox = $(e).next(), n.searchbox.addClass("searchbox"), c(l);
    function u() {
      if (r.menu) {
        n.menu = $(r.menu).menu();
        var f = n.menu.menu("options"), v = f.onClick;
        f.onClick = function(m) {
          c(m), v.call(this, m);
        };
      } else
        n.menu && n.menu.menu("destroy"), n.menu = null;
    }
    function h() {
      if (n.menu) {
        var f = n.menu.children("div.menu-item:first");
        return n.menu.children("div.menu-item").each(function() {
          var v = $.extend({}, $.parser.parseOptions(this), { selected: $(this).attr("selected") ? !0 : void 0 });
          if (v.selected)
            return f = $(this), !1;
        }), n.menu.menu("getItem", f[0]);
      } else
        return null;
    }
    function c(f) {
      f && ($(e).textbox("button").menubutton({ text: f.text, iconCls: f.iconCls || null, menu: n.menu, menuAlign: r.buttonAlign, plain: !1 }), n.searchbox.find("input.textbox-value").attr("name", f.name || f.text), $(e).searchbox("resize"));
    }
  }
  $.fn.searchbox = function(e, n) {
    if (typeof e == "string") {
      var r = $.fn.searchbox.methods[e];
      return r ? r(this, n) : this.textbox(e, n);
    }
    return e = e || {}, this.each(function() {
      var o = $.data(this, "searchbox");
      o ? $.extend(o.options, e) : $.data(this, "searchbox", { options: $.extend({}, $.fn.searchbox.defaults, $.fn.searchbox.parseOptions(this), e) }), _571(this);
    });
  }, $.fn.searchbox.methods = { options: function(e) {
    var n = e.textbox("options");
    return $.extend($.data(e[0], "searchbox").options, { width: n.width, value: n.value, originalValue: n.originalValue, disabled: n.disabled, readonly: n.readonly });
  }, menu: function(e) {
    return $.data(e[0], "searchbox").menu;
  }, getName: function(e) {
    return $.data(e[0], "searchbox").searchbox.find("input.textbox-value").attr("name");
  }, selectName: function(e, n) {
    return e.each(function() {
      var r = $.data(this, "searchbox").menu;
      r && r.children("div.menu-item").each(function() {
        var o = r.menu("getItem", this);
        if (o.name == n)
          return $(this).triggerHandler("click"), !1;
      });
    });
  }, destroy: function(e) {
    return e.each(function() {
      var n = $(this).searchbox("menu");
      n && n.menu("destroy"), $(this).textbox("destroy");
    });
  } }, $.fn.searchbox.parseOptions = function(_580) {
    var t = $(_580);
    return $.extend({}, $.fn.textbox.parseOptions(_580), $.parser.parseOptions(_580, ["menu"]), { searcher: t.attr("searcher") ? eval(t.attr("searcher")) : void 0 });
  }, $.fn.searchbox.defaults = $.extend({}, $.fn.textbox.defaults, { inputEvents: $.extend({}, $.fn.textbox.defaults.inputEvents, { keydown: function(e) {
    if (e.keyCode == 13) {
      e.preventDefault();
      var n = $(e.data.target), r = n.searchbox("options");
      return n.searchbox("setValue", $(this).val()), r.searcher.call(e.data.target, n.searchbox("getValue"), n.searchbox("getName")), !1;
    }
  } }), buttonAlign: "left", menu: null, searcher: function(e, n) {
  } });
})($);
(function(e) {
  function n(g, y) {
    var w = e.data(g, "form").options;
    e.extend(w, y || {});
    var E = e.extend({}, w.queryParams);
    if (w.onSubmit.call(g, E) != !1) {
      var x = e(g).find(".textbox-text:focus");
      x.triggerHandler("blur"), x.focus();
      var D = null;
      if (w.dirty) {
        var F = [];
        e.map(w.dirtyFields, function(k) {
          e(k).hasClass("textbox-f") ? e(k).next().find(".textbox-value").each(function() {
            F.push(this);
          }) : F.push(k);
        }), D = e(g).find("input[name]:enabled,textarea[name]:enabled,select[name]:enabled").filter(function() {
          return e.inArray(this, F) == -1;
        }), D.attr("disabled", "disabled");
      }
      w.ajax ? w.iframe ? r(g, E) : window.FormData !== void 0 ? o(g, E) : r(g, E) : e(g).submit(), w.dirty && D.removeAttr("disabled");
    }
  }
  function r(g, y) {
    var w = e.data(g, "form").options, E = "easyui_frame_" + (/* @__PURE__ */ new Date()).getTime(), x = e("<iframe id=" + E + " name=" + E + "></iframe>").appendTo("body");
    x.attr("src", window.ActiveXObject ? "javascript:false" : "about:blank"), x.css({ position: "absolute", top: -1e3, left: -1e3 }), x.bind("load", N), D(y);
    function D(H) {
      var R = e(g);
      w.url && R.attr("action", w.url);
      var j = R.attr("target"), S = R.attr("action");
      R.attr("target", E);
      var tt = e();
      try {
        for (var nt in H) {
          var ft = e('<input type="hidden" name="' + nt + '">').val(H[nt]).appendTo(R);
          tt = tt.add(ft);
        }
        F(), R[0].submit();
      } finally {
        R.attr("action", S), j ? R.attr("target", j) : R.removeAttr("target"), tt.remove();
      }
    }
    function F() {
      var H = e("#" + E);
      if (H.length)
        try {
          var R = H.contents()[0].readyState;
          R && R.toLowerCase() == "uninitialized" && setTimeout(F, 100);
        } catch {
          N();
        }
    }
    var k = 10;
    function N() {
      var H = e("#" + E);
      if (H.length) {
        H.unbind();
        var R = "";
        try {
          var j = H.contents().find("body");
          if (R = j.html(), R == "" && --k) {
            setTimeout(N, 100);
            return;
          }
          var S = j.find(">textarea");
          if (S.length)
            R = S.val();
          else {
            var tt = j.find(">pre");
            tt.length && (R = tt.html());
          }
        } catch {
        }
        w.success.call(g, R), setTimeout(function() {
          H.unbind(), H.remove();
        }, 100);
      }
    }
  }
  function o(g, y) {
    var w = e.data(g, "form").options, E = new FormData(e(g)[0]);
    for (var x in y)
      E.append(x, y[x]);
    e.ajax({ url: w.url, type: "post", xhr: function() {
      var D = e.ajaxSettings.xhr();
      return D.upload && D.upload.addEventListener("progress", function(F) {
        if (F.lengthComputable) {
          var k = F.total, N = F.loaded || F.position, H = Math.ceil(N * 100 / k);
          w.onProgress.call(g, H);
        }
      }, !1), D;
    }, data: E, dataType: "html", cache: !1, contentType: !1, processData: !1, complete: function(D) {
      w.success.call(g, D.responseText);
    } });
  }
  function l(g, y) {
    var w = e.data(g, "form").options;
    if (typeof y == "string") {
      var E = {};
      if (w.onBeforeLoad.call(g, E) == !1)
        return;
      e.ajax({ url: y, data: E, dataType: "json", success: function(N) {
        x(N);
      }, error: function() {
        w.onLoadError.apply(g, arguments);
      } });
    } else
      x(y);
    function x(N) {
      var H = e(g);
      for (var R in N) {
        var j = N[R];
        D(R, j) || k(R, j) || (H.find('input[name="' + R + '"]').val(j), H.find('textarea[name="' + R + '"]').val(j), H.find('select[name="' + R + '"]').val(j));
      }
      w.onLoadSuccess.call(g, N), H.form("validate");
    }
    function D(N, H) {
      var R = e(g).find('[switchbuttonName="' + N + '"]');
      return R.length ? (R.switchbutton("uncheck"), R.each(function() {
        F(e(this).switchbutton("options").value, H) && e(this).switchbutton("check");
      }), !0) : (R = e(g).find('input[name="' + N + '"][type=radio], input[name="' + N + '"][type=checkbox]'), R.length ? (R._propAttr("checked", !1), R.each(function() {
        F(e(this).val(), H) && e(this)._propAttr("checked", !0);
      }), !0) : !1);
    }
    function F(N, H) {
      return N == String(H) || e.inArray(N, e.isArray(H) ? H : [H]) >= 0;
    }
    function k(N, H) {
      var R = e(g).find('[textboxName="' + N + '"],[sliderName="' + N + '"]');
      if (R.length)
        for (var j = 0; j < w.fieldTypes.length; j++) {
          var S = w.fieldTypes[j], tt = R.data(S);
          if (tt)
            return tt.options.multiple || tt.options.range ? R[S]("setValues", H) : R[S]("setValue", H), !0;
        }
      return !1;
    }
  }
  function u(g) {
    e("input,select,textarea", g).each(function() {
      if (!e(this).hasClass("textbox-value")) {
        var k = this.type, N = this.tagName.toLowerCase();
        if (k == "text" || k == "hidden" || k == "password" || N == "textarea")
          this.value = "";
        else if (k == "file") {
          var H = e(this);
          if (!H.hasClass("textbox-value")) {
            var R = H.clone().val("");
            R.insertAfter(H), H.data("validatebox") ? (H.validatebox("destroy"), R.validatebox()) : H.remove();
          }
        } else
          k == "checkbox" || k == "radio" ? this.checked = !1 : N == "select" && (this.selectedIndex = -1);
      }
    });
    for (var y = e(), w = e(g), E = e.data(g, "form").options, x = 0; x < E.fieldTypes.length; x++) {
      var D = E.fieldTypes[x], F = w.find("." + D + "-f").not(y);
      F.length && F[D] && (F[D]("clear"), y = y.add(F));
    }
    w.form("validate");
  }
  function h(g) {
    g.reset();
    for (var y = e(g), w = e.data(g, "form").options, E = w.fieldTypes.length - 1; E >= 0; E--) {
      var x = w.fieldTypes[E], D = y.find("." + x + "-f");
      D.length && D[x] && D[x]("reset");
    }
    y.form("validate");
  }
  function c(g) {
    var y = e.data(g, "form").options;
    e(g).unbind(".form"), y.ajax && e(g).bind("submit.form", function() {
      return setTimeout(function() {
        n(g, y);
      }, 0), !1;
    }), e(g).bind("_change.form", function(w, E) {
      e.inArray(E, y.dirtyFields) == -1 && y.dirtyFields.push(E), y.onChange.call(this, E);
    }).bind("change.form", function(w) {
      var E = w.target;
      e(E).hasClass("textbox-text") || (e.inArray(E, y.dirtyFields) == -1 && y.dirtyFields.push(E), y.onChange.call(this, E));
    }), m(g, y.novalidate);
  }
  function f(g, y) {
    y = y || {};
    var w = e.data(g, "form");
    w ? e.extend(w.options, y) : e.data(g, "form", { options: e.extend({}, e.fn.form.defaults, e.fn.form.parseOptions(g), y) });
  }
  function v(g) {
    if (e.fn.validatebox) {
      var y = e(g);
      y.find(".validatebox-text:not(:disabled)").validatebox("validate");
      var w = y.find(".validatebox-invalid");
      return w.filter(":not(:disabled):first").focus(), w.length == 0;
    }
    return !0;
  }
  function m(g, y) {
    var w = e.data(g, "form").options;
    w.novalidate = y, e(g).find(".validatebox-text:not(:disabled)").validatebox(y ? "disableValidation" : "enableValidation");
  }
  e.fn.form = function(g, y) {
    return typeof g == "string" ? (this.each(function() {
      f(this);
    }), e.fn.form.methods[g](this, y)) : this.each(function() {
      f(this, g), c(this);
    });
  }, e.fn.form.methods = { options: function(g) {
    return e.data(g[0], "form").options;
  }, submit: function(g, y) {
    return g.each(function() {
      n(this, y);
    });
  }, load: function(g, y) {
    return g.each(function() {
      l(this, y);
    });
  }, clear: function(g) {
    return g.each(function() {
      u(this);
    });
  }, reset: function(g) {
    return g.each(function() {
      h(this);
    });
  }, validate: function(g) {
    return v(g[0]);
  }, disableValidation: function(g) {
    return g.each(function() {
      m(this, !0);
    });
  }, enableValidation: function(g) {
    return g.each(function() {
      m(this, !1);
    });
  }, resetValidation: function(g) {
    return g.each(function() {
      e(this).find(".validatebox-text:not(:disabled)").validatebox("resetValidation");
    });
  }, resetDirty: function(g) {
    return g.each(function() {
      e(this).form("options").dirtyFields = [];
    });
  } }, e.fn.form.parseOptions = function(g) {
    var y = e(g);
    return e.extend({}, e.parser.parseOptions(g, [{ ajax: "boolean", dirty: "boolean" }]), { url: y.attr("action") ? y.attr("action") : void 0 });
  }, e.fn.form.defaults = { fieldTypes: ["combobox", "combotree", "combogrid", "combotreegrid", "datetimebox", "datebox", "combo", "datetimespinner", "timespinner", "numberspinner", "spinner", "slider", "searchbox", "numberbox", "passwordbox", "filebox", "textbox", "switchbutton"], novalidate: !1, ajax: !0, iframe: !0, dirty: !1, dirtyFields: [], url: null, queryParams: {}, onSubmit: function(g) {
    return e(this).form("validate");
  }, onProgress: function(g) {
  }, success: function(g) {
  }, onBeforeLoad: function(g) {
  }, onLoadSuccess: function(g) {
  }, onLoadError: function() {
  }, onChange: function(g) {
  } };
})($);
(function(e) {
  function n(o) {
    var l = e.data(o, "numberbox"), u = l.options;
    e(o).addClass("numberbox-f").textbox(u), e(o).textbox("textbox").css({ imeMode: "disabled" }), e(o).attr("numberboxName", e(o).attr("textboxName")), l.numberbox = e(o).next(), l.numberbox.addClass("numberbox");
    var h = u.parser.call(o, u.value), c = u.formatter.call(o, h);
    e(o).numberbox("initValue", h).numberbox("setText", c);
  }
  function r(o, c) {
    var u = e.data(o, "numberbox"), h = u.options;
    h.value = parseFloat(c);
    var c = h.parser.call(o, c), f = h.formatter.call(o, c);
    h.value = c, e(o).textbox("setText", f).textbox("setValue", c), f = h.formatter.call(o, e(o).textbox("getValue")), e(o).textbox("setText", f);
  }
  e.fn.numberbox = function(o, l) {
    if (typeof o == "string") {
      var u = e.fn.numberbox.methods[o];
      return u ? u(this, l) : this.textbox(o, l);
    }
    return o = o || {}, this.each(function() {
      var h = e.data(this, "numberbox");
      h ? e.extend(h.options, o) : h = e.data(this, "numberbox", { options: e.extend({}, e.fn.numberbox.defaults, e.fn.numberbox.parseOptions(this), o) }), n(this);
    });
  }, e.fn.numberbox.methods = { options: function(o) {
    var l = o.data("textbox") ? o.textbox("options") : {};
    return e.extend(e.data(o[0], "numberbox").options, { width: l.width, originalValue: l.originalValue, disabled: l.disabled, readonly: l.readonly });
  }, fix: function(o) {
    return o.each(function() {
      var l = e(this).numberbox("options");
      l.value = null;
      var u = l.parser.call(this, e(this).numberbox("getText"));
      e(this).numberbox("setValue", u);
    });
  }, setValue: function(o, l) {
    return o.each(function() {
      r(this, l);
    });
  }, clear: function(o) {
    return o.each(function() {
      e(this).textbox("clear"), e(this).numberbox("options").value = "";
    });
  }, reset: function(o) {
    return o.each(function() {
      e(this).textbox("reset"), e(this).numberbox("setValue", e(this).numberbox("getValue"));
    });
  } }, e.fn.numberbox.parseOptions = function(o) {
    var l = e(o);
    return e.extend({}, e.fn.textbox.parseOptions(o), e.parser.parseOptions(o, ["decimalSeparator", "groupSeparator", "suffix", { min: "number", max: "number", precision: "number" }]), { prefix: l.attr("prefix") ? l.attr("prefix") : void 0 });
  }, e.fn.numberbox.defaults = e.extend({}, e.fn.textbox.defaults, { inputEvents: { keypress: function(o) {
    var l = o.data.target, u = e(l).numberbox("options");
    return u.filter.call(l, o);
  }, blur: function(o) {
    e(o.data.target).numberbox("fix");
  }, keydown: function(o) {
    o.keyCode == 13 && e(o.data.target).numberbox("fix");
  } }, min: null, max: null, precision: 0, decimalSeparator: ".", groupSeparator: "", prefix: "", suffix: "", filter: function(o) {
    var l = e(this).numberbox("options"), u = e(this).numberbox("getText");
    if (o.metaKey || o.ctrlKey || e.inArray(String(o.which), ["46", "8", "13", "0"]) >= 0)
      return !0;
    var h = e("<span></span>");
    h.html(String.fromCharCode(o.which));
    var c = h.text();
    return h.remove(), c ? c == "-" || c == l.decimalSeparator ? u.indexOf(c) == -1 : c == l.groupSeparator ? !0 : "0123456789".indexOf(c) >= 0 : !0;
  }, formatter: function(o) {
    if (!o)
      return o;
    o = o + "";
    var l = e(this).numberbox("options"), u = o, h = "", c = o.indexOf(".");
    if (c >= 0 && (u = o.substring(0, c), h = o.substring(c + 1, o.length)), l.groupSeparator)
      for (var f = /(\d+)(\d{3})/; f.test(u); )
        u = u.replace(f, "$1" + l.groupSeparator + "$2");
    return h ? l.prefix + u + l.decimalSeparator + h + l.suffix : l.prefix + u + l.suffix;
  }, parser: function(o) {
    o = o + "";
    var l = e(this).numberbox("options");
    l.prefix && (o = e.trim(o.replace(new RegExp("\\" + e.trim(l.prefix), "g"), ""))), l.suffix && (o = e.trim(o.replace(new RegExp("\\" + e.trim(l.suffix), "g"), ""))), parseFloat(o) != l.value && (l.groupSeparator && (o = e.trim(o.replace(new RegExp("\\" + l.groupSeparator, "g"), ""))), l.decimalSeparator && (o = e.trim(o.replace(new RegExp("\\" + l.decimalSeparator, "g"), "."))), o = o.replace(/\s/g, ""));
    var u = parseFloat(o).toFixed(l.precision);
    return isNaN(u) ? u = "" : typeof l.min == "number" && u < l.min ? u = l.min.toFixed(l.precision) : typeof l.max == "number" && u > l.max && (u = l.max.toFixed(l.precision)), u;
  } });
})($);
(function(e) {
  function n(c, f) {
    var v = e.data(c, "calendar").options, m = e(c);
    f && e.extend(v, { width: f.width, height: f.height }), m._size(v, m.parent()), m.find(".calendar-body")._outerHeight(m.height() - m.find(".calendar-header")._outerHeight()), m.find(".calendar-menu").is(":visible") && l(c);
  }
  function r(c) {
    e(c).addClass("calendar").html('<div class="calendar-header"><div class="calendar-nav calendar-prevmonth"></div><div class="calendar-nav calendar-nextmonth"></div><div class="calendar-nav calendar-prevyear"></div><div class="calendar-nav calendar-nextyear"></div><div class="calendar-title"><span class="calendar-text"></span></div></div><div class="calendar-body"><div class="calendar-menu"><div class="calendar-menu-year-inner"><span class="calendar-nav calendar-menu-prev"></span><span><input class="calendar-menu-year" type="text"></input></span><span class="calendar-nav calendar-menu-next"></span></div><div class="calendar-menu-month-inner"></div></div></div>'), e(c).bind("_resize", function(f, v) {
      return (e(this).hasClass("easyui-fluid") || v) && n(c), !1;
    });
  }
  function o(c) {
    var f = e.data(c, "calendar").options, v = e(c).find(".calendar-menu");
    v.find(".calendar-menu-year").unbind(".calendar").bind("keypress.calendar", function(E) {
      E.keyCode == 13 && g(!0);
    }), e(c).unbind(".calendar").bind("mouseover.calendar", function(E) {
      var x = m(E.target);
      (x.hasClass("calendar-nav") || x.hasClass("calendar-text") || x.hasClass("calendar-day") && !x.hasClass("calendar-disabled")) && x.addClass("calendar-nav-hover");
    }).bind("mouseout.calendar", function(E) {
      var x = m(E.target);
      (x.hasClass("calendar-nav") || x.hasClass("calendar-text") || x.hasClass("calendar-day") && !x.hasClass("calendar-disabled")) && x.removeClass("calendar-nav-hover");
    }).bind("click.calendar", function(E) {
      var x = m(E.target);
      if (x.hasClass("calendar-menu-next") || x.hasClass("calendar-nextyear"))
        y(1);
      else if (x.hasClass("calendar-menu-prev") || x.hasClass("calendar-prevyear"))
        y(-1);
      else if (x.hasClass("calendar-menu-month"))
        v.find(".calendar-selected").removeClass("calendar-selected"), x.addClass("calendar-selected"), g(!0);
      else if (x.hasClass("calendar-prevmonth"))
        w(-1);
      else if (x.hasClass("calendar-nextmonth"))
        w(1);
      else if (x.hasClass("calendar-text"))
        v.is(":visible") ? v.hide() : l(c);
      else if (x.hasClass("calendar-day")) {
        if (x.hasClass("calendar-disabled"))
          return;
        var D = f.current;
        x.closest("div.calendar-body").find(".calendar-selected").removeClass("calendar-selected"), x.addClass("calendar-selected");
        var F = x.attr("abbr").split(","), k = parseInt(F[0]), N = parseInt(F[1]), H = parseInt(F[2]);
        f.current = new Date(k, N - 1, H), f.onSelect.call(c, f.current), (!D || D.getTime() != f.current.getTime()) && f.onChange.call(c, f.current, D), (f.year != k || f.month != N) && (f.year = k, f.month = N, h(c));
      }
    });
    function m(E) {
      var x = e(E).closest(".calendar-day");
      return x.length ? x : e(E);
    }
    function g(E) {
      var x = e(c).find(".calendar-menu"), D = x.find(".calendar-menu-year").val(), F = x.find(".calendar-selected").attr("abbr");
      isNaN(D) || (f.year = parseInt(D), f.month = parseInt(F), h(c)), E && x.hide();
    }
    function y(E) {
      f.year += E, h(c), v.find(".calendar-menu-year").val(f.year);
    }
    function w(E) {
      f.month += E, f.month > 12 ? (f.year++, f.month = 1) : f.month < 1 && (f.year--, f.month = 12), h(c), v.find("td.calendar-selected").removeClass("calendar-selected"), v.find("td:eq(" + (f.month - 1) + ")").addClass("calendar-selected");
    }
  }
  function l(c) {
    var f = e.data(c, "calendar").options;
    if (e(c).find(".calendar-menu").show(), e(c).find(".calendar-menu-month-inner").is(":empty")) {
      e(c).find(".calendar-menu-month-inner").empty();
      for (var v = e('<table class="calendar-mtable"></table>').appendTo(e(c).find(".calendar-menu-month-inner")), m = 0, g = 0; g < 3; g++)
        for (var y = e("<tr></tr>").appendTo(v), w = 0; w < 4; w++)
          e('<td class="calendar-nav calendar-menu-month"></td>').html(f.months[m++]).attr("abbr", m).appendTo(y);
    }
    var E = e(c).find(".calendar-body"), x = e(c).find(".calendar-menu"), D = x.find(".calendar-menu-year-inner"), F = x.find(".calendar-menu-month-inner");
    D.find("input").val(f.year).focus(), F.find("td.calendar-selected").removeClass("calendar-selected"), F.find("td:eq(" + (f.month - 1) + ")").addClass("calendar-selected"), x._outerWidth(E._outerWidth()), x._outerHeight(E._outerHeight()), F._outerHeight(x.height() - D._outerHeight());
  }
  function u(c, f, v) {
    for (var m = e.data(c, "calendar").options, g = [], y = new Date(f, v, 0).getDate(), w = 1; w <= y; w++)
      g.push([f, v, w]);
    for (var E = [], x = [], D = -1; g.length > 0; ) {
      var F = g.shift();
      x.push(F);
      var k = new Date(F[0], F[1] - 1, F[2]).getDay();
      D == k ? k = 0 : k == (m.firstDay == 0 ? 7 : m.firstDay) - 1 && (E.push(x), x = []), D = k;
    }
    x.length && E.push(x);
    var N = E[0];
    if (N.length < 7)
      for (; N.length < 7; ) {
        var H = N[0], F = new Date(H[0], H[1] - 1, H[2] - 1);
        N.unshift([F.getFullYear(), F.getMonth() + 1, F.getDate()]);
      }
    else {
      for (var H = N[0], x = [], w = 1; w <= 7; w++) {
        var F = new Date(H[0], H[1] - 1, H[2] - w);
        x.unshift([F.getFullYear(), F.getMonth() + 1, F.getDate()]);
      }
      E.unshift(x);
    }
    for (var R = E[E.length - 1]; R.length < 7; ) {
      var j = R[R.length - 1], F = new Date(j[0], j[1] - 1, j[2] + 1);
      R.push([F.getFullYear(), F.getMonth() + 1, F.getDate()]);
    }
    if (E.length < 6) {
      for (var j = R[R.length - 1], x = [], w = 1; w <= 7; w++) {
        var F = new Date(j[0], j[1] - 1, j[2] + w);
        x.push([F.getFullYear(), F.getMonth() + 1, F.getDate()]);
      }
      E.push(x);
    }
    return E;
  }
  function h(c) {
    var f = e.data(c, "calendar").options;
    f.current && !f.validator.call(c, f.current) && (f.current = null);
    var v = /* @__PURE__ */ new Date(), m = v.getFullYear() + "," + (v.getMonth() + 1) + "," + v.getDate(), g = f.current ? f.current.getFullYear() + "," + (f.current.getMonth() + 1) + "," + f.current.getDate() : "", y = 6 - f.firstDay, w = y + 1;
    y >= 7 && (y -= 7), w >= 7 && (w -= 7), e(c).find(".calendar-title span").html(f.months[f.month - 1] + " " + f.year);
    var E = e(c).find("div.calendar-body");
    E.children("table").remove();
    var x = ['<table class="calendar-dtable" cellspacing="0" cellpadding="0" border="0">'];
    x.push("<thead><tr>"), f.showWeek && x.push('<th class="calendar-week">' + f.weekNumberHeader + "</th>");
    for (var D = f.firstDay; D < f.weeks.length; D++)
      x.push("<th>" + f.weeks[D] + "</th>");
    for (var D = 0; D < f.firstDay; D++)
      x.push("<th>" + f.weeks[D] + "</th>");
    x.push("</tr></thead>"), x.push("<tbody>");
    for (var F = u(c, f.year, f.month), D = 0; D < F.length; D++) {
      var k = F[D], N = "";
      if (D == 0 ? N = "calendar-first" : D == F.length - 1 && (N = "calendar-last"), x.push('<tr class="' + N + '">'), f.showWeek) {
        var H = f.getWeekNumber(new Date(k[0][0], parseInt(k[0][1]) - 1, k[0][2]));
        x.push('<td class="calendar-week">' + H + "</td>");
      }
      for (var R = 0; R < k.length; R++) {
        var j = k[R], S = j[0] + "," + j[1] + "," + j[2], tt = new Date(j[0], parseInt(j[1]) - 1, j[2]), nt = f.formatter.call(c, tt), ft = f.styler.call(c, tt), pt = "", ct = "";
        typeof ft == "string" ? ct = ft : ft && (pt = ft.class || "", ct = ft.style || "");
        var N = "calendar-day";
        f.year == j[0] && f.month == j[1] || (N += " calendar-other-month"), S == m && (N += " calendar-today"), S == g && (N += " calendar-selected"), R == y ? N += " calendar-saturday" : R == w && (N += " calendar-sunday"), R == 0 ? N += " calendar-first" : R == k.length - 1 && (N += " calendar-last"), N += " " + pt, f.validator.call(c, tt) || (N += " calendar-disabled"), x.push('<td class="' + N + '" abbr="' + S + '" style="' + ct + '">' + nt + "</td>");
      }
      x.push("</tr>");
    }
    x.push("</tbody>"), x.push("</table>"), E.append(x.join("")), E.children("table.calendar-dtable").prependTo(E), f.onNavigate.call(c, f.year, f.month);
  }
  e.fn.calendar = function(c, f) {
    return typeof c == "string" ? e.fn.calendar.methods[c](this, f) : (c = c || {}, this.each(function() {
      var v = e.data(this, "calendar");
      v ? e.extend(v.options, c) : (v = e.data(this, "calendar", { options: e.extend({}, e.fn.calendar.defaults, e.fn.calendar.parseOptions(this), c) }), r(this)), v.options.border == !1 && e(this).addClass("calendar-noborder"), n(this), o(this), h(this), e(this).find("div.calendar-menu").hide();
    }));
  }, e.fn.calendar.methods = { options: function(c) {
    return e.data(c[0], "calendar").options;
  }, resize: function(c, f) {
    return c.each(function() {
      n(this, f);
    });
  }, moveTo: function(c, f) {
    return c.each(function() {
      if (!f) {
        var v = /* @__PURE__ */ new Date();
        e(this).calendar({ year: v.getFullYear(), month: v.getMonth() + 1, current: f });
        return;
      }
      var m = e(this).calendar("options");
      if (m.validator.call(this, f)) {
        var g = m.current;
        e(this).calendar({ year: f.getFullYear(), month: f.getMonth() + 1, current: f }), (!g || g.getTime() != f.getTime()) && m.onChange.call(this, m.current, g);
      }
    });
  } }, e.fn.calendar.parseOptions = function(c) {
    return e(c), e.extend({}, e.parser.parseOptions(c, ["weekNumberHeader", { firstDay: "number", fit: "boolean", border: "boolean", showWeek: "boolean" }]));
  }, e.fn.calendar.defaults = { width: 180, height: 180, fit: !1, border: !0, showWeek: !1, firstDay: 0, weeks: ["S", "M", "T", "W", "T", "F", "S"], months: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], year: (/* @__PURE__ */ new Date()).getFullYear(), month: (/* @__PURE__ */ new Date()).getMonth() + 1, current: function() {
    var c = /* @__PURE__ */ new Date();
    return new Date(c.getFullYear(), c.getMonth(), c.getDate());
  }(), weekNumberHeader: "", getWeekNumber: function(c) {
    var f = new Date(c.getTime());
    f.setDate(f.getDate() + 4 - (f.getDay() || 7));
    var v = f.getTime();
    return f.setMonth(0), f.setDate(1), Math.floor(Math.round((v - f) / 864e5) / 7) + 1;
  }, formatter: function(c) {
    return c.getDate();
  }, styler: function(c) {
    return "";
  }, validator: function(c) {
    return !0;
  }, onSelect: function(c) {
  }, onChange: function(c, f) {
  }, onNavigate: function(c, f) {
  } };
})($);
(function(e) {
  function n(o) {
    var l = e.data(o, "spinner"), u = l.options, h = e.extend(!0, [], u.icons);
    if (u.spinAlign == "left" || u.spinAlign == "right") {
      u.spinArrow = !0, u.iconAlign = u.spinAlign;
      var c = { iconCls: "spinner-arrow", handler: function(g) {
        var y = e(g.target).closest(".spinner-arrow-up,.spinner-arrow-down");
        r(g.data.target, y.hasClass("spinner-arrow-down"));
      } };
      u.spinAlign == "left" ? h.unshift(c) : h.push(c);
    } else
      u.spinArrow = !1, u.spinAlign == "vertical" ? (u.buttonAlign != "top" && (u.buttonAlign = "bottom"), u.clsLeft = "textbox-button-bottom", u.clsRight = "textbox-button-top") : (u.clsLeft = "textbox-button-left", u.clsRight = "textbox-button-right");
    if (e(o).addClass("spinner-f").textbox(e.extend({}, u, { icons: h, doSize: !1, onResize: function(g, y) {
      if (!u.spinArrow) {
        var w = e(this).next(), E = w.find(".textbox-button:not(.spinner-button)");
        if (E.length) {
          var x = E.outerWidth(), D = E.outerHeight(), F = w.find(".spinner-button." + u.clsLeft), k = w.find(".spinner-button." + u.clsRight);
          u.buttonAlign == "right" ? k.css("marginRight", x + "px") : u.buttonAlign == "left" ? F.css("marginLeft", x + "px") : u.buttonAlign == "top" ? k.css("marginTop", D + "px") : F.css("marginBottom", D + "px");
        }
      }
      u.onResize.call(this, g, y);
    } })), e(o).attr("spinnerName", e(o).attr("textboxName")), l.spinner = e(o).next(), l.spinner.addClass("spinner"), u.spinArrow) {
      var f = l.spinner.find(".spinner-arrow");
      f.append('<a href="javascript:;" class="spinner-arrow-up" tabindex="-1"></a>'), f.append('<a href="javascript:;" class="spinner-arrow-down" tabindex="-1"></a>');
    } else {
      var v = e('<a href="javascript:;" class="textbox-button spinner-button"></a>').addClass(u.clsLeft).appendTo(l.spinner), m = e('<a href="javascript:;" class="textbox-button spinner-button"></a>').addClass(u.clsRight).appendTo(l.spinner);
      v.linkbutton({ iconCls: u.reversed ? "spinner-button-up" : "spinner-button-down", onClick: function() {
        r(o, !u.reversed);
      } }), m.linkbutton({ iconCls: u.reversed ? "spinner-button-down" : "spinner-button-up", onClick: function() {
        r(o, u.reversed);
      } }), u.disabled && e(o).spinner("disable"), u.readonly && e(o).spinner("readonly");
    }
    e(o).spinner("resize");
  }
  function r(o, l) {
    var u = e(o).spinner("options");
    u.spin.call(o, l), u[l ? "onSpinDown" : "onSpinUp"].call(o), e(o).spinner("validate");
  }
  e.fn.spinner = function(o, l) {
    if (typeof o == "string") {
      var u = e.fn.spinner.methods[o];
      return u ? u(this, l) : this.textbox(o, l);
    }
    return o = o || {}, this.each(function() {
      var h = e.data(this, "spinner");
      h ? e.extend(h.options, o) : h = e.data(this, "spinner", { options: e.extend({}, e.fn.spinner.defaults, e.fn.spinner.parseOptions(this), o) }), n(this);
    });
  }, e.fn.spinner.methods = { options: function(o) {
    var l = o.textbox("options");
    return e.extend(e.data(o[0], "spinner").options, { width: l.width, value: l.value, originalValue: l.originalValue, disabled: l.disabled, readonly: l.readonly });
  } }, e.fn.spinner.parseOptions = function(o) {
    return e.extend({}, e.fn.textbox.parseOptions(o), e.parser.parseOptions(o, ["min", "max", "spinAlign", { increment: "number", reversed: "boolean" }]));
  }, e.fn.spinner.defaults = e.extend({}, e.fn.textbox.defaults, { min: null, max: null, increment: 1, spinAlign: "right", reversed: !1, spin: function(o) {
  }, onSpinUp: function() {
  }, onSpinDown: function() {
  } });
})($);
(function(e) {
  function n(o) {
    e(o).addClass("numberspinner-f");
    var l = e.data(o, "numberspinner").options;
    e(o).numberbox(e.extend({}, l, { doSize: !1 })).spinner(l), e(o).numberbox("setValue", l.value);
  }
  function r(o, l) {
    var u = e.data(o, "numberspinner").options, h = parseFloat(e(o).numberbox("getValue") || u.value) || 0;
    l ? h -= u.increment : h += u.increment, e(o).numberbox("setValue", h);
  }
  e.fn.numberspinner = function(o, l) {
    if (typeof o == "string") {
      var u = e.fn.numberspinner.methods[o];
      return u ? u(this, l) : this.numberbox(o, l);
    }
    return o = o || {}, this.each(function() {
      var h = e.data(this, "numberspinner");
      h ? e.extend(h.options, o) : e.data(this, "numberspinner", { options: e.extend({}, e.fn.numberspinner.defaults, e.fn.numberspinner.parseOptions(this), o) }), n(this);
    });
  }, e.fn.numberspinner.methods = { options: function(o) {
    var l = o.numberbox("options");
    return e.extend(e.data(o[0], "numberspinner").options, { width: l.width, value: l.value, originalValue: l.originalValue, disabled: l.disabled, readonly: l.readonly });
  } }, e.fn.numberspinner.parseOptions = function(o) {
    return e.extend({}, e.fn.spinner.parseOptions(o), e.fn.numberbox.parseOptions(o), {});
  }, e.fn.numberspinner.defaults = e.extend({}, e.fn.spinner.defaults, e.fn.numberbox.defaults, { spin: function(o) {
    r(this, o);
  } });
})($);
(function(e) {
  function n(h) {
    var c = e.data(h, "timespinner").options;
    e(h).addClass("timespinner-f").spinner(c);
    var f = c.formatter.call(h, c.parser.call(h, c.value));
    e(h).timespinner("initValue", f);
  }
  function r(h) {
    for (var c = h.data.target, f = e.data(c, "timespinner").options, v = e(c).timespinner("getSelectionStart"), m = 0; m < f.selections.length; m++) {
      var g = f.selections[m];
      if (v >= g[0] && v <= g[1]) {
        o(c, m);
        return;
      }
    }
  }
  function o(h, c) {
    var f = e.data(h, "timespinner").options;
    c != null && (f.highlight = c);
    var v = f.selections[f.highlight];
    if (v) {
      var m = e(h).timespinner("textbox");
      e(h).timespinner("setSelectionRange", { start: v[0], end: v[1] }), m.focus();
    }
  }
  function l(h, v) {
    var f = e.data(h, "timespinner").options, v = f.parser.call(h, v), m = f.formatter.call(h, v);
    e(h).spinner("setValue", m);
  }
  function u(h, c) {
    var f = e.data(h, "timespinner").options, v = e(h).timespinner("getValue"), m = f.selections[f.highlight], g = v.substring(0, m[0]), y = v.substring(m[0], m[1]), w = v.substring(m[1]), E = g + ((parseInt(y, 10) || 0) + f.increment * (c ? -1 : 1)) + w;
    e(h).timespinner("setValue", E), o(h);
  }
  e.fn.timespinner = function(h, c) {
    if (typeof h == "string") {
      var f = e.fn.timespinner.methods[h];
      return f ? f(this, c) : this.spinner(h, c);
    }
    return h = h || {}, this.each(function() {
      var v = e.data(this, "timespinner");
      v ? e.extend(v.options, h) : e.data(this, "timespinner", { options: e.extend({}, e.fn.timespinner.defaults, e.fn.timespinner.parseOptions(this), h) }), n(this);
    });
  }, e.fn.timespinner.methods = { options: function(h) {
    var c = h.data("spinner") ? h.spinner("options") : {};
    return e.extend(e.data(h[0], "timespinner").options, { width: c.width, value: c.value, originalValue: c.originalValue, disabled: c.disabled, readonly: c.readonly });
  }, setValue: function(h, c) {
    return h.each(function() {
      l(this, c);
    });
  }, getHours: function(h) {
    var c = e.data(h[0], "timespinner").options, f = h.timespinner("getValue").split(c.separator);
    return parseInt(f[0], 10);
  }, getMinutes: function(h) {
    var c = e.data(h[0], "timespinner").options, f = h.timespinner("getValue").split(c.separator);
    return parseInt(f[1], 10);
  }, getSeconds: function(h) {
    var c = e.data(h[0], "timespinner").options, f = h.timespinner("getValue").split(c.separator);
    return parseInt(f[2], 10) || 0;
  } }, e.fn.timespinner.parseOptions = function(h) {
    return e.extend({}, e.fn.spinner.parseOptions(h), e.parser.parseOptions(h, ["separator", { showSeconds: "boolean", highlight: "number" }]));
  }, e.fn.timespinner.defaults = e.extend({}, e.fn.spinner.defaults, { inputEvents: e.extend({}, e.fn.spinner.defaults.inputEvents, { click: function(h) {
    r.call(this, h);
  }, blur: function(h) {
    var c = e(h.data.target);
    c.timespinner("setValue", c.timespinner("getText"));
  }, keydown: function(h) {
    if (h.keyCode == 13) {
      var c = e(h.data.target);
      c.timespinner("setValue", c.timespinner("getText"));
    }
  } }), formatter: function(h) {
    if (!h)
      return "";
    var c = e(this).timespinner("options"), f = [v(h.getHours()), v(h.getMinutes())];
    return c.showSeconds && f.push(v(h.getSeconds())), f.join(c.separator);
    function v(m) {
      return (m < 10 ? "0" : "") + m;
    }
  }, parser: function(h) {
    var c = e(this).timespinner("options"), f = g(h);
    if (f) {
      var v = g(c.min), m = g(c.max);
      v && v > f && (f = v), m && m < f && (f = m);
    }
    return f;
    function g(y) {
      if (!y)
        return null;
      var w = y.split(c.separator);
      return new Date(1900, 0, 0, parseInt(w[0], 10) || 0, parseInt(w[1], 10) || 0, parseInt(w[2], 10) || 0);
    }
  }, selections: [[0, 2], [3, 5], [6, 8]], separator: ":", showSeconds: !1, highlight: 0, spin: function(h) {
    u(this, h);
  } });
})($);
(function(e) {
  function n(r) {
    var o = e.data(r, "datetimespinner").options;
    e(r).addClass("datetimespinner-f").timespinner(o);
  }
  e.fn.datetimespinner = function(r, o) {
    if (typeof r == "string") {
      var l = e.fn.datetimespinner.methods[r];
      return l ? l(this, o) : this.timespinner(r, o);
    }
    return r = r || {}, this.each(function() {
      var u = e.data(this, "datetimespinner");
      u ? e.extend(u.options, r) : e.data(this, "datetimespinner", { options: e.extend({}, e.fn.datetimespinner.defaults, e.fn.datetimespinner.parseOptions(this), r) }), n(this);
    });
  }, e.fn.datetimespinner.methods = { options: function(r) {
    var o = r.timespinner("options");
    return e.extend(e.data(r[0], "datetimespinner").options, { width: o.width, value: o.value, originalValue: o.originalValue, disabled: o.disabled, readonly: o.readonly });
  } }, e.fn.datetimespinner.parseOptions = function(r) {
    return e.extend({}, e.fn.timespinner.parseOptions(r), e.parser.parseOptions(r, []));
  }, e.fn.datetimespinner.defaults = e.extend({}, e.fn.timespinner.defaults, { formatter: function(r) {
    return r ? e.fn.datebox.defaults.formatter.call(this, r) + " " + e.fn.timespinner.defaults.formatter.call(this, r) : "";
  }, parser: function(r) {
    if (r = e.trim(r), !r)
      return null;
    var o = r.split(" "), l = e.fn.datebox.defaults.parser.call(this, o[0]);
    if (o.length < 2)
      return l;
    var u = e.fn.timespinner.defaults.parser.call(this, o[1]);
    return new Date(l.getFullYear(), l.getMonth(), l.getDate(), u.getHours(), u.getMinutes(), u.getSeconds());
  }, selections: [[0, 2], [3, 5], [6, 10], [11, 13], [14, 16], [17, 19]] });
})($);
(function($) {
  var _645 = 0;
  function _646(e, n) {
    return $.easyui.indexOfArray(e, n);
  }
  function _647(e, n, r) {
    $.easyui.removeArrayItem(e, n, r);
  }
  function _648(e, n, r) {
    $.easyui.addArrayItem(e, n, r);
  }
  function _649(e, n) {
    return $.data(e, "treegrid") ? n.slice(1) : n;
  }
  function _64b(e) {
    var n = $.data(e, "datagrid"), r = n.options, o = n.panel, l = n.dc, u = null;
    r.sharedStyleSheet ? u = typeof r.sharedStyleSheet == "boolean" ? "head" : r.sharedStyleSheet : (u = o.closest("div.datagrid-view"), u.length || (u = l.view));
    var h = $(u), c = $.data(h[0], "ss");
    return c || (c = $.data(h[0], "ss", { cache: {}, dirty: [] })), { add: function(f) {
      for (var v = ['<style type="text/css" easyui="true">'], m = 0; m < f.length; m++)
        c.cache[f[m][0]] = { width: f[m][1] };
      var g = 0;
      for (var y in c.cache) {
        var w = c.cache[y];
        w.index = g++, v.push(y + "{width:" + w.width + "}");
      }
      v.push("</style>"), $(v.join(`
`)).appendTo(h), h.children("style[easyui]:not(:last)").remove();
    }, getRule: function(f) {
      var v = h.children("style[easyui]:last")[0], m = v.styleSheet ? v.styleSheet : v.sheet || document.styleSheets[document.styleSheets.length - 1], g = m.cssRules || m.rules;
      return g[f];
    }, set: function(f, v) {
      var m = c.cache[f];
      if (m) {
        m.width = v;
        var g = this.getRule(m.index);
        g && (g.style.width = v);
      }
    }, remove: function(f) {
      var v = [];
      for (var m in c.cache)
        m.indexOf(f) == -1 && v.push([m, c.cache[m].width]);
      c.cache = {}, this.add(v);
    }, dirty: function(f) {
      f && c.dirty.push(f);
    }, clean: function() {
      for (var f = 0; f < c.dirty.length; f++)
        this.remove(c.dirty[f]);
      c.dirty = [];
    } };
  }
  function _65a(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = r.panel;
    if (n && $.extend(o, n), o.fit == !0) {
      var u = l.panel("panel").parent();
      o.width = u.width(), o.height = u.height();
    }
    l.panel("resize", o);
  }
  function _65f(e) {
    var n = $.data(e, "datagrid"), r = n.options, o = n.dc, l = n.panel, u = l.width(), h = l.height(), c = o.view, f = o.view1, v = o.view2, m = f.children("div.datagrid-header"), g = v.children("div.datagrid-header"), y = m.find("table"), w = g.find("table");
    c.width(u);
    var E = m.children("div.datagrid-header-inner").show();
    f.width(E.find("table").width()), r.showHeader || E.hide(), v.width(u - f._outerWidth()), f.children()._outerWidth(f.width()), v.children()._outerWidth(v.width());
    var x = m.add(g).add(y).add(w);
    x.css("height", "");
    var D = Math.max(y.height(), w.height());
    x._outerHeight(D), c.children(".datagrid-empty").css("top", D + "px"), o.body1.add(o.body2).children("table.datagrid-btable-frozen").css({ position: "absolute", top: o.header2._outerHeight() });
    var F = o.body2.children("table.datagrid-btable-frozen")._outerHeight(), k = F + g._outerHeight() + v.children(".datagrid-footer")._outerHeight();
    l.children(":not(.datagrid-view,.datagrid-mask,.datagrid-mask-msg)").each(function() {
      k += $(this)._outerHeight();
    });
    var N = l.outerHeight() - l.height(), H = l._size("minHeight") || "", R = l._size("maxHeight") || "";
    f.add(v).children("div.datagrid-body").css({ marginTop: F, height: isNaN(parseInt(r.height)) ? "" : h - k, minHeight: H ? H - N - k : "", maxHeight: R ? R - N - k : "" }), c.height(v.height());
  }
  function _670(e, n, r) {
    $.data(e, "datagrid").data.rows;
    var o = $.data(e, "datagrid").options, l = $.data(e, "datagrid").dc;
    if (!l.body1.is(":empty") && (!o.nowrap || o.autoRowHeight || r))
      if (n != null) {
        var u = o.finder.getTr(e, n, "body", 1), h = o.finder.getTr(e, n, "body", 2);
        g(u, h);
      } else {
        var u = o.finder.getTr(e, 0, "allbody", 1), h = o.finder.getTr(e, 0, "allbody", 2);
        if (g(u, h), o.showFooter) {
          var u = o.finder.getTr(e, 0, "allfooter", 1), h = o.finder.getTr(e, 0, "allfooter", 2);
          g(u, h);
        }
      }
    if (_65f(e), o.height == "auto") {
      var c = l.body1.parent(), f = l.body2, v = y(f), m = v.height;
      v.width > f.width() && (m += 18), m -= parseInt(f.css("marginTop")) || 0, c.height(m), f.height(m), l.view.height(l.view2.height());
    }
    l.body2.triggerHandler("scroll");
    function g(w, E) {
      for (var x = 0; x < E.length; x++) {
        var D = $(w[x]), F = $(E[x]);
        D.css("height", ""), F.css("height", "");
        var k = Math.max(D.height(), F.height());
        D.css("height", k), F.css("height", k);
      }
    }
    function y(w) {
      var E = 0, x = 0;
      return $(w).children().each(function() {
        var D = $(this);
        D.is(":visible") && (x += D._outerHeight(), E < D._outerWidth() && (E = D._outerWidth()));
      }), { width: E, height: x };
    }
  }
  function _67d(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = r.dc;
    l.body2.children("table.datagrid-btable-frozen").length || l.body1.add(l.body2).prepend('<table class="datagrid-btable datagrid-btable-frozen" cellspacing="0" cellpadding="0"></table>'), u(!0), u(!1), _65f(e);
    function u(h) {
      var c = h ? 1 : 2, f = o.finder.getTr(e, n, "body", c);
      (h ? l.body1 : l.body2).children("table.datagrid-btable-frozen").append(f);
    }
  }
  function _684(_685, _686) {
    function _687() {
      var _688 = [], _689 = [];
      return $(_685).children("thead").each(function() {
        var opt = $.parser.parseOptions(this, [{ frozen: "boolean" }]);
        $(this).find("tr").each(function() {
          var cols = [];
          $(this).find("th").each(function() {
            var th = $(this), col = $.extend({}, $.parser.parseOptions(this, ["id", "field", "align", "halign", "order", "width", { sortable: "boolean", checkbox: "boolean", resizable: "boolean", fixed: "boolean" }, { rowspan: "number", colspan: "number" }]), { title: th.html() || void 0, hidden: th.attr("hidden") ? !0 : void 0, formatter: th.attr("formatter") ? eval(th.attr("formatter")) : void 0, styler: th.attr("styler") ? eval(th.attr("styler")) : void 0, sorter: th.attr("sorter") ? eval(th.attr("sorter")) : void 0 });
            if (col.width && String(col.width).indexOf("%") == -1 && (col.width = parseInt(col.width)), th.attr("editor")) {
              var s = $.trim(th.attr("editor"));
              s.substr(0, 1) == "{" ? col.editor = eval("(" + s + ")") : col.editor = s;
            }
            cols.push(col);
          }), opt.frozen ? _688.push(cols) : _689.push(cols);
        });
      }), [_688, _689];
    }
    var _68a = $('<div class="datagrid-wrap"><div class="datagrid-view"><div class="datagrid-view1"><div class="datagrid-header"><div class="datagrid-header-inner"></div></div><div class="datagrid-body"><div class="datagrid-body-inner"></div></div><div class="datagrid-footer"><div class="datagrid-footer-inner"></div></div></div><div class="datagrid-view2"><div class="datagrid-header"><div class="datagrid-header-inner"></div></div><div class="datagrid-body"></div><div class="datagrid-footer"><div class="datagrid-footer-inner"></div></div></div></div></div>').insertAfter(_685);
    _68a.panel({ doSize: !1, cls: "datagrid" }), $(_685).addClass("datagrid-f").hide().appendTo(_68a.children("div.datagrid-view"));
    var cc = _687(), view = _68a.children("div.datagrid-view"), _68b = view.children("div.datagrid-view1"), _68c = view.children("div.datagrid-view2");
    return { panel: _68a, frozenColumns: cc[0], columns: cc[1], dc: { view, view1: _68b, view2: _68c, header1: _68b.children("div.datagrid-header").children("div.datagrid-header-inner"), header2: _68c.children("div.datagrid-header").children("div.datagrid-header-inner"), body1: _68b.children("div.datagrid-body").children("div.datagrid-body-inner"), body2: _68c.children("div.datagrid-body"), footer1: _68b.children("div.datagrid-footer").children("div.datagrid-footer-inner"), footer2: _68c.children("div.datagrid-footer").children("div.datagrid-footer-inner") } };
  }
  function _68d(_68e) {
    var _68f = $.data(_68e, "datagrid"), opts = _68f.options, dc = _68f.dc, _690 = _68f.panel;
    if (_68f.ss = $(_68e).datagrid("createStyleSheet"), _690.panel($.extend({}, opts, { id: null, doSize: !1, onResize: function(e, n) {
      $.data(_68e, "datagrid") && (_65f(_68e), $(_68e).datagrid("fitColumns"), opts.onResize.call(_690, e, n));
    }, onExpand: function() {
      $.data(_68e, "datagrid") && ($(_68e).datagrid("fixRowHeight").datagrid("fitColumns"), opts.onExpand.call(_690));
    } })), _68f.rowIdPrefix = "datagrid-row-r" + ++_645, _68f.cellClassPrefix = "datagrid-cell-c" + _645, _693(dc.header1, opts.frozenColumns, !0), _693(dc.header2, opts.columns, !1), _694(), dc.header1.add(dc.header2).css("display", opts.showHeader ? "block" : "none"), dc.footer1.add(dc.footer2).css("display", opts.showFooter ? "block" : "none"), opts.toolbar)
      if ($.isArray(opts.toolbar)) {
        $("div.datagrid-toolbar", _690).remove();
        for (var tb = $('<div class="datagrid-toolbar"><table cellspacing="0" cellpadding="0"><tr></tr></table></div>').prependTo(_690), tr = tb.find("tr"), i = 0; i < opts.toolbar.length; i++) {
          var btn = opts.toolbar[i];
          if (btn == "-")
            $('<td><div class="datagrid-btn-separator"></div></td>').appendTo(tr);
          else {
            var td = $("<td></td>").appendTo(tr), tool = $('<a href="javascript:;"></a>').appendTo(td);
            tool[0].onclick = eval(btn.handler || function() {
            }), tool.linkbutton($.extend({}, btn, { plain: !0 }));
          }
        }
      } else
        $(opts.toolbar).addClass("datagrid-toolbar").prependTo(_690), $(opts.toolbar).show();
    else
      $("div.datagrid-toolbar", _690).remove();
    if ($("div.datagrid-pager", _690).remove(), opts.pagination) {
      var _695 = $('<div class="datagrid-pager"></div>');
      if (opts.pagePosition == "bottom")
        _695.appendTo(_690);
      else if (opts.pagePosition == "top")
        _695.addClass("datagrid-pager-top").prependTo(_690);
      else {
        var ptop = $('<div class="datagrid-pager datagrid-pager-top"></div>').prependTo(_690);
        _695.appendTo(_690), _695 = _695.add(ptop);
      }
      _695.pagination({ total: 0, pageNumber: opts.pageNumber, pageSize: opts.pageSize, pageList: opts.pageList, onSelectPage: function(e, n) {
        opts.pageNumber = e || 1, opts.pageSize = n, _695.pagination("refresh", { pageNumber: e, pageSize: n }), _6df(_68e);
      } }), opts.pageSize = _695.pagination("options").pageSize;
    }
    function _693(e, n, r) {
      if (n) {
        $(e).show(), $(e).empty();
        var o = $('<div class="datagrid-cell" style="position:absolute;left:-99999px"></div>').appendTo("body");
        o._outerWidth(99);
        var l = 100 - parseInt(o[0].style.width);
        o.remove();
        var u = [], h = [], c = [];
        opts.sortName && (u = opts.sortName.split(","), h = opts.sortOrder.split(","));
        for (var f = $('<table class="datagrid-htable" border="0" cellspacing="0" cellpadding="0"><tbody></tbody></table>').appendTo(e), v = 0; v < n.length; v++)
          for (var m = $('<tr class="datagrid-header-row"></tr>').appendTo($("tbody", f)), g = n[v], y = 0; y < g.length; y++) {
            var w = g[y], E = "";
            w.rowspan && (E += 'rowspan="' + w.rowspan + '" '), w.colspan && (E += 'colspan="' + w.colspan + '" ', w.id || (w.id = ["datagrid-td-group" + _645, v, y].join("-"))), w.id && (E += 'id="' + w.id + '"');
            var x = $("<td " + E + "></td>").appendTo(m);
            if (w.checkbox)
              x.attr("field", w.field), $('<div class="datagrid-header-check"></div>').html('<input type="checkbox"/>').appendTo(x);
            else if (w.field) {
              x.attr("field", w.field), x.append('<div class="datagrid-cell"><span></span><span class="datagrid-sort-icon"></span></div>'), x.find("span:first").html(w.title);
              var D = x.find("div.datagrid-cell"), F = _646(u, w.field);
              if (F >= 0 && D.addClass("datagrid-sort-" + h[F]), w.sortable && D.addClass("datagrid-sort"), w.resizable == !1 && D.attr("resizable", "false"), w.width) {
                var k = $.parser.parseValue("width", w.width, dc.view, opts.scrollbarSize + (opts.rownumbers ? opts.rownumberWidth : 0));
                w.deltaWidth = l, w.boxWidth = k - l;
              } else
                w.auto = !0;
              D.css("text-align", w.halign || w.align || ""), w.cellClass = _68f.cellClassPrefix + "-" + w.field.replace(/[\.|\s]/g, "-"), D.addClass(w.cellClass);
            } else
              $('<div class="datagrid-cell-group"></div>').html(w.title).appendTo(x);
            w.hidden && (x.hide(), c.push(w.field));
          }
        if (r && opts.rownumbers) {
          var x = $('<td rowspan="' + opts.frozenColumns.length + '"><div class="datagrid-header-rownumber"></div></td>');
          $("tr", f).length == 0 ? x.wrap('<tr class="datagrid-header-row"></tr>').parent().appendTo($("tbody", f)) : x.prependTo($("tr:first", f));
        }
        for (var v = 0; v < c.length; v++)
          _6e1(_68e, c[v], -1);
      }
    }
    function _694() {
      for (var e = [[".datagrid-header-rownumber", opts.rownumberWidth - 1 + "px"], [".datagrid-cell-rownumber", opts.rownumberWidth - 1 + "px"]], n = _6a2(_68e, !0).concat(_6a2(_68e)), r = 0; r < n.length; r++) {
        var o = _6a3(_68e, n[r]);
        o && !o.checkbox && e.push(["." + o.cellClass, o.boxWidth ? o.boxWidth + "px" : "auto"]);
      }
      _68f.ss.add(e), _68f.ss.dirty(_68f.cellSelectorPrefix), _68f.cellSelectorPrefix = "." + _68f.cellClassPrefix;
    }
  }
  function _6a4(e) {
    var n = $.data(e, "datagrid"), r = n.panel, o = n.options, l = n.dc, u = l.header1.add(l.header2);
    u.unbind(".datagrid");
    for (var h in o.headerEvents)
      u.bind(h + ".datagrid", o.headerEvents[h]);
    var c = u.find("div.datagrid-cell"), f = o.resizeHandle == "right" ? "e" : o.resizeHandle == "left" ? "w" : "e,w";
    c.each(function() {
      $(this).resizable({ handles: f, disabled: $(this).attr("resizable") ? $(this).attr("resizable") == "false" : !1, minWidth: 25, onStartResize: function(m) {
        n.resizing = !0, u.css("cursor", $("body").css("cursor")), n.proxy || (n.proxy = $('<div class="datagrid-resize-proxy"></div>').appendTo(l.view)), n.proxy.css({ left: m.pageX - $(r).offset().left - 1, display: "none" }), setTimeout(function() {
          n.proxy && n.proxy.show();
        }, 500);
      }, onResize: function(m) {
        return n.proxy.css({ left: m.pageX - $(r).offset().left - 1, display: "block" }), !1;
      }, onStopResize: function(m) {
        u.css("cursor", ""), $(this).css("height", "");
        var g = $(this).parent().attr("field"), y = _6a3(e, g);
        y.width = $(this)._outerWidth(), y.boxWidth = y.width - y.deltaWidth, y.auto = void 0, $(this).css("width", ""), $(e).datagrid("fixColumnSize", g), n.proxy.remove(), n.proxy = null, $(this).parents("div:first.datagrid-header").parent().hasClass("datagrid-view1") && _65f(e), $(e).datagrid("fitColumns"), o.onResizeColumn.call(e, g, y.width), setTimeout(function() {
          n.resizing = !1;
        }, 0);
      } });
    });
    var v = l.body1.add(l.body2);
    v.unbind();
    for (var h in o.rowEvents)
      v.bind(h, o.rowEvents[h]);
    l.body1.bind("mousewheel DOMMouseScroll", function(m) {
      m.preventDefault();
      var g = m.originalEvent || window.event, y = g.wheelDelta || g.detail * -1;
      "deltaY" in g && (y = g.deltaY * -1);
      var w = $(m.target).closest("div.datagrid-view").children(".datagrid-f"), E = w.data("datagrid").dc;
      E.body2.scrollTop(E.body2.scrollTop() - y);
    }), l.body2.bind("scroll", function() {
      var m = l.view1.children("div.datagrid-body");
      m.scrollTop($(this).scrollTop());
      var g = l.body1.children(":first"), y = l.body2.children(":first");
      if (g.length && y.length) {
        var w = g.offset().top, E = y.offset().top;
        w != E && m.scrollTop(m.scrollTop() + w - E);
      }
      l.view2.children("div.datagrid-header,div.datagrid-footer")._scrollLeft($(this)._scrollLeft()), l.body2.children("table.datagrid-btable-frozen").css("left", -$(this)._scrollLeft());
    });
  }
  function _6ae(e) {
    return function(n) {
      var r = $(n.target).closest("td[field]");
      if (r.length) {
        var o = _6b1(r);
        !$(o).data("datagrid").resizing && e ? r.addClass("datagrid-header-over") : r.removeClass("datagrid-header-over");
      }
    };
  }
  function _6b2(e) {
    var n = _6b1(e.target), r = $(n).datagrid("options"), o = $(e.target).closest("input[type=checkbox]");
    if (o.length) {
      if (r.singleSelect && r.selectOnCheck)
        return !1;
      o.is(":checked") ? _6b4(n) : _6b5(n), e.stopPropagation();
    } else {
      var l = $(e.target).closest(".datagrid-cell");
      if (l.length) {
        var u = l.offset().left + 5, h = l.offset().left + l._outerWidth() - 5;
        e.pageX < h && e.pageX > u && _6b6(n, l.parent().attr("field"));
      }
    }
  }
  function _6b7(e) {
    var n = _6b1(e.target), r = $(n).datagrid("options"), o = $(e.target).closest(".datagrid-cell");
    if (o.length) {
      var l = o.offset().left + 5, u = o.offset().left + o._outerWidth() - 5, h = r.resizeHandle == "right" ? e.pageX > u : r.resizeHandle == "left" ? e.pageX < l : e.pageX < l || e.pageX > u;
      if (h) {
        var c = o.parent().attr("field"), f = _6a3(n, c);
        if (f.resizable == !1)
          return;
        $(n).datagrid("autoSizeColumn", c), f.auto = !1;
      }
    }
  }
  function _6ba(e) {
    var n = _6b1(e.target), r = $(n).datagrid("options"), o = $(e.target).closest("td[field]");
    r.onHeaderContextMenu.call(n, e, o.attr("field"));
  }
  function _6bc(e) {
    return function(n) {
      var r = _6be(n.target);
      if (r) {
        var o = _6b1(r);
        if (!$.data(o, "datagrid").resizing) {
          var l = _6c1(r);
          if (e)
            _6c2(o, l);
          else {
            var u = $.data(o, "datagrid").options;
            u.finder.getTr(o, l).removeClass("datagrid-row-over");
          }
        }
      }
    };
  }
  function _6c3(e) {
    var n = _6be(e.target);
    if (n) {
      var r = _6b1(n), o = $.data(r, "datagrid").options, l = _6c1(n), u = $(e.target);
      if (u.parent().hasClass("datagrid-cell-check"))
        o.singleSelect && o.selectOnCheck ? (u._propAttr("checked", !u.is(":checked")), _6c6(r, l)) : u.is(":checked") ? (u._propAttr("checked", !1), _6c6(r, l)) : (u._propAttr("checked", !0), _6c7(r, l));
      else {
        var h = o.finder.getRow(r, l), c = u.closest("td[field]", n);
        if (c.length) {
          var f = c.attr("field");
          o.onClickCell.call(r, l, f, h[f]);
        }
        if (o.singleSelect == !0)
          _6c9(r, l);
        else if (o.ctrlSelect)
          if (e.metaKey || e.ctrlKey)
            n.hasClass("datagrid-row-selected") ? _6ca(r, l) : _6c9(r, l);
          else if (e.shiftKey) {
            $(r).datagrid("clearSelections");
            for (var v = Math.min(o.lastSelectedIndex || 0, l), m = Math.max(o.lastSelectedIndex || 0, l), g = v; g <= m; g++)
              _6c9(r, g);
          } else
            $(r).datagrid("clearSelections"), _6c9(r, l), o.lastSelectedIndex = l;
        else
          n.hasClass("datagrid-row-selected") ? _6ca(r, l) : _6c9(r, l);
        o.onClickRow.apply(r, _649(r, [l, h]));
      }
    }
  }
  function _6cd(e) {
    var n = _6be(e.target);
    if (n) {
      var r = _6b1(n), o = $.data(r, "datagrid").options, l = _6c1(n), u = o.finder.getRow(r, l), h = $(e.target).closest("td[field]", n);
      if (h.length) {
        var c = h.attr("field");
        o.onDblClickCell.call(r, l, c, u[c]);
      }
      o.onDblClickRow.apply(r, _649(r, [l, u]));
    }
  }
  function _6d1(e) {
    var n = _6be(e.target);
    if (n) {
      var r = _6b1(n), o = $.data(r, "datagrid").options, l = _6c1(n), u = o.finder.getRow(r, l);
      o.onRowContextMenu.call(r, e, l, u);
    } else {
      var h = _6be(e.target, ".datagrid-body");
      if (h) {
        var r = _6b1(h), o = $.data(r, "datagrid").options;
        o.onRowContextMenu.call(r, e, -1, null);
      }
    }
  }
  function _6b1(e) {
    return $(e).closest("div.datagrid-view").children(".datagrid-f")[0];
  }
  function _6be(e, n) {
    var r = $(e).closest(n || "tr.datagrid-row");
    if (r.length && r.parent().length)
      return r;
  }
  function _6c1(e) {
    return e.attr("datagrid-row-index") ? parseInt(e.attr("datagrid-row-index")) : e.attr("node-id");
  }
  function _6b6(e, n) {
    var r = $.data(e, "datagrid"), o = r.options;
    n = n || {};
    var l = { sortName: o.sortName, sortOrder: o.sortOrder };
    typeof n == "object" && $.extend(l, n);
    var u = [], h = [];
    if (l.sortName && (u = l.sortName.split(","), h = l.sortOrder.split(",")), typeof n == "string") {
      var c = n, f = _6a3(e, c);
      if (!f.sortable || r.resizing)
        return;
      var v = f.order || "asc", m = _646(u, c);
      if (m >= 0) {
        var g = h[m] == "asc" ? "desc" : "asc";
        o.multiSort && g == v ? (u.splice(m, 1), h.splice(m, 1)) : h[m] = g;
      } else
        o.multiSort ? (u.push(c), h.push(v)) : (u = [c], h = [v]);
      l.sortName = u.join(","), l.sortOrder = h.join(",");
    }
    if (o.onBeforeSortColumn.call(e, l.sortName, l.sortOrder) != !1) {
      $.extend(o, l);
      var y = r.dc, w = y.header1.add(y.header2);
      w.find("div.datagrid-cell").removeClass("datagrid-sort-asc datagrid-sort-desc");
      for (var E = 0; E < u.length; E++) {
        var f = _6a3(e, u[E]);
        w.find("div." + f.cellClass).addClass("datagrid-sort-" + h[E]);
      }
      o.remoteSort ? _6df(e) : _6e0(e, $(e).datagrid("getData")), o.onSortColumn.call(e, o.sortName, o.sortOrder);
    }
  }
  function _6e1(e, n, r) {
    o(!0), o(!1);
    function o(l) {
      var u = _6e7(e, l);
      if (u.length) {
        var h = u[u.length - 1], c = _646(h, n);
        if (c >= 0)
          for (var f = 0; f < u.length - 1; f++) {
            var v = $("#" + u[f][c]), m = parseInt(v.attr("colspan") || 1) + (r || 0);
            v.attr("colspan", m), m ? v.show() : v.hide();
          }
      }
    }
  }
  function _6ec(e) {
    var n = $.data(e, "datagrid"), r = n.options, o = n.dc, l = o.view2.children("div.datagrid-header");
    o.body2.css("overflow-x", ""), c(), h(), u(), c(!0), l.width() >= l.find("table").width() && o.body2.css("overflow-x", "hidden");
    function u() {
      if (r.fitColumns) {
        n.leftWidth || (n.leftWidth = 0);
        for (var v = 0, m = [], g = _6a2(e, !1), y = 0; y < g.length; y++) {
          var w = _6a3(e, g[y]);
          f(w) && (v += w.width, m.push({ field: w.field, col: w, addingWidth: 0 }));
        }
        if (v) {
          m[m.length - 1].addingWidth -= n.leftWidth;
          var E = l.children("div.datagrid-header-inner").show(), x = l.width() - l.find("table").width() - r.scrollbarSize + n.leftWidth, D = x / v;
          r.showHeader || E.hide();
          for (var y = 0; y < m.length; y++) {
            var F = m[y], k = parseInt(F.col.width * D);
            F.addingWidth += k, x -= k;
          }
          m[m.length - 1].addingWidth += x;
          for (var y = 0; y < m.length; y++) {
            var F = m[y];
            F.col.boxWidth + F.addingWidth > 0 && (F.col.boxWidth += F.addingWidth, F.col.width += F.addingWidth);
          }
          n.leftWidth = x, $(e).datagrid("fixColumnSize");
        }
      }
    }
    function h() {
      var v = !1, m = _6a2(e, !0).concat(_6a2(e, !1));
      $.map(m, function(g) {
        var y = _6a3(e, g);
        if (String(y.width || "").indexOf("%") >= 0) {
          var w = $.parser.parseValue("width", y.width, o.view, r.scrollbarSize + (r.rownumbers ? r.rownumberWidth : 0)) - y.deltaWidth;
          w > 0 && (y.boxWidth = w, v = !0);
        }
      }), v && $(e).datagrid("fixColumnSize");
    }
    function c(v) {
      var m = o.header1.add(o.header2).find(".datagrid-cell-group");
      m.length && (m.each(function() {
        $(this)._outerWidth(v ? $(this).parent().width() : 10);
      }), v && _65f(e));
    }
    function f(v) {
      if (String(v.width || "").indexOf("%") >= 0)
        return !1;
      if (!v.hidden && !v.checkbox && !v.auto && !v.fixed)
        return !0;
    }
  }
  function _6fe(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = r.dc, u = $('<div class="datagrid-cell" style="position:absolute;left:-9999px"></div>').appendTo("body");
    if (n)
      m(n), $(e).datagrid("fitColumns");
    else {
      for (var h = !1, c = _6a2(e, !0).concat(_6a2(e, !1)), f = 0; f < c.length; f++) {
        var n = c[f], v = _6a3(e, n);
        v.auto && (m(n), h = !0);
      }
      h && $(e).datagrid("fitColumns");
    }
    u.remove();
    function m(g) {
      var y = l.view.find('div.datagrid-header td[field="' + g + '"] div.datagrid-cell');
      y.css("width", "");
      var w = $(e).datagrid("getColumnOption", g);
      w.width = void 0, w.boxWidth = void 0, w.auto = !0, $(e).datagrid("fixColumnSize", g);
      var E = Math.max(x("header"), x("allbody"), x("allfooter")) + 1;
      y._outerWidth(E - 1), w.width = E, w.boxWidth = parseInt(y[0].style.width), w.deltaWidth = E - w.boxWidth, y.css("width", ""), $(e).datagrid("fixColumnSize", g), o.onResizeColumn.call(e, g, w.width);
      function x(D) {
        var F = 0;
        return D == "header" ? F = k(y) : o.finder.getTr(e, 0, D).find('td[field="' + g + '"] div.datagrid-cell').each(function() {
          var N = k($(this));
          F < N && (F = N);
        }), F;
        function k(N) {
          return N.is(":visible") ? N._outerWidth() : u.html(N.html())._outerWidth();
        }
      }
    }
  }
  function _70a(e, n) {
    var r = $.data(e, "datagrid");
    r.options;
    var o = r.dc, l = o.view.find("table.datagrid-btable,table.datagrid-ftable");
    if (l.css("table-layout", "fixed"), n)
      c(n);
    else
      for (var u = _6a2(e, !0).concat(_6a2(e, !1)), h = 0; h < u.length; h++)
        c(u[h]);
    l.css("table-layout", ""), _70f(e), _670(e), _710(e);
    function c(f) {
      var v = _6a3(e, f);
      v.cellClass && r.ss.set("." + v.cellClass, v.boxWidth ? v.boxWidth + "px" : "auto");
    }
  }
  function _70f(e, n) {
    var r = $.data(e, "datagrid").dc;
    n = n || r.view.find("td.datagrid-td-merged"), n.each(function() {
      var o = $(this), l = o.attr("colspan") || 1;
      if (l > 1) {
        for (var u = _6a3(e, o.attr("field")), h = u.boxWidth + u.deltaWidth - 1, c = 1; c < l; c++)
          o = o.next(), u = _6a3(e, o.attr("field")), h += u.boxWidth + u.deltaWidth;
        $(this).children("div.datagrid-cell")._outerWidth(h);
      }
    });
  }
  function _710(e) {
    var n = $.data(e, "datagrid").dc;
    n.view.find("div.datagrid-editable").each(function() {
      var r = $(this), o = r.parent().attr("field"), l = $(e).datagrid("getColumnOption", o);
      r._outerWidth(l.boxWidth + l.deltaWidth - 1);
      var u = $.data(this, "datagrid.editor");
      u.actions.resize && u.actions.resize(u.target, r.width());
    });
  }
  function _6a3(e, n) {
    function r(u) {
      if (u)
        for (var h = 0; h < u.length; h++)
          for (var c = u[h], f = 0; f < c.length; f++) {
            var v = c[f];
            if (v.field == n)
              return v;
          }
      return null;
    }
    var o = $.data(e, "datagrid").options, l = r(o.columns);
    return l || (l = r(o.frozenColumns)), l;
  }
  function _6e7(e, n) {
    for (var r = $.data(e, "datagrid").options, o = n ? r.frozenColumns : r.columns, l = [], u = f(), h = 0; h < o.length; h++)
      l[h] = new Array(u);
    for (var c = 0; c < o.length; c++)
      $.map(o[c], function(m) {
        var g = v(l[c]);
        if (g >= 0)
          for (var y = m.field || m.id || "", w = 0; w < (m.colspan || 1); w++) {
            for (var E = 0; E < (m.rowspan || 1); E++)
              l[c + E][g] = y;
            g++;
          }
      });
    return l;
    function f() {
      var m = 0;
      return $.map(o[0] || [], function(g) {
        m += g.colspan || 1;
      }), m;
    }
    function v(m) {
      for (var g = 0; g < m.length; g++)
        if (m[g] == null)
          return g;
      return -1;
    }
  }
  function _6a2(e, n) {
    var r = _6e7(e, n);
    return r.length ? r[r.length - 1] : r;
  }
  function _6e0(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = r.dc;
    if (n = o.loadFilter.call(e, n), $.isArray(n) && (n = { total: n.length, rows: n }), n.total = parseInt(n.total), r.data = n, n.footer && (r.footer = n.footer), !o.remoteSort && o.sortName) {
      var u = o.sortName.split(","), h = o.sortOrder.split(",");
      n.rows.sort(function(v, m) {
        for (var g = 0, y = 0; y < u.length; y++) {
          var w = u[y], E = h[y], x = _6a3(e, w), D = x.sorter || function(F, k) {
            return F == k ? 0 : F > k ? 1 : -1;
          };
          if (g = D(v[w], m[w]) * (E == "asc" ? 1 : -1), g != 0)
            return g;
        }
        return g;
      });
    }
    o.view.onBeforeRender && o.view.onBeforeRender.call(o.view, e, n.rows), o.view.render.call(o.view, e, l.body2, !1), o.view.render.call(o.view, e, l.body1, !0), o.showFooter && (o.view.renderFooter.call(o.view, e, l.footer2, !1), o.view.renderFooter.call(o.view, e, l.footer1, !0)), o.view.onAfterRender && o.view.onAfterRender.call(o.view, e), r.ss.clean();
    var c = $(e).datagrid("getPager");
    if (c.length) {
      var f = c.pagination("options");
      f.total != n.total && (c.pagination("refresh", { total: n.total }), o.pageNumber != f.pageNumber && f.pageNumber > 0 && (o.pageNumber = f.pageNumber, _6df(e)));
    }
    _670(e), l.body2.triggerHandler("scroll"), $(e).datagrid("setSelectionState"), $(e).datagrid("autoSizeColumn"), o.onLoadSuccess.call(e, n);
  }
  function _72d(e) {
    var n = $.data(e, "datagrid"), r = n.options, o = n.dc;
    if (o.header1.add(o.header2).find("input[type=checkbox]")._propAttr("checked", !1), r.idField) {
      var l = !!$.data(e, "treegrid"), u = r.onSelect, h = r.onCheck;
      r.onSelect = r.onCheck = function() {
      };
      for (var c = r.finder.getRows(e), f = 0; f < c.length; f++) {
        var v = c[f], m = l ? v[r.idField] : $(e).datagrid("getRowIndex", v[r.idField]);
        g(n.selectedRows, v) && _6c9(e, m, !0, !0), g(n.checkedRows, v) && _6c6(e, m, !0);
      }
      r.onSelect = u, r.onCheck = h;
    }
    function g(y, w) {
      for (var E = 0; E < y.length; E++)
        if (y[E][r.idField] == w[r.idField])
          return y[E] = w, !0;
      return !1;
    }
  }
  function _735(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = r.data.rows;
    if (typeof n == "object")
      return _646(l, n);
    for (var u = 0; u < l.length; u++)
      if (l[u][o.idField] == n)
        return u;
    return -1;
  }
  function _738(e) {
    var n = $.data(e, "datagrid"), r = n.options;
    if (n.data, r.idField)
      return n.selectedRows;
    var o = [];
    return r.finder.getTr(e, "", "selected", 2).each(function() {
      o.push(r.finder.getRow(e, $(this)));
    }), o;
  }
  function _73b(e) {
    var n = $.data(e, "datagrid"), r = n.options;
    if (r.idField)
      return n.checkedRows;
    var o = [];
    return r.finder.getTr(e, "", "checked", 2).each(function() {
      o.push(r.finder.getRow(e, $(this)));
    }), o;
  }
  function _73e(e, n) {
    var r = $.data(e, "datagrid"), o = r.dc, l = r.options, u = l.finder.getTr(e, n);
    if (u.length) {
      if (u.closest("table").hasClass("datagrid-btable-frozen"))
        return;
      var h = o.view2.children("div.datagrid-header")._outerHeight(), c = o.body2, f = l.scrollbarSize;
      c[0].offsetHeight && c[0].clientHeight && c[0].offsetHeight <= c[0].clientHeight && (f = 0);
      var v = c.outerHeight(!0) - c.outerHeight(), m = u.position().top - h - v;
      m < 0 ? c.scrollTop(c.scrollTop() + m) : m + u._outerHeight() > c.height() - f && c.scrollTop(c.scrollTop() + m + u._outerHeight() - c.height() + f);
    }
  }
  function _6c2(e, n) {
    var r = $.data(e, "datagrid"), o = r.options;
    o.finder.getTr(e, r.highlightIndex).removeClass("datagrid-row-over"), o.finder.getTr(e, n).addClass("datagrid-row-over"), r.highlightIndex = n;
  }
  function _6c9(e, n, r, o) {
    var l = $.data(e, "datagrid"), u = l.options, h = u.finder.getRow(e, n);
    h && u.onBeforeSelect.apply(e, _649(e, [n, h])) != !1 && (u.singleSelect && (_74e(e, !0), l.selectedRows = []), !r && u.checkOnSelect && _6c6(e, n, !0), u.idField && _648(l.selectedRows, u.idField, h), u.finder.getTr(e, n).addClass("datagrid-row-selected"), u.onSelect.apply(e, _649(e, [n, h])), !o && u.scrollOnSelect && _73e(e, n));
  }
  function _6ca(e, n, r) {
    var o = $.data(e, "datagrid");
    o.dc;
    var l = o.options, u = l.finder.getRow(e, n);
    u && l.onBeforeUnselect.apply(e, _649(e, [n, u])) != !1 && (!r && l.checkOnSelect && _6c7(e, n, !0), l.finder.getTr(e, n).removeClass("datagrid-row-selected"), l.idField && _647(o.selectedRows, l.idField, u[l.idField]), l.onUnselect.apply(e, _649(e, [n, u])));
  }
  function _753(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = o.finder.getRows(e), u = $.data(e, "datagrid").selectedRows;
    if (!n && o.checkOnSelect && _6b4(e, !0), o.finder.getTr(e, "", "allbody").addClass("datagrid-row-selected"), o.idField)
      for (var h = 0; h < l.length; h++)
        _648(u, o.idField, l[h]);
    o.onSelectAll.call(e, l);
  }
  function _74e(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = o.finder.getRows(e), u = $.data(e, "datagrid").selectedRows;
    if (!n && o.checkOnSelect && _6b5(e, !0), o.finder.getTr(e, "", "selected").removeClass("datagrid-row-selected"), o.idField)
      for (var h = 0; h < l.length; h++)
        _647(u, o.idField, l[h][o.idField]);
    o.onUnselectAll.call(e, l);
  }
  function _6c6(e, n, r) {
    var o = $.data(e, "datagrid"), l = o.options, u = l.finder.getRow(e, n);
    if (u && l.onBeforeCheck.apply(e, _649(e, [n, u])) != !1) {
      l.singleSelect && l.selectOnCheck && (_6b5(e, !0), o.checkedRows = []), !r && l.selectOnCheck && _6c9(e, n, !0);
      var h = l.finder.getTr(e, n).addClass("datagrid-row-checked");
      if (h.find("div.datagrid-cell-check input[type=checkbox]")._propAttr("checked", !0), h = l.finder.getTr(e, "", "checked", 2), h.length == l.finder.getRows(e).length) {
        var c = o.dc;
        c.header1.add(c.header2).find("input[type=checkbox]")._propAttr("checked", !0);
      }
      l.idField && _648(o.checkedRows, l.idField, u), l.onCheck.apply(e, _649(e, [n, u]));
    }
  }
  function _6c7(e, n, r) {
    var o = $.data(e, "datagrid"), l = o.options, u = l.finder.getRow(e, n);
    if (u && l.onBeforeUncheck.apply(e, _649(e, [n, u])) != !1) {
      !r && l.selectOnCheck && _6ca(e, n, !0);
      var h = l.finder.getTr(e, n).removeClass("datagrid-row-checked");
      h.find("div.datagrid-cell-check input[type=checkbox]")._propAttr("checked", !1);
      var c = o.dc, f = c.header1.add(c.header2);
      f.find("input[type=checkbox]")._propAttr("checked", !1), l.idField && _647(o.checkedRows, l.idField, u[l.idField]), l.onUncheck.apply(e, _649(e, [n, u]));
    }
  }
  function _6b4(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = o.finder.getRows(e);
    !n && o.selectOnCheck && _753(e, !0);
    var u = r.dc, h = u.header1.add(u.header2).find("input[type=checkbox]"), c = o.finder.getTr(e, "", "allbody").addClass("datagrid-row-checked").find("div.datagrid-cell-check input[type=checkbox]");
    if (h.add(c)._propAttr("checked", !0), o.idField)
      for (var f = 0; f < l.length; f++)
        _648(r.checkedRows, o.idField, l[f]);
    o.onCheckAll.call(e, l);
  }
  function _6b5(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = o.finder.getRows(e);
    !n && o.selectOnCheck && _74e(e, !0);
    var u = r.dc, h = u.header1.add(u.header2).find("input[type=checkbox]"), c = o.finder.getTr(e, "", "checked").removeClass("datagrid-row-checked").find("div.datagrid-cell-check input[type=checkbox]");
    if (h.add(c)._propAttr("checked", !1), o.idField)
      for (var f = 0; f < l.length; f++)
        _647(r.checkedRows, o.idField, l[f][o.idField]);
    o.onUncheckAll.call(e, l);
  }
  function _76d(e, n) {
    var r = $.data(e, "datagrid").options, o = r.finder.getTr(e, n), l = r.finder.getRow(e, n);
    o.hasClass("datagrid-row-editing") || r.onBeforeEdit.apply(e, _649(e, [n, l])) != !1 && (o.addClass("datagrid-row-editing"), _770(e, n), _710(e), o.find("div.datagrid-editable").each(function() {
      var u = $(this).parent().attr("field"), h = $.data(this, "datagrid.editor");
      h.actions.setValue(h.target, l[u]);
    }), _772(e, n), r.onBeginEdit.apply(e, _649(e, [n, l])));
  }
  function _773(e, n, r) {
    var o = $.data(e, "datagrid"), l = o.options, u = o.updatedRows, h = o.insertedRows, c = l.finder.getTr(e, n), f = l.finder.getRow(e, n);
    if (c.hasClass("datagrid-row-editing")) {
      if (!r) {
        if (!_772(e, n))
          return;
        var v = !1, m = {};
        c.find("div.datagrid-editable").each(function() {
          var g = $(this).parent().attr("field"), y = $.data(this, "datagrid.editor"), w = $(y.target), E = w.data("textbox") ? w.textbox("textbox") : w;
          E.is(":focus") && E.triggerHandler("blur");
          var x = y.actions.getValue(y.target);
          f[g] !== x && (f[g] = x, v = !0, m[g] = x);
        }), v && _646(h, f) == -1 && _646(u, f) == -1 && u.push(f), l.onEndEdit.apply(e, _649(e, [n, f, m]));
      }
      c.removeClass("datagrid-row-editing"), _77f(e, n), $(e).datagrid("refreshRow", n), r ? l.onCancelEdit.apply(e, _649(e, [n, f])) : l.onAfterEdit.apply(e, _649(e, [n, f, m]));
    }
  }
  function _780(e, n) {
    var r = $.data(e, "datagrid").options, o = r.finder.getTr(e, n), l = [];
    return o.children("td").each(function() {
      var u = $(this).find("div.datagrid-editable");
      if (u.length) {
        var h = $.data(u[0], "datagrid.editor");
        l.push(h);
      }
    }), l;
  }
  function _784(e, n) {
    for (var r = _780(e, n.index != null ? n.index : n.id), o = 0; o < r.length; o++)
      if (r[o].field == n.field)
        return r[o];
    return null;
  }
  function _770(e, n) {
    var r = $.data(e, "datagrid").options, o = r.finder.getTr(e, n);
    o.children("td").each(function() {
      var l = $(this).find("div.datagrid-cell"), u = $(this).attr("field"), h = _6a3(e, u);
      if (h && h.editor) {
        var c, f;
        typeof h.editor == "string" ? c = h.editor : (c = h.editor.type, f = h.editor.options);
        var v = r.editors[c];
        if (v) {
          var m = l.html(), g = l._outerWidth();
          l.addClass("datagrid-editable"), l._outerWidth(g), l.html('<table border="0" cellspacing="0" cellpadding="1"><tr><td></td></tr></table>'), l.children("table").bind("click dblclick contextmenu", function(y) {
            y.stopPropagation();
          }), $.data(l[0], "datagrid.editor", { actions: v, target: v.init(l.find("td"), $.extend({ height: r.editorHeight }, f)), field: u, type: c, oldHtml: m });
        }
      }
    }), _670(e, n, !0);
  }
  function _77f(e, n) {
    var r = $.data(e, "datagrid").options, o = r.finder.getTr(e, n);
    o.children("td").each(function() {
      var l = $(this).find("div.datagrid-editable");
      if (l.length) {
        var u = $.data(l[0], "datagrid.editor");
        u.actions.destroy && u.actions.destroy(u.target), l.html(u.oldHtml), $.removeData(l[0], "datagrid.editor"), l.removeClass("datagrid-editable"), l.css("width", "");
      }
    });
  }
  function _772(e, n) {
    var r = $.data(e, "datagrid").options.finder.getTr(e, n);
    if (!r.hasClass("datagrid-row-editing"))
      return !0;
    var o = r.find(".validatebox-text");
    o.validatebox("validate"), o.trigger("mouseleave");
    var l = r.find(".validatebox-invalid");
    return l.length == 0;
  }
  function _795(e, n) {
    var r = $.data(e, "datagrid").insertedRows, o = $.data(e, "datagrid").deletedRows, l = $.data(e, "datagrid").updatedRows;
    if (n) {
      if (n == "inserted")
        return r;
      if (n == "deleted")
        return o;
      if (n == "updated")
        return l;
    } else {
      var u = [];
      return u = u.concat(r), u = u.concat(o), u = u.concat(l), u;
    }
    return [];
  }
  function _79b(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = r.data, u = r.insertedRows, h = r.deletedRows;
    $(e).datagrid("cancelEdit", n);
    var c = o.finder.getRow(e, n);
    _646(u, c) >= 0 ? _647(u, c) : h.push(c), _647(r.selectedRows, o.idField, c[o.idField]), _647(r.checkedRows, o.idField, c[o.idField]), o.view.deleteRow.call(o.view, e, n), o.height == "auto" && _670(e), $(e).datagrid("getPager").pagination("refresh", { total: l.total });
  }
  function _7a1(e, n) {
    var r = $.data(e, "datagrid").data, o = $.data(e, "datagrid").options.view, l = $.data(e, "datagrid").insertedRows;
    o.insertRow.call(o, e, n.index, n.row), l.push(n.row), $(e).datagrid("getPager").pagination("refresh", { total: r.total });
  }
  function _7a5(e, n) {
    var r = $.data(e, "datagrid").data, o = $.data(e, "datagrid").options.view, l = $.data(e, "datagrid").insertedRows;
    o.insertRow.call(o, e, null, n), l.push(n), $(e).datagrid("getPager").pagination("refresh", { total: r.total });
  }
  function _7a8(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = o.finder.getRow(e, n.index), u = !1;
    n.row = n.row || {};
    for (var h in n.row)
      if (l[h] !== n.row[h]) {
        u = !0;
        break;
      }
    u && (_646(r.insertedRows, l) == -1 && _646(r.updatedRows, l) == -1 && r.updatedRows.push(l), o.view.updateRow.call(o.view, e, n.index, n.row));
  }
  function _7ae(e) {
    for (var n = $.data(e, "datagrid"), r = n.data, o = r.rows, l = [], u = 0; u < o.length; u++)
      l.push($.extend({}, o[u]));
    n.originalRows = l, n.updatedRows = [], n.insertedRows = [], n.deletedRows = [];
  }
  function _7b2(e) {
    for (var n = $.data(e, "datagrid").data, r = !0, o = 0, l = n.rows.length; o < l; o++)
      _772(e, o) ? $(e).datagrid("endEdit", o) : r = !1;
    r && _7ae(e);
  }
  function _7b4(e) {
    var n = $.data(e, "datagrid"), r = n.options, o = n.originalRows, l = n.insertedRows, u = n.deletedRows, h = n.selectedRows, c = n.checkedRows, f = n.data;
    function v(E) {
      for (var x = [], D = 0; D < E.length; D++)
        x.push(E[D][r.idField]);
      return x;
    }
    function m(E, x) {
      for (var D = 0; D < E.length; D++) {
        var F = _735(e, E[D]);
        F >= 0 && (x == "s" ? _6c9 : _6c6)(e, F, !0);
      }
    }
    for (var g = 0; g < f.rows.length; g++)
      $(e).datagrid("cancelEdit", g);
    var y = v(h), w = v(c);
    h.splice(0, h.length), c.splice(0, c.length), f.total += u.length - l.length, f.rows = o, _6e0(e, f), m(y, "s"), m(w, "c"), _7ae(e);
  }
  function _6df(e, n, r) {
    var o = $.data(e, "datagrid").options;
    n && (o.queryParams = n);
    var l = $.extend({}, o.queryParams);
    if (o.pagination && $.extend(l, { page: o.pageNumber || 1, rows: o.pageSize }), o.sortName && $.extend(l, { sort: o.sortName, order: o.sortOrder }), o.onBeforeLoad.call(e, l) != !1) {
      $(e).datagrid("loading");
      var u = o.loader.call(e, l, function(h) {
        $(e).datagrid("loaded"), $(e).datagrid("loadData", h), r && r();
      }, function() {
        $(e).datagrid("loaded"), o.onLoadError.apply(e, arguments);
      });
      u == !1 && $(e).datagrid("loaded");
    }
  }
  function _7c6(e, n) {
    var r = $.data(e, "datagrid").options;
    if (n.type = n.type || "body", n.rowspan = n.rowspan || 1, n.colspan = n.colspan || 1, n.rowspan == 1 && n.colspan == 1)
      return;
    var o = r.finder.getTr(e, n.index != null ? n.index : n.id, n.type);
    if (!o.length)
      return;
    var l = o.find('td[field="' + n.field + '"]');
    l.attr("rowspan", n.rowspan).attr("colspan", n.colspan), l.addClass("datagrid-td-merged"), h(l.next(), n.colspan - 1);
    for (var u = 1; u < n.rowspan && (o = o.next(), !!o.length); u++)
      h(o.find('td[field="' + n.field + '"]'), n.colspan);
    _70f(e, l);
    function h(c, f) {
      for (var v = 0; v < f; v++)
        c.hide(), c = c.next();
    }
  }
  $.fn.datagrid = function(e, n) {
    return typeof e == "string" ? $.fn.datagrid.methods[e](this, n) : (e = e || {}, this.each(function() {
      var r = $.data(this, "datagrid"), o;
      if (r)
        o = $.extend(r.options, e), r.options = o;
      else {
        o = $.extend({}, $.extend({}, $.fn.datagrid.defaults, { queryParams: {} }), $.fn.datagrid.parseOptions(this), e), $(this).css("width", "").css("height", "");
        var l = _684(this, o.rownumbers);
        o.columns || (o.columns = l.columns), o.frozenColumns || (o.frozenColumns = l.frozenColumns), o.columns = $.extend(!0, [], o.columns), o.frozenColumns = $.extend(!0, [], o.frozenColumns), o.view = $.extend({}, o.view), $.data(this, "datagrid", { options: o, panel: l.panel, dc: l.dc, ss: null, selectedRows: [], checkedRows: [], data: { total: 0, rows: [] }, originalRows: [], updatedRows: [], insertedRows: [], deletedRows: [] });
      }
      if (_68d(this), _6a4(this), _65a(this), o.data)
        $(this).datagrid("loadData", o.data);
      else {
        var u = $.fn.datagrid.parseData(this);
        u.total > 0 ? $(this).datagrid("loadData", u) : (o.view.setEmptyMsg(this), $(this).datagrid("autoSizeColumn"));
      }
      _6df(this);
    }));
  };
  function _7cf(e) {
    var n = {};
    return $.map(e, function(o) {
      n[o] = r(o);
    }), n;
    function r(o) {
      function l(u) {
        return $.data($(u)[0], o) != null;
      }
      return { init: function(u, h) {
        var c = $('<input type="text" class="datagrid-editable-input">').appendTo(u);
        return c[o] && o != "text" ? c[o](h) : c;
      }, destroy: function(u) {
        l(u) && $(u)[o]("destroy");
      }, getValue: function(u) {
        if (l(u)) {
          var h = $(u)[o]("options");
          return h.multiple ? $(u)[o]("getValues").join(h.separator) : $(u)[o]("getValue");
        } else
          return $(u).val();
      }, setValue: function(u, h) {
        if (l(u)) {
          var c = $(u)[o]("options");
          c.multiple ? h ? $(u)[o]("setValues", h.split(c.separator)) : $(u)[o]("clear") : $(u)[o]("setValue", h);
        } else
          $(u).val(h);
      }, resize: function(u, h) {
        l(u) ? $(u)[o]("resize", h) : $(u)._size({ width: h, height: $.fn.datagrid.defaults.editorHeight });
      } };
    }
  }
  var _7dd = $.extend({}, _7cf(["text", "textbox", "passwordbox", "filebox", "numberbox", "numberspinner", "combobox", "combotree", "combogrid", "combotreegrid", "datebox", "datetimebox", "timespinner", "datetimespinner"]), { textarea: { init: function(e, n) {
    var r = $('<textarea class="datagrid-editable-input"></textarea>').appendTo(e);
    return r.css("vertical-align", "middle")._outerHeight(n.height), r;
  }, getValue: function(e) {
    return $(e).val();
  }, setValue: function(e, n) {
    $(e).val(n);
  }, resize: function(e, n) {
    $(e)._outerWidth(n);
  } }, checkbox: { init: function(e, n) {
    var r = $('<input type="checkbox">').appendTo(e);
    return r.val(n.on), r.attr("offval", n.off), r;
  }, getValue: function(e) {
    return $(e).is(":checked") ? $(e).val() : $(e).attr("offval");
  }, setValue: function(e, n) {
    var r = !1;
    $(e).val() == n && (r = !0), $(e)._propAttr("checked", r);
  } }, validatebox: { init: function(e, n) {
    var r = $('<input type="text" class="datagrid-editable-input">').appendTo(e);
    return r.validatebox(n), r;
  }, destroy: function(e) {
    $(e).validatebox("destroy");
  }, getValue: function(e) {
    return $(e).val();
  }, setValue: function(e, n) {
    $(e).val(n);
  }, resize: function(e, n) {
    $(e)._outerWidth(n)._outerHeight($.fn.datagrid.defaults.editorHeight);
  } } });
  $.fn.datagrid.methods = { options: function(e) {
    var n = $.data(e[0], "datagrid").options, r = $.data(e[0], "datagrid").panel.panel("options"), o = $.extend(n, { width: r.width, height: r.height, closed: r.closed, collapsed: r.collapsed, minimized: r.minimized, maximized: r.maximized });
    return o;
  }, setSelectionState: function(e) {
    return e.each(function() {
      _72d(this);
    });
  }, createStyleSheet: function(e) {
    return _64b(e[0]);
  }, getPanel: function(e) {
    return $.data(e[0], "datagrid").panel;
  }, getPager: function(e) {
    return $.data(e[0], "datagrid").panel.children("div.datagrid-pager");
  }, getColumnFields: function(e, n) {
    return _6a2(e[0], n);
  }, getColumnOption: function(e, n) {
    return _6a3(e[0], n);
  }, resize: function(e, n) {
    return e.each(function() {
      _65a(this, n);
    });
  }, load: function(e, n) {
    return e.each(function() {
      var r = $(this).datagrid("options");
      typeof n == "string" && (r.url = n, n = null), r.pageNumber = 1;
      var o = $(this).datagrid("getPager");
      o.pagination("refresh", { pageNumber: 1 }), _6df(this, n);
    });
  }, reload: function(e, n) {
    return e.each(function() {
      var r = $(this).datagrid("options");
      typeof n == "string" && (r.url = n, n = null), _6df(this, n);
    });
  }, reloadFooter: function(e, n) {
    return e.each(function() {
      var r = $.data(this, "datagrid").options, o = $.data(this, "datagrid").dc;
      n && ($.data(this, "datagrid").footer = n), r.showFooter && (r.view.renderFooter.call(r.view, this, o.footer2, !1), r.view.renderFooter.call(r.view, this, o.footer1, !0), r.view.onAfterRender && r.view.onAfterRender.call(r.view, this), $(this).datagrid("fixRowHeight"));
    });
  }, loading: function(e) {
    return e.each(function() {
      var n = $.data(this, "datagrid").options;
      if ($(this).datagrid("getPager").pagination("loading"), n.loadMsg) {
        var r = $(this).datagrid("getPanel");
        if (!r.children("div.datagrid-mask").length) {
          $('<div class="datagrid-mask" style="display:block"></div>').appendTo(r);
          var o = $('<div class="datagrid-mask-msg" style="display:block;left:50%"></div>').html(n.loadMsg).appendTo(r);
          o._outerHeight(40), o.css({ marginLeft: -o.outerWidth() / 2, lineHeight: o.height() + "px" });
        }
      }
    });
  }, loaded: function(e) {
    return e.each(function() {
      $(this).datagrid("getPager").pagination("loaded");
      var n = $(this).datagrid("getPanel");
      n.children("div.datagrid-mask-msg").remove(), n.children("div.datagrid-mask").remove();
    });
  }, fitColumns: function(e) {
    return e.each(function() {
      _6ec(this);
    });
  }, fixColumnSize: function(e, n) {
    return e.each(function() {
      _70a(this, n);
    });
  }, fixRowHeight: function(e, n) {
    return e.each(function() {
      _670(this, n);
    });
  }, freezeRow: function(e, n) {
    return e.each(function() {
      _67d(this, n);
    });
  }, autoSizeColumn: function(e, n) {
    return e.each(function() {
      _6fe(this, n);
    });
  }, loadData: function(e, n) {
    return e.each(function() {
      _6e0(this, n), _7ae(this);
    });
  }, getData: function(e) {
    return $.data(e[0], "datagrid").data;
  }, getRows: function(e) {
    return $.data(e[0], "datagrid").data.rows;
  }, getFooterRows: function(e) {
    return $.data(e[0], "datagrid").footer;
  }, getRowIndex: function(e, n) {
    return _735(e[0], n);
  }, getChecked: function(e) {
    return _73b(e[0]);
  }, getSelected: function(e) {
    var n = _738(e[0]);
    return n.length > 0 ? n[0] : null;
  }, getSelections: function(e) {
    return _738(e[0]);
  }, clearSelections: function(e) {
    return e.each(function() {
      var n = $.data(this, "datagrid"), r = n.selectedRows, o = n.checkedRows;
      r.splice(0, r.length), _74e(this), n.options.checkOnSelect && o.splice(0, o.length);
    });
  }, clearChecked: function(e) {
    return e.each(function() {
      var n = $.data(this, "datagrid"), r = n.selectedRows, o = n.checkedRows;
      o.splice(0, o.length), _6b5(this), n.options.selectOnCheck && r.splice(0, r.length);
    });
  }, scrollTo: function(e, n) {
    return e.each(function() {
      _73e(this, n);
    });
  }, highlightRow: function(e, n) {
    return e.each(function() {
      _6c2(this, n), _73e(this, n);
    });
  }, selectAll: function(e) {
    return e.each(function() {
      _753(this);
    });
  }, unselectAll: function(e) {
    return e.each(function() {
      _74e(this);
    });
  }, selectRow: function(e, n) {
    return e.each(function() {
      _6c9(this, n);
    });
  }, selectRecord: function(e, n) {
    return e.each(function() {
      var r = $.data(this, "datagrid").options;
      if (r.idField) {
        var o = _735(this, n);
        o >= 0 && $(this).datagrid("selectRow", o);
      }
    });
  }, unselectRow: function(e, n) {
    return e.each(function() {
      _6ca(this, n);
    });
  }, checkRow: function(e, n) {
    return e.each(function() {
      _6c6(this, n);
    });
  }, uncheckRow: function(e, n) {
    return e.each(function() {
      _6c7(this, n);
    });
  }, checkAll: function(e) {
    return e.each(function() {
      _6b4(this);
    });
  }, uncheckAll: function(e) {
    return e.each(function() {
      _6b5(this);
    });
  }, beginEdit: function(e, n) {
    return e.each(function() {
      _76d(this, n);
    });
  }, endEdit: function(e, n) {
    return e.each(function() {
      _773(this, n, !1);
    });
  }, cancelEdit: function(e, n) {
    return e.each(function() {
      _773(this, n, !0);
    });
  }, getEditors: function(e, n) {
    return _780(e[0], n);
  }, getEditor: function(e, n) {
    return _784(e[0], n);
  }, refreshRow: function(e, n) {
    return e.each(function() {
      var r = $.data(this, "datagrid").options;
      r.view.refreshRow.call(r.view, this, n);
    });
  }, validateRow: function(e, n) {
    return _772(e[0], n);
  }, updateRow: function(e, n) {
    return e.each(function() {
      _7a8(this, n);
    });
  }, appendRow: function(e, n) {
    return e.each(function() {
      _7a5(this, n);
    });
  }, insertRow: function(e, n) {
    return e.each(function() {
      _7a1(this, n);
    });
  }, deleteRow: function(e, n) {
    return e.each(function() {
      _79b(this, n);
    });
  }, getChanges: function(e, n) {
    return _795(e[0], n);
  }, acceptChanges: function(e) {
    return e.each(function() {
      _7b2(this);
    });
  }, rejectChanges: function(e) {
    return e.each(function() {
      _7b4(this);
    });
  }, mergeCells: function(e, n) {
    return e.each(function() {
      _7c6(this, n);
    });
  }, showColumn: function(e, n) {
    return e.each(function() {
      var r = $(this).datagrid("getColumnOption", n);
      r.hidden && (r.hidden = !1, $(this).datagrid("getPanel").find('td[field="' + n + '"]').show(), _6e1(this, n, 1), $(this).datagrid("fitColumns"));
    });
  }, hideColumn: function(e, n) {
    return e.each(function() {
      var r = $(this).datagrid("getColumnOption", n);
      r.hidden || (r.hidden = !0, $(this).datagrid("getPanel").find('td[field="' + n + '"]').hide(), _6e1(this, n, -1), $(this).datagrid("fitColumns"));
    });
  }, sort: function(e, n) {
    return e.each(function() {
      _6b6(this, n);
    });
  }, gotoPage: function(e, n) {
    return e.each(function() {
      var r = this, o, l;
      typeof n == "object" ? (o = n.page, l = n.callback) : o = n, $(r).datagrid("options").pageNumber = o, $(r).datagrid("getPager").pagination("refresh", { pageNumber: o }), _6df(r, null, function() {
        l && l.call(r, o);
      });
    });
  } }, $.fn.datagrid.parseOptions = function(_823) {
    var t = $(_823);
    return $.extend({}, $.fn.panel.parseOptions(_823), $.parser.parseOptions(_823, ["url", "toolbar", "idField", "sortName", "sortOrder", "pagePosition", "resizeHandle", { sharedStyleSheet: "boolean", fitColumns: "boolean", autoRowHeight: "boolean", striped: "boolean", nowrap: "boolean" }, { rownumbers: "boolean", singleSelect: "boolean", ctrlSelect: "boolean", checkOnSelect: "boolean", selectOnCheck: "boolean" }, { pagination: "boolean", pageSize: "number", pageNumber: "number" }, { multiSort: "boolean", remoteSort: "boolean", showHeader: "boolean", showFooter: "boolean" }, { scrollbarSize: "number", scrollOnSelect: "boolean" }]), { pageList: t.attr("pageList") ? eval(t.attr("pageList")) : void 0, loadMsg: t.attr("loadMsg") != null ? t.attr("loadMsg") : void 0, rowStyler: t.attr("rowStyler") ? eval(t.attr("rowStyler")) : void 0 });
  }, $.fn.datagrid.parseData = function(e) {
    var n = $(e), r = { total: 0, rows: [] }, o = n.datagrid("getColumnFields", !0).concat(n.datagrid("getColumnFields", !1));
    return n.find("tbody tr").each(function() {
      r.total++;
      var l = {};
      $.extend(l, $.parser.parseOptions(this, ["iconCls", "state"]));
      for (var u = 0; u < o.length; u++)
        l[o[u]] = $(this).find("td:eq(" + u + ")").html();
      r.rows.push(l);
    }), r;
  };
  var _826 = { render: function(e, n, r) {
    var o = $(e).datagrid("getRows");
    $(n).html(this.renderTable(e, 0, o, r));
  }, renderFooter: function(e, n, r) {
    $.data(e, "datagrid").options;
    for (var o = $.data(e, "datagrid").footer || [], l = $(e).datagrid("getColumnFields", r), u = ['<table class="datagrid-ftable" cellspacing="0" cellpadding="0" border="0"><tbody>'], h = 0; h < o.length; h++)
      u.push('<tr class="datagrid-row" datagrid-row-index="' + h + '">'), u.push(this.renderRow.call(this, e, l, r, h, o[h])), u.push("</tr>");
    u.push("</tbody></table>"), $(n).html(u.join(""));
  }, renderTable: function(e, n, r, o) {
    var l = $.data(e, "datagrid"), u = l.options;
    if (o && !(u.rownumbers || u.frozenColumns && u.frozenColumns.length))
      return "";
    for (var h = $(e).datagrid("getColumnFields", o), c = ['<table class="datagrid-btable" cellspacing="0" cellpadding="0" border="0"><tbody>'], f = 0; f < r.length; f++) {
      var v = r[f], m = u.rowStyler ? u.rowStyler.call(e, n, v) : "", g = this.getStyleValue(m), y = 'class="datagrid-row ' + (n % 2 && u.striped ? "datagrid-row-alt " : " ") + g.c + '"', w = g.s ? 'style="' + g.s + '"' : "", E = l.rowIdPrefix + "-" + (o ? 1 : 2) + "-" + n;
      c.push('<tr id="' + E + '" datagrid-row-index="' + n + '" ' + y + " " + w + ">"), c.push(this.renderRow.call(this, e, h, o, n, v)), c.push("</tr>"), n++;
    }
    return c.push("</tbody></table>"), c.join("");
  }, renderRow: function(e, n, r, o, l) {
    var u = $.data(e, "datagrid").options, h = [];
    if (r && u.rownumbers) {
      var c = o + 1;
      u.pagination && (c += (u.pageNumber - 1) * u.pageSize), h.push('<td class="datagrid-td-rownumber"><div class="datagrid-cell-rownumber">' + c + "</div></td>");
    }
    for (var f = 0; f < n.length; f++) {
      var v = n[f], m = $(e).datagrid("getColumnOption", v);
      if (m) {
        var g = l[v], y = m.styler && m.styler.call(e, g, l, o) || "", w = this.getStyleValue(y), E = w.c ? 'class="' + w.c + '"' : "", x = m.hidden ? 'style="display:none;' + w.s + '"' : w.s ? 'style="' + w.s + '"' : "";
        h.push('<td field="' + v + '" ' + E + " " + x + ">");
        var x = "";
        m.checkbox || (m.align && (x += "text-align:" + m.align + ";"), u.nowrap ? u.autoRowHeight && (x += "height:auto;") : x += "white-space:normal;height:auto;"), h.push('<div style="' + x + '" '), h.push(m.checkbox ? 'class="datagrid-cell-check"' : 'class="datagrid-cell ' + m.cellClass + '"'), h.push(">"), m.checkbox ? (h.push('<input type="checkbox" ' + (l.checked ? 'checked="checked"' : "")), h.push(' name="' + v + '" value="' + (g ?? "") + '">')) : m.formatter ? h.push(m.formatter(g, l, o)) : h.push(g), h.push("</div>"), h.push("</td>");
      }
    }
    return h.join("");
  }, getStyleValue: function(e) {
    var n = "", r = "";
    return typeof e == "string" ? r = e : e && (n = e.class || "", r = e.style || ""), { c: n, s: r };
  }, refreshRow: function(e, n) {
    this.updateRow.call(this, e, n, {});
  }, updateRow: function(e, n, r) {
    var o = $.data(e, "datagrid").options, l = o.finder.getRow(e, n);
    $.extend(l, r);
    var u = f.call(this, n), h = u.s, c = "datagrid-row " + (n % 2 && o.striped ? "datagrid-row-alt " : " ") + u.c;
    function f(m) {
      var g = o.rowStyler ? o.rowStyler.call(e, m, l) : "";
      return this.getStyleValue(g);
    }
    function v(m) {
      var g = o.finder.getTr(e, n, "body", m ? 1 : 2);
      if (g.length) {
        var y = $(e).datagrid("getColumnFields", m), w = g.find("div.datagrid-cell-check input[type=checkbox]").is(":checked");
        g.html(this.renderRow.call(this, e, y, m, n, l));
        var E = (g.hasClass("datagrid-row-checked") ? " datagrid-row-checked" : "") + (g.hasClass("datagrid-row-selected") ? " datagrid-row-selected" : "");
        g.attr("style", h).attr("class", c + E), w && g.find("div.datagrid-cell-check input[type=checkbox]")._propAttr("checked", !0);
      }
    }
    v.call(this, !0), v.call(this, !1), $(e).datagrid("fixRowHeight", n);
  }, insertRow: function(e, n, r) {
    var o = $.data(e, "datagrid"), l = o.options, u = o.dc, h = o.data;
    (n == null || n == null) && (n = h.rows.length), n > h.rows.length && (n = h.rows.length);
    function c(v) {
      for (var m = v ? 1 : 2, g = h.rows.length - 1; g >= n; g--) {
        var y = l.finder.getTr(e, g, "body", m);
        if (y.attr("datagrid-row-index", g + 1), y.attr("id", o.rowIdPrefix + "-" + m + "-" + (g + 1)), v && l.rownumbers) {
          var w = g + 2;
          l.pagination && (w += (l.pageNumber - 1) * l.pageSize), y.find("div.datagrid-cell-rownumber").html(w);
        }
        l.striped && y.removeClass("datagrid-row-alt").addClass((g + 1) % 2 ? "datagrid-row-alt" : "");
      }
    }
    function f(v) {
      var m = v ? 1 : 2;
      $(e).datagrid("getColumnFields", v);
      var g = o.rowIdPrefix + "-" + m + "-" + n, y = '<tr id="' + g + '" class="datagrid-row" datagrid-row-index="' + n + '"></tr>';
      if (n >= h.rows.length)
        if (h.rows.length)
          l.finder.getTr(e, "", "last", m).after(y);
        else {
          var w = v ? u.body1 : u.body2;
          w.html('<table class="datagrid-btable" cellspacing="0" cellpadding="0" border="0"><tbody>' + y + "</tbody></table>");
        }
      else
        l.finder.getTr(e, n + 1, "body", m).before(y);
    }
    c.call(this, !0), c.call(this, !1), f.call(this, !0), f.call(this, !1), h.total += 1, h.rows.splice(n, 0, r), this.setEmptyMsg(e), this.refreshRow.call(this, e, n);
  }, deleteRow: function(e, n) {
    var r = $.data(e, "datagrid"), o = r.options, l = r.data;
    function u(h) {
      for (var c = h ? 1 : 2, f = n + 1; f < l.rows.length; f++) {
        var v = o.finder.getTr(e, f, "body", c);
        if (v.attr("datagrid-row-index", f - 1), v.attr("id", r.rowIdPrefix + "-" + c + "-" + (f - 1)), h && o.rownumbers) {
          var m = f;
          o.pagination && (m += (o.pageNumber - 1) * o.pageSize), v.find("div.datagrid-cell-rownumber").html(m);
        }
        o.striped && v.removeClass("datagrid-row-alt").addClass((f - 1) % 2 ? "datagrid-row-alt" : "");
      }
    }
    o.finder.getTr(e, n).remove(), u.call(this, !0), u.call(this, !1), l.total -= 1, l.rows.splice(n, 1), this.setEmptyMsg(e);
  }, onBeforeRender: function(e, n) {
  }, onAfterRender: function(e) {
    var n = $.data(e, "datagrid"), r = n.options;
    if (r.showFooter) {
      var o = $(e).datagrid("getPanel").find("div.datagrid-footer");
      o.find("div.datagrid-cell-rownumber,div.datagrid-cell-check").css("visibility", "hidden");
    }
    this.setEmptyMsg(e);
  }, setEmptyMsg: function(e) {
    var n = $.data(e, "datagrid"), r = n.options, o = r.finder.getRows(e).length == 0;
    if (o && this.renderEmptyRow(e), r.emptyMsg && (n.dc.view.children(".datagrid-empty").remove(), o)) {
      var l = n.dc.header2.parent().outerHeight(), u = $('<div class="datagrid-empty"></div>').appendTo(n.dc.view);
      u.html(r.emptyMsg).css("top", l + "px");
    }
  }, renderEmptyRow: function(e) {
    var n = $.map($(e).datagrid("getColumnFields"), function(l) {
      return $(e).datagrid("getColumnOption", l);
    });
    $.map(n, function(l) {
      l.formatter1 = l.formatter, l.styler1 = l.styler, l.formatter = l.styler = void 0;
    });
    var r = $.data(e, "datagrid").dc.body2;
    r.html(this.renderTable(e, 0, [{}], !1)), r.find("tbody *").css({ height: 1, borderColor: "transparent", background: "transparent" });
    var o = r.find(".datagrid-row");
    o.removeClass("datagrid-row").removeAttr("datagrid-row-index"), o.find(".datagrid-cell,.datagrid-cell-check").empty(), $.map(n, function(l) {
      l.formatter = l.formatter1, l.styler = l.styler1, l.formatter1 = l.styler1 = void 0;
    });
  } };
  $.fn.datagrid.defaults = $.extend({}, $.fn.panel.defaults, { sharedStyleSheet: !1, frozenColumns: void 0, columns: void 0, fitColumns: !1, resizeHandle: "right", autoRowHeight: !0, toolbar: null, striped: !1, method: "post", nowrap: !0, idField: null, url: null, data: null, loadMsg: "Processing, please wait ...", emptyMsg: "", rownumbers: !1, singleSelect: !1, ctrlSelect: !1, selectOnCheck: !0, checkOnSelect: !0, pagination: !1, pagePosition: "bottom", pageNumber: 1, pageSize: 10, pageList: [10, 20, 30, 40, 50], queryParams: {}, sortName: null, sortOrder: "asc", multiSort: !1, remoteSort: !0, showHeader: !0, showFooter: !1, scrollOnSelect: !0, scrollbarSize: 18, rownumberWidth: 30, editorHeight: 24, headerEvents: { mouseover: _6ae(!0), mouseout: _6ae(!1), click: _6b2, dblclick: _6b7, contextmenu: _6ba }, rowEvents: { mouseover: _6bc(!0), mouseout: _6bc(!1), click: _6c3, dblclick: _6cd, contextmenu: _6d1 }, rowStyler: function(e, n) {
  }, loader: function(e, n, r) {
    var o = $(this).datagrid("options");
    if (!o.url)
      return !1;
    $.ajax({ type: o.method, url: o.url, data: e, dataType: "json", success: function(l) {
      n(l);
    }, error: function() {
      r.apply(this, arguments);
    } });
  }, loadFilter: function(e) {
    return e;
  }, editors: _7dd, finder: { getTr: function(e, n, r, o) {
    r = r || "body", o = o || 0;
    var l = $.data(e, "datagrid"), u = l.dc, h = l.options;
    if (o == 0) {
      var c = h.finder.getTr(e, n, r, 1), f = h.finder.getTr(e, n, r, 2);
      return c.add(f);
    } else if (r == "body") {
      var v = $("#" + l.rowIdPrefix + "-" + o + "-" + n);
      return v.length || (v = (o == 1 ? u.body1 : u.body2).find(">table>tbody>tr[datagrid-row-index=" + n + "]")), v;
    } else {
      if (r == "footer")
        return (o == 1 ? u.footer1 : u.footer2).find(">table>tbody>tr[datagrid-row-index=" + n + "]");
      if (r == "selected")
        return (o == 1 ? u.body1 : u.body2).find(">table>tbody>tr.datagrid-row-selected");
      if (r == "highlight")
        return (o == 1 ? u.body1 : u.body2).find(">table>tbody>tr.datagrid-row-over");
      if (r == "checked")
        return (o == 1 ? u.body1 : u.body2).find(">table>tbody>tr.datagrid-row-checked");
      if (r == "editing")
        return (o == 1 ? u.body1 : u.body2).find(">table>tbody>tr.datagrid-row-editing");
      if (r == "last")
        return (o == 1 ? u.body1 : u.body2).find(">table>tbody>tr[datagrid-row-index]:last");
      if (r == "allbody")
        return (o == 1 ? u.body1 : u.body2).find(">table>tbody>tr[datagrid-row-index]");
      if (r == "allfooter")
        return (o == 1 ? u.footer1 : u.footer2).find(">table>tbody>tr[datagrid-row-index]");
    }
  }, getRow: function(e, n) {
    var r = typeof n == "object" ? n.attr("datagrid-row-index") : n;
    return $.data(e, "datagrid").data.rows[parseInt(r)];
  }, getRows: function(e) {
    return $(e).datagrid("getRows");
  } }, view: _826, onBeforeLoad: function(e) {
  }, onLoadSuccess: function() {
  }, onLoadError: function() {
  }, onClickRow: function(e, n) {
  }, onDblClickRow: function(e, n) {
  }, onClickCell: function(e, n, r) {
  }, onDblClickCell: function(e, n, r) {
  }, onBeforeSortColumn: function(e, n) {
  }, onSortColumn: function(e, n) {
  }, onResizeColumn: function(e, n) {
  }, onBeforeSelect: function(e, n) {
  }, onSelect: function(e, n) {
  }, onBeforeUnselect: function(e, n) {
  }, onUnselect: function(e, n) {
  }, onSelectAll: function(e) {
  }, onUnselectAll: function(e) {
  }, onBeforeCheck: function(e, n) {
  }, onCheck: function(e, n) {
  }, onBeforeUncheck: function(e, n) {
  }, onUncheck: function(e, n) {
  }, onCheckAll: function(e) {
  }, onUncheckAll: function(e) {
  }, onBeforeEdit: function(e, n) {
  }, onBeginEdit: function(e, n) {
  }, onEndEdit: function(e, n, r) {
  }, onAfterEdit: function(e, n, r) {
  }, onCancelEdit: function(e, n) {
  }, onHeaderContextMenu: function(e, n) {
  }, onRowContextMenu: function(e, n, r) {
  } });
})($);
(function(e) {
  var n;
  e(document).unbind(".propertygrid").bind("mousedown.propertygrid", function(u) {
    var h = e(u.target).closest("div.datagrid-view,div.combo-panel");
    h.length || (o(n), n = void 0);
  });
  function r(u) {
    e.data(u, "propertygrid");
    var h = e.data(u, "propertygrid").options;
    e(u).datagrid(e.extend({}, h, { cls: "propertygrid", view: h.showGroup ? h.groupView : h.view, onBeforeEdit: function(c, m) {
      if (h.onBeforeEdit.call(u, c, m) == !1)
        return !1;
      var v = e(this), m = v.datagrid("getRows")[c], g = v.datagrid("getColumnOption", "value");
      g.editor = m.editor;
    }, onClickCell: function(c, f, v) {
      if (n != this && (o(n), n = this), h.editIndex != c) {
        o(n), e(this).datagrid("beginEdit", c);
        var m = e(this).datagrid("getEditor", { index: c, field: f });
        if (m || (m = e(this).datagrid("getEditor", { index: c, field: "value" })), m) {
          var g = e(m.target), y = g.data("textbox") ? g.textbox("textbox") : g;
          y.focus(), h.editIndex = c;
        }
      }
      h.onClickCell.call(u, c, f, v);
    }, loadFilter: function(c) {
      return o(this), h.loadFilter.call(this, c);
    } }));
  }
  function o(u) {
    var h = e(u);
    if (h.length) {
      var c = e.data(u, "propertygrid").options;
      c.finder.getTr(u, null, "editing").each(function() {
        var f = parseInt(e(this).attr("datagrid-row-index"));
        h.datagrid("validateRow", f) ? h.datagrid("endEdit", f) : h.datagrid("cancelEdit", f);
      }), c.editIndex = void 0;
    }
  }
  e.fn.propertygrid = function(u, h) {
    if (typeof u == "string") {
      var c = e.fn.propertygrid.methods[u];
      return c ? c(this, h) : this.datagrid(u, h);
    }
    return u = u || {}, this.each(function() {
      var f = e.data(this, "propertygrid");
      if (f)
        e.extend(f.options, u);
      else {
        var v = e.extend({}, e.fn.propertygrid.defaults, e.fn.propertygrid.parseOptions(this), u);
        v.frozenColumns = e.extend(!0, [], v.frozenColumns), v.columns = e.extend(!0, [], v.columns), e.data(this, "propertygrid", { options: v });
      }
      r(this);
    });
  }, e.fn.propertygrid.methods = { options: function(u) {
    return e.data(u[0], "propertygrid").options;
  } }, e.fn.propertygrid.parseOptions = function(u) {
    return e.extend({}, e.fn.datagrid.parseOptions(u), e.parser.parseOptions(u, [{ showGroup: "boolean" }]));
  };
  var l = e.extend({}, e.fn.datagrid.defaults.view, { render: function(u, h, c) {
    for (var f = [], v = this.groups, m = 0; m < v.length; m++)
      f.push(this.renderGroup.call(this, u, m, v[m], c));
    e(h).html(f.join(""));
  }, renderGroup: function(u, h, c, f) {
    var v = e.data(u, "datagrid"), m = v.options, g = e(u).datagrid("getColumnFields", f), y = [];
    y.push('<div class="datagrid-group" group-index=' + h + ">"), (f && (m.rownumbers || m.frozenColumns.length) || !f && !(m.rownumbers || m.frozenColumns.length)) && (y.push('<span class="datagrid-group-expander">'), y.push('<span class="datagrid-row-expander datagrid-row-collapse">&nbsp;</span>'), y.push("</span>")), f || (y.push('<span class="datagrid-group-title">'), y.push(m.groupFormatter.call(u, c.value, c.rows)), y.push("</span>")), y.push("</div>"), y.push('<table class="datagrid-btable" cellspacing="0" cellpadding="0" border="0"><tbody>');
    for (var w = c.startIndex, E = 0; E < c.rows.length; E++) {
      var x = m.rowStyler ? m.rowStyler.call(u, w, c.rows[E]) : "", D = "", F = "";
      typeof x == "string" ? F = x : x && (D = x.class || "", F = x.style || "");
      var k = 'class="datagrid-row ' + (w % 2 && m.striped ? "datagrid-row-alt " : " ") + D + '"', N = F ? 'style="' + F + '"' : "", H = v.rowIdPrefix + "-" + (f ? 1 : 2) + "-" + w;
      y.push('<tr id="' + H + '" datagrid-row-index="' + w + '" ' + k + " " + N + ">"), y.push(this.renderRow.call(this, u, g, f, w, c.rows[E])), y.push("</tr>"), w++;
    }
    return y.push("</tbody></table>"), y.join("");
  }, bindEvents: function(u) {
    var h = e.data(u, "datagrid"), c = h.dc, f = c.body1.add(c.body2), v = (e.data(f[0], "events") || e._data(f[0], "events")).click[0].handler;
    f.unbind("click").bind("click", function(m) {
      var g = e(m.target), y = g.closest("span.datagrid-row-expander");
      if (y.length) {
        var w = y.closest("div.datagrid-group").attr("group-index");
        y.hasClass("datagrid-row-collapse") ? e(u).datagrid("collapseGroup", w) : e(u).datagrid("expandGroup", w);
      } else
        v(m);
      m.stopPropagation();
    });
  }, onBeforeRender: function(u, h) {
    var c = e.data(u, "datagrid"), f = c.options;
    F();
    for (var v = [], m = 0; m < h.length; m++) {
      var g = h[m], y = D(g[f.groupField]);
      y ? y.rows.push(g) : (y = { value: g[f.groupField], rows: [g] }, v.push(y));
    }
    for (var w = 0, E = [], m = 0; m < v.length; m++) {
      var y = v[m];
      y.startIndex = w, w += y.rows.length, E = E.concat(y.rows);
    }
    c.data.rows = E, this.groups = v;
    var x = this;
    setTimeout(function() {
      x.bindEvents(u);
    }, 0);
    function D(k) {
      for (var N = 0; N < v.length; N++) {
        var H = v[N];
        if (H.value == k)
          return H;
      }
      return null;
    }
    function F() {
      e("#datagrid-group-style").length || e("head").append('<style id="datagrid-group-style">.datagrid-group{height:' + f.groupHeight + "px;overflow:hidden;font-weight:bold;border-bottom:1px solid #ccc;}.datagrid-group-title,.datagrid-group-expander{display:inline-block;vertical-align:bottom;height:100%;line-height:" + f.groupHeight + "px;padding:0 4px;}.datagrid-group-expander{width:" + f.expanderWidth + "px;text-align:center;padding:0}.datagrid-row-expander{margin:" + Math.floor((f.groupHeight - 16) / 2) + "px 0;display:inline-block;width:16px;height:16px;cursor:pointer}</style>");
    }
  } });
  e.extend(e.fn.datagrid.methods, { groups: function(u) {
    return u.datagrid("options").view.groups;
  }, expandGroup: function(u, h) {
    return u.each(function() {
      var c = e.data(this, "datagrid").dc.view, f = c.find(h != null ? 'div.datagrid-group[group-index="' + h + '"]' : "div.datagrid-group"), v = f.find("span.datagrid-row-expander");
      v.hasClass("datagrid-row-expand") && (v.removeClass("datagrid-row-expand").addClass("datagrid-row-collapse"), f.next("table").show()), e(this).datagrid("fixRowHeight");
    });
  }, collapseGroup: function(u, h) {
    return u.each(function() {
      var c = e.data(this, "datagrid").dc.view, f = c.find(h != null ? 'div.datagrid-group[group-index="' + h + '"]' : "div.datagrid-group"), v = f.find("span.datagrid-row-expander");
      v.hasClass("datagrid-row-collapse") && (v.removeClass("datagrid-row-collapse").addClass("datagrid-row-expand"), f.next("table").hide()), e(this).datagrid("fixRowHeight");
    });
  } }), e.extend(l, { refreshGroupTitle: function(u, h) {
    var c = e.data(u, "datagrid"), f = c.options, v = c.dc, m = this.groups[h], g = v.body2.children("div.datagrid-group[group-index=" + h + "]").find("span.datagrid-group-title");
    g.html(f.groupFormatter.call(u, m.value, m.rows));
  }, insertRow: function(u, h, c) {
    var f = e.data(u, "datagrid"), v = f.options, m = f.dc, g = null, y;
    if (!f.data.rows.length) {
      e(u).datagrid("loadData", [c]);
      return;
    }
    for (var w = 0; w < this.groups.length; w++)
      if (this.groups[w].value == c[v.groupField]) {
        g = this.groups[w], y = w;
        break;
      }
    g ? ((h == null || h == null) && (h = f.data.rows.length), h < g.startIndex ? h = g.startIndex : h > g.startIndex + g.rows.length && (h = g.startIndex + g.rows.length), e.fn.datagrid.defaults.view.insertRow.call(this, u, h, c), h >= g.startIndex + g.rows.length && (E(h, !0), E(h, !1)), g.rows.splice(h - g.startIndex, 0, c)) : (g = { value: c[v.groupField], rows: [c], startIndex: f.data.rows.length }, y = this.groups.length, m.body1.append(this.renderGroup.call(this, u, y, g, !0)), m.body2.append(this.renderGroup.call(this, u, y, g, !1)), this.groups.push(g), f.data.rows.push(c)), this.refreshGroupTitle(u, y);
    function E(x, D) {
      var F = D ? 1 : 2, k = v.finder.getTr(u, x - 1, "body", F), N = v.finder.getTr(u, x, "body", F);
      N.insertAfter(k);
    }
  }, updateRow: function(u, h, c) {
    var f = e.data(u, "datagrid").options;
    e.fn.datagrid.defaults.view.updateRow.call(this, u, h, c);
    var v = f.finder.getTr(u, h, "body", 2).closest("table.datagrid-btable"), m = parseInt(v.prev().attr("group-index"));
    this.refreshGroupTitle(u, m);
  }, deleteRow: function(u, x) {
    var c = e.data(u, "datagrid"), f = c.options, v = c.dc, m = v.body1.add(v.body2), g = f.finder.getTr(u, x, "body", 2).closest("table.datagrid-btable"), y = parseInt(g.prev().attr("group-index"));
    e.fn.datagrid.defaults.view.deleteRow.call(this, u, x);
    var w = this.groups[y];
    if (w.rows.length > 1)
      w.rows.splice(x - w.startIndex, 1), this.refreshGroupTitle(u, y);
    else {
      m.children("div.datagrid-group[group-index=" + y + "]").remove();
      for (var E = y + 1; E < this.groups.length; E++)
        m.children("div.datagrid-group[group-index=" + E + "]").attr("group-index", E - 1);
      this.groups.splice(y, 1);
    }
    for (var x = 0, E = 0; E < this.groups.length; E++) {
      var w = this.groups[E];
      w.startIndex = x, x += w.rows.length;
    }
  } }), e.fn.propertygrid.defaults = e.extend({}, e.fn.datagrid.defaults, { groupHeight: 21, expanderWidth: 16, singleSelect: !0, remoteSort: !1, fitColumns: !0, loadMsg: "", frozenColumns: [[{ field: "f", width: 16, resizable: !1 }]], columns: [[{ field: "name", title: "Name", width: 100, sortable: !0 }, { field: "value", title: "Value", width: 100, resizable: !1 }]], showGroup: !1, groupView: l, groupField: "group", groupFormatter: function(u, h) {
    return u;
  } });
})($);
(function(e) {
  function n(G) {
    var Y = e.data(G, "treegrid"), it = Y.options;
    e(G).datagrid(e.extend({}, it, { url: null, data: null, loader: function() {
      return !1;
    }, onBeforeLoad: function() {
      return !1;
    }, onLoadSuccess: function() {
    }, onResizeColumn: function(bt, yt) {
      r(G), it.onResizeColumn.call(G, bt, yt);
    }, onBeforeSortColumn: function(bt, yt) {
      if (it.onBeforeSortColumn.call(G, bt, yt) == !1)
        return !1;
    }, onSortColumn: function(bt, yt) {
      if (it.sortName = bt, it.sortOrder = yt, it.remoteSort)
        x(G);
      else {
        var St = e(G).treegrid("getData");
        E(G, null, St);
      }
      it.onSortColumn.call(G, bt, yt);
    }, onClickCell: function(bt, yt) {
      it.onClickCell.call(G, yt, R(G, bt));
    }, onDblClickCell: function(bt, yt) {
      it.onDblClickCell.call(G, yt, R(G, bt));
    }, onRowContextMenu: function(bt, yt) {
      it.onContextMenu.call(G, bt, R(G, yt));
    } }));
    var rt = e.data(G, "datagrid").options;
    if (it.columns = rt.columns, it.frozenColumns = rt.frozenColumns, Y.dc = e.data(G, "datagrid").dc, it.pagination) {
      var ht = e(G).datagrid("getPager");
      ht.pagination({ pageNumber: it.pageNumber, pageSize: it.pageSize, pageList: it.pageList, onSelectPage: function(bt, yt) {
        it.pageNumber = bt, it.pageSize = yt, x(G);
      } }), it.pageSize = ht.pagination("options").pageSize;
    }
  }
  function r(G, Y) {
    var it = e.data(G, "datagrid").options, rt = e.data(G, "datagrid").dc;
    if (!rt.body1.is(":empty") && (!it.nowrap || it.autoRowHeight) && Y != null)
      for (var ht = N(G, Y), bt = 0; bt < ht.length; bt++)
        yt(ht[bt][it.idField]);
    e(G).datagrid("fixRowHeight", Y);
    function yt(St) {
      var Ft = it.finder.getTr(G, St, "body", 1), zt = it.finder.getTr(G, St, "body", 2);
      Ft.css("height", ""), zt.css("height", "");
      var Zt = Math.max(Ft.height(), zt.height());
      Ft.css("height", Zt), zt.css("height", Zt);
    }
  }
  function o(G) {
    var Y = e.data(G, "datagrid").dc, it = e.data(G, "treegrid").options;
    it.rownumbers && Y.body1.find("div.datagrid-cell-rownumber").each(function(rt) {
      e(this).html(rt + 1);
    });
  }
  function l(G) {
    return function(Y) {
      e.fn.datagrid.defaults.rowEvents[G ? "mouseover" : "mouseout"](Y);
      var it = e(Y.target), rt = G ? "addClass" : "removeClass";
      it.hasClass("tree-hit") && (it.hasClass("tree-expanded") ? it[rt]("tree-expanded-hover") : it[rt]("tree-collapsed-hover"));
    };
  }
  function u(G) {
    var Y = e(G.target), it = Y.closest("tr.datagrid-row");
    if (!(!it.length || !it.parent().length)) {
      var rt = it.attr("node-id"), ht = h(it);
      if (Y.hasClass("tree-hit"))
        tt(ht, rt);
      else if (Y.hasClass("tree-checkbox"))
        c(ht, rt);
      else {
        var bt = e(ht).datagrid("options");
        if (!Y.parent().hasClass("datagrid-cell-check") && !bt.singleSelect && G.shiftKey) {
          var yt = e(ht).treegrid("getChildren"), St = e.easyui.indexOfArray(yt, bt.idField, bt.lastSelectedIndex), Ft = e.easyui.indexOfArray(yt, bt.idField, rt), zt = Math.min(Math.max(St, 0), Ft), Zt = Math.max(St, Ft), J = yt[Ft], et = Y.closest("td[field]", it);
          if (et.length) {
            var at = et.attr("field");
            bt.onClickCell.call(ht, rt, at, J[at]);
          }
          e(ht).treegrid("clearSelections");
          for (var gt = zt; gt <= Zt; gt++)
            e(ht).treegrid("selectRow", yt[gt][bt.idField]);
          bt.onClickRow.call(ht, J);
        } else
          e.fn.datagrid.defaults.rowEvents.click(G);
      }
    }
  }
  function h(G) {
    return e(G).closest("div.datagrid-view").children(".datagrid-f")[0];
  }
  function c(G, Y, it, rt) {
    var ht = e.data(G, "treegrid");
    ht.checkedRows;
    var bt = ht.options;
    if (bt.checkbox) {
      var yt = R(G, Y);
      if (yt.checkState) {
        var St = bt.finder.getTr(G, Y), Ft = St.find(".tree-checkbox");
        if (it == null && (Ft.hasClass("tree-checkbox1") ? it = !1 : Ft.hasClass("tree-checkbox0") ? it = !0 : (yt._checked == null && (yt._checked = Ft.hasClass("tree-checkbox1")), it = !yt._checked)), yt._checked = it, it) {
          if (Ft.hasClass("tree-checkbox1"))
            return;
        } else if (Ft.hasClass("tree-checkbox0"))
          return;
        !rt && bt.onBeforeCheckNode.call(G, yt, it) == !1 || (bt.cascadeCheck ? (v(G, yt, it), m(G, yt)) : f(G, yt, it ? "1" : "0"), rt || bt.onCheckNode.call(G, yt, it));
      }
    }
  }
  function f(G, Y, it) {
    var rt = e.data(G, "treegrid"), ht = rt.checkedRows, bt = rt.options;
    if (!(!Y.checkState || it == null)) {
      var yt = bt.finder.getTr(G, Y[bt.idField]), St = yt.find(".tree-checkbox");
      St.length && (Y.checkState = ["unchecked", "checked", "indeterminate"][it], Y.checked = Y.checkState == "checked", St.removeClass("tree-checkbox0 tree-checkbox1 tree-checkbox2"), St.addClass("tree-checkbox" + it), it == 0 ? e.easyui.removeArrayItem(ht, bt.idField, Y[bt.idField]) : e.easyui.addArrayItem(ht, bt.idField, Y));
    }
  }
  function v(G, Y, it) {
    var rt = it ? 1 : 0;
    f(G, Y, rt), e.easyui.forEach(Y.children || [], !0, function(ht) {
      f(G, ht, rt);
    });
  }
  function m(G, Y) {
    var it = e.data(G, "treegrid").options, rt = k(G, Y[it.idField]);
    rt && (f(G, rt, g(rt)), m(G, rt));
  }
  function g(G) {
    var Y = 0, it = 0, rt = 0;
    if (e.easyui.forEach(G.children || [], !1, function(bt) {
      bt.checkState && (Y++, bt.checkState == "checked" ? rt++ : bt.checkState == "unchecked" && it++);
    }), Y != 0) {
      var ht = 0;
      return it == Y ? ht = 0 : rt == Y ? ht = 1 : ht = 2, ht;
    }
  }
  function y(G, Y) {
    var it = e.data(G, "treegrid").options;
    if (it.checkbox) {
      var rt = R(G, Y), ht = it.finder.getTr(G, Y), bt = ht.find(".tree-checkbox");
      if (it.view.hasCheckbox(G, rt))
        if (bt.length || (rt.checkState = rt.checkState || "unchecked", e('<span class="tree-checkbox"></span>').insertBefore(ht.find(".tree-title"))), rt.checkState == "checked")
          c(G, Y, !0, !0);
        else if (rt.checkState == "unchecked")
          c(G, Y, !1, !0);
        else {
          var yt = g(rt);
          yt === 0 ? c(G, Y, !1, !0) : yt === 1 && c(G, Y, !0, !0);
        }
      else
        bt.remove(), rt.checkState = void 0, rt.checked = void 0, m(G, rt);
    }
  }
  function w(G, Y) {
    var it = e.data(G, "treegrid").options, rt = it.finder.getTr(G, Y, "body", 1), ht = it.finder.getTr(G, Y, "body", 2), bt = e(G).datagrid("getColumnFields", !0).length + (it.rownumbers ? 1 : 0), yt = e(G).datagrid("getColumnFields", !1).length;
    St(rt, bt), St(ht, yt);
    function St(Ft, zt) {
      e('<tr class="treegrid-tr-tree"><td style="border:0px" colspan="' + zt + '"><div></div></td></tr>').insertAfter(Ft);
    }
  }
  function E(G, Y, it, rt, ht) {
    var bt = e.data(G, "treegrid"), yt = bt.options, St = bt.dc;
    it = yt.loadFilter.call(G, it, Y);
    var Ft = R(G, Y);
    if (Ft) {
      var zt = yt.finder.getTr(G, Y, "body", 1), Zt = yt.finder.getTr(G, Y, "body", 2), J = zt.next("tr.treegrid-tr-tree").children("td").children("div"), et = Zt.next("tr.treegrid-tr-tree").children("td").children("div");
      rt || (Ft.children = []);
    } else {
      var J = St.body1, et = St.body2;
      rt || (bt.data = []);
    }
    if (rt || (J.empty(), et.empty()), yt.view.onBeforeRender && yt.view.onBeforeRender.call(yt.view, G, Y, it), yt.view.render.call(yt.view, G, J, !0), yt.view.render.call(yt.view, G, et, !1), yt.showFooter && (yt.view.renderFooter.call(yt.view, G, St.footer1, !0), yt.view.renderFooter.call(yt.view, G, St.footer2, !1)), yt.view.onAfterRender && yt.view.onAfterRender.call(yt.view, G), !Y && yt.pagination) {
      var at = e.data(G, "treegrid").total, gt = e(G).datagrid("getPager");
      gt.pagination("options").total != at && gt.pagination({ total: at });
    }
    r(G), o(G), e(G).treegrid("showLines"), e(G).treegrid("setSelectionState"), e(G).treegrid("autoSizeColumn"), ht || yt.onLoadSuccess.call(G, Ft, it);
  }
  function x(G, Y, it, rt, ht) {
    var bt = e.data(G, "treegrid").options, yt = e(G).datagrid("getPanel").find("div.datagrid-body");
    Y == null && bt.queryParams && (bt.queryParams.id = void 0), it && (bt.queryParams = it);
    var St = e.extend({}, bt.queryParams);
    bt.pagination && e.extend(St, { page: bt.pageNumber, rows: bt.pageSize }), bt.sortName && e.extend(St, { sort: bt.sortName, order: bt.sortOrder });
    var Ft = R(G, Y);
    if (bt.onBeforeLoad.call(G, Ft, St) != !1) {
      var zt = yt.find('tr[node-id="' + Y + '"] span.tree-folder');
      zt.addClass("tree-loading"), e(G).treegrid("loading");
      var Zt = bt.loader.call(G, St, function(J) {
        zt.removeClass("tree-loading"), e(G).treegrid("loaded"), E(G, Y, J, rt), ht && ht();
      }, function() {
        zt.removeClass("tree-loading"), e(G).treegrid("loaded"), bt.onLoadError.apply(G, arguments), ht && ht();
      });
      Zt == !1 && (zt.removeClass("tree-loading"), e(G).treegrid("loaded"));
    }
  }
  function D(G) {
    var Y = F(G);
    return Y.length ? Y[0] : null;
  }
  function F(G) {
    return e.data(G, "treegrid").data;
  }
  function k(G, Y) {
    var it = R(G, Y);
    return it._parentId ? R(G, it._parentId) : null;
  }
  function N(G, Y) {
    var it = e.data(G, "treegrid").data;
    if (Y) {
      var rt = R(G, Y);
      it = rt ? rt.children || [] : [];
    }
    var ht = [];
    return e.easyui.forEach(it, !0, function(bt) {
      ht.push(bt);
    }), ht;
  }
  function H(G, Y) {
    var it = e.data(G, "treegrid").options, rt = it.finder.getTr(G, Y), ht = rt.children('td[field="' + it.treeField + '"]');
    return ht.find("span.tree-indent,span.tree-hit").length;
  }
  function R(G, Y) {
    var it = e.data(G, "treegrid"), rt = it.options, ht = null;
    return e.easyui.forEach(it.data, !0, function(bt) {
      if (bt[rt.idField] == Y)
        return ht = bt, !1;
    }), ht;
  }
  function j(G, Y) {
    var it = e.data(G, "treegrid").options, rt = R(G, Y), ht = it.finder.getTr(G, Y), bt = ht.find("span.tree-hit");
    if (bt.length != 0 && !bt.hasClass("tree-collapsed") && it.onBeforeCollapse.call(G, rt) != !1) {
      bt.removeClass("tree-expanded tree-expanded-hover").addClass("tree-collapsed"), bt.next().removeClass("tree-folder-open"), rt.state = "closed", ht = ht.next("tr.treegrid-tr-tree");
      var yt = ht.children("td").children("div");
      it.animate ? yt.slideUp("normal", function() {
        e(G).treegrid("autoSizeColumn"), r(G, Y), it.onCollapse.call(G, rt);
      }) : (yt.hide(), e(G).treegrid("autoSizeColumn"), r(G, Y), it.onCollapse.call(G, rt));
    }
  }
  function S(G, Y) {
    var it = e.data(G, "treegrid").options, rt = it.finder.getTr(G, Y), ht = rt.find("span.tree-hit"), bt = R(G, Y);
    if (ht.length == 0 || ht.hasClass("tree-expanded") || it.onBeforeExpand.call(G, bt) == !1)
      return;
    ht.removeClass("tree-collapsed tree-collapsed-hover").addClass("tree-expanded"), ht.next().addClass("tree-folder-open");
    var yt = rt.next("tr.treegrid-tr-tree");
    if (yt.length) {
      var St = yt.children("td").children("div");
      zt(St);
    } else {
      w(G, bt[it.idField]);
      var yt = rt.next("tr.treegrid-tr-tree"), St = yt.children("td").children("div");
      St.hide();
      var Ft = e.extend({}, it.queryParams || {});
      Ft.id = bt[it.idField], x(G, bt[it.idField], Ft, !0, function() {
        St.is(":empty") ? yt.remove() : zt(St);
      });
    }
    function zt(Zt) {
      bt.state = "open", it.animate ? Zt.slideDown("normal", function() {
        e(G).treegrid("autoSizeColumn"), r(G, Y), it.onExpand.call(G, bt);
      }) : (Zt.show(), e(G).treegrid("autoSizeColumn"), r(G, Y), it.onExpand.call(G, bt));
    }
  }
  function tt(G, Y) {
    var it = e.data(G, "treegrid").options, rt = it.finder.getTr(G, Y), ht = rt.find("span.tree-hit");
    ht.hasClass("tree-expanded") ? j(G, Y) : S(G, Y);
  }
  function nt(G, Y) {
    var it = e.data(G, "treegrid").options, rt = N(G, Y);
    Y && rt.unshift(R(G, Y));
    for (var ht = 0; ht < rt.length; ht++)
      j(G, rt[ht][it.idField]);
  }
  function ft(G, Y) {
    var it = e.data(G, "treegrid").options, rt = N(G, Y);
    Y && rt.unshift(R(G, Y));
    for (var ht = 0; ht < rt.length; ht++)
      S(G, rt[ht][it.idField]);
  }
  function pt(G, Y) {
    for (var it = e.data(G, "treegrid").options, rt = [], ht = k(G, Y); ht; ) {
      var bt = ht[it.idField];
      rt.unshift(bt), ht = k(G, bt);
    }
    for (var yt = 0; yt < rt.length; yt++)
      S(G, rt[yt]);
  }
  function ct(G, Y) {
    var it = e.data(G, "treegrid"), rt = it.options;
    if (Y.parent) {
      var ht = rt.finder.getTr(G, Y.parent);
      ht.next("tr.treegrid-tr-tree").length == 0 && w(G, Y.parent);
      var bt = ht.children('td[field="' + rt.treeField + '"]').children("div.datagrid-cell"), yt = bt.children("span.tree-icon");
      if (yt.hasClass("tree-file")) {
        yt.removeClass("tree-file").addClass("tree-folder tree-folder-open");
        var St = e('<span class="tree-hit tree-expanded"></span>').insertBefore(yt);
        St.prev().length && St.prev().remove();
      }
    }
    E(G, Y.parent, Y.data, it.data.length > 0, !0);
  }
  function Nt(G, Y) {
    var it = Y.before || Y.after, rt = e.data(G, "treegrid").options, ht = k(G, it);
    ct(G, { parent: ht ? ht[rt.idField] : null, data: [Y.data] });
    for (var bt = ht ? ht.children : e(G).treegrid("getRoots"), yt = 0; yt < bt.length; yt++)
      if (bt[yt][rt.idField] == it) {
        var St = bt[bt.length - 1];
        bt.splice(Y.before ? yt : yt + 1, 0, St), bt.splice(bt.length - 1, 1);
        break;
      }
    Ft(!0), Ft(!1), o(G), e(G).treegrid("showLines");
    function Ft(zt) {
      var Zt = zt ? 1 : 2, J = rt.finder.getTr(G, Y.data[rt.idField], "body", Zt), et = J.closest("table.datagrid-btable");
      J = J.parent().children();
      var at = rt.finder.getTr(G, it, "body", Zt);
      if (Y.before)
        J.insertBefore(at);
      else {
        var gt = at.next("tr.treegrid-tr-tree");
        J.insertAfter(gt.length ? gt : at);
      }
      et.remove();
    }
  }
  function kt(G, Y) {
    var it = e.data(G, "treegrid"), rt = it.options, ht = k(G, Y);
    e(G).datagrid("deleteRow", Y), e.easyui.removeArrayItem(it.checkedRows, rt.idField, Y), o(G), ht && y(G, ht[rt.idField]), it.total -= 1, e(G).datagrid("getPager").pagination("refresh", { total: it.total }), e(G).treegrid("showLines");
  }
  function Rt(G) {
    var Y = e(G), it = Y.treegrid("options");
    if (it.lines)
      Y.treegrid("getPanel").addClass("tree-lines");
    else {
      Y.treegrid("getPanel").removeClass("tree-lines");
      return;
    }
    Y.treegrid("getPanel").find("span.tree-indent").removeClass("tree-line tree-join tree-joinbottom"), Y.treegrid("getPanel").find("div.datagrid-cell").removeClass("tree-node-last tree-root-first tree-root-one");
    var rt = Y.treegrid("getRoots");
    rt.length > 1 ? yt(rt[0]).addClass("tree-root-first") : rt.length == 1 && yt(rt[0]).addClass("tree-root-one"), ht(rt), bt(rt);
    function ht(St) {
      if (e.map(St, function(zt) {
        if (zt.children && zt.children.length)
          ht(zt.children);
        else {
          var Zt = yt(zt);
          Zt.find(".tree-icon").prev().addClass("tree-join");
        }
      }), St.length) {
        var Ft = yt(St[St.length - 1]);
        Ft.addClass("tree-node-last"), Ft.find(".tree-join").removeClass("tree-join").addClass("tree-joinbottom");
      }
    }
    function bt(St) {
      e.map(St, function(at) {
        at.children && at.children.length && bt(at.children);
      });
      for (var Ft = 0; Ft < St.length - 1; Ft++) {
        var zt = St[Ft], Zt = Y.treegrid("getLevel", zt[it.idField]), J = it.finder.getTr(G, zt[it.idField]), et = J.next().find('tr.datagrid-row td[field="' + it.treeField + '"] div.datagrid-cell');
        et.find("span:eq(" + (Zt - 1) + ")").addClass("tree-line");
      }
    }
    function yt(St) {
      var Ft = it.finder.getTr(G, St[it.idField]), zt = Ft.find('td[field="' + it.treeField + '"] div.datagrid-cell');
      return zt;
    }
  }
  e.fn.treegrid = function(G, Y) {
    if (typeof G == "string") {
      var it = e.fn.treegrid.methods[G];
      return it ? it(this, Y) : this.datagrid(G, Y);
    }
    return G = G || {}, this.each(function() {
      var rt = e.data(this, "treegrid");
      rt ? e.extend(rt.options, G) : rt = e.data(this, "treegrid", { options: e.extend({}, e.fn.treegrid.defaults, e.fn.treegrid.parseOptions(this), G), data: [], checkedRows: [], tmpIds: [] }), n(this), rt.options.data && e(this).treegrid("loadData", rt.options.data), x(this);
    });
  }, e.fn.treegrid.methods = { options: function(G) {
    return e.data(G[0], "treegrid").options;
  }, resize: function(G, Y) {
    return G.each(function() {
      e(this).datagrid("resize", Y);
    });
  }, fixRowHeight: function(G, Y) {
    return G.each(function() {
      r(this, Y);
    });
  }, loadData: function(G, Y) {
    return G.each(function() {
      E(this, Y.parent, Y);
    });
  }, load: function(G, Y) {
    return G.each(function() {
      e(this).treegrid("options").pageNumber = 1, e(this).treegrid("getPager").pagination({ pageNumber: 1 }), e(this).treegrid("reload", Y);
    });
  }, reload: function(G, Y) {
    return G.each(function() {
      var it = e(this).treegrid("options"), rt = {};
      if (typeof Y == "object" ? rt = Y : (rt = e.extend({}, it.queryParams), rt.id = Y), rt.id) {
        var ht = e(this).treegrid("find", rt.id);
        ht.children && ht.children.splice(0, ht.children.length), it.queryParams = rt;
        var bt = it.finder.getTr(this, rt.id);
        bt.next("tr.treegrid-tr-tree").remove(), bt.find("span.tree-hit").removeClass("tree-expanded tree-expanded-hover").addClass("tree-collapsed"), S(this, rt.id);
      } else
        x(this, null, rt);
    });
  }, reloadFooter: function(G, Y) {
    return G.each(function() {
      var it = e.data(this, "treegrid").options, rt = e.data(this, "datagrid").dc;
      Y && (e.data(this, "treegrid").footer = Y), it.showFooter && (it.view.renderFooter.call(it.view, this, rt.footer1, !0), it.view.renderFooter.call(it.view, this, rt.footer2, !1), it.view.onAfterRender && it.view.onAfterRender.call(it.view, this), e(this).treegrid("fixRowHeight"));
    });
  }, getData: function(G) {
    return e.data(G[0], "treegrid").data;
  }, getFooterRows: function(G) {
    return e.data(G[0], "treegrid").footer;
  }, getRoot: function(G) {
    return D(G[0]);
  }, getRoots: function(G) {
    return F(G[0]);
  }, getParent: function(G, Y) {
    return k(G[0], Y);
  }, getChildren: function(G, Y) {
    return N(G[0], Y);
  }, getLevel: function(G, Y) {
    return H(G[0], Y);
  }, find: function(G, Y) {
    return R(G[0], Y);
  }, isLeaf: function(G, Y) {
    var it = e.data(G[0], "treegrid").options, rt = it.finder.getTr(G[0], Y), ht = rt.find("span.tree-hit");
    return ht.length == 0;
  }, select: function(G, Y) {
    return G.each(function() {
      e(this).datagrid("selectRow", Y);
    });
  }, unselect: function(G, Y) {
    return G.each(function() {
      e(this).datagrid("unselectRow", Y);
    });
  }, collapse: function(G, Y) {
    return G.each(function() {
      j(this, Y);
    });
  }, expand: function(G, Y) {
    return G.each(function() {
      S(this, Y);
    });
  }, toggle: function(G, Y) {
    return G.each(function() {
      tt(this, Y);
    });
  }, collapseAll: function(G, Y) {
    return G.each(function() {
      nt(this, Y);
    });
  }, expandAll: function(G, Y) {
    return G.each(function() {
      ft(this, Y);
    });
  }, expandTo: function(G, Y) {
    return G.each(function() {
      pt(this, Y);
    });
  }, append: function(G, Y) {
    return G.each(function() {
      ct(this, Y);
    });
  }, insert: function(G, Y) {
    return G.each(function() {
      Nt(this, Y);
    });
  }, remove: function(G, Y) {
    return G.each(function() {
      kt(this, Y);
    });
  }, pop: function(G, Y) {
    var it = G.treegrid("find", Y);
    return G.treegrid("remove", Y), it;
  }, refresh: function(G, Y) {
    return G.each(function() {
      var it = e.data(this, "treegrid").options;
      it.view.refreshRow.call(it.view, this, Y);
    });
  }, update: function(G, Y) {
    return G.each(function() {
      var it = e.data(this, "treegrid").options, rt = Y.row;
      it.view.updateRow.call(it.view, this, Y.id, rt), rt.checked != null && (rt = R(this, Y.id), e.extend(rt, { checkState: rt.checked ? "checked" : rt.checked === !1 ? "unchecked" : void 0 }), y(this, Y.id));
    });
  }, beginEdit: function(G, Y) {
    return G.each(function() {
      e(this).datagrid("beginEdit", Y), e(this).treegrid("fixRowHeight", Y);
    });
  }, endEdit: function(G, Y) {
    return G.each(function() {
      e(this).datagrid("endEdit", Y);
    });
  }, cancelEdit: function(G, Y) {
    return G.each(function() {
      e(this).datagrid("cancelEdit", Y);
    });
  }, showLines: function(G) {
    return G.each(function() {
      Rt(this);
    });
  }, setSelectionState: function(G) {
    return G.each(function() {
      e(this).datagrid("setSelectionState");
      for (var Y = e(this).data("treegrid"), it = 0; it < Y.tmpIds.length; it++)
        c(this, Y.tmpIds[it], !0, !0);
      Y.tmpIds = [];
    });
  }, getCheckedNodes: function(G, Y) {
    Y = Y || "checked";
    var it = [];
    return e.easyui.forEach(G.data("treegrid").checkedRows, !1, function(rt) {
      rt.checkState == Y && it.push(rt);
    }), it;
  }, checkNode: function(G, Y) {
    return G.each(function() {
      c(this, Y, !0);
    });
  }, uncheckNode: function(G, Y) {
    return G.each(function() {
      c(this, Y, !1);
    });
  }, clearChecked: function(G) {
    return G.each(function() {
      var Y = this, it = e(Y).treegrid("options");
      e(Y).datagrid("clearChecked"), e.map(e(Y).treegrid("getCheckedNodes"), function(rt) {
        c(Y, rt[it.idField], !1, !0);
      });
    });
  } }, e.fn.treegrid.parseOptions = function(G) {
    return e.extend({}, e.fn.datagrid.parseOptions(G), e.parser.parseOptions(G, ["treeField", { checkbox: "boolean", cascadeCheck: "boolean", onlyLeafCheck: "boolean" }, { animate: "boolean" }]));
  };
  var Mt = e.extend({}, e.fn.datagrid.defaults.view, { render: function(G, Y, it) {
    var rt = e.data(G, "treegrid").options, ht = e(G).datagrid("getColumnFields", it), bt = e.data(G, "datagrid").rowIdPrefix;
    if (it && !(rt.rownumbers || rt.frozenColumns && rt.frozenColumns.length))
      return;
    var yt = this;
    if (this.treeNodes && this.treeNodes.length) {
      var St = Ft.call(this, it, this.treeLevel, this.treeNodes);
      e(Y).append(St.join(""));
    }
    function Ft(zt, Zt, J) {
      for (var et = e(G).treegrid("getParent", J[0][rt.idField]), at = (et ? et.children.length : e(G).treegrid("getRoots").length) - J.length, gt = ['<table class="datagrid-btable" cellspacing="0" cellpadding="0" border="0"><tbody>'], wt = 0; wt < J.length; wt++) {
        var Et = J[wt];
        Et.state != "open" && Et.state != "closed" && (Et.state = "open");
        var qt = rt.rowStyler ? rt.rowStyler.call(G, Et) : "", Jt = this.getStyleValue(qt), Gt = 'class="datagrid-row ' + (at++ % 2 && rt.striped ? "datagrid-row-alt " : " ") + Jt.c + '"', Yt = Jt.s ? 'style="' + Jt.s + '"' : "", he = bt + "-" + (zt ? 1 : 2) + "-" + Et[rt.idField];
        if (gt.push('<tr id="' + he + '" node-id="' + Et[rt.idField] + '" ' + Gt + " " + Yt + ">"), gt = gt.concat(yt.renderRow.call(yt, G, ht, zt, Zt, Et)), gt.push("</tr>"), Et.children && Et.children.length) {
          var Pe = Ft.call(this, zt, Zt + 1, Et.children), ce = Et.state == "closed" ? "none" : "block";
          gt.push('<tr class="treegrid-tr-tree"><td style="border:0px" colspan=' + (ht.length + (rt.rownumbers ? 1 : 0)) + '><div style="display:' + ce + '">'), gt = gt.concat(Pe), gt.push("</div></td></tr>");
        }
      }
      return gt.push("</tbody></table>"), gt;
    }
  }, renderFooter: function(G, Y, it) {
    for (var rt = e.data(G, "treegrid").options, ht = e.data(G, "treegrid").footer || [], bt = e(G).datagrid("getColumnFields", it), yt = ['<table class="datagrid-ftable" cellspacing="0" cellpadding="0" border="0"><tbody>'], St = 0; St < ht.length; St++) {
      var Ft = ht[St];
      Ft[rt.idField] = Ft[rt.idField] || "foot-row-id" + St, yt.push('<tr class="datagrid-row" node-id="' + Ft[rt.idField] + '">'), yt.push(this.renderRow.call(this, G, bt, it, 0, Ft)), yt.push("</tr>");
    }
    yt.push("</tbody></table>"), e(Y).html(yt.join(""));
  }, renderRow: function(G, Y, it, rt, ht) {
    var bt = e.data(G, "treegrid"), yt = bt.options, St = [];
    it && yt.rownumbers && St.push('<td class="datagrid-td-rownumber"><div class="datagrid-cell-rownumber">0</div></td>');
    for (var Ft = 0; Ft < Y.length; Ft++) {
      var zt = Y[Ft], Zt = e(G).datagrid("getColumnOption", zt);
      if (Zt) {
        var J = Zt.styler && Zt.styler(ht[zt], ht) || "", et = this.getStyleValue(J), at = et.c ? 'class="' + et.c + '"' : "", gt = Zt.hidden ? 'style="display:none;' + et.s + '"' : et.s ? 'style="' + et.s + '"' : "";
        St.push('<td field="' + zt + '" ' + at + " " + gt + ">");
        var gt = "";
        if (Zt.checkbox || (Zt.align && (gt += "text-align:" + Zt.align + ";"), yt.nowrap ? yt.autoRowHeight && (gt += "height:auto;") : gt += "white-space:normal;height:auto;"), St.push('<div style="' + gt + '" '), Zt.checkbox ? St.push('class="datagrid-cell-check ') : St.push('class="datagrid-cell ' + Zt.cellClass), St.push('">'), Zt.checkbox)
          ht.checked ? St.push('<input type="checkbox" checked="checked"') : St.push('<input type="checkbox"'), St.push(' name="' + zt + '" value="' + (ht[zt] != null ? ht[zt] : "") + '">');
        else {
          var wt = null;
          if (Zt.formatter ? wt = Zt.formatter(ht[zt], ht) : wt = ht[zt], zt == yt.treeField) {
            for (var Et = 0; Et < rt; Et++)
              St.push('<span class="tree-indent"></span>');
            if (ht.state == "closed" ? (St.push('<span class="tree-hit tree-collapsed"></span>'), St.push('<span class="tree-icon tree-folder ' + (ht.iconCls ? ht.iconCls : "") + '"></span>')) : ht.children && ht.children.length ? (St.push('<span class="tree-hit tree-expanded"></span>'), St.push('<span class="tree-icon tree-folder tree-folder-open ' + (ht.iconCls ? ht.iconCls : "") + '"></span>')) : (St.push('<span class="tree-indent"></span>'), St.push('<span class="tree-icon tree-file ' + (ht.iconCls ? ht.iconCls : "") + '"></span>')), this.hasCheckbox(G, ht)) {
              var qt = 0, Jt = e.easyui.getArrayItem(bt.checkedRows, yt.idField, ht[yt.idField]);
              if (Jt)
                qt = Jt.checkState == "checked" ? 1 : 2, ht.checkState = Jt.checkState, ht.checked = Jt.checked, e.easyui.addArrayItem(bt.checkedRows, yt.idField, ht);
              else {
                var Gt = e.easyui.getArrayItem(bt.checkedRows, yt.idField, ht._parentId);
                Gt && Gt.checkState == "checked" && yt.cascadeCheck ? (qt = 1, ht.checked = !0, e.easyui.addArrayItem(bt.checkedRows, yt.idField, ht)) : ht.checked && e.easyui.addArrayItem(bt.tmpIds, ht[yt.idField]), ht.checkState = qt ? "checked" : "unchecked";
              }
              St.push('<span class="tree-checkbox tree-checkbox' + qt + '"></span>');
            } else
              ht.checkState = void 0, ht.checked = void 0;
            St.push('<span class="tree-title">' + wt + "</span>");
          } else
            St.push(wt);
        }
        St.push("</div>"), St.push("</td>");
      }
    }
    return St.join("");
  }, hasCheckbox: function(G, Y) {
    var it = e.data(G, "treegrid").options;
    if (it.checkbox) {
      if (e.isFunction(it.checkbox))
        return !!it.checkbox.call(G, Y);
      if (it.onlyLeafCheck) {
        if (Y.state == "open" && !(Y.children && Y.children.length))
          return !0;
      } else
        return !0;
    }
    return !1;
  }, refreshRow: function(G, Y) {
    this.updateRow.call(this, G, Y, {});
  }, updateRow: function(G, Y, it) {
    var rt = e.data(G, "treegrid").options, ht = e(G).treegrid("find", Y);
    e.extend(ht, it);
    var bt = e(G).treegrid("getLevel", Y) - 1, yt = rt.rowStyler ? rt.rowStyler.call(G, ht) : "", St = e.data(G, "datagrid").rowIdPrefix, Ft = ht[rt.idField];
    function zt(Zt) {
      var J = e(G).treegrid("getColumnFields", Zt), et = rt.finder.getTr(G, Y, "body", Zt ? 1 : 2), at = et.find("div.datagrid-cell-rownumber").html(), gt = et.find("div.datagrid-cell-check input[type=checkbox]").is(":checked");
      et.html(this.renderRow(G, J, Zt, bt, ht)), et.attr("style", yt || ""), et.find("div.datagrid-cell-rownumber").html(at), gt && et.find("div.datagrid-cell-check input[type=checkbox]")._propAttr("checked", !0), Ft != Y && (et.attr("id", St + "-" + (Zt ? 1 : 2) + "-" + Ft), et.attr("node-id", Ft));
    }
    zt.call(this, !0), zt.call(this, !1), e(G).treegrid("fixRowHeight", Y);
  }, deleteRow: function(G, Y) {
    var it = e.data(G, "treegrid").options, rt = it.finder.getTr(G, Y);
    rt.next("tr.treegrid-tr-tree").remove(), rt.remove();
    var ht = yt(Y);
    if (ht && ht.children.length == 0) {
      rt = it.finder.getTr(G, ht[it.idField]), rt.next("tr.treegrid-tr-tree").remove();
      var bt = rt.children('td[field="' + it.treeField + '"]').children("div.datagrid-cell");
      bt.find(".tree-icon").removeClass("tree-folder").addClass("tree-file"), bt.find(".tree-hit").remove(), e('<span class="tree-indent"></span>').prependTo(bt);
    }
    this.setEmptyMsg(G);
    function yt(St) {
      var Ft, zt = e(G).treegrid("getParent", St);
      zt ? Ft = zt.children : Ft = e(G).treegrid("getData");
      for (var Zt = 0; Zt < Ft.length; Zt++)
        if (Ft[Zt][it.idField] == St) {
          Ft.splice(Zt, 1);
          break;
        }
      return zt;
    }
  }, onBeforeRender: function(G, Y, it) {
    if (e.isArray(Y) && (it = { total: Y.length, rows: Y }, Y = null), !it)
      return !1;
    var rt = e.data(G, "treegrid"), ht = rt.options;
    if (it.length == null)
      it.footer && (rt.footer = it.footer), it.total && (rt.total = it.total), it = this.transfer(G, Y, it.rows);
    else {
      let yt = function(St, Ft) {
        for (var zt = 0; zt < St.length; zt++) {
          var Zt = St[zt];
          Zt._parentId = Ft, Zt.children && Zt.children.length && yt(Zt.children, Zt[ht.idField]);
        }
      };
      yt(it, Y);
    }
    this.sort(G, it), this.treeNodes = it, this.treeLevel = e(G).treegrid("getLevel", Y);
    var bt = R(G, Y);
    bt ? bt.children ? bt.children = bt.children.concat(it) : bt.children = it : rt.data = rt.data.concat(it);
  }, sort: function(G, Y) {
    var it = e.data(G, "treegrid").options;
    if (!it.remoteSort && it.sortName) {
      var rt = it.sortName.split(","), ht = it.sortOrder.split(",");
      bt(Y);
    }
    function bt(yt) {
      yt.sort(function(zt, Zt) {
        for (var J = 0, et = 0; et < rt.length; et++) {
          var at = rt[et], gt = ht[et], wt = e(G).treegrid("getColumnOption", at), Et = wt.sorter || function(qt, Jt) {
            return qt == Jt ? 0 : qt > Jt ? 1 : -1;
          };
          if (J = Et(zt[at], Zt[at]) * (gt == "asc" ? 1 : -1), J != 0)
            return J;
        }
        return J;
      });
      for (var St = 0; St < yt.length; St++) {
        var Ft = yt[St].children;
        Ft && Ft.length && bt(Ft);
      }
    }
  }, transfer: function(G, Y, it) {
    for (var rt = e.data(G, "treegrid").options, ht = e.extend([], it), bt = zt(Y, ht), yt = e.extend([], bt); yt.length; ) {
      var St = yt.shift(), Ft = zt(St[rt.idField], ht);
      Ft.length && (St.children ? St.children = St.children.concat(Ft) : St.children = Ft, yt = yt.concat(Ft));
    }
    return bt;
    function zt(Zt, J) {
      for (var et = [], at = 0; at < J.length; at++) {
        var gt = J[at];
        gt._parentId == Zt && (et.push(gt), J.splice(at, 1), at--);
      }
      return et;
    }
  } });
  e.fn.treegrid.defaults = e.extend({}, e.fn.datagrid.defaults, { treeField: null, checkbox: !1, cascadeCheck: !0, onlyLeafCheck: !1, lines: !1, animate: !1, singleSelect: !0, view: Mt, rowEvents: e.extend({}, e.fn.datagrid.defaults.rowEvents, { mouseover: l(!0), mouseout: l(!1), click: u }), loader: function(G, Y, it) {
    var rt = e(this).treegrid("options");
    if (!rt.url)
      return !1;
    e.ajax({ type: rt.method, url: rt.url, data: G, dataType: "json", success: function(ht) {
      Y(ht);
    }, error: function() {
      it.apply(this, arguments);
    } });
  }, loadFilter: function(G, Y) {
    return G;
  }, finder: { getTr: function(G, Y, it, rt) {
    it = it || "body", rt = rt || 0;
    var ht = e.data(G, "datagrid").dc;
    if (rt == 0) {
      var bt = e.data(G, "treegrid").options, yt = bt.finder.getTr(G, Y, it, 1), St = bt.finder.getTr(G, Y, it, 2);
      return yt.add(St);
    } else if (it == "body") {
      var Ft = e("#" + e.data(G, "datagrid").rowIdPrefix + "-" + rt + "-" + Y);
      return Ft.length || (Ft = (rt == 1 ? ht.body1 : ht.body2).find('tr[node-id="' + Y + '"]')), Ft;
    } else {
      if (it == "footer")
        return (rt == 1 ? ht.footer1 : ht.footer2).find('tr[node-id="' + Y + '"]');
      if (it == "selected")
        return (rt == 1 ? ht.body1 : ht.body2).find("tr.datagrid-row-selected");
      if (it == "highlight")
        return (rt == 1 ? ht.body1 : ht.body2).find("tr.datagrid-row-over");
      if (it == "checked")
        return (rt == 1 ? ht.body1 : ht.body2).find("tr.datagrid-row-checked");
      if (it == "last")
        return (rt == 1 ? ht.body1 : ht.body2).find("tr:last[node-id]");
      if (it == "allbody")
        return (rt == 1 ? ht.body1 : ht.body2).find("tr[node-id]");
      if (it == "allfooter")
        return (rt == 1 ? ht.footer1 : ht.footer2).find("tr[node-id]");
    }
  }, getRow: function(G, Y) {
    var it = typeof Y == "object" ? Y.attr("node-id") : Y;
    return e(G).treegrid("find", it);
  }, getRows: function(G) {
    return e(G).treegrid("getChildren");
  } }, onBeforeLoad: function(G, Y) {
  }, onLoadSuccess: function(G, Y) {
  }, onLoadError: function() {
  }, onBeforeCollapse: function(G) {
  }, onCollapse: function(G) {
  }, onBeforeExpand: function(G) {
  }, onExpand: function(G) {
  }, onClickRow: function(G) {
  }, onDblClickRow: function(G) {
  }, onClickCell: function(G, Y) {
  }, onDblClickCell: function(G, Y) {
  }, onContextMenu: function(G, Y) {
  }, onBeforeEdit: function(G) {
  }, onAfterEdit: function(G, Y) {
  }, onCancelEdit: function(G) {
  }, onBeforeCheckNode: function(G, Y) {
  }, onCheckNode: function(G, Y) {
  } });
})($);
(function(e) {
  function n(o) {
    var l = e.data(o, "datalist").options;
    e(o).datagrid(e.extend({}, l, { cls: "datalist" + (l.lines ? " datalist-lines" : ""), frozenColumns: l.frozenColumns && l.frozenColumns.length ? l.frozenColumns : l.checkbox ? [[{ field: "_ck", checkbox: !0 }]] : void 0, columns: l.columns && l.columns.length ? l.columns : [[{ field: l.textField, width: "100%", formatter: function(u, h, c) {
      return l.textFormatter ? l.textFormatter(u, h, c) : u;
    } }]] }));
  }
  var r = e.extend({}, e.fn.datagrid.defaults.view, { render: function(o, l, u) {
    var h = e.data(o, "datagrid"), c = h.options;
    if (c.groupField) {
      var f = this.groupRows(o, h.data.rows);
      this.groups = f.groups, h.data.rows = f.rows;
      for (var v = [], m = 0; m < f.groups.length; m++)
        v.push(this.renderGroup.call(this, o, m, f.groups[m], u));
      e(l).html(v.join(""));
    } else
      e(l).html(this.renderTable(o, 0, h.data.rows, u));
  }, renderGroup: function(o, l, u, h) {
    var c = e.data(o, "datagrid"), f = c.options;
    e(o).datagrid("getColumnFields", h);
    var v = [];
    return v.push('<div class="datagrid-group" group-index=' + l + ">"), h || (v.push('<span class="datagrid-group-title">'), v.push(f.groupFormatter.call(o, u.value, u.rows)), v.push("</span>")), v.push("</div>"), v.push(this.renderTable(o, u.startIndex, u.rows, h)), v.join("");
  }, groupRows: function(o, y) {
    for (var u = e.data(o, "datagrid"), h = u.options, c = [], f = 0; f < y.length; f++) {
      var v = y[f], m = w(v[h.groupField]);
      m ? m.rows.push(v) : (m = { value: v[h.groupField], rows: [v] }, c.push(m));
    }
    for (var g = 0, y = [], f = 0; f < c.length; f++) {
      var m = c[f];
      m.startIndex = g, g += m.rows.length, y = y.concat(m.rows);
    }
    return { groups: c, rows: y };
    function w(E) {
      for (var x = 0; x < c.length; x++) {
        var D = c[x];
        if (D.value == E)
          return D;
      }
      return null;
    }
  } });
  e.fn.datalist = function(o, l) {
    if (typeof o == "string") {
      var u = e.fn.datalist.methods[o];
      return u ? u(this, l) : this.datagrid(o, l);
    }
    return o = o || {}, this.each(function() {
      var h = e.data(this, "datalist");
      if (h)
        e.extend(h.options, o);
      else {
        var c = e.extend({}, e.fn.datalist.defaults, e.fn.datalist.parseOptions(this), o);
        c.columns = e.extend(!0, [], c.columns), h = e.data(this, "datalist", { options: c });
      }
      if (n(this), !h.options.data) {
        var f = e.fn.datalist.parseData(this);
        f.total && e(this).datalist("loadData", f);
      }
    });
  }, e.fn.datalist.methods = { options: function(o) {
    return e.data(o[0], "datalist").options;
  } }, e.fn.datalist.parseOptions = function(o) {
    return e.extend({}, e.fn.datagrid.parseOptions(o), e.parser.parseOptions(o, ["valueField", "textField", "groupField", { checkbox: "boolean", lines: "boolean" }]));
  }, e.fn.datalist.parseData = function(o) {
    var l = e.data(o, "datalist").options, u = { total: 0, rows: [] };
    return e(o).children().each(function() {
      var h = e.parser.parseOptions(this, ["value", "group"]), c = {}, f = e(this).html();
      c[l.valueField] = h.value != null ? h.value : f, c[l.textField] = f, l.groupField && (c[l.groupField] = h.group), u.total++, u.rows.push(c);
    }), u;
  }, e.fn.datalist.defaults = e.extend({}, e.fn.datagrid.defaults, { fitColumns: !0, singleSelect: !0, showHeader: !1, checkbox: !1, lines: !1, valueField: "value", textField: "text", groupField: "", view: r, textFormatter: function(o, l) {
    return o;
  }, groupFormatter: function(o, l) {
    return o;
  } });
})($);
(function(e) {
  e(function() {
    e(document).unbind(".combo").bind("mousedown.combo mousewheel.combo", function(x) {
      var D = e(x.target).closest("span.combo,div.combo-p,div.menu");
      if (D.length) {
        l(D);
        return;
      }
      e("body>div.combo-p>div.combo-panel:visible").panel("close");
    });
  });
  function n(x) {
    var D = e.data(x, "combo"), F = D.options;
    D.panel || (D.panel = e('<div class="combo-panel"></div>').appendTo("body"), D.panel.panel({ minWidth: F.panelMinWidth, maxWidth: F.panelMaxWidth, minHeight: F.panelMinHeight, maxHeight: F.panelMaxHeight, doSize: !1, closed: !0, cls: "combo-p", style: { position: "absolute", zIndex: 10 }, onOpen: function() {
      var N = e(this).panel("options").comboTarget, H = e.data(N, "combo");
      H && H.options.onShowPanel.call(N);
    }, onBeforeClose: function() {
      l(e(this).parent());
    }, onClose: function() {
      var N = e(this).panel("options").comboTarget, H = e(N).data("combo");
      H && H.options.onHidePanel.call(N);
    } }));
    var k = e.extend(!0, [], F.icons);
    F.hasDownArrow && k.push({ iconCls: "combo-arrow", handler: function(N) {
      o(N.data.target);
    } }), e(x).addClass("combo-f").textbox(e.extend({}, F, { icons: k, onChange: function() {
    } })), e(x).attr("comboName", e(x).attr("textboxName")), D.combo = e(x).next(), D.combo.addClass("combo");
  }
  function r(x) {
    var D = e.data(x, "combo"), F = D.options, k = D.panel;
    k.is(":visible") && k.panel("close"), F.cloned || k.panel("destroy"), e(x).textbox("destroy");
  }
  function o(x) {
    var D = e.data(x, "combo").panel;
    if (D.is(":visible")) {
      var F = D.combo("combo");
      f(F), F != x && e(x).combo("showPanel");
    } else {
      var k = e(x).closest("div.combo-p").children(".combo-panel");
      e("div.combo-panel:visible").not(D).not(k).panel("close"), e(x).combo("showPanel");
    }
    e(x).combo("textbox").focus();
  }
  function l(x) {
    e(x).find(".combo-f").each(function() {
      var D = e(this).combo("panel");
      D.is(":visible") && D.panel("close");
    });
  }
  function u(x) {
    var D = x.data.target, F = e.data(D, "combo"), k = F.options;
    if (!k.editable)
      o(D);
    else {
      var N = e(D).closest("div.combo-p").children(".combo-panel");
      e("div.combo-panel:visible").not(N).each(function() {
        var H = e(this).combo("combo");
        H != D && f(H);
      });
    }
  }
  function h(x) {
    var D = x.data.target, F = e(D), k = F.data("combo"), N = F.combo("options");
    switch (k.panel.panel("options").comboTarget = D, x.keyCode) {
      case 38:
        N.keyHandler.up.call(D, x);
        break;
      case 40:
        N.keyHandler.down.call(D, x);
        break;
      case 37:
        N.keyHandler.left.call(D, x);
        break;
      case 39:
        N.keyHandler.right.call(D, x);
        break;
      case 13:
        return x.preventDefault(), N.keyHandler.enter.call(D, x), !1;
      case 9:
      case 27:
        f(D);
        break;
      default:
        N.editable && (k.timer && clearTimeout(k.timer), k.timer = setTimeout(function() {
          var H = F.combo("getText");
          k.previousText != H && (k.previousText = H, F.combo("showPanel"), N.keyHandler.query.call(D, H, x), F.combo("validate"));
        }, N.delay));
    }
  }
  function c(x) {
    var D = e.data(x, "combo"), F = D.combo, k = D.panel, N = e(x).combo("options"), H = k.panel("options");
    H.comboTarget = x, H.closed && (k.panel("panel").show().css({ zIndex: e.fn.menu ? e.fn.menu.defaults.zIndex++ : e.fn.window ? e.fn.window.defaults.zIndex++ : 99, left: -999999 }), k.panel("resize", { width: N.panelWidth ? N.panelWidth : F._outerWidth(), height: N.panelHeight }), k.panel("panel").hide(), k.panel("open")), function() {
      H.comboTarget == x && k.is(":visible") && (k.panel("move", { left: R(), top: j() }), setTimeout(arguments.callee, 200));
    }();
    function R() {
      var S = F.offset().left;
      return N.panelAlign == "right" && (S += F._outerWidth() - k._outerWidth()), S + k._outerWidth() > e(window)._outerWidth() + e(document).scrollLeft() && (S = e(window)._outerWidth() + e(document).scrollLeft() - k._outerWidth()), S < 0 && (S = 0), S;
    }
    function j() {
      var S = F.offset().top + F._outerHeight();
      return S + k._outerHeight() > e(window)._outerHeight() + e(document).scrollTop() && (S = F.offset().top - k._outerHeight()), S < e(document).scrollTop() && (S = F.offset().top + F._outerHeight()), S;
    }
  }
  function f(x) {
    var D = e.data(x, "combo").panel;
    D.panel("close");
  }
  function v(x, D) {
    var F = e.data(x, "combo"), k = e(x).textbox("getText");
    k != D && e(x).textbox("setText", D), F.previousText = D;
  }
  function m(x) {
    var D = e.data(x, "combo"), F = D.options, k = e(x).next(), N = [];
    return k.find(".textbox-value").each(function() {
      N.push(e(this).val());
    }), F.multivalue ? N : N.length ? N[0].split(F.separator) : N;
  }
  function g(x, D) {
    var F = e.data(x, "combo"), k = F.combo, N = e(x).combo("options");
    e.isArray(D) || (D = D.split(N.separator));
    var H = m(x);
    if (k.find(".textbox-value").remove(), D.length)
      if (N.multivalue)
        for (var R = 0; R < D.length; R++)
          j(D[R]);
      else
        j(D.join(N.separator));
    function j(tt) {
      var nt = e(x).attr("textboxName") || "", ft = e('<input type="hidden" class="textbox-value">').appendTo(k);
      ft.attr("name", nt), N.disabled && ft.attr("disabled", "disabled"), ft.val(tt);
    }
    var S = function() {
      if (H.length != D.length)
        return !0;
      for (var tt = 0; tt < D.length; tt++)
        if (D[tt] != H[tt])
          return !0;
      return !1;
    }();
    S && (e(x).val(D.join(N.separator)), N.multiple ? N.onChange.call(x, D, H) : N.onChange.call(x, D[0], H[0]), e(x).closest("form").trigger("_change", [x]));
  }
  function y(x) {
    var D = m(x);
    return D[0];
  }
  function w(x, D) {
    g(x, [D]);
  }
  function E(x) {
    var D = e.data(x, "combo").options, F = D.onChange;
    D.onChange = function() {
    }, D.multiple ? g(x, D.value ? D.value : []) : w(x, D.value), D.onChange = F;
  }
  e.fn.combo = function(x, D) {
    if (typeof x == "string") {
      var F = e.fn.combo.methods[x];
      return F ? F(this, D) : this.textbox(x, D);
    }
    return x = x || {}, this.each(function() {
      var k = e.data(this, "combo");
      k ? (e.extend(k.options, x), x.value != null && (k.options.originalValue = x.value)) : (k = e.data(this, "combo", { options: e.extend({}, e.fn.combo.defaults, e.fn.combo.parseOptions(this), x), previousText: "" }), k.options.originalValue = k.options.value), n(this), E(this);
    });
  }, e.fn.combo.methods = { options: function(x) {
    var D = x.textbox("options");
    return e.extend(e.data(x[0], "combo").options, { width: D.width, height: D.height, disabled: D.disabled, readonly: D.readonly });
  }, cloneFrom: function(x, D) {
    return x.each(function() {
      e(this).textbox("cloneFrom", D), e.data(this, "combo", { options: e.extend(!0, { cloned: !0 }, e(D).combo("options")), combo: e(this).next(), panel: e(D).combo("panel") }), e(this).addClass("combo-f").attr("comboName", e(this).attr("textboxName"));
    });
  }, combo: function(x) {
    return x.closest(".combo-panel").panel("options").comboTarget;
  }, panel: function(x) {
    return e.data(x[0], "combo").panel;
  }, destroy: function(x) {
    return x.each(function() {
      r(this);
    });
  }, showPanel: function(x) {
    return x.each(function() {
      c(this);
    });
  }, hidePanel: function(x) {
    return x.each(function() {
      f(this);
    });
  }, clear: function(x) {
    return x.each(function() {
      e(this).textbox("setText", "");
      var D = e.data(this, "combo").options;
      D.multiple ? e(this).combo("setValues", []) : e(this).combo("setValue", "");
    });
  }, reset: function(x) {
    return x.each(function() {
      var D = e.data(this, "combo").options;
      D.multiple ? e(this).combo("setValues", D.originalValue) : e(this).combo("setValue", D.originalValue);
    });
  }, setText: function(x, D) {
    return x.each(function() {
      v(this, D);
    });
  }, getValues: function(x) {
    return m(x[0]);
  }, setValues: function(x, D) {
    return x.each(function() {
      g(this, D);
    });
  }, getValue: function(x) {
    return y(x[0]);
  }, setValue: function(x, D) {
    return x.each(function() {
      w(this, D);
    });
  } }, e.fn.combo.parseOptions = function(x) {
    var D = e(x);
    return e.extend({}, e.fn.textbox.parseOptions(x), e.parser.parseOptions(x, ["separator", "panelAlign", { panelWidth: "number", hasDownArrow: "boolean", delay: "number", reversed: "boolean", multivalue: "boolean", selectOnNavigation: "boolean" }, { panelMinWidth: "number", panelMaxWidth: "number", panelMinHeight: "number", panelMaxHeight: "number" }]), { panelHeight: D.attr("panelHeight") == "auto" ? "auto" : parseInt(D.attr("panelHeight")) || void 0, multiple: D.attr("multiple") ? !0 : void 0 });
  }, e.fn.combo.defaults = e.extend({}, e.fn.textbox.defaults, { inputEvents: { click: u, keydown: h, paste: h, drop: h }, panelWidth: null, panelHeight: 200, panelMinWidth: null, panelMaxWidth: null, panelMinHeight: null, panelMaxHeight: null, panelAlign: "left", reversed: !1, multiple: !1, multivalue: !0, selectOnNavigation: !0, separator: ",", hasDownArrow: !0, delay: 200, keyHandler: { up: function(x) {
  }, down: function(x) {
  }, left: function(x) {
  }, right: function(x) {
  }, enter: function(x) {
  }, query: function(x, D) {
  } }, onShowPanel: function() {
  }, onHidePanel: function() {
  }, onChange: function(x, D) {
  } });
})($);
(function(e) {
  function n(k, N) {
    var H = e.data(k, "combobox");
    return e.easyui.indexOfArray(H.data, H.options.valueField, N);
  }
  function r(k, N) {
    var H = e.data(k, "combobox").options, R = e(k).combo("panel"), j = H.finder.getEl(k, N);
    if (j.length) {
      if (j.position().top <= 0) {
        var S = R.scrollTop() + j.position().top;
        R.scrollTop(S);
      } else if (j.position().top + j.outerHeight() > R.height()) {
        var S = R.scrollTop() + j.position().top + j.outerHeight() - R.height();
        R.scrollTop(S);
      }
    }
    R.triggerHandler("scroll");
  }
  function o(k, N) {
    var H = e.data(k, "combobox").options, R = e(k).combobox("panel"), j = R.children("div.combobox-item-hover");
    j.length || (j = R.children("div.combobox-item-selected")), j.removeClass("combobox-item-hover");
    var S = "div.combobox-item:visible:not(.combobox-item-disabled):first", tt = "div.combobox-item:visible:not(.combobox-item-disabled):last";
    if (j.length ? N == "next" ? (j = j.nextAll(S), j.length || (j = R.children(S))) : (j = j.prevAll(S), j.length || (j = R.children(tt))) : j = R.children(N == "next" ? S : tt), j.length) {
      j.addClass("combobox-item-hover");
      var nt = H.finder.getRow(k, j);
      nt && (e(k).combobox("scrollTo", nt[H.valueField]), H.selectOnNavigation && l(k, nt[H.valueField]));
    }
  }
  function l(k, N, H) {
    var R = e.data(k, "combobox").options, j = e(k).combo("getValues");
    e.inArray(N + "", j) == -1 && (R.multiple ? j.push(N) : j = [N], h(k, j, H));
  }
  function u(k, N) {
    e.data(k, "combobox").options;
    var H = e(k).combo("getValues"), R = e.inArray(N + "", H);
    R >= 0 && (H.splice(R, 1), h(k, H));
  }
  function h(k, N, H) {
    var R = e.data(k, "combobox").options, j = e(k).combo("panel");
    e.isArray(N) || (N = N.split(R.separator)), R.multiple || (N = N.length ? [N[0]] : [""]);
    var S = e(k).combo("getValues");
    j.is(":visible") && j.find(".combobox-item-selected").each(function() {
      var G = R.finder.getRow(k, e(this));
      G && e.easyui.indexOfArray(S, G[R.valueField]) == -1 && e(this).removeClass("combobox-item-selected");
    }), e.map(S, function(G) {
      if (e.easyui.indexOfArray(N, G) == -1) {
        var Y = R.finder.getEl(k, G);
        Y.hasClass("combobox-item-selected") && (Y.removeClass("combobox-item-selected"), R.onUnselect.call(k, R.finder.getRow(k, G)));
      }
    });
    for (var tt = null, nt = [], ft = [], pt = 0; pt < N.length; pt++) {
      var ct = N[pt], Nt = ct, kt = R.finder.getRow(k, ct);
      if (kt) {
        Nt = kt[R.textField], tt = kt;
        var Rt = R.finder.getEl(k, ct);
        Rt.hasClass("combobox-item-selected") || (Rt.addClass("combobox-item-selected"), R.onSelect.call(k, kt));
      }
      nt.push(ct), ft.push(Nt);
    }
    if (H || e(k).combo("setText", ft.join(R.separator)), R.showItemIcon) {
      var Mt = e(k).combobox("textbox");
      Mt.removeClass("textbox-bgicon " + R.textboxIconCls), tt && tt.iconCls && (Mt.addClass("textbox-bgicon " + tt.iconCls), R.textboxIconCls = tt.iconCls);
    }
    e(k).combo("setValues", nt), j.triggerHandler("scroll");
  }
  function c(k, N, H) {
    var R = e.data(k, "combobox"), j = R.options;
    R.data = j.loadFilter.call(k, N), j.view.render.call(j.view, k, e(k).combo("panel"), R.data);
    var S = e(k).combobox("getValues");
    e.easyui.forEach(R.data, !1, function(tt) {
      tt.selected && e.easyui.addArrayItem(S, tt[j.valueField] + "");
    }), j.multiple ? h(k, S, H) : h(k, S.length ? [S[S.length - 1]] : [], H), j.onLoadSuccess.call(k, N);
  }
  function f(k, N, H, R) {
    var j = e.data(k, "combobox").options;
    N && (j.url = N), H = e.extend({}, j.queryParams, H || {}), j.onBeforeLoad.call(k, H) != !1 && j.loader.call(k, H, function(S) {
      c(k, S, R);
    }, function() {
      j.onLoadError.apply(this, arguments);
    });
  }
  function v(k, N) {
    var H = e.data(k, "combobox"), R = H.options, j = e(), S = R.multiple ? N.split(R.separator) : [N];
    if (R.mode == "remote")
      pt(S), f(k, null, { q: N }, !0);
    else {
      var tt = e(k).combo("panel");
      tt.find(".combobox-item-hover").removeClass("combobox-item-hover"), tt.find(".combobox-item,.combobox-group").hide();
      var nt = H.data, ft = [];
      e.map(S, function(ct) {
        ct = e.trim(ct);
        var Nt = ct, kt = void 0;
        j = e();
        for (var Rt = 0; Rt < nt.length; Rt++) {
          var Mt = nt[Rt];
          if (R.filter.call(k, ct, Mt)) {
            var G = Mt[R.valueField], Y = Mt[R.textField], it = Mt[R.groupField], rt = R.finder.getEl(k, G).show();
            Y.toLowerCase() == ct.toLowerCase() && (Nt = G, R.reversed ? j = rt : l(k, G, !0)), R.groupField && kt != it && (R.finder.getGroupEl(k, it).show(), kt = it);
          }
        }
        ft.push(Nt);
      }), pt(ft);
    }
    function pt(ct) {
      R.reversed ? j.addClass("combobox-item-hover") : h(k, R.multiple ? N ? ct : [] : ct, !0);
    }
  }
  function m(k) {
    var N = e(k), H = N.combobox("options"), R = N.combobox("panel"), j = R.children("div.combobox-item-hover");
    if (j.length) {
      j.removeClass("combobox-item-hover");
      var S = H.finder.getRow(k, j), tt = S[H.valueField];
      H.multiple && j.hasClass("combobox-item-selected") ? N.combobox("unselect", tt) : N.combobox("select", tt);
    }
    var nt = [];
    e.map(N.combobox("getValues"), function(ft) {
      n(k, ft) >= 0 && nt.push(ft);
    }), N.combobox("setValues", nt), H.multiple || N.combobox("hidePanel");
  }
  function g(k) {
    var N = e.data(k, "combobox"), H = N.options;
    e(k).addClass("combobox-f"), e(k).combo(e.extend({}, H, { onShowPanel: function() {
      e(this).combo("panel").find("div.combobox-item:hidden,div.combobox-group:hidden").show(), h(this, e(this).combobox("getValues"), !0), e(this).combobox("scrollTo", e(this).combobox("getValue")), H.onShowPanel.call(this);
    } }));
    var R = e(k).combo("panel");
    R.unbind(".combobox");
    for (var j in H.panelEvents)
      R.bind(j + ".combobox", { target: k }, H.panelEvents[j]);
  }
  function y(k) {
    e(this).children("div.combobox-item-hover").removeClass("combobox-item-hover");
    var N = e(k.target).closest("div.combobox-item");
    N.hasClass("combobox-item-disabled") || N.addClass("combobox-item-hover"), k.stopPropagation();
  }
  function w(k) {
    e(k.target).closest("div.combobox-item").removeClass("combobox-item-hover"), k.stopPropagation();
  }
  function E(k) {
    var N = e(this).panel("options").comboTarget;
    if (N) {
      var H = e(N).combobox("options"), R = e(k.target).closest("div.combobox-item");
      if (!(!R.length || R.hasClass("combobox-item-disabled"))) {
        var j = H.finder.getRow(N, R);
        if (j) {
          H.blurTimer && (clearTimeout(H.blurTimer), H.blurTimer = null), H.onClick.call(N, j);
          var S = j[H.valueField];
          H.multiple ? R.hasClass("combobox-item-selected") ? u(N, S) : l(N, S) : e(N).combobox("setValue", S).combobox("hidePanel"), k.stopPropagation();
        }
      }
    }
  }
  function x(k) {
    var N = e(this).panel("options").comboTarget;
    if (N) {
      var H = e(N).combobox("options");
      if (H.groupPosition == "sticky") {
        var R = e(this).children(".combobox-stick");
        R.length || (R = e('<div class="combobox-stick"></div>').appendTo(this)), R.hide();
        var j = e(N).data("combobox");
        e(this).children(".combobox-group:visible").each(function() {
          var S = e(this), tt = H.finder.getGroup(N, S), nt = j.data[tt.startIndex + tt.count - 1], ft = H.finder.getEl(N, nt[H.valueField]);
          if (S.position().top < 0 && ft.position().top > 0)
            return R.show().html(S.html()), !1;
        });
      }
    }
  }
  e.fn.combobox = function(k, N) {
    if (typeof k == "string") {
      var H = e.fn.combobox.methods[k];
      return H ? H(this, N) : this.combo(k, N);
    }
    return k = k || {}, this.each(function() {
      var R = e.data(this, "combobox");
      if (R ? e.extend(R.options, k) : R = e.data(this, "combobox", { options: e.extend({}, e.fn.combobox.defaults, e.fn.combobox.parseOptions(this), k), data: [] }), g(this), R.options.data)
        c(this, R.options.data);
      else {
        var j = e.fn.combobox.parseData(this);
        j.length && c(this, j);
      }
      f(this);
    });
  }, e.fn.combobox.methods = { options: function(k) {
    var N = k.combo("options");
    return e.extend(e.data(k[0], "combobox").options, { width: N.width, height: N.height, originalValue: N.originalValue, disabled: N.disabled, readonly: N.readonly });
  }, cloneFrom: function(k, N) {
    return k.each(function() {
      e(this).combo("cloneFrom", N), e.data(this, "combobox", e(N).data("combobox")), e(this).addClass("combobox-f").attr("comboboxName", e(this).attr("textboxName"));
    });
  }, getData: function(k) {
    return e.data(k[0], "combobox").data;
  }, setValues: function(k, N) {
    return k.each(function() {
      h(this, N);
    });
  }, setValue: function(k, N) {
    return k.each(function() {
      h(this, e.isArray(N) ? N : [N]);
    });
  }, clear: function(k) {
    return k.each(function() {
      h(this, []);
    });
  }, reset: function(k) {
    return k.each(function() {
      var N = e(this).combobox("options");
      N.multiple ? e(this).combobox("setValues", N.originalValue) : e(this).combobox("setValue", N.originalValue);
    });
  }, loadData: function(k, N) {
    return k.each(function() {
      c(this, N);
    });
  }, reload: function(k, N) {
    return k.each(function() {
      if (typeof N == "string")
        f(this, N);
      else {
        if (N) {
          var H = e(this).combobox("options");
          H.queryParams = N;
        }
        f(this);
      }
    });
  }, select: function(k, N) {
    return k.each(function() {
      l(this, N);
    });
  }, unselect: function(k, N) {
    return k.each(function() {
      u(this, N);
    });
  }, scrollTo: function(k, N) {
    return k.each(function() {
      r(this, N);
    });
  } }, e.fn.combobox.parseOptions = function(k) {
    return e(k), e.extend({}, e.fn.combo.parseOptions(k), e.parser.parseOptions(k, ["valueField", "textField", "groupField", "groupPosition", "mode", "method", "url", { showItemIcon: "boolean", limitToList: "boolean" }]));
  }, e.fn.combobox.parseData = function(k) {
    var N = [], H = e(k).combobox("options");
    return e(k).children().each(function() {
      if (this.tagName.toLowerCase() == "optgroup") {
        var j = e(this).attr("label");
        e(this).children().each(function() {
          R(this, j);
        });
      } else
        R(this);
    }), N;
    function R(j, S) {
      var tt = e(j), nt = {};
      nt[H.valueField] = tt.attr("value") != null ? tt.attr("value") : tt.text(), nt[H.textField] = tt.text(), nt.selected = tt.is(":selected"), nt.disabled = tt.is(":disabled"), S && (H.groupField = H.groupField || "group", nt[H.groupField] = S), N.push(nt);
    }
  };
  var D = 0, F = { render: function(k, N, H) {
    var R = e.data(k, "combobox"), j = R.options;
    D++, R.itemIdPrefix = "_easyui_combobox_i" + D, R.groupIdPrefix = "_easyui_combobox_g" + D, R.groups = [];
    for (var S = [], tt = void 0, nt = 0; nt < H.length; nt++) {
      var ft = H[nt];
      ft[j.valueField] + "";
      var pt = ft[j.textField], ct = ft[j.groupField];
      ct ? tt != ct ? (tt = ct, R.groups.push({ value: ct, startIndex: nt, count: 1 }), S.push('<div id="' + (R.groupIdPrefix + "_" + (R.groups.length - 1)) + '" class="combobox-group">'), S.push(j.groupFormatter ? j.groupFormatter.call(k, ct) : ct), S.push("</div>")) : R.groups[R.groups.length - 1].count++ : tt = void 0;
      var Nt = "combobox-item" + (ft.disabled ? " combobox-item-disabled" : "") + (ct ? " combobox-gitem" : "");
      S.push('<div id="' + (R.itemIdPrefix + "_" + nt) + '" class="' + Nt + '">'), j.showItemIcon && ft.iconCls && S.push('<span class="combobox-icon ' + ft.iconCls + '"></span>'), S.push(j.formatter ? j.formatter.call(k, ft) : pt), S.push("</div>");
    }
    e(N).html(S.join(""));
  } };
  e.fn.combobox.defaults = e.extend({}, e.fn.combo.defaults, { valueField: "value", textField: "text", groupPosition: "static", groupField: null, groupFormatter: function(k) {
    return k;
  }, mode: "local", method: "post", url: null, data: null, queryParams: {}, showItemIcon: !1, limitToList: !1, view: F, keyHandler: { up: function(k) {
    o(this, "prev"), k.preventDefault();
  }, down: function(k) {
    o(this, "next"), k.preventDefault();
  }, left: function(k) {
  }, right: function(k) {
  }, enter: function(k) {
    m(this);
  }, query: function(k, N) {
    v(this, k);
  } }, inputEvents: e.extend({}, e.fn.combo.defaults.inputEvents, { blur: function(k) {
    var N = k.data.target, H = e(N).combobox("options");
    (H.reversed || H.limitToList) && (H.blurTimer && clearTimeout(H.blurTimer), H.blurTimer = setTimeout(function() {
      var R = e(N).parent().length;
      R && (H.reversed ? e(N).combobox("setValues", e(N).combobox("getValues")) : H.limitToList && m(N), H.blurTimer = null);
    }, 50));
  } }), panelEvents: { mouseover: y, mouseout: w, click: E, scroll: x }, filter: function(k, N) {
    var H = e(this).combobox("options");
    return N[H.textField].toLowerCase().indexOf(k.toLowerCase()) >= 0;
  }, formatter: function(k) {
    var N = e(this).combobox("options");
    return k[N.textField];
  }, loader: function(k, N, H) {
    var R = e(this).combobox("options");
    if (!R.url)
      return !1;
    e.ajax({ type: R.method, url: R.url, data: k, dataType: "json", success: function(j) {
      N(j);
    }, error: function() {
      H.apply(this, arguments);
    } });
  }, loadFilter: function(k) {
    return k;
  }, finder: { getEl: function(k, N) {
    var H = n(k, N), R = e.data(k, "combobox").itemIdPrefix + "_" + H;
    return e("#" + R);
  }, getGroupEl: function(k, N) {
    var H = e.data(k, "combobox"), R = e.easyui.indexOfArray(H.groups, "value", N), j = H.groupIdPrefix + "_" + R;
    return e("#" + j);
  }, getGroup: function(k, N) {
    var H = e.data(k, "combobox"), R = N.attr("id").substr(H.groupIdPrefix.length + 1);
    return H.groups[parseInt(R)];
  }, getRow: function(k, N) {
    var H = e.data(k, "combobox"), R = N instanceof e ? N.attr("id").substr(H.itemIdPrefix.length + 1) : n(k, N);
    return H.data[parseInt(R)];
  } }, onBeforeLoad: function(k) {
  }, onLoadSuccess: function(k) {
  }, onLoadError: function() {
  }, onSelect: function(k) {
  }, onUnselect: function(k) {
  }, onClick: function(k) {
  } });
})($);
(function(e) {
  function n(h) {
    var c = e.data(h, "combotree"), f = c.options, v = c.tree;
    e(h).addClass("combotree-f"), e(h).combo(e.extend({}, f, { onShowPanel: function() {
      f.editable && v.tree("doFilter", ""), f.onShowPanel.call(this);
    } }));
    var m = e(h).combo("panel");
    v || (v = e("<ul></ul>").appendTo(m), c.tree = v), v.tree(e.extend({}, f, { checkbox: f.multiple, onLoadSuccess: function(g, y) {
      var w = e(h).combotree("getValues");
      f.multiple && e.map(v.tree("getChecked"), function(E) {
        e.easyui.addArrayItem(w, E.id);
      }), o(h, w, c.remainText), f.onLoadSuccess.call(this, g, y);
    }, onClick: function(g) {
      f.multiple ? e(this).tree(g.checked ? "uncheck" : "check", g.target) : e(h).combo("hidePanel"), c.remainText = !1, r(h), f.onClick.call(this, g);
    }, onCheck: function(g, y) {
      c.remainText = !1, r(h), f.onCheck.call(this, g, y);
    } }));
  }
  function r(h) {
    var c = e.data(h, "combotree"), f = c.options, v = c.tree, m = [];
    if (f.multiple)
      m = e.map(v.tree("getChecked"), function(y) {
        return y.id;
      });
    else {
      var g = v.tree("getSelected");
      g && m.push(g.id);
    }
    m = m.concat(f.unselectedValues), o(h, m, c.remainText);
  }
  function o(h, c, f) {
    var v = e.data(h, "combotree"), m = v.options, g = v.tree, y = g.tree("options"), w = y.onBeforeCheck, E = y.onCheck, x = y.onSelect;
    y.onBeforeCheck = y.onCheck = y.onSelect = function() {
    }, e.isArray(c) || (c = c.split(m.separator)), m.multiple || (c = c.length ? [c[0]] : [""]);
    var D = e.map(c, function(R) {
      return String(R);
    });
    g.find("div.tree-node-selected").removeClass("tree-node-selected"), e.map(g.tree("getChecked"), function(R) {
      e.inArray(String(R.id), D) == -1 && g.tree("uncheck", R.target);
    });
    var F = [];
    if (m.unselectedValues = [], e.map(D, function(R) {
      var j = g.tree("find", R);
      j ? (g.tree("check", j.target).tree("select", j.target), F.push(H(j))) : (F.push(N(R, m.mappingRows) || R), m.unselectedValues.push(R));
    }), m.multiple && e.map(g.tree("getChecked"), function(R) {
      var j = String(R.id);
      e.inArray(j, D) == -1 && (D.push(j), F.push(H(R)));
    }), y.onBeforeCheck = w, y.onCheck = E, y.onSelect = x, !f) {
      var k = F.join(m.separator);
      e(h).combo("getText") != k && e(h).combo("setText", k);
    }
    e(h).combo("setValues", D);
    function N(R, j) {
      var S = e.easyui.getArrayItem(j, "id", R);
      return S ? H(S) : void 0;
    }
    function H(R) {
      return R[m.textField || ""] || R.text;
    }
  }
  function l(h, c) {
    var f = e.data(h, "combotree"), v = f.options, m = f.tree;
    f.remainText = !0, m.tree("doFilter", v.multiple ? c.split(v.separator) : c);
  }
  function u(h) {
    var c = e.data(h, "combotree");
    c.remainText = !1, e(h).combotree("setValues", e(h).combotree("getValues")), e(h).combotree("hidePanel");
  }
  e.fn.combotree = function(h, c) {
    if (typeof h == "string") {
      var f = e.fn.combotree.methods[h];
      return f ? f(this, c) : this.combo(h, c);
    }
    return h = h || {}, this.each(function() {
      var v = e.data(this, "combotree");
      v ? e.extend(v.options, h) : e.data(this, "combotree", { options: e.extend({}, e.fn.combotree.defaults, e.fn.combotree.parseOptions(this), h) }), n(this);
    });
  }, e.fn.combotree.methods = { options: function(h) {
    var c = h.combo("options");
    return e.extend(e.data(h[0], "combotree").options, { width: c.width, height: c.height, originalValue: c.originalValue, disabled: c.disabled, readonly: c.readonly });
  }, clone: function(h, c) {
    var f = h.combo("clone", c);
    return f.data("combotree", { options: e.extend(!0, {}, h.combotree("options")), tree: h.combotree("tree") }), f;
  }, tree: function(h) {
    return e.data(h[0], "combotree").tree;
  }, loadData: function(h, c) {
    return h.each(function() {
      var f = e.data(this, "combotree").options;
      f.data = c;
      var v = e.data(this, "combotree").tree;
      v.tree("loadData", c);
    });
  }, reload: function(h, c) {
    return h.each(function() {
      var f = e.data(this, "combotree").options, v = e.data(this, "combotree").tree;
      c && (f.url = c), v.tree({ url: f.url });
    });
  }, setValues: function(h, c) {
    return h.each(function() {
      var f = e(this).combotree("options");
      e.isArray(c) && (c = e.map(c, function(v) {
        return v && typeof v == "object" ? (e.easyui.addArrayItem(f.mappingRows, "id", v), v.id) : v;
      })), o(this, c);
    });
  }, setValue: function(h, c) {
    return h.each(function() {
      e(this).combotree("setValues", e.isArray(c) ? c : [c]);
    });
  }, clear: function(h) {
    return h.each(function() {
      e(this).combotree("setValues", []);
    });
  }, reset: function(h) {
    return h.each(function() {
      var c = e(this).combotree("options");
      c.multiple ? e(this).combotree("setValues", c.originalValue) : e(this).combotree("setValue", c.originalValue);
    });
  } }, e.fn.combotree.parseOptions = function(h) {
    return e.extend({}, e.fn.combo.parseOptions(h), e.fn.tree.parseOptions(h));
  }, e.fn.combotree.defaults = e.extend({}, e.fn.combo.defaults, e.fn.tree.defaults, { editable: !1, textField: null, unselectedValues: [], mappingRows: [], keyHandler: { up: function(h) {
  }, down: function(h) {
  }, left: function(h) {
  }, right: function(h) {
  }, enter: function(h) {
    u(this);
  }, query: function(h, c) {
    l(this, h);
  } } });
})($);
(function(e) {
  function n(h) {
    var c = e.data(h, "combogrid"), f = c.options, v = c.grid;
    e(h).addClass("combogrid-f").combo(e.extend({}, f, { onShowPanel: function() {
      o(this, e(this).combogrid("getValues"), !0);
      var D = e(this).combogrid("panel"), F = D.outerHeight() - D.height(), k = D._size("minHeight"), N = D._size("maxHeight"), H = e(this).combogrid("grid");
      H.datagrid("resize", { width: "100%", height: isNaN(parseInt(f.panelHeight)) ? "auto" : "100%", minHeight: k ? k - F : "", maxHeight: N ? N - F : "" });
      var R = H.datagrid("getSelected");
      R && H.datagrid("scrollTo", H.datagrid("getRowIndex", R)), f.onShowPanel.call(this);
    } }));
    var m = e(h).combo("panel");
    v || (v = e("<table></table>").appendTo(m), c.grid = v), v.datagrid(e.extend({}, f, { border: !1, singleSelect: !f.multiple, onLoadSuccess: y, onClickRow: w, onSelect: E("onSelect"), onUnselect: E("onUnselect"), onSelectAll: E("onSelectAll"), onUnselectAll: E("onUnselectAll") }));
    function g(D) {
      return e(D).closest(".combo-panel").panel("options").comboTarget || h;
    }
    function y(D) {
      var F = g(this), k = e(F).data("combogrid"), N = k.options, H = e(F).combo("getValues");
      o(F, H, k.remainText), N.onLoadSuccess.call(this, D);
    }
    function w(D, F) {
      var k = g(this), N = e(k).data("combogrid"), H = N.options;
      N.remainText = !1, x.call(this), H.multiple || e(k).combo("hidePanel"), H.onClickRow.call(this, D, F);
    }
    function E(D) {
      return function(F, k) {
        var N = g(this), H = e(N).combogrid("options");
        D == "onUnselectAll" ? H.multiple && x.call(this) : x.call(this), H[D].call(this, F, k);
      };
    }
    function x() {
      var D = e(this), F = g(D), k = e(F).data("combogrid"), N = k.options, H = e.map(D.datagrid("getSelections"), function(R) {
        return R[N.idField];
      });
      H = H.concat(N.unselectedValues), o(F, H, k.remainText);
    }
  }
  function r(h, c) {
    var f = e.data(h, "combogrid"), v = f.options, m = f.grid, g = m.datagrid("getRows").length;
    if (g) {
      var y = v.finder.getTr(m[0], null, "highlight");
      y.length || (y = v.finder.getTr(m[0], null, "selected"));
      var w;
      if (!y.length)
        w = c == "next" ? 0 : g - 1;
      else {
        var w = parseInt(y.attr("datagrid-row-index"));
        w += c == "next" ? 1 : -1, w < 0 && (w = g - 1), w >= g && (w = 0);
      }
      m.datagrid("highlightRow", w), v.selectOnNavigation && (f.remainText = !1, m.datagrid("selectRow", w));
    }
  }
  function o(h, c, f) {
    var v = e.data(h, "combogrid"), m = v.options, g = v.grid, y = e(h).combo("getValues"), w = e(h).combo("options"), E = w.onChange;
    w.onChange = function() {
    };
    var x = g.datagrid("options"), D = x.onSelect, F = x.onUnselectAll;
    x.onSelect = x.onUnselectAll = function() {
    }, e.isArray(c) || (c = c.split(m.separator)), m.multiple || (c = c.length ? [c[0]] : [""]);
    var k = e.map(c, function(S) {
      return String(S);
    });
    k = e.grep(k, function(S, tt) {
      return tt === e.inArray(S, k);
    });
    var N = e.grep(g.datagrid("getSelections"), function(S, tt) {
      return e.inArray(String(S[m.idField]), k) >= 0;
    });
    g.datagrid("clearSelections"), g.data("datagrid").selectedRows = N;
    var H = [];
    if (m.unselectedValues = [], e.map(k, function(S) {
      var tt = g.datagrid("getRowIndex", S);
      tt >= 0 ? g.datagrid("selectRow", tt) : m.unselectedValues.push(S), H.push(j(S, g.datagrid("getRows")) || j(S, N) || j(S, m.mappingRows) || S);
    }), e(h).combo("setValues", y), w.onChange = E, x.onSelect = D, x.onUnselectAll = F, !f) {
      var R = H.join(m.separator);
      e(h).combo("getText") != R && e(h).combo("setText", R);
    }
    e(h).combo("setValues", c);
    function j(S, tt) {
      var nt = e.easyui.getArrayItem(tt, m.idField, S);
      return nt ? nt[m.textField] : void 0;
    }
  }
  function l(h, c) {
    var f = e.data(h, "combogrid"), v = f.options, m = f.grid;
    f.remainText = !0;
    var g = v.multiple ? c.split(v.separator) : [c];
    if (g = e.grep(g, function(D) {
      return e.trim(D) != "";
    }), v.mode == "remote")
      x(g), m.datagrid("load", e.extend({}, v.queryParams, { q: c }));
    else {
      m.datagrid("highlightRow", -1);
      var y = m.datagrid("getRows"), w = [];
      e.map(g, function(D) {
        D = e.trim(D), E(v.mappingRows, D), E(m.datagrid("getSelections"), D);
        var F = E(y, D);
        F >= 0 ? v.reversed && m.datagrid("highlightRow", F) : e.map(y, function(k, N) {
          v.filter.call(h, D, k) && m.datagrid("highlightRow", N);
        });
      }), x(w);
    }
    function E(D, F) {
      for (var k = 0; k < D.length; k++) {
        var N = D[k];
        if ((N[v.textField] || "").toLowerCase() == F.toLowerCase())
          return w.push(N[v.idField]), k;
      }
      return -1;
    }
    function x(D) {
      v.reversed || o(h, D, !0);
    }
  }
  function u(h) {
    var c = e.data(h, "combogrid"), f = c.options, v = c.grid, m = f.finder.getTr(v[0], null, "highlight");
    if (c.remainText = !1, m.length) {
      var g = parseInt(m.attr("datagrid-row-index"));
      f.multiple && m.hasClass("datagrid-row-selected") ? v.datagrid("unselectRow", g) : v.datagrid("selectRow", g);
    }
    var y = [];
    e.map(v.datagrid("getSelections"), function(w) {
      y.push(w[f.idField]);
    }), e.map(f.unselectedValues, function(w) {
      e.easyui.indexOfArray(f.mappingRows, f.idField, w) >= 0 && e.easyui.addArrayItem(y, w);
    }), e(h).combogrid("setValues", y), f.multiple || e(h).combogrid("hidePanel");
  }
  e.fn.combogrid = function(h, c) {
    if (typeof h == "string") {
      var f = e.fn.combogrid.methods[h];
      return f ? f(this, c) : this.combo(h, c);
    }
    return h = h || {}, this.each(function() {
      var v = e.data(this, "combogrid");
      v ? e.extend(v.options, h) : v = e.data(this, "combogrid", { options: e.extend({}, e.fn.combogrid.defaults, e.fn.combogrid.parseOptions(this), h) }), n(this);
    });
  }, e.fn.combogrid.methods = { options: function(h) {
    var c = h.combo("options");
    return e.extend(e.data(h[0], "combogrid").options, { width: c.width, height: c.height, originalValue: c.originalValue, disabled: c.disabled, readonly: c.readonly });
  }, cloneFrom: function(h, c) {
    return h.each(function() {
      e(this).combo("cloneFrom", c), e.data(this, "combogrid", { options: e.extend(!0, { cloned: !0 }, e(c).combogrid("options")), combo: e(this).next(), panel: e(c).combo("panel"), grid: e(c).combogrid("grid") });
    });
  }, grid: function(h) {
    return e.data(h[0], "combogrid").grid;
  }, setValues: function(h, c) {
    return h.each(function() {
      var f = e(this).combogrid("options");
      e.isArray(c) && (c = e.map(c, function(v) {
        return v && typeof v == "object" ? (e.easyui.addArrayItem(f.mappingRows, f.idField, v), v[f.idField]) : v;
      })), o(this, c);
    });
  }, setValue: function(h, c) {
    return h.each(function() {
      e(this).combogrid("setValues", e.isArray(c) ? c : [c]);
    });
  }, clear: function(h) {
    return h.each(function() {
      e(this).combogrid("setValues", []);
    });
  }, reset: function(h) {
    return h.each(function() {
      var c = e(this).combogrid("options");
      c.multiple ? e(this).combogrid("setValues", c.originalValue) : e(this).combogrid("setValue", c.originalValue);
    });
  } }, e.fn.combogrid.parseOptions = function(h) {
    return e(h), e.extend({}, e.fn.combo.parseOptions(h), e.fn.datagrid.parseOptions(h), e.parser.parseOptions(h, ["idField", "textField", "mode"]));
  }, e.fn.combogrid.defaults = e.extend({}, e.fn.combo.defaults, e.fn.datagrid.defaults, { loadMsg: null, idField: null, textField: null, unselectedValues: [], mappingRows: [], mode: "local", keyHandler: { up: function(h) {
    r(this, "prev"), h.preventDefault();
  }, down: function(h) {
    r(this, "next"), h.preventDefault();
  }, left: function(h) {
  }, right: function(h) {
  }, enter: function(h) {
    u(this);
  }, query: function(h, c) {
    l(this, h);
  } }, inputEvents: e.extend({}, e.fn.combo.defaults.inputEvents, { blur: function(h) {
    var c = h.data.target, f = e(c).combogrid("options");
    f.reversed && e(c).combogrid("setValues", e(c).combogrid("getValues"));
  } }), filter: function(h, c) {
    var f = e(this).combogrid("options");
    return (c[f.textField] || "").toLowerCase().indexOf(h.toLowerCase()) >= 0;
  } });
})($);
(function(e) {
  function n(h) {
    var c = e.data(h, "combotreegrid"), f = c.options;
    if (e(h).addClass("combotreegrid-f").combo(e.extend({}, f, { onShowPanel: function() {
      var m = e(this).combotreegrid("panel"), g = m.outerHeight() - m.height(), y = m._size("minHeight"), w = m._size("maxHeight"), E = e(this).combotreegrid("grid");
      E.treegrid("resize", { width: "100%", height: isNaN(parseInt(f.panelHeight)) ? "auto" : "100%", minHeight: y ? y - g : "", maxHeight: w ? w - g : "" });
      var x = E.treegrid("getSelected");
      x && E.treegrid("scrollTo", x[f.idField]), f.onShowPanel.call(this);
    } })), !c.grid) {
      var v = e(h).combo("panel");
      c.grid = e("<table></table>").appendTo(v);
    }
    c.grid.treegrid(e.extend({}, f, { border: !1, checkbox: f.multiple, onLoadSuccess: function(m, g) {
      var y = e(h).combotreegrid("getValues");
      f.multiple && e.map(e(this).treegrid("getCheckedNodes"), function(w) {
        e.easyui.addArrayItem(y, w[f.idField]);
      }), o(h, y), f.onLoadSuccess.call(this, m, g), c.remainText = !1;
    }, onClickRow: function(m) {
      f.multiple ? (e(this).treegrid(m.checked ? "uncheckNode" : "checkNode", m[f.idField]), e(this).treegrid("unselect", m[f.idField])) : e(h).combo("hidePanel"), r(h), f.onClickRow.call(this, m);
    }, onCheckNode: function(m, g) {
      r(h), f.onCheckNode.call(this, m, g);
    } }));
  }
  function r(h) {
    var c = e.data(h, "combotreegrid"), f = c.options, v = c.grid, m = [];
    if (f.multiple)
      m = e.map(v.treegrid("getCheckedNodes"), function(y) {
        return y[f.idField];
      });
    else {
      var g = v.treegrid("getSelected");
      g && m.push(g[f.idField]);
    }
    m = m.concat(f.unselectedValues), o(h, m);
  }
  function o(h, c) {
    var f = e.data(h, "combotreegrid"), v = f.options, m = f.grid;
    e.isArray(c) || (c = c.split(v.separator)), v.multiple || (c = c.length ? [c[0]] : [""]);
    var g = e.map(c, function(F) {
      return String(F);
    });
    g = e.grep(g, function(F, k) {
      return k === e.inArray(F, g);
    });
    var y = m.treegrid("getSelected");
    y && m.treegrid("unselect", y[v.idField]), e.map(m.treegrid("getCheckedNodes"), function(F) {
      e.inArray(String(F[v.idField]), g) == -1 && m.treegrid("uncheckNode", F[v.idField]);
    });
    var w = [];
    if (v.unselectedValues = [], e.map(g, function(F) {
      var k = m.treegrid("find", F);
      k ? (v.multiple ? m.treegrid("checkNode", F) : m.treegrid("select", F), w.push(D(k))) : (w.push(x(F, v.mappingRows) || F), v.unselectedValues.push(F));
    }), v.multiple && e.map(m.treegrid("getCheckedNodes"), function(F) {
      var k = String(F[v.idField]);
      e.inArray(k, g) == -1 && (g.push(k), w.push(D(F)));
    }), !f.remainText) {
      var E = w.join(v.separator);
      e(h).combo("getText") != E && e(h).combo("setText", E);
    }
    e(h).combo("setValues", g);
    function x(F, k) {
      var N = e.easyui.getArrayItem(k, v.idField, F);
      return N ? D(N) : void 0;
    }
    function D(F) {
      return F[v.textField || ""] || F[v.treeField];
    }
  }
  function l(h, c) {
    var f = e.data(h, "combotreegrid"), v = f.options, m = f.grid;
    if (f.remainText = !0, m.treegrid("clearSelections").treegrid("clearChecked").treegrid("highlightRow", -1), v.mode == "remote")
      e(h).combotreegrid("clear"), m.treegrid("load", e.extend({}, v.queryParams, { q: c }));
    else if (c) {
      var g = m.treegrid("getData"), y = [], w = v.multiple ? c.split(v.separator) : [c];
      e.map(w, function(E) {
        if (E = e.trim(E), E) {
          var x = void 0;
          e.easyui.forEach(g, !0, function(D) {
            if (E.toLowerCase() == String(D[v.treeField]).toLowerCase())
              return x = D[v.idField], !1;
            if (v.filter.call(h, E, D))
              return m.treegrid("expandTo", D[v.idField]), m.treegrid("highlightRow", D[v.idField]), !1;
          }), x == null && e.easyui.forEach(v.mappingRows, !1, function(D) {
            if (E.toLowerCase() == String(D[v.treeField]))
              return x = D[v.idField], !1;
          }), x != null && y.push(x);
        }
      }), o(h, y), f.remainText = !1;
    }
  }
  function u(h) {
    r(h);
  }
  e.fn.combotreegrid = function(h, c) {
    if (typeof h == "string") {
      var f = e.fn.combotreegrid.methods[h];
      return f ? f(this, c) : this.combo(h, c);
    }
    return h = h || {}, this.each(function() {
      var v = e.data(this, "combotreegrid");
      v ? e.extend(v.options, h) : v = e.data(this, "combotreegrid", { options: e.extend({}, e.fn.combotreegrid.defaults, e.fn.combotreegrid.parseOptions(this), h) }), n(this);
    });
  }, e.fn.combotreegrid.methods = { options: function(h) {
    var c = h.combo("options");
    return e.extend(e.data(h[0], "combotreegrid").options, { width: c.width, height: c.height, originalValue: c.originalValue, disabled: c.disabled, readonly: c.readonly });
  }, grid: function(h) {
    return e.data(h[0], "combotreegrid").grid;
  }, setValues: function(h, c) {
    return h.each(function() {
      var f = e(this).combotreegrid("options");
      e.isArray(c) && (c = e.map(c, function(v) {
        return v && typeof v == "object" ? (e.easyui.addArrayItem(f.mappingRows, f.idField, v), v[f.idField]) : v;
      })), o(this, c);
    });
  }, setValue: function(h, c) {
    return h.each(function() {
      e(this).combotreegrid("setValues", e.isArray(c) ? c : [c]);
    });
  }, clear: function(h) {
    return h.each(function() {
      e(this).combotreegrid("setValues", []);
    });
  }, reset: function(h) {
    return h.each(function() {
      var c = e(this).combotreegrid("options");
      c.multiple ? e(this).combotreegrid("setValues", c.originalValue) : e(this).combotreegrid("setValue", c.originalValue);
    });
  } }, e.fn.combotreegrid.parseOptions = function(h) {
    return e(h), e.extend({}, e.fn.combo.parseOptions(h), e.fn.treegrid.parseOptions(h), e.parser.parseOptions(h, ["mode", { limitToGrid: "boolean" }]));
  }, e.fn.combotreegrid.defaults = e.extend({}, e.fn.combo.defaults, e.fn.treegrid.defaults, { editable: !1, singleSelect: !0, limitToGrid: !1, unselectedValues: [], mappingRows: [], mode: "local", textField: null, keyHandler: { up: function(h) {
  }, down: function(h) {
  }, left: function(h) {
  }, right: function(h) {
  }, enter: function(h) {
    u(this);
  }, query: function(h, c) {
    l(this, h);
  } }, inputEvents: e.extend({}, e.fn.combo.defaults.inputEvents, { blur: function(h) {
    var c = h.data.target, f = e(c).combotreegrid("options");
    f.limitToGrid && u(c);
  } }), filter: function(h, c) {
    var f = e(this).combotreegrid("options");
    return (c[f.treeField] || "").toLowerCase().indexOf(h.toLowerCase()) >= 0;
  } });
})($);
(function(e) {
  function n(c) {
    var f = e.data(c, "tagbox"), v = f.options;
    e(c).addClass("tagbox-f").combobox(e.extend({}, v, { cls: "tagbox", reversed: !0, onChange: function(g, y) {
      m(), e(this).combobox("hidePanel"), v.onChange.call(c, g, y);
    }, onResizing: function(g, y) {
      var w = e(this).combobox("textbox"), E = e(this).data("textbox").textbox;
      E.css({ height: "", paddingLeft: w.css("marginLeft"), paddingRight: w.css("marginRight") }), w.css("margin", 0), E._size({ width: v.width }, e(this).parent()), l(c), r(this), v.onResizing.call(c, g, y);
    }, onLoadSuccess: function(g) {
      m(), v.onLoadSuccess.call(c, g);
    } })), m(), l(c);
    function m() {
      e(c).next().find(".tagbox-label").remove();
      var g = e(c).tagbox("textbox");
      e.map(e(c).tagbox("getValues"), function(y, w) {
        var E = v.finder.getRow(c, y), x = v.tagFormatter.call(c, y, E), D = {}, F = v.tagStyler.call(c, y, E) || "";
        typeof F == "string" ? D = { s: F } : D = { c: F.class || "", s: F.style || "" };
        var k = e('<span class="tagbox-label"></span>').insertBefore(g).html(x);
        k.attr("tagbox-index", w), k.attr("style", D.s).addClass(D.c), e('<a href="javascript:;" class="tagbox-remove"></a>').appendTo(k);
      }), r(c), e(c).combobox("setText", "");
    }
  }
  function r(c, f) {
    var v = e(c).next(), m = f ? e(f) : v.find(".tagbox-label");
    if (m.length) {
      var g = e(c).tagbox("textbox"), y = e(m[0]), w = y.outerHeight(!0) - y.outerHeight(), E = g.outerHeight() - w * 2;
      m.css({ height: E + "px", lineHeight: E + "px" });
      var x = v.find(".textbox-addon").css("height", "100%");
      x.find(".textbox-icon").css("height", "100%"), v.find(".textbox-button").linkbutton("resize", { height: "100%" });
    }
  }
  function o(c) {
    var f = e(c).next();
    f.unbind(".tagbox").bind("click.tagbox", function(v) {
      var m = e(c).tagbox("options");
      if (!(m.disabled || m.readonly)) {
        if (e(v.target).hasClass("tagbox-remove")) {
          var g = parseInt(e(v.target).parent().attr("tagbox-index")), y = e(c).tagbox("getValues");
          if (m.onBeforeRemoveTag.call(c, y[g]) == !1)
            return;
          m.onRemoveTag.call(c, y[g]), y.splice(g, 1), e(c).tagbox("setValues", y);
        } else {
          var w = e(v.target).closest(".tagbox-label");
          if (w.length) {
            var g = parseInt(w.attr("tagbox-index")), y = e(c).tagbox("getValues");
            m.onClickTag.call(c, y[g]);
          }
        }
        e(this).find(".textbox-text").focus();
      }
    }).bind("keyup.tagbox", function(v) {
      l(c);
    }).bind("mouseover.tagbox", function(v) {
      e(v.target).closest(".textbox-button,.textbox-addon,.tagbox-label").length ? e(this).triggerHandler("mouseleave") : e(this).find(".textbox-text").triggerHandler("mouseenter");
    }).bind("mouseleave.tagbox", function(v) {
      e(this).find(".textbox-text").triggerHandler("mouseleave");
    });
  }
  function l(c) {
    var f = e(c).tagbox("options"), v = e(c).tagbox("textbox"), m = e(c).next(), g = e("<span></span>").appendTo("body");
    g.attr("style", v.attr("style")), g.css({ position: "absolute", top: -9999, left: -9999, width: "auto", fontFamily: v.css("fontFamily"), fontSize: v.css("fontSize"), fontWeight: v.css("fontWeight"), whiteSpace: "nowrap" });
    var y = x(v.val()), w = x(f.prompt || "");
    g.remove();
    var E = Math.min(Math.max(y, w) + 20, m.width());
    v._outerWidth(E), m.find(".textbox-button").linkbutton("resize", { height: "100%" });
    function x(D) {
      var F = D.replace(/&/g, "&amp;").replace(/\s/g, " ").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      return g.html(F), g.outerWidth();
    }
  }
  function u(c) {
    var f = e(c), v = f.tagbox("options");
    if (v.limitToList) {
      var m = f.tagbox("panel"), g = m.children("div.combobox-item-hover");
      if (g.length) {
        g.removeClass("combobox-item-hover");
        var y = v.finder.getRow(c, g), w = y[v.valueField];
        e(c).tagbox(g.hasClass("combobox-item-selected") ? "unselect" : "select", w);
      }
      e(c).tagbox("hidePanel");
    } else {
      var E = e.trim(e(c).tagbox("getText"));
      if (E !== "") {
        var x = e(c).tagbox("getValues");
        x.push(E), e(c).tagbox("setValues", x);
      }
    }
  }
  function h(c, f) {
    e(c).combobox("setText", ""), l(c), e(c).combobox("setValues", f), e(c).combobox("setText", ""), e(c).tagbox("validate");
  }
  e.fn.tagbox = function(c, f) {
    if (typeof c == "string") {
      var v = e.fn.tagbox.methods[c];
      return v ? v(this, f) : this.combobox(c, f);
    }
    return c = c || {}, this.each(function() {
      var m = e.data(this, "tagbox");
      m ? e.extend(m.options, c) : e.data(this, "tagbox", { options: e.extend({}, e.fn.tagbox.defaults, e.fn.tagbox.parseOptions(this), c) }), n(this), o(this);
    });
  }, e.fn.tagbox.methods = { options: function(c) {
    var f = c.combobox("options");
    return e.extend(e.data(c[0], "tagbox").options, { width: f.width, height: f.height, originalValue: f.originalValue, disabled: f.disabled, readonly: f.readonly });
  }, setValues: function(c, f) {
    return c.each(function() {
      h(this, f);
    });
  } }, e.fn.tagbox.parseOptions = function(c) {
    return e.extend({}, e.fn.combobox.parseOptions(c), e.parser.parseOptions(c, []));
  }, e.fn.tagbox.defaults = e.extend({}, e.fn.combobox.defaults, { hasDownArrow: !1, multiple: !0, reversed: !0, selectOnNavigation: !1, tipOptions: e.extend({}, e.fn.textbox.defaults.tipOptions, { showDelay: 200 }), val: function(c) {
    var f = e(c).parent().prev().tagbox("getValues");
    return e(c).is(":focus") && f.push(e(c).val()), f.join(",");
  }, inputEvents: e.extend({}, e.fn.combo.defaults.inputEvents, { blur: function(c) {
    var f = c.data.target, v = e(f).tagbox("options");
    v.limitToList && u(f);
  } }), keyHandler: e.extend({}, e.fn.combobox.defaults.keyHandler, { enter: function(c) {
    u(this);
  }, query: function(c, f) {
    var v = e(this).tagbox("options");
    v.limitToList ? e.fn.combobox.defaults.keyHandler.query.call(this, c, f) : e(this).combobox("hidePanel");
  } }), tagFormatter: function(c, f) {
    var v = e(this).tagbox("options");
    return f ? f[v.textField] : c;
  }, tagStyler: function(c, f) {
    return "";
  }, onClickTag: function(c) {
  }, onBeforeRemoveTag: function(c) {
  }, onRemoveTag: function(c) {
  } });
})($);
(function(e) {
  function n(u) {
    var h = e.data(u, "datebox"), c = h.options;
    if (e(u).addClass("datebox-f").combo(e.extend({}, c, { onShowPanel: function() {
      g(this), y(this), w(this), l(this, e(this).datebox("getText"), !0), c.onShowPanel.call(this);
    } })), !h.calendar) {
      var f = e(u).combo("panel").css("overflow", "hidden");
      f.panel("options").onBeforeDestroy = function() {
        var E = e(this).find(".calendar-shared");
        E.length && E.insertBefore(E[0].pholder);
      };
      var v = e('<div class="datebox-calendar-inner"></div>').prependTo(f);
      if (c.sharedCalendar) {
        var m = e(c.sharedCalendar);
        m[0].pholder || (m[0].pholder = e('<div class="calendar-pholder" style="display:none"></div>').insertAfter(m)), m.addClass("calendar-shared").appendTo(v), m.hasClass("calendar") || m.calendar(), h.calendar = m;
      } else
        h.calendar = e("<div></div>").appendTo(v).calendar();
      e.extend(h.calendar.calendar("options"), { fit: !0, border: !1, onSelect: function(E) {
        var x = this.target, D = e(x).datebox("options");
        l(x, D.formatter.call(x, E)), e(x).combo("hidePanel"), D.onSelect.call(x, E);
      } });
    }
    e(u).combo("textbox").parent().addClass("datebox"), e(u).datebox("initValue", c.value);
    function g(E) {
      var x = e(E).datebox("options"), D = e(E).combo("panel");
      D.unbind(".datebox").bind("click.datebox", function(F) {
        if (e(F.target).hasClass("datebox-button-a")) {
          var k = parseInt(e(F.target).attr("datebox-button-index"));
          x.buttons[k].handler.call(F.target, E);
        }
      });
    }
    function y(E) {
      var x = e(E).combo("panel");
      if (!x.children("div.datebox-button").length) {
        for (var D = e('<div class="datebox-button"><table cellspacing="0" cellpadding="0" style="width:100%"><tr></tr></table></div>').appendTo(x), F = D.find("tr"), k = 0; k < c.buttons.length; k++) {
          var N = e("<td></td>").appendTo(F), H = c.buttons[k], R = e('<a class="datebox-button-a" href="javascript:;"></a>').html(e.isFunction(H.text) ? H.text(E) : H.text).appendTo(N);
          R.attr("datebox-button-index", k);
        }
        F.find("td").css("width", 100 / c.buttons.length + "%");
      }
    }
    function w(E) {
      var x = e(E).combo("panel"), D = x.children("div.datebox-calendar-inner");
      if (x.children()._outerWidth(x.width()), h.calendar.appendTo(D), h.calendar[0].target = E, c.panelHeight != "auto") {
        var F = x.height();
        x.children().not(D).each(function() {
          F -= e(this).outerHeight();
        }), D._outerHeight(F);
      }
      h.calendar.calendar("resize");
    }
  }
  function r(u, h) {
    l(u, h, !0);
  }
  function o(u) {
    var h = e.data(u, "datebox"), c = h.options, f = h.calendar.calendar("options").current;
    f && (l(u, c.formatter.call(u, f)), e(u).combo("hidePanel"));
  }
  function l(u, h, c) {
    var f = e.data(u, "datebox"), v = f.options, m = f.calendar;
    m.calendar("moveTo", v.parser.call(u, h)), c ? e(u).combo("setValue", h) : (h && (h = v.formatter.call(u, m.calendar("options").current)), e(u).combo("setText", h).combo("setValue", h));
  }
  e.fn.datebox = function(u, h) {
    if (typeof u == "string") {
      var c = e.fn.datebox.methods[u];
      return c ? c(this, h) : this.combo(u, h);
    }
    return u = u || {}, this.each(function() {
      var f = e.data(this, "datebox");
      f ? e.extend(f.options, u) : e.data(this, "datebox", { options: e.extend({}, e.fn.datebox.defaults, e.fn.datebox.parseOptions(this), u) }), n(this);
    });
  }, e.fn.datebox.methods = { options: function(u) {
    var h = u.combo("options");
    return e.extend(e.data(u[0], "datebox").options, { width: h.width, height: h.height, originalValue: h.originalValue, disabled: h.disabled, readonly: h.readonly });
  }, cloneFrom: function(u, h) {
    return u.each(function() {
      e(this).combo("cloneFrom", h), e.data(this, "datebox", { options: e.extend(!0, {}, e(h).datebox("options")), calendar: e(h).datebox("calendar") }), e(this).addClass("datebox-f");
    });
  }, calendar: function(u) {
    return e.data(u[0], "datebox").calendar;
  }, initValue: function(u, h) {
    return u.each(function() {
      var c = e(this).datebox("options"), f = c.value;
      f && (f = c.formatter.call(this, c.parser.call(this, f))), e(this).combo("initValue", f).combo("setText", f);
    });
  }, setValue: function(u, h) {
    return u.each(function() {
      l(this, h);
    });
  }, reset: function(u) {
    return u.each(function() {
      var h = e(this).datebox("options");
      e(this).datebox("setValue", h.originalValue);
    });
  } }, e.fn.datebox.parseOptions = function(u) {
    return e.extend({}, e.fn.combo.parseOptions(u), e.parser.parseOptions(u, ["sharedCalendar"]));
  }, e.fn.datebox.defaults = e.extend({}, e.fn.combo.defaults, { panelWidth: 180, panelHeight: "auto", sharedCalendar: null, keyHandler: { up: function(u) {
  }, down: function(u) {
  }, left: function(u) {
  }, right: function(u) {
  }, enter: function(u) {
    o(this);
  }, query: function(u, h) {
    r(this, u);
  } }, currentText: "Today", closeText: "Close", okText: "Ok", buttons: [{ text: function(u) {
    return e(u).datebox("options").currentText;
  }, handler: function(u) {
    var h = /* @__PURE__ */ new Date();
    e(u).datebox("calendar").calendar({ year: h.getFullYear(), month: h.getMonth() + 1, current: new Date(h.getFullYear(), h.getMonth(), h.getDate()) }), o(u);
  } }, { text: function(u) {
    return e(u).datebox("options").closeText;
  }, handler: function(u) {
    e(this).closest("div.combo-panel").panel("close");
  } }], formatter: function(u) {
    var h = u.getFullYear(), c = u.getMonth() + 1, f = u.getDate();
    return (c < 10 ? "0" + c : c) + "/" + (f < 10 ? "0" + f : f) + "/" + h;
  }, parser: function(u) {
    if (!u)
      return /* @__PURE__ */ new Date();
    var h = u.split("/"), c = parseInt(h[0], 10), f = parseInt(h[1], 10), v = parseInt(h[2], 10);
    return !isNaN(v) && !isNaN(c) && !isNaN(f) ? new Date(v, c - 1, f) : /* @__PURE__ */ new Date();
  }, onSelect: function(u) {
  } });
})($);
(function(e) {
  function n(h) {
    var c = e.data(h, "datetimebox"), f = c.options;
    if (e(h).datebox(e.extend({}, f, { onShowPanel: function() {
      var g = e(this).datetimebox("getValue");
      u(this, g, !0), f.onShowPanel.call(this);
    }, formatter: e.fn.datebox.defaults.formatter, parser: e.fn.datebox.defaults.parser })), e(h).removeClass("datebox-f").addClass("datetimebox-f"), e(h).datebox("calendar").calendar({ onSelect: function(g) {
      f.onSelect.call(this.target, g);
    } }), !c.spinner) {
      var v = e(h).datebox("panel"), m = e('<div style="padding:2px"><input></div>').insertAfter(v.children("div.datebox-calendar-inner"));
      c.spinner = m.children("input");
    }
    c.spinner.timespinner({ width: f.spinnerWidth, showSeconds: f.showSeconds, separator: f.timeSeparator }), e(h).datetimebox("initValue", f.value);
  }
  function r(h) {
    var c = e(h).datetimebox("calendar"), f = e(h).datetimebox("spinner"), v = c.calendar("options").current;
    return new Date(v.getFullYear(), v.getMonth(), v.getDate(), f.timespinner("getHours"), f.timespinner("getMinutes"), f.timespinner("getSeconds"));
  }
  function o(h, c) {
    u(h, c, !0);
  }
  function l(h) {
    var c = e.data(h, "datetimebox").options, f = r(h);
    u(h, c.formatter.call(h, f)), e(h).combo("hidePanel");
  }
  function u(h, c, f) {
    var v = e.data(h, "datetimebox").options;
    if (e(h).combo("setValue", c), !f)
      if (c) {
        var m = v.parser.call(h, c);
        e(h).combo("setText", v.formatter.call(h, m)), e(h).combo("setValue", v.formatter.call(h, m));
      } else
        e(h).combo("setText", c);
    var m = v.parser.call(h, c);
    e(h).datetimebox("calendar").calendar("moveTo", m), e(h).datetimebox("spinner").timespinner("setValue", g(m));
    function g(y) {
      function w(x) {
        return (x < 10 ? "0" : "") + x;
      }
      var E = [w(y.getHours()), w(y.getMinutes())];
      return v.showSeconds && E.push(w(y.getSeconds())), E.join(e(h).datetimebox("spinner").timespinner("options").separator);
    }
  }
  e.fn.datetimebox = function(h, c) {
    if (typeof h == "string") {
      var f = e.fn.datetimebox.methods[h];
      return f ? f(this, c) : this.datebox(h, c);
    }
    return h = h || {}, this.each(function() {
      var v = e.data(this, "datetimebox");
      v ? e.extend(v.options, h) : e.data(this, "datetimebox", { options: e.extend({}, e.fn.datetimebox.defaults, e.fn.datetimebox.parseOptions(this), h) }), n(this);
    });
  }, e.fn.datetimebox.methods = { options: function(h) {
    var c = h.datebox("options");
    return e.extend(e.data(h[0], "datetimebox").options, { originalValue: c.originalValue, disabled: c.disabled, readonly: c.readonly });
  }, cloneFrom: function(h, c) {
    return h.each(function() {
      e(this).datebox("cloneFrom", c), e.data(this, "datetimebox", { options: e.extend(!0, {}, e(c).datetimebox("options")), spinner: e(c).datetimebox("spinner") }), e(this).removeClass("datebox-f").addClass("datetimebox-f");
    });
  }, spinner: function(h) {
    return e.data(h[0], "datetimebox").spinner;
  }, initValue: function(h, c) {
    return h.each(function() {
      var f = e(this).datetimebox("options"), v = f.value;
      v && (v = f.formatter.call(this, f.parser.call(this, v))), e(this).combo("initValue", v).combo("setText", v);
    });
  }, setValue: function(h, c) {
    return h.each(function() {
      u(this, c);
    });
  }, reset: function(h) {
    return h.each(function() {
      var c = e(this).datetimebox("options");
      e(this).datetimebox("setValue", c.originalValue);
    });
  } }, e.fn.datetimebox.parseOptions = function(h) {
    return e(h), e.extend({}, e.fn.datebox.parseOptions(h), e.parser.parseOptions(h, ["timeSeparator", "spinnerWidth", { showSeconds: "boolean" }]));
  }, e.fn.datetimebox.defaults = e.extend({}, e.fn.datebox.defaults, { spinnerWidth: "100%", showSeconds: !0, timeSeparator: ":", keyHandler: { up: function(h) {
  }, down: function(h) {
  }, left: function(h) {
  }, right: function(h) {
  }, enter: function(h) {
    l(this);
  }, query: function(h, c) {
    o(this, h);
  } }, buttons: [{ text: function(h) {
    return e(h).datetimebox("options").currentText;
  }, handler: function(h) {
    var c = e(h).datetimebox("options");
    u(h, c.formatter.call(h, /* @__PURE__ */ new Date())), e(h).datetimebox("hidePanel");
  } }, { text: function(h) {
    return e(h).datetimebox("options").okText;
  }, handler: function(h) {
    l(h);
  } }, { text: function(h) {
    return e(h).datetimebox("options").closeText;
  }, handler: function(h) {
    e(h).datetimebox("hidePanel");
  } }], formatter: function(h) {
    var c = h.getHours(), f = h.getMinutes(), v = h.getSeconds();
    function m(w) {
      return (w < 10 ? "0" : "") + w;
    }
    var g = e(this).datetimebox("spinner").timespinner("options").separator, y = e.fn.datebox.defaults.formatter(h) + " " + m(c) + g + m(f);
    return e(this).datetimebox("options").showSeconds && (y += g + m(v)), y;
  }, parser: function(h) {
    if (e.trim(h) == "")
      return /* @__PURE__ */ new Date();
    var c = h.split(" "), f = e.fn.datebox.defaults.parser(c[0]);
    if (c.length < 2)
      return f;
    var v = e(this).datetimebox("spinner").timespinner("options").separator, m = c[1].split(v), g = parseInt(m[0], 10) || 0, y = parseInt(m[1], 10) || 0, w = parseInt(m[2], 10) || 0;
    return new Date(f.getFullYear(), f.getMonth(), f.getDate(), g, y, w);
  } });
})($);
(function($) {
  function init(e) {
    var n = $('<div class="slider"><div class="slider-inner"><a href="javascript:;" class="slider-handle"></a><span class="slider-tip"></span></div><div class="slider-rule"></div><div class="slider-rulelabel"></div><div style="clear:both"></div><input type="hidden" class="slider-value"></div>').insertAfter(e), r = $(e);
    r.addClass("slider-f").hide();
    var o = r.attr("name");
    return o && (n.find("input.slider-value").attr("name", o), r.removeAttr("name").attr("sliderName", o)), n.bind("_resize", function(l, u) {
      return ($(this).hasClass("easyui-fluid") || u) && _bd5(e), !1;
    }), n;
  }
  function _bd5(e, n) {
    var r = $.data(e, "slider"), o = r.options, l = r.slider;
    n && (n.width && (o.width = n.width), n.height && (o.height = n.height)), l._size(o), o.mode == "h" ? (l.css("height", ""), l.children("div").css("height", "")) : (l.css("width", ""), l.children("div").css("width", ""), l.children("div.slider-rule,div.slider-rulelabel,div.slider-inner")._outerHeight(l._outerHeight())), _bda(e);
  }
  function _bdb(e) {
    var n = $.data(e, "slider"), r = n.options, o = n.slider, l = r.mode == "h" ? r.rule : r.rule.slice(0).reverse();
    r.reversed && (l = l.slice(0).reverse()), u(l);
    function u(h) {
      var c = o.find("div.slider-rule"), f = o.find("div.slider-rulelabel");
      c.empty(), f.empty();
      for (var v = 0; v < h.length; v++) {
        var m = v * 100 / (h.length - 1) + "%", g = $("<span></span>").appendTo(c);
        g.css(r.mode == "h" ? "left" : "top", m), h[v] != "|" && (g = $("<span></span>").appendTo(f), g.html(h[v]), r.mode == "h" ? g.css({ left: m, marginLeft: -Math.round(g.outerWidth() / 2) }) : g.css({ top: m, marginTop: -Math.round(g.outerHeight() / 2) }));
      }
    }
  }
  function _be2(e) {
    var n = $.data(e, "slider"), r = n.options, o = n.slider;
    o.removeClass("slider-h slider-v slider-disabled"), o.addClass(r.mode == "h" ? "slider-h" : "slider-v"), o.addClass(r.disabled ? "slider-disabled" : "");
    var l = o.find(".slider-inner");
    l.html('<a href="javascript:;" class="slider-handle"></a><span class="slider-tip"></span>'), r.range && l.append('<a href="javascript:;" class="slider-handle"></a><span class="slider-tip"></span>'), o.find("a.slider-handle").draggable({ axis: r.mode, cursor: "pointer", disabled: r.disabled, onDrag: function(h) {
      var c = h.data.left, f = o.width();
      return r.mode != "h" && (c = h.data.top, f = o.height()), c < 0 || c > f || u(c, this), !1;
    }, onStartDrag: function() {
      n.isDragging = !0, r.onSlideStart.call(e, r.value);
    }, onStopDrag: function(h) {
      u(r.mode == "h" ? h.data.left : h.data.top, this), r.onSlideEnd.call(e, r.value), r.onComplete.call(e, r.value), n.isDragging = !1;
    } }), o.find("div.slider-inner").unbind(".slider").bind("mousedown.slider", function(h) {
      if (!(n.isDragging || r.disabled)) {
        var c = $(this).offset();
        u(r.mode == "h" ? h.pageX - c.left : h.pageY - c.top), r.onComplete.call(e, r.value);
      }
    });
    function u(h, c) {
      var f = _beb(e, h), v = Math.abs(f % r.step);
      if (v < r.step / 2 ? f -= v : f = f - v + r.step, r.range) {
        var m = r.value[0], g = r.value[1], y = parseFloat((m + g) / 2);
        if (c) {
          var w = $(c).nextAll(".slider-handle").length > 0;
          f <= g && w ? m = f : f >= m && !w && (g = f);
        } else
          f < m ? m = f : f > g ? g = f : f < y ? m = f : g = f;
        $(e).slider("setValues", [m, g]);
      } else
        $(e).slider("setValue", f);
    }
  }
  function _bed(e, n) {
    var r = $.data(e, "slider"), o = r.options, l = r.slider, u = $.isArray(o.value) ? o.value : [o.value], h = [];
    $.isArray(n) || (n = $.map(String(n).split(o.separator), function(x) {
      return parseFloat(x);
    })), l.find(".slider-value").remove();
    for (var c = $(e).attr("sliderName") || "", f = 0; f < n.length; f++) {
      var v = n[f];
      v < o.min && (v = o.min), v > o.max && (v = o.max);
      var m = $('<input type="hidden" class="slider-value">').appendTo(l);
      m.attr("name", c), m.val(v), h.push(v);
      var g = l.find(".slider-handle:eq(" + f + ")"), y = g.next(), w = _bf7(e, v);
      if (o.showTip ? (y.show(), y.html(o.tipFormatter.call(e, v))) : y.hide(), o.mode == "h") {
        var E = "left:" + w + "px;";
        g.attr("style", E), y.attr("style", E + "margin-left:" + -Math.round(y.outerWidth() / 2) + "px");
      } else {
        var E = "top:" + w + "px;";
        g.attr("style", E), y.attr("style", E + "margin-left:" + -Math.round(y.outerWidth()) + "px");
      }
    }
    o.value = o.range ? h : h[0], $(e).val(o.range ? h.join(o.separator) : h[0]), u.join(",") != h.join(",") && o.onChange.call(e, o.value, o.range ? u : u[0]);
  }
  function _bda(e) {
    var n = $.data(e, "slider").options, r = n.onChange;
    n.onChange = function() {
    }, _bed(e, n.value), n.onChange = r;
  }
  function _bf7(e, n) {
    var r = $.data(e, "slider"), o = r.options, l = r.slider, u = o.mode == "h" ? l.width() : l.height(), h = o.converter.toPosition.call(e, n, u);
    return o.mode == "v" && (h = l.height() - h), o.reversed && (h = u - h), h.toFixed(0);
  }
  function _beb(e, h) {
    var r = $.data(e, "slider"), o = r.options, l = r.slider, u = o.mode == "h" ? l.width() : l.height(), h = o.mode == "h" ? o.reversed ? u - h : h : o.reversed ? h : u - h, c = o.converter.toValue.call(e, h, u);
    return c.toFixed(0);
  }
  $.fn.slider = function(e, n) {
    return typeof e == "string" ? $.fn.slider.methods[e](this, n) : (e = e || {}, this.each(function() {
      var r = $.data(this, "slider");
      r ? $.extend(r.options, e) : (r = $.data(this, "slider", { options: $.extend({}, $.fn.slider.defaults, $.fn.slider.parseOptions(this), e), slider: init(this) }), $(this).removeAttr("disabled"));
      var o = r.options;
      o.min = parseFloat(o.min), o.max = parseFloat(o.max), o.range ? ($.isArray(o.value) || (o.value = $.map(String(o.value).split(o.separator), function(l) {
        return parseFloat(l);
      })), o.value.length < 2 && o.value.push(o.max)) : o.value = parseFloat(o.value), o.step = parseFloat(o.step), o.originalValue = o.value, _be2(this), _bdb(this), _bd5(this);
    }));
  }, $.fn.slider.methods = { options: function(e) {
    return $.data(e[0], "slider").options;
  }, destroy: function(e) {
    return e.each(function() {
      $.data(this, "slider").slider.remove(), $(this).remove();
    });
  }, resize: function(e, n) {
    return e.each(function() {
      _bd5(this, n);
    });
  }, getValue: function(e) {
    return e.slider("options").value;
  }, getValues: function(e) {
    return e.slider("options").value;
  }, setValue: function(e, n) {
    return e.each(function() {
      _bed(this, [n]);
    });
  }, setValues: function(e, n) {
    return e.each(function() {
      _bed(this, n);
    });
  }, clear: function(e) {
    return e.each(function() {
      var n = $(this).slider("options");
      _bed(this, n.range ? [n.min, n.max] : [n.min]);
    });
  }, reset: function(e) {
    return e.each(function() {
      var n = $(this).slider("options");
      $(this).slider(n.range ? "setValues" : "setValue", n.originalValue);
    });
  }, enable: function(e) {
    return e.each(function() {
      $.data(this, "slider").options.disabled = !1, _be2(this);
    });
  }, disable: function(e) {
    return e.each(function() {
      $.data(this, "slider").options.disabled = !0, _be2(this);
    });
  } }, $.fn.slider.parseOptions = function(_c08) {
    var t = $(_c08);
    return $.extend({}, $.parser.parseOptions(_c08, ["width", "height", "mode", { reversed: "boolean", showTip: "boolean", range: "boolean", min: "number", max: "number", step: "number" }]), { value: t.val() || void 0, disabled: t.attr("disabled") ? !0 : void 0, rule: t.attr("rule") ? eval(t.attr("rule")) : void 0 });
  }, $.fn.slider.defaults = { width: "auto", height: "auto", mode: "h", reversed: !1, showTip: !1, disabled: !1, range: !1, value: 0, separator: ",", min: 0, max: 100, step: 1, rule: [], tipFormatter: function(e) {
    return e;
  }, converter: { toPosition: function(e, n) {
    var r = $(this).slider("options");
    return (e - r.min) / (r.max - r.min) * n;
  }, toValue: function(e, n) {
    var r = $(this).slider("options");
    return r.min + (r.max - r.min) * (e / n);
  } }, onChange: function(e, n) {
  }, onSlideStart: function(e) {
  }, onSlideEnd: function(e) {
  }, onComplete: function(e) {
  } };
})($);
class DrawHandler extends BaseObject {
  constructor(n, r, o) {
    super(), this._plotLayer = r, this._map = n, this._clickHandled = !1, this._isDrawing = !1, this._points = [], this._markers = [], this._mouseDownOrigin = null, this._markerGroup = leafletSrcExports.featureGroup().addTo(this._map._map), this._options = {
      zIndexOffset: 2e3,
      icon: new leafletSrcExports.DivIcon({
        iconSize: new leafletSrcExports.Point(8, 8),
        className: "leaflet-div-icon leaflet-editing-icon"
      })
    }, this._mouseMarker = leafletSrcExports.marker(this._map._map.getCenter(), {
      icon: leafletSrcExports.divIcon({
        className: "leaflet-mouse-marker",
        iconAnchor: [20, 20],
        iconSize: [40, 40]
      }),
      opacity: 0,
      zIndexOffset: this._options.zIndexOffset
    }), this._currentPlotCallback = o, this._initialize();
  }
  _initialize() {
  }
  _onMouseDown(n) {
    if (n && n.originalEvent.button === 0 && !this._clickHandled) {
      this._clickHandled = !0, this._onMouseMove(n);
      const r = n.originalEvent;
      this._startPoint.call(this, r.clientX, r.clientY);
    }
  }
  _onMouseUp(n) {
    if (this._plotLayer.onTriggerMapDrag())
      return;
    if (n && n.originalEvent.button === 2) {
      this._finishShape(), this.disable();
      return;
    }
    !this._mouseDownOrigin && this._onMouseDown.call(this, n);
    const r = n.originalEvent;
    this._endPoint.call(this, r.clientX, r.clientY, n), this._clickHandled = !1, leafletSrcExports.DomEvent.stopPropagation(n);
  }
  _onMouseMove(n) {
    const r = this._map._map.mouseEventToLayerPoint(n.originalEvent), o = this._map._map.layerPointToLatLng(r);
    if (this._isDrawing && defined(this._plot)) {
      const l = this._points.slice();
      l.length === 0 ? l.push(new GeoPoint3D(o.lng, o.lat)) : l[l.length - 1].lat !== o.lat && l[l.length - 1].lng !== o.lng && l.push(new GeoPoint3D(o.lng, o.lat)), this._plot && this._plot.setPoints(l);
    }
    this._mouseMarker.setLatLng(o);
  }
  _onMouserDoubleClick(n) {
    console.log("_onMouserDoubleClick", n);
  }
  _onMouseRightClick(n) {
  }
  _createMouserEvents() {
    this._map._map.on("mouseup", this._onMouseUp, this), this._map._map.on("mousemove", this._onMouseMove, this), this._map._map.on("contextmenu", this._onMouseRightClick, this);
  }
  _mouseEventsOff() {
    this._map._map.off("mouseup", this._onMouseUp, this), this._map._map.off("mousemove", this._onMouseMove), this._map._map.off("contextmenu", this._onMouseRightClick);
  }
  _startPoint(n, r) {
    this._mouseDownOrigin = new leafletSrcExports.Point(n, r);
  }
  createPlotFeature(n, r, o) {
    return this._plot = new Feature(n, r, o), this._plotLayer.addFeature(this._plot), this._map && this._createMouserEvents(), this._isDrawing = !0, this._map._map.getContainer().style.cursor = "pointer", this._plot;
  }
  startEdite() {
    this._mouseMarker.on("mousedown", this._onMouseDown, this).on("mouseup", this._onMouseUp, this), defined(this._mouseMarker) && (this._mouseMarker = leafletSrcExports.marker(this._map._map.getCenter(), {
      icon: leafletSrcExports.divIcon({
        className: "leaflet-mouse-marker",
        iconAnchor: [20, 20],
        iconSize: [40, 40]
      }),
      opacity: 0,
      zIndexOffset: this._options.zIndexOffset
    })), this._isDrawing = !0;
  }
  endEdite() {
    defined(this._mouseMarker) && this._mouseMarker.off("mousedown", this._onMouseDown, this).off("mouseup", this._onMouseUp, this), this._markerGroup && this._markerGroup.clearLayers(), this._markers = [], this._points = [], this._mouseEventsOff(), this._plot = null, this._isDrawing = !1;
  }
  _endPoint(n, r, o) {
    if (this._mouseDownOrigin) {
      const l = this._calculateFinishDistance(o.latlng);
      this._points.length + 1 >= this._plot._symbol.maxEditPts || l < 5 ? this._finishShape() : this.addVertex(o.latlng);
    }
  }
  _finishShape() {
    defined(this._mouseMarker) && this._mouseMarker.off("mousedown", this._onMouseDown, this).off("mouseup", this._onMouseUp, this), this._markerGroup && this._markerGroup.clearLayers(), this._markers = [], this._points = [], this._mouseEventsOff(), this._isDrawing = !1, this._map._map.getContainer().style.cursor = "", this._currentPlotCallback && this._currentPlotCallback(this._plot), defined(this._plot) && defined(this._plotLayer) && (this._plot._featureComponents.on("click", this._plotLayer._featureClick, this._plotLayer), this._plot._featureComponents.eachLayer((n) => {
      n.on("contextmenu", this._plot._contextmenuEvent, this._plot);
    }));
  }
  _createMarker(n) {
    const r = new leafletSrcExports.Marker(n, {
      icon: this._options.icon,
      zIndexOffset: 2 * this._options.zIndexOffset
    });
    return this._markerGroup.addLayer(r), r;
  }
  disable() {
  }
  _vertexChanged() {
    let n = this._markers.length;
    n > 1 && this._markers[n - 1].on("click", this._finishShape, this), n > 2 && this._markers[n - 2].off("click", this._finishShape, this);
  }
  _calculateFinishDistance(n) {
    let r;
    if (this._markers.length > 0) {
      let o = this._markers[this._markers.length - 1], l = this._map._map.latLngToContainerPoint(o.getLatLng()), u = this._map._map.latLngToContainerPoint(n);
      r = l.distanceTo(u);
    } else
      r = 1 / 0;
    return r;
  }
  addVertex(n) {
    this._markers.push(this._createMarker(n)), this._points.push(new GeoPoint3D(n.lng, n.lat)), this._plot && this._plot.setPoints(this._points), this._vertexChanged();
  }
  removeHooks() {
    this._isDrawing && this._plot && this._plot.getPoints().length < this._plot._symbol.minEditPts && this._plotLayer.removeFeature(this._plot);
  }
}
class PlotLayer extends FeatureLayer {
  constructor(n, r, o = null) {
    super(n, r), this._layerType = LayerType.PLOT, this._className = "PlotLayer", this._callback = o, this._featureClickCallback = null, this._rightClickCallback = null, this._featureClickFun = null, this._initialize();
  }
  setEditeFeature(n) {
    defined(n) && (this._unselectFeatures(), this._editeFeature = n, defined(n) && (this._onTriggerMapClick = !0, this._selectedFeatures.push(n), n.createControlPointsMarkers()), n._featureComponents.on("mousemove", n._featureMouseMove, n), n._featureComponents.on("mouseout", n._featureMouseOut, n), n._featureComponents.on("click", n._featureClick, n), n._featureComponents.on("contextmenu", (r) => {
      r.preventDefault(), defined(this._rightClickCallback) && this._rightClickCallback(this, n), alert("你右击了地图，坐标是: " + r.latlng.toString());
    }));
  }
  _initialize() {
    this._drawHandler = null, this._editeFeature = null, this._drawHandler = new DrawHandler(this._map, this, this._callback), this._onTriggerMapClick = !1, this._onTriggerMapDrag = !1, this._isEditing = !1, super._initialize();
  }
  setFeatureClickEvent(n) {
    this._featureClickCallback = n;
  }
  setFeatureClick(n) {
    this._featureClickFun = n;
  }
  setRightClickEvent(n) {
    this._rightClickCallback = n;
  }
  startEdite() {
    this._drawHandler && this._drawHandler.startEdite(), this._featureMap.forEach((n, r) => {
      n._featureComponents.on("click", this._featureClick, this);
    }), this._map._featureLayerCollection.forEach((n) => {
      if (n._layerType == LayerType.PLOT) {
        let r = n;
        r._isEditing && r._id != this._id && r.endEdite();
      }
    }), this._map._map.on("click", this._onMapClick, this), this._map._map.on("dragstart", this._onMapDragStart, this), this._map._map.on("dragend", this._onMapDragEnd, this), this._map._map.on("keyup", this._keyUpEvent, this), this._isEditing = !0;
  }
  endEdite() {
    this._isEditing = !1, this._map._map.off("click", this._onMapClick, this), this._map._map.off("dragstart", this._onMapDragStart, this), this._map._map.off("dragend", this._onMapDragEnd, this), this._map._map.off("keyup", this._keyUpEvent, this), this._unselectFeatures(), this._featureMap.forEach((n, r) => {
      n._featureComponents.off("click", this._featureClick, this);
    }), this._drawHandler.endEdite();
  }
  createPlotFeature(n, r = null, o = null) {
    return this._isEditing ? (this._unselectFeatures(), this._editeFeature = this._drawHandler.createPlotFeature(n, r, o), this._editeFeature._map = this._map, this._editeFeature) : null;
  }
  _featureClick(n) {
    if (this._onTriggerMapClick = !1, this._featureClickFun) {
      let l = this._featureCollection.find((u) => u._id === n.layer._featureid);
      this._featureClickFun(l);
    }
    const r = this._selectedFeatures.some((l) => l._id === n.layer._featureid);
    if (defined(this._featureClickCallback) && this._featureClickCallback(this, r), !r) {
      this._unselectFeatures();
      var o = this._featureMap.get(n.layer._featureid);
      this._editeFeature = o, defined(o) && (this._onTriggerMapClick = !0, this._selectedFeatures.push(o), o.createControlPointsMarkers()), o._featureComponents.on("mousemove", o._featureMouseMove, o), o._featureComponents.on("mouseout", o._featureMouseOut, o), o._featureComponents.on("click", o._featureClick, o), o._isSelect = !0, leafletSrcExports.DomEvent.stopPropagation(n);
    }
  }
  _onMapClick(n) {
    this._onTriggerMapClick === !0 ? (this._unselectFeatures(), leafletSrcExports.DomEvent.stopPropagation(n)) : this._onTriggerMapClick = !0;
  }
  _onMapDragStart(n) {
    this._onTriggerMapDrag = !0;
  }
  _onMapDragEnd(n) {
    this._onTriggerMapDrag = !1;
  }
  _unselectFeatures() {
    this._selectedFeatures.length > 0 && (this._selectedFeatures.forEach((n) => {
      if (n.getType() == FeatureType.Circle) {
        let r = n._symbol;
        r._baseRadius = !1;
      }
      n.cleanControlsPointsMarkers(), n._featureComponents.off("mousemove", n._featureMouseMove, n), n._featureComponents.off("mouseout", n._featureMouseOut, n), n._isSelect = !1;
    }), this._selectedFeatures = []);
  }
  _keyUpEvent(n) {
    switch (n.originalEvent.code) {
      case "Delete": {
        this._selectedFeatures.length > 0 && (this._selectedFeatures.forEach((r) => {
          r.cleanControlsPointsMarkers(), this.removeFeature(r);
        }), this._selectedFeatures = []);
        break;
      }
    }
  }
  onTriggerMapDrag() {
    return this._onTriggerMapDrag;
  }
}
Object.assign(window, { $, jQuery: $ });
class Control extends BaseObject {
  constructor(n, r, o) {
    super(), this._mapcontainerid = n, this._map = r, this._className = "Control", this._mapOptions = o, this._imageryLayers = [], this._featureLayers = [], this._editeLayer = null, this._plotTreeDict = {}, this._initialize();
  }
  _initialize() {
    if (this._mapOptions.layerPanel || this._mapOptions.navPanel || this._mapOptions.plotPanel || this._mapOptions.elementPanel || this._mapOptions.toolPanel || this._mapOptions.coordinate || this._mapOptions.squareRid) {
      var n = "<div id='controlButtonWrapper' class='buttonWrapper'></div>";
      $("#" + this._mapcontainerid).prepend(n), $("#controlButtonWrapper").css("position", "absolute"), $("#controlButtonWrapper").css("right", "50px"), $("#controlButtonWrapper").css("top", "50px");
    }
    if (this._mapOptions.layerPanel) {
      var r = "<button id='layerButton' class='easyui-button control-button large'>图层</button>";
      $("#controlButtonWrapper").append(r);
      var o = "<div id='layerPanel' class='easyui-draggable control-panel'><div>";
      $("#" + this._mapcontainerid).prepend(o), $("#layerPanel").css("position", "absolute"), $("#layerPanel").css("z-index", "1001"), $("#layerPanel").css("right", "150px"), $("#layerPanel").css("top", "150px"), $("#layerPanel").css("display", "flex"), $("#layerPanel").css("flex-direction", "column"), $("#layerPanel").css("width", "200px"), $("#layerPanel").css("height", "360px"), $("#layerPanel").hide();
      var l = "<div id='layerPanelTitle' class='control-panel-title'><span>图层管理</span><div>";
      $("#layerPanel").prepend(l);
      var u = "<div id='layerList'></div>";
      $("#layerPanel").append(u), $("#layerList").css("width", "200px"), $("#layerList").css("height", "330px"), $("#layerList").css("overflow-y", "auto"), $("#layerButton").click(function() {
        $("#layerPanel").is(":hidden") ? $("#layerPanel").show() : $("#layerPanel").hide();
      }), $("#addLayerButton").hover(function() {
        $(this).css("cursor", "pointer");
      }, function() {
        $(this).css("cursor", "move");
      }), $("#addLayerButton").click(() => {
        let Rt = "标绘图层" + (this._featureLayers.length + 1), Mt = new FeatureLayerOptions(Rt), G = new PlotLayer(this._map, Mt);
        this._map.addPlotLayer(G);
      });
    }
    if (this._mapOptions.navPanel) {
      var h = "<button id='navButton' class='easyui-button control-button large' >导航图</button>";
      $("#controlButtonWrapper").append(h), $("#navButton").css("margin-right", "10px");
    }
    if (this._mapOptions.plotPanel) {
      var c = "<button id='plotButton' class='easyui-button control-button large'>标绘面板</button>";
      $("#controlButtonWrapper").append(c);
      var f = "<div id='plotPanel' class='easyui-draggable control-panel'><div>";
      $("#" + this._mapcontainerid).prepend(f), $("#plotPanel").css("position", "absolute"), $("#plotPanel").css("z-index", "1002"), $("#plotPanel").css("left", "150px"), $("#plotPanel").css("top", "150px"), $("#plotPanel").css("display", "flex"), $("#plotPanel").css("flex-direction", "column"), $("#plotPanel").css("width", "270px"), $("#plotPanel").css("height", "480px"), $("#plotPanel").hide();
      var v = "<div id='plotPanelTitle' class='control-panel-title'>标绘面板<div>";
      $("#plotPanel").prepend(v);
      var m = "<ul id='plotPanelContent' class='easyui-tree'></ul>";
      $("#plotPanel").append(m), $("#plotPanelContent").css("border-bottom", "1px solid #05c6fe"), $("#plotPanelContent").css("margin", "8px"), $("#plotPanelContent").css("width", "250px"), $("#plotPanelContent").css("height", "220px"), $("#plotPanelContent").css("border", "1px solid #fff"), $("#plotPanelContent").css("text-align", "left"), $("#plotPanelContent").css("overflow-y", "auto");
      var g = "<div id='markList' style='display:flex;flex-wrap:wrap;margin:0 8px 8px 8px;width:250px;height:240px;overflow-y:auto;border:1px solid #fff;'></div>";
      $("#plotPanel").append(g), $("#plotButton").click(function() {
        $("#plotPanel").is(":hidden") ? $("#plotPanel").show() : $("#plotPanel").hide();
      });
    }
    if (this._mapOptions.elementPanel) {
      var y = "<button id='elementButton' class='easyui-button control-button large' >图元绘制</button>";
      $("#controlButtonWrapper").append(y), $("#elementButton").css("margin-right", "10px");
      var w = "<div id='elementPanel' class='easyui-draggable control-panel'><div id='elementPanelContent' class='sub-panel'></div><div>";
      $("#" + this._mapcontainerid).prepend(w), $("#elementPanel").css("position", "absolute"), $("#elementPanel").css("z-index", "1003"), $("#elementPanel").css("left", "450px"), $("#elementPanel").css("top", "60px"), $("#elementPanel").css("width", "400px"), $("#elementPanel").css("height", "48px"), $("#elementPanelContent").css("width", "100%"), $("#elementPanelContent").css("height", "100%"), $("#elementPanel").hide();
      var E = "<div id='polygonButton' class='element-icon'><svg t='1710297073164' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='1064' width='32' height='32'><path d='M340.2 796L122.8 237.4h770l-56 496.2L340.2 796zM176 273.8l187.8 482.8L804 701.2l48.4-427.4H176z' fill='#ffffff' p-id='1065'></path><path d='M146.2 263.6m-78.2 0a78.2 78.2 0 1 0 156.4 0 78.2 78.2 0 1 0-156.4 0Z' p-id='1066' fill='#ffffff'></path><path d='M873.4 250.2m-78.2 0a78.2 78.2 0 1 0 156.4 0 78.2 78.2 0 1 0-156.4 0Z' p-id='1067' fill='#ffffff'></path><path d='M357.6 762.4m-78.2 0a78.2 78.2 0 1 0 156.4 0 78.2 78.2 0 1 0-156.4 0Z' p-id='1068' fill='#ffffff'></path><path d='M806.8 723.8m-78.2 0a78.2 78.2 0 1 0 156.4 0 78.2 78.2 0 1 0-156.4 0Z' p-id='1069' fill='#ffffff'></path></svg></div>", x = "<div id='polylineButton' class='element-icon'><svg t='1710297033219' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='814' width='32' height='32'><path d='M831.68 650.4c-5.6 0-10.96 0.8-16.08 2.24L680.88 487.2c4.64-8.72 7.28-18.64 7.28-29.2 0-34.24-27.84-62-62-62s-62 27.84-62 62c0 9.68 2.24 18.72 6.24 26.88L482.96 583.84c-5.28-1.52-10.8-2.4-16.48-2.4-6.48 0-12.72 1.04-18.56 2.96L245.84 340.64c4.08-8.08 6.48-17.28 6.48-26.96 0-33.12-26.88-60-60-60s-60 26.88-60 60 26.88 60 60 60c5.76 0 11.28-0.88 16.56-2.4L412 616.32c-3.52 7.68-5.6 16.16-5.6 25.12 0 33.12 26.88 60 60 60s60-26.88 60-60c0-9.76-2.4-18.88-6.48-27.04l86.4-97.68c6.24 2.08 12.88 3.36 19.84 3.36 6.08 0 11.92-0.88 17.52-2.56L778.4 682.96a59.72 59.72 0 0 0-6.72 27.44c0 33.12 26.88 60 60 60s60-26.88 60-60-26.88-60-60-60z' fill='#ffffff' p-id='815'></path></svg></div>", D = "<div id='pinButton' class='element-icon'><svg t='1710751976257' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='3823' width='26' height='26'><path d='M513.577807 1018.488425a24.572224 24.572224 0 0 1-20.193066-10.568544L192.002048 573.35428a24.680756 24.680756 0 0 1-0.937879-1.458012 373.881965 373.881965 0 0 1-34.076952-75.366151c-12.077751-37.311405-18.198538-76.196522-18.198537-115.589486 0-206.664086 168.133233-374.798343 374.798342-374.798343 47.94343 0 96.038396 11.579119 142.947702 34.415857 42.703185 20.788968 83.766106 51.042731 118.751244 87.488954 34.08719 35.511415 62.431408 76.862047 81.96714 119.582638 20.362007 44.524677 31.122018 90.612827 31.120994 133.280177 0 39.402179-6.12181 78.286272-18.194442 115.573104-8.337498 25.72819-19.85928 51.384709-33.324396 74.200969-0.304094 0.516038-0.627642 1.020814-0.968595 1.514327L533.770874 1007.917833a24.576319 24.576319 0 0 1-20.193067 10.570592zM232.890908 546.072856l280.683828 404.718319L794.978354 544.949654c11.469563-19.570544 21.298863-41.546195 28.44763-63.607852 10.484586-32.383445 15.802646-66.175756 15.802646-100.430864 0.004096-72.181868-37.153727-153.987233-99.396739-218.828867C674.686163 94.213832 592.223463 55.289808 513.588046 55.289808c-179.564913 0-325.651847 146.086934-325.651847 325.651847 0 34.245892 5.317036 68.039228 15.804694 100.439054a324.581887 324.581887 0 0 0 29.150015 64.692147z m582.802694 12.12485h0.010239-0.010239z m-302.760842 18.642904c-96.8616 0-175.66391-78.803334-175.66391-175.664934s78.80231-175.66391 175.66391-175.663909c96.862623 0 175.66391 78.80231 175.663909 175.663909s-78.801286 175.664934-175.663909 175.664934z m0-302.182348c-69.762427 0-126.517414 56.756011-126.517415 126.517414S443.171357 527.694114 512.93276 527.694114 639.450174 470.938103 639.450174 401.175676s-56.754987-126.517414-126.517414-126.517414z' fill='#ffffff' p-id='3824'></path></svg></div>", F = "<div id='rectangleButton' class='element-icon'><svg t='1710376822757' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='1992' width='28' height='28'><path d='M928 896H96a53.393333 53.393333 0 0 1-53.333333-53.333333V181.333333a53.393333 53.393333 0 0 1 53.333333-53.333333h832a53.393333 53.393333 0 0 1 53.333333 53.333333v661.333334a53.393333 53.393333 0 0 1-53.333333 53.333333zM96 170.666667a10.666667 10.666667 0 0 0-10.666667 10.666666v661.333334a10.666667 10.666667 0 0 0 10.666667 10.666666h832a10.666667 10.666667 0 0 0 10.666667-10.666666V181.333333a10.666667 10.666667 0 0 0-10.666667-10.666666z' fill='#ffffff' p-id='1993'></path></svg></div>";
      $("#elementPanelContent").append(x), $("#elementPanelContent").append(E), $("#elementPanelContent").append(D), $("#elementPanelContent").append(F), $(".element-icon").hover(function() {
        $(this).css("cursor", "pointer"), $(this).css("background", "#234667"), $(this).css("border", "1px solid rgba(62,153,246,1)");
      }, function() {
        $(this).css("cursor", "move"), $(this).css("background", "rgb(85, 103, 122)"), $(this).css("border", "1px solid rgba(255,255,255,0)");
      }), $("#elementButton").click(function() {
        $("#elementPanel").is(":hidden") ? $("#elementPanel").show() : $("#elementPanel").hide();
      }), $("#polygonButton").click(() => {
        this._editeLayer.createPlotFeature(FeatureType.Polygon);
      }), $("#polylineButton").click(() => {
        this._editeLayer.createPlotFeature(FeatureType.Polyline);
      }), $("#pinButton").click(() => {
        this._editeLayer.createPlotFeature(FeatureType.Pin);
      }), $("#rectangleButton").click(() => {
        this._editeLayer.createPlotFeature(FeatureType.Rectangle);
      });
    }
    if (this._mapOptions.toolPanel) {
      var k = "<button id='toolButton' class='easyui-button control-button large' >工具</button>";
      $("#controlButtonWrapper").append(k), $("#toolButton").css("margin-right", "10px");
      var N = "<div id='toolPanel' class='easyui-draggable control-panel'><div id='toolPanelContent' class='sub-panel'></div><div>";
      $("#" + this._mapcontainerid).prepend(N), $("#toolPanel").css("position", "absolute"), $("#toolPanel").css("z-index", "1004"), $("#toolPanel").css("left", "480px"), $("#toolPanel").css("top", "60px"), $("#toolPanel").css("width", "400px"), $("#toolPanel").css("height", "48px"), $("#toolPanelContent").css("width", "100%"), $("#toolPanelContent").css("height", "100%"), $("#toolPanel").hide();
      var H = "<div id='distanceMeasureButton' class='element-icon'><svg t='1712046575007' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='4846' width='40' height='40'><path d='M751.76 611.04v62.8l-71.28-41.12v40.32H354.64v-40.32l-79.44 45.84v-67.52h-48v172h48v-67.52l79.44 45.92v-40.4h325.84v40.4l71.28-41.12v62.72h48v-172zM772.8 462.24c13.28 0 24-10.72 24-24V240.96c0-13.28-10.72-24-24-24H240c-13.28 0-24 10.72-24 24v197.36c0 13.28 10.72 24 24 24h532.8zM264 264.96h484.8v149.36h-40.8v-61.36h-48v61.36h-40.8v-96h-48v96h-40.8v-61.36h-48v61.36h-40.8v-96h-48v96h-40.8v-61.36h-48v61.36H264V264.96z' fill='#ffffff' p-id='4847'></path></svg></div>", R = "<div id='areaMeasureButton' class='element-icon'><svg t='1712046785623' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='6080' width='40' height='40'><path d='M804 360.8c13.28 0 24-10.72 24-24V220c0-13.28-10.72-24-24-24H687.2c-13.28 0-24 10.72-24 24v34.4H360.8v-34.4c0-13.28-10.72-24-24-24H220c-13.28 0-24 10.72-24 24v116.8c0 13.28 10.72 24 24 24h34.4v302.4h-34.4c-13.28 0-24 10.72-24 24v116.8c0 13.28 10.72 24 24 24h116.8c13.28 0 24-10.72 24-24v-34.4h302.4v34.4c0 13.28 10.72 24 24 24h116.8c13.28 0 24-10.72 24-24V687.2c0-13.28-10.72-24-24-24h-34.4V360.8h34.4zM711.2 244h68.8v68.8h-68.8v-68.8z m-467.2 0h68.8v68.8h-68.8v-68.8z m92.8 116.8c13.28 0 24-10.72 24-24v-34.4h135.04L302.4 495.84V360.8h34.4z m-34.4 202.88L563.68 302.4H663.2v25.04L327.44 663.2H302.4V563.68z m10.4 216.32h-68.8v-68.8h68.8v68.8z m467.2 0h-68.8v-68.8h68.8v68.8zM687.2 663.2c-13.28 0-24 10.72-24 24v34.4H537.28L721.6 537.28V663.2h-34.4z m34.4-193.76L469.44 721.6H360.8v-23.92L697.68 360.8h23.92v108.64z' fill='#ffffff' p-id='6081'></path></svg></div>", j = "<div id='angelMeasureButton' class='element-icon'><svg t='1712047309559' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='8463' width='28' height='28'><path d='M924.116617 777.660522c-22.916942 0-42.774199 13.317307-52.259224 32.615838l-373.537462 0c9.152451-34.678824 10.166547-68.674079 2.982938-101.405551-7.346315-33.471322-23.214724-65.545832-47.164183-95.329159-23.092951-28.718065-48.998971-49.551556-67.344804-62.33572l274.65129-307.433928c5.406127 1.663896 11.144828 2.564405 17.089214 2.564405 32.088836 0 58.196447-26.107611 58.196447-58.19747s-26.107611-58.19747-58.196447-58.19747c-32.090882 0-58.198493 26.107611-58.198493 58.19747 0 7.257288 1.345648 14.202467 3.784186 20.615527L114.267998 779.464611c-4.602831-1.174756-9.42158-1.803066-14.384615-1.803066-32.089859 0-58.19747 26.107611-58.19747 58.19747s26.107611 58.19747 58.19747 58.19747c22.915919 0 42.772152-13.317307 52.258201-32.614815l719.716832 0c9.486048 19.296485 29.343305 32.613792 52.258201 32.613792 32.088836 0 58.196447-26.107611 58.196447-58.196447C982.313064 803.768133 956.206476 777.660522 924.116617 777.660522zM438.188412 626.367771c45.063335 56.040341 58.101279 117.812219 38.910195 183.909613L155.349649 810.277384l217.674625-243.656369C390.234237 578.427922 415.803589 598.530772 438.188412 626.367771zM678.533362 160.641677c15.161305 0 27.497261 12.335956 27.497261 27.498284s-12.335956 27.498284-27.497261 27.498284c-15.162328 0-27.499307-12.335956-27.499307-27.498284S663.371034 160.641677 678.533362 160.641677zM99.883383 863.358323c-15.162328 0-27.498284-12.335956-27.498284-27.498284s12.335956-27.498284 27.498284-27.498284 27.498284 12.335956 27.498284 27.498284S115.045711 863.358323 99.883383 863.358323zM924.116617 863.3573c-15.162328 0-27.499307-12.335956-27.499307-27.497261 0-15.162328 12.33698-27.499307 27.499307-27.499307 15.161305 0 27.497261 12.33698 27.497261 27.499307C951.613878 851.021344 939.278945 863.3573 924.116617 863.3573z' p-id='8464' fill='#ffffff'></path></svg></div>", S = "<div id='cleanMeasureButton' class='element-icon'><svg t='1712110553146' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='3144' width='26' height='26'><path d='M929.17333333 925.03466667H416.064c5.16266667-3.25333333 10.112-6.912 14.53866667-11.33866667l118.96533333-118.96533333c8.62933333 3.15733333 17.76 5.04533333 27.22133333 5.04533333 21.14133333 0 41.024-8.224 55.97866667-23.17866667L938.96533333 470.4c14.95466667-14.95466667 23.2-34.82666667 23.2-56 0-21.13066667-8.23466667-41.01333333-23.18933333-55.97866667L641.14133333 60.608c-30.86933333-30.85866667-81.07733333-30.83733333-111.94666666 0L222.99733333 366.816c-22.47466667 22.464-28.37333333 55.136-18.13333333 83.18933333L85.89866667 568.98133333c-30.85866667 30.85866667-31.904 80.02133333-2.336 109.62133334l237.42933333 237.42933333c3.392 3.392 7.08266667 6.37866667 10.976 9.00266667H94.08c-17.056 0-30.88 13.83466667-30.88 30.88 0 17.04533333 13.824 30.88 30.88 30.88h835.09333333c17.056 0 30.88-13.83466667 30.88-30.88 0-17.04533333-13.824-30.88-30.88-30.88zM266.66666667 410.48533333l306.18666666-306.18666666c3.40266667-3.40266667 7.86133333-5.10933333 12.32-5.10933334 4.45866667 0 8.90666667 1.70666667 12.29866667 5.088l297.824 297.824c3.28533333 3.296 5.09866667 7.65866667 5.09866667 12.30933334 0 4.64-1.81333333 9.00266667-5.09866667 12.30933333L589.09866667 732.928c-6.57066667 6.54933333-18.048 6.592-24.59733334 0L266.66666667 435.104c-3.28533333-3.296-5.09866667-7.65866667-5.09866667-12.30933333 0-4.64 1.81333333-9.01333333 5.09866667-12.30933334zM127.24266667 634.93333333c-5.408-5.408-4.34133333-15.60533333 2.32533333-22.272L243.22133333 498.98666667 500.58666667 756.37333333 386.93333333 870.02666667c-3.57333333 3.584-8.08533333 5.632-12.69333333 5.792-2.74133333 0.384-6.528-0.40533333-9.568-3.456L127.24266667 634.93333333z' fill='#ffffff' p-id='3145'></path></svg></div>";
      $("#toolPanelContent").append(H), $("#toolPanelContent").append(R), $("#toolPanelContent").append(j), $("#toolPanelContent").append(S), $(".element-icon").hover(function() {
        $(this).css("cursor", "pointer"), $(this).css("background", "#234667"), $(this).css("border", "1px solid rgba(62,153,246,1)");
      }, function() {
        $(this).css("cursor", "move"), $(this).css("background", "rgb(85, 103, 122)"), $(this).css("border", "1px solid rgba(255,255,255,0)");
      }), $("#toolButton").click(function() {
        $("#toolPanel").is(":hidden") ? $("#toolPanel").show() : $("#toolPanel").hide();
      }), $("#distanceMeasureButton").click(() => {
        this._map.getGeoMeasureToos().startDistanceMeasure();
      }), $("#areaMeasureButton").click(() => {
        this._map.getGeoMeasureToos().startAreaMeasure();
      }), $("#angelMeasureButton").click(() => {
        this._map.getGeoMeasureToos().startAngelMeasure();
      }), $("#cleanMeasureButton").click(() => {
        this._map.getGeoMeasureToos().cleanMeasureResult();
      });
    }
    if (this._mapOptions.coordinate) {
      var tt = "<button id='coordinateButton' class='easyui-button control-button large' >经纬网</button>";
      $("#controlButtonWrapper").append(tt), $("#coordinateButton").css("margin-right", "10px"), $("#coordinateButton").click(() => {
        var kt = LonLatGridLayer.getInstance(this._map);
        kt.isShow() ? kt.hide() : kt.show();
      });
    }
    if (this._mapOptions.squareRid) {
      var nt = "<button id='squareRidButton' class='easyui-button control-button large' >方里网</button>";
      $("#controlButtonWrapper").append(nt), $("#squareRidButton").css("margin-right", "10px"), $("#squareRidButton").click(() => {
        var kt = KiloMetersGridLayer.getInstance(this._map);
        kt.isShow() ? kt.hide() : kt.show();
      });
    }
    if (this._mapOptions.assist) {
      var ft = "<div id='assistButtonWrapper' class='buttonWrapper'></div>";
      $("#" + this._mapcontainerid).prepend(ft), $("#assistButtonWrapper").css("position", "absolute"), $("#assistButtonWrapper").css("right", "50px"), $("#assistButtonWrapper").css("bottom", "50px"), $("#assistButtonWrapper").css("display", "flex"), $("#assistButtonWrapper").css("flex-direction", "column");
      var pt = "<button id='globalButton' class='easyui-button control-button small' ><svg t='1712559621864' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='4230' width='20' height='20'><path d='M512 0.128C229.312 0.128 0.16 229.12 0.16 511.584c0 260.928 195.52 476.224 448.16 507.52 14.24 3.008 31.584 4.768 52.256 4.768 5.792 0 11.392-0.32 16.8-0.864 280.192-2.88 506.464-230.72 506.464-511.424C1023.84 229.12 794.688 0.128 512 0.128zM431.296 973.44C211.04 934.976 43.584 742.944 43.584 511.808c0-33.12 3.456-65.472 10.016-96.64 20.256 21.632 68 21.12 79.616-11.232 20.832 12.416 48.832 14.656 48.832 39.488 0 81.888 2.912 169.696 77.344 171.04 2.08 0 41.472 14.944 60.224 63.552 6.496 16.832 32.128 0 60.256 0 14.048 0 0 23.68 0 74.816 0 50.944 109.856 129.408 109.856 129.408-0.512 33.728 0.864 60.992 3.68 82.784-24.8-0.48-45.696 2.816-62.08 8.416z m196.768-7.296c-2.432-11.904-13.088-18.432-32.48-13.312 15.488-65.952 23.008-102.88 55.36-130.944 46.72-40.544 5.536-85.632-30.048-80.32-28.064 4.256-10.336-34.72-35.36-36.896-25.056-2.08-57.728-51.872-93.76-69.024-19.104-9.056-37.888-33.376-67.36-34.464-26.112-1.024-64.256 22.08-64.256 4.256 0-57.312-5.824-98.24-7.008-114.56-0.96-13.12-8.576-4.416 26.72-3.584 19.2 0.512 9.824-38.592 28.864-40.096 18.656-1.472 63.168 17.472 74.496 9.92 10.56-7.04 77.44 175.584 77.44 30.176 0-17.248-8.96-47.232 0-63.584 35.328-64.544 68.384-117.184 65.44-124.896-1.696-4.32-36.16-7.904-63.744 1.344-9.28 3.136 2.976 17.696-10.4 20.8-50.08 11.584-94.336-13.504-78.848-37.056 15.872-24.128 73.376-10.528 78.4-58.976 2.88-27.744 5.312-59.872 6.912-83.744 67.424 10.528 60-87.488-40.224-97.984 202.752 2.368 374.56 133.312 437.6 315.04a19.104 19.104 0 0 0-11.2-5.12c-30.272-75.68-103.84-20.896-78.88 45.856-133.664 102.784-99.456 174.464-55.552 215.488 23.136 21.568 45.152 54.016 59.52 77.312-15.616 45.536 57.504 27.328 93.6-49.952a469.696 469.696 0 0 1-335.232 324.32z m312.96-546.624a439.904 439.904 0 0 1 9.632 99.296 501.728 501.728 0 0 0-9.984-74.752c0.448-8.672 0.576-16.896 0.352-24.544z' fill='#ffffff' p-id='4231'></path></svg></button>", ct = "<button id='zoominButton' class='easyui-button control-button small' ><svg t='1712559168871' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='1489' width='24' height='24'><path d='M919.264 905.984l-138.912-138.912C851.808 692.32 896 591.328 896 480c0-229.376-186.624-416-416-416S64 250.624 64 480s186.624 416 416 416c95.008 0 182.432-32.384 252.544-86.208l141.44 141.44a31.904 31.904 0 0 0 45.248 0 32 32 0 0 0 0.032-45.248zM128 480C128 285.92 285.92 128 480 128s352 157.92 352 352-157.92 352-352 352S128 674.08 128 480z' p-id='1490' fill='#ffffff'></path><path d='M625.792 448H512v-112a32 32 0 0 0-64 0V448h-112a32 32 0 0 0 0 64H448v112a32 32 0 1 0 64 0V512h113.792a32 32 0 1 0 0-64z' p-id='1491' fill='#ffffff'></path></svg></button>", Nt = "<button id='zoomoutButton' class='easyui-button control-button small' ><svg t='1712559519030' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='2659' width='24' height='24'><path d='M919.264 905.984l-138.912-138.912C851.808 692.32 896 591.328 896 480c0-229.376-186.624-416-416-416S64 250.624 64 480s186.624 416 416 416c95.008 0 182.432-32.384 252.544-86.208l141.44 141.44a31.904 31.904 0 0 0 45.248 0 32 32 0 0 0 0.032-45.248zM128 480C128 285.92 285.92 128 480 128s352 157.92 352 352-157.92 352-352 352S128 674.08 128 480z' p-id='2660' fill='#ffffff'></path><path d='M625.792 448H336a32 32 0 0 0 0 64h289.792a32 32 0 1 0 0-64z' p-id='2661' fill='#ffffff'></path></svg></button>";
      $("#assistButtonWrapper").append(pt), $("#assistButtonWrapper").append(ct), $("#assistButtonWrapper").append(Nt), $("#globalButton").css("margin-bottom", "10px"), $("#zoominButton").css("margin-bottom", "10px"), $("#globalButton").click(() => {
      }), $("#zoominButton").click(() => {
        this._map.zoomIn();
      }), $("#zoomoutButton").click(() => {
        this._map.zoomOut();
      });
    }
    this._mapOptions.plotPanel || this._mapOptions.elementPanel, $(".buttonWrapper").css("z-index", "1000"), $(".buttonWrapper").css("padding", "5px"), $(".buttonWrapper").css("pointer-events", "none"), $(".control-button").css("margin-right", "10px"), $(".control-button").css("pointer-events", "auto"), $(".control-button").css("background", "#55677a"), $(".control-button").css("opacity", "0.9"), $(".control-button").css("border", "0"), $(".control-button").css("border-radius", "4px"), $(".control-button").css("color", "#fff"), $(".control-button").css("font-size", "18px"), $(".large").css("width", "100px"), $(".large").css("height", "40px"), $(".small").css("width", "40px"), $(".small").css("height", "40px"), $(".control-panel").css("border-radius", "10px"), $(".control-panel").css("background", "#55677a"), $(".control-panel").css("opacity", "0.9"), $(".control-panel").css("color", "#fff"), $(".control-panel-title").css("border-bottom", "1px solid #05c6fe"), $(".control-panel-title").css("font-size", "16px"), $(".control-panel-title").css("height", "32px"), $(".control-panel-title").css("display", "flex"), $(".control-panel-title").css("justify-content", "center"), $(".control-panel-title").css("align-items", "center"), $(".sub-panel").css("border-radius", "10px"), $(".sub-panel").css("background", "#55677a"), $(".sub-panel").css("opacity", "0.9"), $(".sub-panel").css("color", "#fff"), $(".sub-panel").css("display", "flex"), $(".sub-panel").css("flex-direction", "row"), $(".sub-panel").css("align-items", "center"), $(".element-icon").css("border-radius", "2px"), $(".element-icon").css("width", "36px"), $(".element-icon").css("height", "36px"), $(".element-icon").css("display", "flex"), $(".element-icon").css("flex-direction", "row"), $(".element-icon").css("justify-content", "center"), $(".element-icon").css("align-items", "center"), $(".element-icon").css("margin", "0 10px"), $(".control-button").hover(function() {
      $(this).css("cursor", "pointer"), $(this).hasClass("active") || $(this).css("color", "#05c6fe");
    }, function() {
      $(this).css("cursor", "move"), $(this).hasClass("active") || $(this).css("color", "#fff");
    }), $("#globalButton").hover(function() {
      $("#globalButton svg path").attr("fill", "#05c6fe");
    }, function() {
      $("#globalButton svg path").attr("fill", "#fff");
    }), $("#zoominButton").hover(function() {
      $("#zoominButton svg path").attr("fill", "#05c6fe");
    }, function() {
      $("#zoominButton svg path").attr("fill", "#fff");
    }), $("#zoomoutButton").hover(function() {
      $("#zoomoutButton svg path").attr("fill", "#05c6fe");
    }, function() {
      $("#zoomoutButton svg path").attr("fill", "#fff");
    }), $(".control-button").click(function() {
      $(this).hasClass("active") ? $(this).css("color", "#fff") : $(this).css("color", "#05c6fe"), $(this).toggleClass("active");
    }), $(".control-panel").on("dblclick", function(kt) {
      kt.stopPropagation(), kt.preventDefault();
    }), $(".buttonWrapper").on("dblclick", function(kt) {
      kt.stopPropagation(), kt.preventDefault();
    }), $(".control-panel").on("mousewheel DOMMouseScroll", function(kt) {
      kt.stopPropagation();
    }), $(".buttonWrapper").on("mousewheel DOMMouseScroll", function(kt) {
      kt.stopPropagation(), kt.preventDefault();
    }), $(".control-panel").draggable({
      onDrag: function(kt) {
        var Rt = kt.data;
        Rt.left < 0 && (Rt.left = 0), Rt.top < 0 && (Rt.top = 0), Rt.left + $(Rt.target).outerWidth() > $(Rt.parent).width() && (Rt.left = $(Rt.parent).width() - $(Rt.target).outerWidth()), Rt.top + $(Rt.target).outerHeight() > $(Rt.parent).height() && (Rt.top = $(Rt.parent).height() - $(Rt.target).outerHeight());
      }
    });
  }
  addImagelayer(n) {
    this._featureLayers.push(n);
    var r = n._layerName, o = n._id, l = "<div id='" + o + "' class='layer-list-item'><div class='layer-item'><input type='checkbox' class='layer-item-checkbox' id='" + o + "_check' checked />" + r + "</div></div>";
    $("#layerList").append(l), $(".layer-list-item").css("display", "flex"), $(".layer-list-item").css("align-items", "center"), $(".layer-list-item").css("justify-content", "space-between"), $(".layer-list-item").css("padding", "8px 20px 8px 0"), $(".layer-item").css("display", "flex"), $(".layer-item").css("margin", "0 !important"), $(".layer-item").css("padding", "0px 5px"), $(".layer-item-checkbox").css("margin-right", "8px"), $("#" + o + "_check").change(function() {
      $(this).is(":checked") === !0 ? n.show() : n.hide();
    }), $("#" + o + "_check").hover(function() {
      $(this).css("cursor", "pointer");
    }, function() {
      $(this).css("cursor", "move");
    }), $(".layer-list-item").hover(function() {
      $(this).css("background", "#2a5074");
    }, function() {
      $(this).css("background", "#55677a");
    });
  }
  removeImagelayer(n) {
    var r = n._id;
    $("#" + r).remove();
  }
  addFeatureLayer(n) {
    this._featureLayers.push(n), n._layerType == LayerType.PLOT && (this._editeLayer = n);
    var r = n._layerName, o = n._id, l = null;
    n._layerType == LayerType.PLOT ? l = "<div id='" + o + "' class='layer-list-item'><div class='layer-item'><input type='checkbox' class='layer-item-checkbox' id='" + o + "_check' checked />" + r + "</div><div class='edit-icon'><svg t='1710321278015' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='1909' width='14' height='14'><path d='M853.333333 501.333333c-17.066667 0-32 14.933333-32 32v320c0 6.4-4.266667 10.666667-10.666666 10.666667H170.666667c-6.4 0-10.666667-4.266667-10.666667-10.666667V213.333333c0-6.4 4.266667-10.666667 10.666667-10.666666h320c17.066667 0 32-14.933333 32-32s-14.933333-32-32-32H170.666667c-40.533333 0-74.666667 34.133333-74.666667 74.666666v640c0 40.533333 34.133333 74.666667 74.666667 74.666667h640c40.533333 0 74.666667-34.133333 74.666666-74.666667V533.333333c0-17.066667-14.933333-32-32-32z' fill='#ffffff' p-id='1910'></path><path d='M405.333333 484.266667l-32 125.866666c-2.133333 10.666667 0 23.466667 8.533334 29.866667 6.4 6.4 14.933333 8.533333 23.466666 8.533333h8.533334l125.866666-32c6.4-2.133333 10.666667-4.266667 14.933334-8.533333l300.8-300.8c38.4-38.4 38.4-102.4 0-140.8-38.4-38.4-102.4-38.4-140.8 0L413.866667 469.333333c-4.266667 4.266667-6.4 8.533333-8.533334 14.933334z m59.733334 23.466666L761.6 213.333333c12.8-12.8 36.266667-12.8 49.066667 0 12.8 12.8 12.8 36.266667 0 49.066667L516.266667 558.933333l-66.133334 17.066667 14.933334-68.266667z' fill='#ffffff' p-id='1911'></path></svg></div></div>" : l = "<div id='" + o + "' class='layer-list-item'><div class='layer-item'><input type='checkbox' class='layer-item-checkbox' id='" + o + "_check' checked />" + r + "</div></div>", $("#layerList").append(l), $(".layer-list-item").css("display", "flex"), $(".layer-list-item").css("align-items", "center"), $(".layer-list-item").css("justify-content", "space-between"), $(".layer-list-item").css("padding", "8px 20px 8px 0"), $(".layer-item").css("display", "flex"), $(".layer-item").css("margin", "0 !important"), $(".layer-item").css("padding", "0px 5px"), $(".layer-item-checkbox").css("margin-right", "8px"), $("#" + o + "_check").change(function() {
      $(this).is(":checked") === !0 ? n.show() : n.hide();
    }), $("#" + o + "_check").hover(function() {
      $(this).css("cursor", "pointer");
    }, function() {
      $(this).css("cursor", "move");
    }), $(".layer-list-item").hover(function() {
      $(this).hasClass("editable") || $(this).css("background", "#2a5074");
    }, function() {
      $(this).hasClass("editable") || $(this).css("background", "#55677a");
    }), $(".edit-icon").hover(function() {
      $(this).css("cursor", "pointer");
    }, function() {
      $(this).css("cursor", "move");
    }), $(".edit-icon").click((u) => {
      let h = $(u.currentTarget).parent().attr("id"), c = this._map.getLayerByID(h);
      c && c._layerType === LayerType.PLOT && ($(".layer-list-item").each(function(f, v) {
        $(v).css("background", "#55677a"), $(v).removeClass("editable");
      }), $(u.currentTarget).parent().css("background", "rgba(153, 167, 20, 1)"), $(u.currentTarget).parent().addClass("editable"), this._editeLayer.endEdite(), this._editeLayer = c, c.startEdite());
    });
  }
  removeFeaturelayer(n) {
    var r = n._id;
    $("#" + r).remove();
  }
  loadPlotTreeJson(n, r) {
    let o = this._plotTreeDict;
    this._editeLayer;
    let l = [];
    for (let u = 0; u < n.data.length; u++) {
      let h = n.data[u];
      h = this.deleteNode(h), l.push(h);
    }
    $("#plotPanelContent").tree({
      data: l,
      onClick: function(u) {
        if ($(".mark-item").remove(), u.leaf)
          for (let c = 0; c < o["node" + u.id].length; c++) {
            var h = "<div class='mark-item' id='node" + u.id + "-" + c + "'><img style='width:55px;height:55px;' src='" + o["node" + u.id][c].url + "' title='" + o["node" + u.id][c].text + "' /></div>";
            $("#markList").append(h);
          }
        $(".mark-item").css("width", "57px"), $(".mark-item").css("height", "57px"), $(".mark-item").css("border-right", "1px solid #fff"), $(".mark-item").css("border-bottom", "1px solid #fff"), $(".mark-item").css("display", "flex"), $(".mark-item").css("justify-content", "center"), $(".mark-item").css("align-items", "center"), $(".mark-item").css("cursor", "pointer"), $(".mark-item").click((c) => {
          let f = c.currentTarget.id, v = f.split("-")[0], m = f.split("-")[1], g = new FeatureStyle();
          if (defined(r)) {
            g.plotPntURL = o[v][m].url;
            let y = r._editeLayer.createPlotFeature(FeatureType.PlotPng, g);
            defined(y) && y.rotate(0);
          }
        });
      }
    });
  }
  deleteNode(n) {
    return n === null || n.url ? null : (n.leaf && (this._plotTreeDict["node" + n.id] = n.children), n.children = n.children.filter((r) => this.deleteNode(r) !== null), n);
  }
}
const Ln = class Ln extends PlotLayer {
  constructor(n, r) {
    super(n, r, null), this._measureResult = [], this._className = "GeoMeasureTools", this._map = n;
  }
  // 提供一个获取实例的静态方法
  static getInstance(n) {
    if (!Ln._instance) {
      let r = new FeatureLayerOptions("测量");
      Ln._instance = new Ln(n, r);
    }
    return Ln._instance;
  }
  startDistanceMeasure() {
    this.startEdite(), this._measureResult.push(this.createPlotFeature(FeatureType.DistanceResult));
  }
  startAreaMeasure() {
    this.startEdite(), this._measureResult.push(this.createPlotFeature(FeatureType.AreaResult));
  }
  startAngelMeasure() {
    this.startEdite(), this._measureResult.push(this.createPlotFeature(FeatureType.AngleResult));
  }
  getPosition() {
    this.startEdite(), this._measureResult.push(this.createPlotFeature(FeatureType.PositionResult));
  }
  cleanMeasureResult() {
    this.removeAll(), this._measureResult = [], this.endEdite();
  }
};
Ln._instance = null;
let GeoMeasureTools = Ln;
function bind(e, n) {
  return function() {
    return e.apply(n, arguments);
  };
}
const { toString } = Object.prototype, { getPrototypeOf } = Object, kindOf = /* @__PURE__ */ ((e) => (n) => {
  const r = toString.call(n);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest = (e) => (e = e.toLowerCase(), (n) => kindOf(n) === e), typeOfTest = (e) => (n) => typeof n === e, { isArray } = Array, isUndefined = typeOfTest("undefined");
function isBuffer(e) {
  return e !== null && !isUndefined(e) && e.constructor !== null && !isUndefined(e.constructor) && isFunction(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(e) {
  let n;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? n = ArrayBuffer.isView(e) : n = e && e.buffer && isArrayBuffer(e.buffer), n;
}
const isString = typeOfTest("string"), isFunction = typeOfTest("function"), isNumber = typeOfTest("number"), isObject = (e) => e !== null && typeof e == "object", isBoolean = (e) => e === !0 || e === !1, isPlainObject = (e) => {
  if (kindOf(e) !== "object")
    return !1;
  const n = getPrototypeOf(e);
  return (n === null || n === Object.prototype || Object.getPrototypeOf(n) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = (e) => isObject(e) && isFunction(e.pipe), isFormData = (e) => {
  let n;
  return e && (typeof FormData == "function" && e instanceof FormData || isFunction(e.append) && ((n = kindOf(e)) === "formdata" || // detect form-data instance
  n === "object" && isFunction(e.toString) && e.toString() === "[object FormData]"));
}, isURLSearchParams = kindOfTest("URLSearchParams"), trim = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(e, n, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let o, l;
  if (typeof e != "object" && (e = [e]), isArray(e))
    for (o = 0, l = e.length; o < l; o++)
      n.call(null, e[o], o, e);
  else {
    const u = r ? Object.getOwnPropertyNames(e) : Object.keys(e), h = u.length;
    let c;
    for (o = 0; o < h; o++)
      c = u[o], n.call(null, e[c], c, e);
  }
}
function findKey(e, n) {
  n = n.toLowerCase();
  const r = Object.keys(e);
  let o = r.length, l;
  for (; o-- > 0; )
    if (l = r[o], n === l.toLowerCase())
      return l;
  return null;
}
const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, isContextDefined = (e) => !isUndefined(e) && e !== _global;
function merge() {
  const { caseless: e } = isContextDefined(this) && this || {}, n = {}, r = (o, l) => {
    const u = e && findKey(n, l) || l;
    isPlainObject(n[u]) && isPlainObject(o) ? n[u] = merge(n[u], o) : isPlainObject(o) ? n[u] = merge({}, o) : isArray(o) ? n[u] = o.slice() : n[u] = o;
  };
  for (let o = 0, l = arguments.length; o < l; o++)
    arguments[o] && forEach(arguments[o], r);
  return n;
}
const extend = (e, n, r, { allOwnKeys: o } = {}) => (forEach(n, (l, u) => {
  r && isFunction(l) ? e[u] = bind(l, r) : e[u] = l;
}, { allOwnKeys: o }), e), stripBOM = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), inherits = (e, n, r, o) => {
  e.prototype = Object.create(n.prototype, o), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: n.prototype
  }), r && Object.assign(e.prototype, r);
}, toFlatObject = (e, n, r, o) => {
  let l, u, h;
  const c = {};
  if (n = n || {}, e == null)
    return n;
  do {
    for (l = Object.getOwnPropertyNames(e), u = l.length; u-- > 0; )
      h = l[u], (!o || o(h, e, n)) && !c[h] && (n[h] = e[h], c[h] = !0);
    e = r !== !1 && getPrototypeOf(e);
  } while (e && (!r || r(e, n)) && e !== Object.prototype);
  return n;
}, endsWith = (e, n, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= n.length;
  const o = e.indexOf(n, r);
  return o !== -1 && o === r;
}, toArray = (e) => {
  if (!e)
    return null;
  if (isArray(e))
    return e;
  let n = e.length;
  if (!isNumber(n))
    return null;
  const r = new Array(n);
  for (; n-- > 0; )
    r[n] = e[n];
  return r;
}, isTypedArray = /* @__PURE__ */ ((e) => (n) => e && n instanceof e)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = (e, n) => {
  const o = (e && e[Symbol.iterator]).call(e);
  let l;
  for (; (l = o.next()) && !l.done; ) {
    const u = l.value;
    n.call(e, u[0], u[1]);
  }
}, matchAll = (e, n) => {
  let r;
  const o = [];
  for (; (r = e.exec(n)) !== null; )
    o.push(r);
  return o;
}, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, o, l) {
    return o.toUpperCase() + l;
  }
), hasOwnProperty = (({ hasOwnProperty: e }) => (n, r) => e.call(n, r))(Object.prototype), isRegExp = kindOfTest("RegExp"), reduceDescriptors = (e, n) => {
  const r = Object.getOwnPropertyDescriptors(e), o = {};
  forEach(r, (l, u) => {
    let h;
    (h = n(l, u, e)) !== !1 && (o[u] = h || l);
  }), Object.defineProperties(e, o);
}, freezeMethods = (e) => {
  reduceDescriptors(e, (n, r) => {
    if (isFunction(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const o = e[r];
    if (isFunction(o)) {
      if (n.enumerable = !1, "writable" in n) {
        n.writable = !1;
        return;
      }
      n.set || (n.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, toObjectSet = (e, n) => {
  const r = {}, o = (l) => {
    l.forEach((u) => {
      r[u] = !0;
    });
  };
  return isArray(e) ? o(e) : o(String(e).split(n)), r;
}, noop = () => {
}, toFiniteNumber = (e, n) => (e = +e, Number.isFinite(e) ? e : n), ALPHA = "abcdefghijklmnopqrstuvwxyz", DIGIT = "0123456789", ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}, generateString = (e = 16, n = ALPHABET.ALPHA_DIGIT) => {
  let r = "";
  const { length: o } = n;
  for (; e--; )
    r += n[Math.random() * o | 0];
  return r;
};
function isSpecCompliantForm(e) {
  return !!(e && isFunction(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const toJSONObject = (e) => {
  const n = new Array(10), r = (o, l) => {
    if (isObject(o)) {
      if (n.indexOf(o) >= 0)
        return;
      if (!("toJSON" in o)) {
        n[l] = o;
        const u = isArray(o) ? [] : {};
        return forEach(o, (h, c) => {
          const f = r(h, l + 1);
          !isUndefined(f) && (u[c] = f);
        }), n[l] = void 0, u;
      }
    }
    return o;
  };
  return r(e, 0);
}, isAsyncFn = kindOfTest("AsyncFunction"), isThenable = (e) => e && (isObject(e) || isFunction(e)) && isFunction(e.then) && isFunction(e.catch), utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(e, n, r, o, l) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", n && (this.code = n), r && (this.config = r), o && (this.request = o), l && (this.response = l);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function e() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype, descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  descriptors[e] = { value: e };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: !0 });
AxiosError.from = (e, n, r, o, l, u) => {
  const h = Object.create(prototype$1);
  return utils$1.toFlatObject(e, h, function(f) {
    return f !== Error.prototype;
  }, (c) => c !== "isAxiosError"), AxiosError.call(h, e.message, n, r, o, l), h.cause = e, h.name = e.name, u && Object.assign(h, u), h;
};
const httpAdapter = null;
function isVisitable(e) {
  return utils$1.isPlainObject(e) || utils$1.isArray(e);
}
function removeBrackets(e) {
  return utils$1.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function renderKey(e, n, r) {
  return e ? e.concat(n).map(function(l, u) {
    return l = removeBrackets(l), !r && u ? "[" + l + "]" : l;
  }).join(r ? "." : "") : n;
}
function isFlatArray(e) {
  return utils$1.isArray(e) && !e.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function e(n) {
  return /^is[A-Z]/.test(n);
});
function toFormData(e, n, r) {
  if (!utils$1.isObject(e))
    throw new TypeError("target must be an object");
  n = n || new FormData(), r = utils$1.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(x, D) {
    return !utils$1.isUndefined(D[x]);
  });
  const o = r.metaTokens, l = r.visitor || m, u = r.dots, h = r.indexes, f = (r.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(n);
  if (!utils$1.isFunction(l))
    throw new TypeError("visitor must be a function");
  function v(E) {
    if (E === null)
      return "";
    if (utils$1.isDate(E))
      return E.toISOString();
    if (!f && utils$1.isBlob(E))
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    return utils$1.isArrayBuffer(E) || utils$1.isTypedArray(E) ? f && typeof Blob == "function" ? new Blob([E]) : Buffer.from(E) : E;
  }
  function m(E, x, D) {
    let F = E;
    if (E && !D && typeof E == "object") {
      if (utils$1.endsWith(x, "{}"))
        x = o ? x : x.slice(0, -2), E = JSON.stringify(E);
      else if (utils$1.isArray(E) && isFlatArray(E) || (utils$1.isFileList(E) || utils$1.endsWith(x, "[]")) && (F = utils$1.toArray(E)))
        return x = removeBrackets(x), F.forEach(function(N, H) {
          !(utils$1.isUndefined(N) || N === null) && n.append(
            // eslint-disable-next-line no-nested-ternary
            h === !0 ? renderKey([x], H, u) : h === null ? x : x + "[]",
            v(N)
          );
        }), !1;
    }
    return isVisitable(E) ? !0 : (n.append(renderKey(D, x, u), v(E)), !1);
  }
  const g = [], y = Object.assign(predicates, {
    defaultVisitor: m,
    convertValue: v,
    isVisitable
  });
  function w(E, x) {
    if (!utils$1.isUndefined(E)) {
      if (g.indexOf(E) !== -1)
        throw Error("Circular reference detected in " + x.join("."));
      g.push(E), utils$1.forEach(E, function(F, k) {
        (!(utils$1.isUndefined(F) || F === null) && l.call(
          n,
          F,
          utils$1.isString(k) ? k.trim() : k,
          x,
          y
        )) === !0 && w(F, x ? x.concat(k) : [k]);
      }), g.pop();
    }
  }
  if (!utils$1.isObject(e))
    throw new TypeError("data must be an object");
  return w(e), n;
}
function encode$1(e) {
  const n = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(o) {
    return n[o];
  });
}
function AxiosURLSearchParams(e, n) {
  this._pairs = [], e && toFormData(e, this, n);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function e(n, r) {
  this._pairs.push([n, r]);
};
prototype.toString = function e(n) {
  const r = n ? function(o) {
    return n.call(this, o, encode$1);
  } : encode$1;
  return this._pairs.map(function(l) {
    return r(l[0]) + "=" + r(l[1]);
  }, "").join("&");
};
function encode(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(e, n, r) {
  if (!n)
    return e;
  const o = r && r.encode || encode, l = r && r.serialize;
  let u;
  if (l ? u = l(n, r) : u = utils$1.isURLSearchParams(n) ? n.toString() : new AxiosURLSearchParams(n, r).toString(o), u) {
    const h = e.indexOf("#");
    h !== -1 && (e = e.slice(0, h)), e += (e.indexOf("?") === -1 ? "?" : "&") + u;
  }
  return e;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(n, r, o) {
    return this.handlers.push({
      fulfilled: n,
      rejected: r,
      synchronous: o ? o.synchronous : !1,
      runWhen: o ? o.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(n) {
    this.handlers[n] && (this.handlers[n] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(n) {
    utils$1.forEach(this.handlers, function(o) {
      o !== null && n(o);
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams, FormData$1 = typeof FormData < "u" ? FormData : null, Blob$1 = typeof Blob < "u" ? Blob : null, platform$1 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, hasBrowserEnv = typeof window < "u" && typeof document < "u", hasStandardBrowserEnv = ((e) => hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" })), platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(e, n) {
  return toFormData(e, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(r, o, l, u) {
      return platform.isNode && utils$1.isBuffer(r) ? (this.append(o, r.toString("base64")), !1) : u.defaultVisitor.apply(this, arguments);
    }
  }, n));
}
function parsePropPath(e) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, e).map((n) => n[0] === "[]" ? "" : n[1] || n[0]);
}
function arrayToObject(e) {
  const n = {}, r = Object.keys(e);
  let o;
  const l = r.length;
  let u;
  for (o = 0; o < l; o++)
    u = r[o], n[u] = e[u];
  return n;
}
function formDataToJSON(e) {
  function n(r, o, l, u) {
    let h = r[u++];
    if (h === "__proto__")
      return !0;
    const c = Number.isFinite(+h), f = u >= r.length;
    return h = !h && utils$1.isArray(l) ? l.length : h, f ? (utils$1.hasOwnProp(l, h) ? l[h] = [l[h], o] : l[h] = o, !c) : ((!l[h] || !utils$1.isObject(l[h])) && (l[h] = []), n(r, o, l[h], u) && utils$1.isArray(l[h]) && (l[h] = arrayToObject(l[h])), !c);
  }
  if (utils$1.isFormData(e) && utils$1.isFunction(e.entries)) {
    const r = {};
    return utils$1.forEachEntry(e, (o, l) => {
      n(parsePropPath(o), l, r, 0);
    }), r;
  }
  return null;
}
function stringifySafely(e, n, r) {
  if (utils$1.isString(e))
    try {
      return (n || JSON.parse)(e), utils$1.trim(e);
    } catch (o) {
      if (o.name !== "SyntaxError")
        throw o;
    }
  return (r || JSON.stringify)(e);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function e(n, r) {
    const o = r.getContentType() || "", l = o.indexOf("application/json") > -1, u = utils$1.isObject(n);
    if (u && utils$1.isHTMLForm(n) && (n = new FormData(n)), utils$1.isFormData(n))
      return l ? JSON.stringify(formDataToJSON(n)) : n;
    if (utils$1.isArrayBuffer(n) || utils$1.isBuffer(n) || utils$1.isStream(n) || utils$1.isFile(n) || utils$1.isBlob(n))
      return n;
    if (utils$1.isArrayBufferView(n))
      return n.buffer;
    if (utils$1.isURLSearchParams(n))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), n.toString();
    let c;
    if (u) {
      if (o.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm(n, this.formSerializer).toString();
      if ((c = utils$1.isFileList(n)) || o.indexOf("multipart/form-data") > -1) {
        const f = this.env && this.env.FormData;
        return toFormData(
          c ? { "files[]": n } : n,
          f && new f(),
          this.formSerializer
        );
      }
    }
    return u || l ? (r.setContentType("application/json", !1), stringifySafely(n)) : n;
  }],
  transformResponse: [function e(n) {
    const r = this.transitional || defaults.transitional, o = r && r.forcedJSONParsing, l = this.responseType === "json";
    if (n && utils$1.isString(n) && (o && !this.responseType || l)) {
      const h = !(r && r.silentJSONParsing) && l;
      try {
        return JSON.parse(n);
      } catch (c) {
        if (h)
          throw c.name === "SyntaxError" ? AxiosError.from(c, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : c;
      }
    }
    return n;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function e(n) {
    return n >= 200 && n < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  defaults.headers[e] = {};
});
const defaults$1 = defaults, ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders = (e) => {
  const n = {};
  let r, o, l;
  return e && e.split(`
`).forEach(function(h) {
    l = h.indexOf(":"), r = h.substring(0, l).trim().toLowerCase(), o = h.substring(l + 1).trim(), !(!r || n[r] && ignoreDuplicateOf[r]) && (r === "set-cookie" ? n[r] ? n[r].push(o) : n[r] = [o] : n[r] = n[r] ? n[r] + ", " + o : o);
  }), n;
}, $internals = Symbol("internals");
function normalizeHeader(e) {
  return e && String(e).trim().toLowerCase();
}
function normalizeValue(e) {
  return e === !1 || e == null ? e : utils$1.isArray(e) ? e.map(normalizeValue) : String(e);
}
function parseTokens(e) {
  const n = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let o;
  for (; o = r.exec(e); )
    n[o[1]] = o[2];
  return n;
}
const isValidHeaderName = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function matchHeaderValue(e, n, r, o, l) {
  if (utils$1.isFunction(o))
    return o.call(this, n, r);
  if (l && (n = r), !!utils$1.isString(n)) {
    if (utils$1.isString(o))
      return n.indexOf(o) !== -1;
    if (utils$1.isRegExp(o))
      return o.test(n);
  }
}
function formatHeader(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (n, r, o) => r.toUpperCase() + o);
}
function buildAccessors(e, n) {
  const r = utils$1.toCamelCase(" " + n);
  ["get", "set", "has"].forEach((o) => {
    Object.defineProperty(e, o + r, {
      value: function(l, u, h) {
        return this[o].call(this, n, l, u, h);
      },
      configurable: !0
    });
  });
}
class AxiosHeaders {
  constructor(n) {
    n && this.set(n);
  }
  set(n, r, o) {
    const l = this;
    function u(c, f, v) {
      const m = normalizeHeader(f);
      if (!m)
        throw new Error("header name must be a non-empty string");
      const g = utils$1.findKey(l, m);
      (!g || l[g] === void 0 || v === !0 || v === void 0 && l[g] !== !1) && (l[g || f] = normalizeValue(c));
    }
    const h = (c, f) => utils$1.forEach(c, (v, m) => u(v, m, f));
    return utils$1.isPlainObject(n) || n instanceof this.constructor ? h(n, r) : utils$1.isString(n) && (n = n.trim()) && !isValidHeaderName(n) ? h(parseHeaders(n), r) : n != null && u(r, n, o), this;
  }
  get(n, r) {
    if (n = normalizeHeader(n), n) {
      const o = utils$1.findKey(this, n);
      if (o) {
        const l = this[o];
        if (!r)
          return l;
        if (r === !0)
          return parseTokens(l);
        if (utils$1.isFunction(r))
          return r.call(this, l, o);
        if (utils$1.isRegExp(r))
          return r.exec(l);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(n, r) {
    if (n = normalizeHeader(n), n) {
      const o = utils$1.findKey(this, n);
      return !!(o && this[o] !== void 0 && (!r || matchHeaderValue(this, this[o], o, r)));
    }
    return !1;
  }
  delete(n, r) {
    const o = this;
    let l = !1;
    function u(h) {
      if (h = normalizeHeader(h), h) {
        const c = utils$1.findKey(o, h);
        c && (!r || matchHeaderValue(o, o[c], c, r)) && (delete o[c], l = !0);
      }
    }
    return utils$1.isArray(n) ? n.forEach(u) : u(n), l;
  }
  clear(n) {
    const r = Object.keys(this);
    let o = r.length, l = !1;
    for (; o--; ) {
      const u = r[o];
      (!n || matchHeaderValue(this, this[u], u, n, !0)) && (delete this[u], l = !0);
    }
    return l;
  }
  normalize(n) {
    const r = this, o = {};
    return utils$1.forEach(this, (l, u) => {
      const h = utils$1.findKey(o, u);
      if (h) {
        r[h] = normalizeValue(l), delete r[u];
        return;
      }
      const c = n ? formatHeader(u) : String(u).trim();
      c !== u && delete r[u], r[c] = normalizeValue(l), o[c] = !0;
    }), this;
  }
  concat(...n) {
    return this.constructor.concat(this, ...n);
  }
  toJSON(n) {
    const r = /* @__PURE__ */ Object.create(null);
    return utils$1.forEach(this, (o, l) => {
      o != null && o !== !1 && (r[l] = n && utils$1.isArray(o) ? o.join(", ") : o);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([n, r]) => n + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(n) {
    return n instanceof this ? n : new this(n);
  }
  static concat(n, ...r) {
    const o = new this(n);
    return r.forEach((l) => o.set(l)), o;
  }
  static accessor(n) {
    const o = (this[$internals] = this[$internals] = {
      accessors: {}
    }).accessors, l = this.prototype;
    function u(h) {
      const c = normalizeHeader(h);
      o[c] || (buildAccessors(l, h), o[c] = !0);
    }
    return utils$1.isArray(n) ? n.forEach(u) : u(n), this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value: e }, n) => {
  let r = n[0].toUpperCase() + n.slice(1);
  return {
    get: () => e,
    set(o) {
      this[r] = o;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(e, n) {
  const r = this || defaults$1, o = n || r, l = AxiosHeaders$1.from(o.headers);
  let u = o.data;
  return utils$1.forEach(e, function(c) {
    u = c.call(r, u, l.normalize(), n ? n.status : void 0);
  }), l.normalize(), u;
}
function isCancel(e) {
  return !!(e && e.__CANCEL__);
}
function CanceledError(e, n, r) {
  AxiosError.call(this, e ?? "canceled", AxiosError.ERR_CANCELED, n, r), this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: !0
});
function settle(e, n, r) {
  const o = r.config.validateStatus;
  !r.status || !o || o(r.status) ? e(r) : n(new AxiosError(
    "Request failed with status code " + r.status,
    [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, n, r, o, l, u) {
      const h = [e + "=" + encodeURIComponent(n)];
      utils$1.isNumber(r) && h.push("expires=" + new Date(r).toGMTString()), utils$1.isString(o) && h.push("path=" + o), utils$1.isString(l) && h.push("domain=" + l), u === !0 && h.push("secure"), document.cookie = h.join("; ");
    },
    read(e) {
      const n = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return n ? decodeURIComponent(n[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function combineURLs(e, n) {
  return n ? e.replace(/\/?\/$/, "") + "/" + n.replace(/^\/+/, "") : e;
}
function buildFullPath(e, n) {
  return e && !isAbsoluteURL(n) ? combineURLs(e, n) : n;
}
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function e() {
    const n = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a");
    let o;
    function l(u) {
      let h = u;
      return n && (r.setAttribute("href", h), h = r.href), r.setAttribute("href", h), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return o = l(window.location.href), function(h) {
      const c = utils$1.isString(h) ? l(h) : h;
      return c.protocol === o.protocol && c.host === o.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function e() {
    return function() {
      return !0;
    };
  }()
);
function parseProtocol(e) {
  const n = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return n && n[1] || "";
}
function speedometer(e, n) {
  e = e || 10;
  const r = new Array(e), o = new Array(e);
  let l = 0, u = 0, h;
  return n = n !== void 0 ? n : 1e3, function(f) {
    const v = Date.now(), m = o[u];
    h || (h = v), r[l] = f, o[l] = v;
    let g = u, y = 0;
    for (; g !== l; )
      y += r[g++], g = g % e;
    if (l = (l + 1) % e, l === u && (u = (u + 1) % e), v - h < n)
      return;
    const w = m && v - m;
    return w ? Math.round(y * 1e3 / w) : void 0;
  };
}
function progressEventReducer(e, n) {
  let r = 0;
  const o = speedometer(50, 250);
  return (l) => {
    const u = l.loaded, h = l.lengthComputable ? l.total : void 0, c = u - r, f = o(c), v = u <= h;
    r = u;
    const m = {
      loaded: u,
      total: h,
      progress: h ? u / h : void 0,
      bytes: c,
      rate: f || void 0,
      estimated: f && h && v ? (h - u) / f : void 0,
      event: l
    };
    m[n ? "download" : "upload"] = !0, e(m);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhrAdapter = isXHRAdapterSupported && function(e) {
  return new Promise(function(r, o) {
    let l = e.data;
    const u = AxiosHeaders$1.from(e.headers).normalize();
    let { responseType: h, withXSRFToken: c } = e, f;
    function v() {
      e.cancelToken && e.cancelToken.unsubscribe(f), e.signal && e.signal.removeEventListener("abort", f);
    }
    let m;
    if (utils$1.isFormData(l)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
        u.setContentType(!1);
      else if ((m = u.getContentType()) !== !1) {
        const [x, ...D] = m ? m.split(";").map((F) => F.trim()).filter(Boolean) : [];
        u.setContentType([x || "multipart/form-data", ...D].join("; "));
      }
    }
    let g = new XMLHttpRequest();
    if (e.auth) {
      const x = e.auth.username || "", D = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      u.set("Authorization", "Basic " + btoa(x + ":" + D));
    }
    const y = buildFullPath(e.baseURL, e.url);
    g.open(e.method.toUpperCase(), buildURL(y, e.params, e.paramsSerializer), !0), g.timeout = e.timeout;
    function w() {
      if (!g)
        return;
      const x = AxiosHeaders$1.from(
        "getAllResponseHeaders" in g && g.getAllResponseHeaders()
      ), F = {
        data: !h || h === "text" || h === "json" ? g.responseText : g.response,
        status: g.status,
        statusText: g.statusText,
        headers: x,
        config: e,
        request: g
      };
      settle(function(N) {
        r(N), v();
      }, function(N) {
        o(N), v();
      }, F), g = null;
    }
    if ("onloadend" in g ? g.onloadend = w : g.onreadystatechange = function() {
      !g || g.readyState !== 4 || g.status === 0 && !(g.responseURL && g.responseURL.indexOf("file:") === 0) || setTimeout(w);
    }, g.onabort = function() {
      g && (o(new AxiosError("Request aborted", AxiosError.ECONNABORTED, e, g)), g = null);
    }, g.onerror = function() {
      o(new AxiosError("Network Error", AxiosError.ERR_NETWORK, e, g)), g = null;
    }, g.ontimeout = function() {
      let D = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const F = e.transitional || transitionalDefaults;
      e.timeoutErrorMessage && (D = e.timeoutErrorMessage), o(new AxiosError(
        D,
        F.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        e,
        g
      )), g = null;
    }, platform.hasStandardBrowserEnv && (c && utils$1.isFunction(c) && (c = c(e)), c || c !== !1 && isURLSameOrigin(y))) {
      const x = e.xsrfHeaderName && e.xsrfCookieName && cookies.read(e.xsrfCookieName);
      x && u.set(e.xsrfHeaderName, x);
    }
    l === void 0 && u.setContentType(null), "setRequestHeader" in g && utils$1.forEach(u.toJSON(), function(D, F) {
      g.setRequestHeader(F, D);
    }), utils$1.isUndefined(e.withCredentials) || (g.withCredentials = !!e.withCredentials), h && h !== "json" && (g.responseType = e.responseType), typeof e.onDownloadProgress == "function" && g.addEventListener("progress", progressEventReducer(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && g.upload && g.upload.addEventListener("progress", progressEventReducer(e.onUploadProgress)), (e.cancelToken || e.signal) && (f = (x) => {
      g && (o(!x || x.type ? new CanceledError(null, e, g) : x), g.abort(), g = null);
    }, e.cancelToken && e.cancelToken.subscribe(f), e.signal && (e.signal.aborted ? f() : e.signal.addEventListener("abort", f)));
    const E = parseProtocol(y);
    if (E && platform.protocols.indexOf(E) === -1) {
      o(new AxiosError("Unsupported protocol " + E + ":", AxiosError.ERR_BAD_REQUEST, e));
      return;
    }
    g.send(l || null);
  });
}, knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$1.forEach(knownAdapters, (e, n) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: n });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: n });
  }
});
const renderReason = (e) => `- ${e}`, isResolvedHandle = (e) => utils$1.isFunction(e) || e === null || e === !1, adapters = {
  getAdapter: (e) => {
    e = utils$1.isArray(e) ? e : [e];
    const { length: n } = e;
    let r, o;
    const l = {};
    for (let u = 0; u < n; u++) {
      r = e[u];
      let h;
      if (o = r, !isResolvedHandle(r) && (o = knownAdapters[(h = String(r)).toLowerCase()], o === void 0))
        throw new AxiosError(`Unknown adapter '${h}'`);
      if (o)
        break;
      l[h || "#" + u] = o;
    }
    if (!o) {
      const u = Object.entries(l).map(
        ([c, f]) => `adapter ${c} ` + (f === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let h = n ? u.length > 1 ? `since :
` + u.map(renderReason).join(`
`) : " " + renderReason(u[0]) : "as no adapter specified";
      throw new AxiosError(
        "There is no suitable adapter to dispatch the request " + h,
        "ERR_NOT_SUPPORT"
      );
    }
    return o;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new CanceledError(null, e);
}
function dispatchRequest(e) {
  return throwIfCancellationRequested(e), e.headers = AxiosHeaders$1.from(e.headers), e.data = transformData.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(e.adapter || defaults$1.adapter)(e).then(function(o) {
    return throwIfCancellationRequested(e), o.data = transformData.call(
      e,
      e.transformResponse,
      o
    ), o.headers = AxiosHeaders$1.from(o.headers), o;
  }, function(o) {
    return isCancel(o) || (throwIfCancellationRequested(e), o && o.response && (o.response.data = transformData.call(
      e,
      e.transformResponse,
      o.response
    ), o.response.headers = AxiosHeaders$1.from(o.response.headers))), Promise.reject(o);
  });
}
const headersToObject = (e) => e instanceof AxiosHeaders$1 ? { ...e } : e;
function mergeConfig(e, n) {
  n = n || {};
  const r = {};
  function o(v, m, g) {
    return utils$1.isPlainObject(v) && utils$1.isPlainObject(m) ? utils$1.merge.call({ caseless: g }, v, m) : utils$1.isPlainObject(m) ? utils$1.merge({}, m) : utils$1.isArray(m) ? m.slice() : m;
  }
  function l(v, m, g) {
    if (utils$1.isUndefined(m)) {
      if (!utils$1.isUndefined(v))
        return o(void 0, v, g);
    } else
      return o(v, m, g);
  }
  function u(v, m) {
    if (!utils$1.isUndefined(m))
      return o(void 0, m);
  }
  function h(v, m) {
    if (utils$1.isUndefined(m)) {
      if (!utils$1.isUndefined(v))
        return o(void 0, v);
    } else
      return o(void 0, m);
  }
  function c(v, m, g) {
    if (g in n)
      return o(v, m);
    if (g in e)
      return o(void 0, v);
  }
  const f = {
    url: u,
    method: u,
    data: u,
    baseURL: h,
    transformRequest: h,
    transformResponse: h,
    paramsSerializer: h,
    timeout: h,
    timeoutMessage: h,
    withCredentials: h,
    withXSRFToken: h,
    adapter: h,
    responseType: h,
    xsrfCookieName: h,
    xsrfHeaderName: h,
    onUploadProgress: h,
    onDownloadProgress: h,
    decompress: h,
    maxContentLength: h,
    maxBodyLength: h,
    beforeRedirect: h,
    transport: h,
    httpAgent: h,
    httpsAgent: h,
    cancelToken: h,
    socketPath: h,
    responseEncoding: h,
    validateStatus: c,
    headers: (v, m) => l(headersToObject(v), headersToObject(m), !0)
  };
  return utils$1.forEach(Object.keys(Object.assign({}, e, n)), function(m) {
    const g = f[m] || l, y = g(e[m], n[m], m);
    utils$1.isUndefined(y) && g !== c || (r[m] = y);
  }), r;
}
const VERSION = "1.6.8", validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, n) => {
  validators$1[e] = function(o) {
    return typeof o === e || "a" + (n < 1 ? "n " : " ") + e;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function e(n, r, o) {
  function l(u, h) {
    return "[Axios v" + VERSION + "] Transitional option '" + u + "'" + h + (o ? ". " + o : "");
  }
  return (u, h, c) => {
    if (n === !1)
      throw new AxiosError(
        l(h, " has been removed" + (r ? " in " + r : "")),
        AxiosError.ERR_DEPRECATED
      );
    return r && !deprecatedWarnings[h] && (deprecatedWarnings[h] = !0, console.warn(
      l(
        h,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), n ? n(u, h, c) : !0;
  };
};
function assertOptions(e, n, r) {
  if (typeof e != "object")
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  const o = Object.keys(e);
  let l = o.length;
  for (; l-- > 0; ) {
    const u = o[l], h = n[u];
    if (h) {
      const c = e[u], f = c === void 0 || h(c, u, e);
      if (f !== !0)
        throw new AxiosError("option " + u + " must be " + f, AxiosError.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new AxiosError("Unknown option " + u, AxiosError.ERR_BAD_OPTION);
  }
}
const validator = {
  assertOptions,
  validators: validators$1
}, validators = validator.validators;
class Axios {
  constructor(n) {
    this.defaults = n, this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(n, r) {
    try {
      return await this._request(n, r);
    } catch (o) {
      if (o instanceof Error) {
        let l;
        Error.captureStackTrace ? Error.captureStackTrace(l = {}) : l = new Error();
        const u = l.stack ? l.stack.replace(/^.+\n/, "") : "";
        o.stack ? u && !String(o.stack).endsWith(u.replace(/^.+\n.+\n/, "")) && (o.stack += `
` + u) : o.stack = u;
      }
      throw o;
    }
  }
  _request(n, r) {
    typeof n == "string" ? (r = r || {}, r.url = n) : r = n || {}, r = mergeConfig(this.defaults, r);
    const { transitional: o, paramsSerializer: l, headers: u } = r;
    o !== void 0 && validator.assertOptions(o, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, !1), l != null && (utils$1.isFunction(l) ? r.paramsSerializer = {
      serialize: l
    } : validator.assertOptions(l, {
      encode: validators.function,
      serialize: validators.function
    }, !0)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let h = u && utils$1.merge(
      u.common,
      u[r.method]
    );
    u && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (E) => {
        delete u[E];
      }
    ), r.headers = AxiosHeaders$1.concat(h, u);
    const c = [];
    let f = !0;
    this.interceptors.request.forEach(function(x) {
      typeof x.runWhen == "function" && x.runWhen(r) === !1 || (f = f && x.synchronous, c.unshift(x.fulfilled, x.rejected));
    });
    const v = [];
    this.interceptors.response.forEach(function(x) {
      v.push(x.fulfilled, x.rejected);
    });
    let m, g = 0, y;
    if (!f) {
      const E = [dispatchRequest.bind(this), void 0];
      for (E.unshift.apply(E, c), E.push.apply(E, v), y = E.length, m = Promise.resolve(r); g < y; )
        m = m.then(E[g++], E[g++]);
      return m;
    }
    y = c.length;
    let w = r;
    for (g = 0; g < y; ) {
      const E = c[g++], x = c[g++];
      try {
        w = E(w);
      } catch (D) {
        x.call(this, D);
        break;
      }
    }
    try {
      m = dispatchRequest.call(this, w);
    } catch (E) {
      return Promise.reject(E);
    }
    for (g = 0, y = v.length; g < y; )
      m = m.then(v[g++], v[g++]);
    return m;
  }
  getUri(n) {
    n = mergeConfig(this.defaults, n);
    const r = buildFullPath(n.baseURL, n.url);
    return buildURL(r, n.params, n.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function e(n) {
  Axios.prototype[n] = function(r, o) {
    return this.request(mergeConfig(o || {}, {
      method: n,
      url: r,
      data: (o || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function e(n) {
  function r(o) {
    return function(u, h, c) {
      return this.request(mergeConfig(c || {}, {
        method: n,
        headers: o ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: u,
        data: h
      }));
    };
  }
  Axios.prototype[n] = r(), Axios.prototype[n + "Form"] = r(!0);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(n) {
    if (typeof n != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(u) {
      r = u;
    });
    const o = this;
    this.promise.then((l) => {
      if (!o._listeners)
        return;
      let u = o._listeners.length;
      for (; u-- > 0; )
        o._listeners[u](l);
      o._listeners = null;
    }), this.promise.then = (l) => {
      let u;
      const h = new Promise((c) => {
        o.subscribe(c), u = c;
      }).then(l);
      return h.cancel = function() {
        o.unsubscribe(u);
      }, h;
    }, n(function(u, h, c) {
      o.reason || (o.reason = new CanceledError(u, h, c), r(o.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(n) {
    if (this.reason) {
      n(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(n) : this._listeners = [n];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(n) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(n);
    r !== -1 && this._listeners.splice(r, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let n;
    return {
      token: new CancelToken(function(l) {
        n = l;
      }),
      cancel: n
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function isAxiosError(e) {
  return utils$1.isObject(e) && e.isAxiosError === !0;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([e, n]) => {
  HttpStatusCode[n] = e;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(e) {
  const n = new Axios$1(e), r = bind(Axios$1.prototype.request, n);
  return utils$1.extend(r, Axios$1.prototype, n, { allOwnKeys: !0 }), utils$1.extend(r, n, null, { allOwnKeys: !0 }), r.create = function(l) {
    return createInstance(mergeConfig(e, l));
  }, r;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function e(n) {
  return Promise.all(n);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (e) => formDataToJSON(utils$1.isHTMLForm(e) ? new FormData(e) : e);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const kn = class kn extends BaseObject {
  constructor() {
    super(), this._className = "Http";
  }
  // 提供一个获取实例的静态方法
  static getInstance() {
    return kn._instance || (kn._instance = new kn()), kn._instance;
  }
  async get(n) {
    return new Promise((r, o) => {
      axios.get(n).then((l) => {
        let u = l || {};
        return u.code === 200 ? r(u.data) : r(u);
      }).catch((l) => o(l));
    });
  }
};
kn._instance = null;
let Http = kn;
const Nn = class Nn extends BaseObject {
  constructor() {
    super(), this._demLayers = [], this._className = "GeoMeasureMethods";
  }
  // 提供一个获取实例的静态方法
  static getInstance() {
    return Nn._instance || (Nn._instance = new Nn()), Nn._instance;
  }
  addDemLayer(n) {
    this._demLayers.push(n);
  }
  async getAltitude(n) {
    var r = null;
    for (const c of this._demLayers) {
      var o = point([n.getLon(), n.getLat()]), l = polygon([[
        [c.layerBonds[0], c.layerBonds[1]],
        // 注意：polygon首尾坐标要一致
        [c.layerBonds[2], c.layerBonds[1]],
        [c.layerBonds[2], c.layerBonds[3]],
        [c.layerBonds[0], c.layerBonds[3]],
        [c.layerBonds[0], c.layerBonds[1]]
      ]]);
      if (booleanPointInPolygon(o, l)) {
        const f = new URLSearchParams({
          //@ts-ignore
          service: "WMS",
          version: "1.1.1",
          request: "GetFeatureInfo",
          layers: c.layers,
          // 你的高程数据图层名称
          styles: "",
          transparent: "true",
          format: "image/png",
          exceptions: "application/vnd.ogc.se_inimage",
          bbox: c.layerBonds,
          // 设定一个边界框，
          height: c.layerHeight,
          width: c.layerWidth,
          query_layers: c.layers,
          srs: "epsg:4326",
          info_format: "text/plain",
          x: Math.round((n.getLon() - c.layerBonds[0]) * c.layerWidth),
          // 将经度转换为像素坐标
          y: Math.round((n.getLat() - c.layerBonds[1]) * c.layerHeight)
          // 将纬度转换为像素坐标
        }), v = `${c.url}/?${f.toString()}`;
        if (r = await Http.getInstance().get(v), r = r.data, r.lastIndexOf("=") != -1) {
          var u = r.substr(r.lastIndexOf("=") + 1), h = Number(u.substr(0, u.indexOf(`
`)));
          r = h;
        } else
          r = -999;
      }
    }
    return r;
  }
};
Nn._instance = null;
let GeoMeasureMethods = Nn;
const On = class On extends PlotLayer {
  constructor(n, r) {
    super(n, r, null), this._measureResult = [], this._className = "GeoMeasureTools", this._map = n;
  }
  // 提供一个获取实例的静态方法
  static getInstance(n) {
    if (!On._instance) {
      let r = new FeatureLayerOptions("测量");
      On._instance = new On(n, r);
    }
    return On._instance;
  }
  getTilesInBounds(n, r, o = [], l = 5) {
    const u = n._layer.getTileSize(), h = this._map._map.getBounds(), c = this._map._map.getSize();
    if (o.length != 2)
      return;
    let f = leafletSrcExports.latLngBounds([o[0].getLat(), o[0].getLon()], [o[1].getLat(), o[1].getLon()]);
    console.log("leafletBounds0", f);
    const v = f.getNorthWest(), m = f.getSouthEast(), g = this._map._map.project(v, l), y = this._map._map.project(m, l), w = this._map._map.project(f.getNorthWest(), l), E = this._map._map.project(f.getSouthEast(), l), x = y.x - g.x, D = y.y - g.y;
    console.log(x, D);
    const F = new leafletSrcExports.Bounds(
      g.divideBy(u.x).floor(),
      y.divideBy(u.y).floor()
    ), k = new leafletSrcExports.Bounds(
      w.floor(),
      E.floor()
    );
    console.log(k, "vecterBounds");
    const N = [];
    for (let pt = F.min.y; pt <= F.max.y; pt++)
      for (let ct = F.min.x; ct <= F.max.x; ct++) {
        const Nt = new leafletSrcExports.Point(ct, pt);
        Nt.z = l, n._layer._tileZoom = l, N.push({
          x: Nt.x,
          y: Nt.y,
          url: n._layer.getTileUrl(Nt)
        });
      }
    const H = [];
    if (r.getAllFeatures().length > 0)
      for (let pt = k.min.y; pt < k.max.y; pt += c.y)
        for (let ct = k.min.x; ct < k.max.x; ct += c.x) {
          const Nt = new leafletSrcExports.Point(ct, pt);
          H.push(Nt);
        }
    console.log("mapViews", H);
    const j = document.createElement("canvas"), S = leafletSrcExports.point(N[0].x * u.x, N[0].y * u.y), tt = leafletSrcExports.point(
      N[N.length - 1].x * u.x + u.x,
      N[N.length - 1].y * u.y + u.y
    );
    j.width = tt.x - S.x, j.height = tt.y - S.y, console.log("canvas", j);
    const nt = j.getContext("2d");
    j.getContext("2d");
    let ft = 0;
    N.forEach((pt) => {
      const ct = new Image();
      ct.onload = () => {
        const Nt = (pt.x - N[0].x) * u.x, kt = (pt.y - N[0].y) * u.y;
        if (nt.drawImage(ct, Nt, kt, u.x, u.y), ft++, ft == N.length) {
          const G = leafletSrcExports.point(N[0].x * u.x, N[0].y * u.y), Y = leafletSrcExports.point(
            N[N.length - 1].x * u.x + u.x,
            N[N.length - 1].y * u.y + u.y
          ), it = Math.abs(Y.x - G.x) / j.width, rt = Math.abs(Y.y - G.y) / j.height, ht = document.createElement("canvas");
          ht.width = x, ht.height = D, console.log("outCanvas", ht);
          const bt = ht.getContext("2d");
          for (let yt = 0; yt < H.length; yt++) {
            const St = H[yt], Ft = this._map._map.getSize(), zt = leafletSrcExports.point(St.x, St.y), Zt = leafletSrcExports.point(St.x + Ft.x, St.y + Ft.y);
            var Rt = leafletSrcExports.point(St.x + Ft.x * 0.5, St.y + Ft.y * 0.5), Mt = this._map._map.unproject(Rt, l);
            leafletSrcExports.latLngBounds(
              this._map._map.unproject(zt, l),
              this._map._map.unproject(Zt, l)
            ), setTimeout(() => {
              H[0].x, H[0].y, this._map._map.setView(Mt, l), setTimeout(() => {
                this._map._map._renderer._bounds.getSize();
                const J = this._map._map.getCenter(), et = this._map._map.project(J, l);
                console.log(et, "iiiiiiiiii"), Math.round((zt.x - G.x) / it), Math.round((zt.y - G.y) / rt), (g.x - G.x) / it, (g.y - G.y) / rt, console.log(this._map._map._renderer._container, Ft.x, Ft.y, "cpmtainer");
                var at = this._map._map._renderer._container.style.transform.split(/[(,)]/);
                at.length > 0 && console.log(at, at[1].slice(0, at[1].length - 2), Number(at[1].slice(0, at[1].length - 2)), Number(at[2].slice(0, at[2].length - 2))), nt.drawImage(
                  this._map._map._renderer._container,
                  Number(at[1].slice(0, at[1].length - 2)),
                  -Number(at[2].slice(0, at[2].length - 2)) - 80,
                  this._map._map._renderer._container.width,
                  this._map._map._renderer._container.height
                );
              }, 2e3);
            }, 3e3 * (yt + 1));
          }
          setTimeout(() => {
            (g.x - G.x) / it, (g.y - G.y) / rt, (y.x - g.x) / it, (y.y - g.y) / rt, console.log(g.x - G.x, g.y - G.y, y.x - g.x, y.y - g.y), bt.putImageData(nt.getImageData(g.x - G.x, g.y - G.y, y.x - g.x, y.y - g.y), 0, 0), console.log("outCtx", bt, nt), ht.toBlob((yt) => {
              const St = URL.createObjectURL(yt);
              let Ft = document.createElement("a");
              Ft.href = St, Ft.download = "image.png", Ft.click();
            }), this._map._map._zoomAnimated = !0, this._map._map._fadeAnimated = !0;
          }, 3e3 * (H.length + 1));
        }
      }, ct.setAttribute("crossOrigin", "anonymous"), ct.src = pt.url;
    }), console.log(u, h, c);
  }
};
On._instance = null;
let GeoCommonTools = On, Map$1 = class extends BaseObject {
  constructor(n, r) {
    super(), this._props = r, this._map = null, this._elementId = n, this._imageryLayersCollection = [], this._featureLayerCollection = [], this._className = "Map", this._control = new Control(n, this, r), this._userMouseEvents = [], this._initialize(), this._geoMeasuretools = GeoMeasureTools.getInstance(this), this._geoCommonTools = GeoCommonTools.getInstance(this), this._lonLatGridLayer = LonLatGridLayer.getInstance(this), this._KiloMeterGrigLayer = KiloMetersGridLayer.getInstance(this);
  }
  addDemLayer(n) {
    n && GeoMeasureMethods.getInstance().addDemLayer(n);
  }
  getZoom() {
    return this._map.getZoom();
  }
  setZoom(n) {
    this._map.setZoom(n);
  }
  zoomIn() {
    this._map.zoomIn();
  }
  zoomOut() {
    this._map.zoomOut();
  }
  zoomTo(n) {
    defined(n) && n.zoomTo();
  }
  setView(n, r) {
    this._map.setView(leafletSrcExports.latLng(n.getLat(), n.getLon()), r);
  }
  setMapCenter(n) {
    this._map.setView(leafletSrcExports.latLng(n.getLat(), n.getLon()));
  }
  flyToMapCenter(n) {
    this._map.flyTo(leafletSrcExports.latLng(n.getLat(), n.getLon()));
  }
  /**
   * 地图初始化
   * */
  _initialize() {
    var n = "";
    this._props.crs === "EPSG:3857" ? n = leafletSrcExports.CRS.EPSG3857 : this._props.crs === "EPSG:4326" ? n = leafletSrcExports.CRS.EPSG4326 : n = leafletSrcExports.CRS.EPSG3857, this._map = leafletSrcExports.map(this._elementId, {
      preferCanvas: !0,
      zoomControl: !1,
      attributionControl: !1,
      crs: n,
      zoom: this._props.zoom,
      maxZoom: this._props.maxZoom,
      minZoom: this._props.minZoom,
      center: [this._props.center.getLat(), this._props.center.getLon()]
    }), this._map.on("click", this._userMouseLClickEvent, this), this._map.getBounds(), this._map.on("zoomend", (o) => {
      this._zoom(o), console.log(o, this._map.getZoom());
    }), this._map.on("moveend", (o) => {
      this._mapMoveend(o);
    });
    var r = leafletSrcExports.control.scale({ imperial: !1 });
    return r.addTo(this._map), !0;
  }
  getAllImageryLayer() {
    return this._imageryLayersCollection;
  }
  getAllFeatureLayer() {
    return this._imageryLayersCollection;
  }
  //添加瓦片图层
  addImageryLayer(n) {
    try {
      if (defined(n)) {
        var r = n;
        if (defined(this._control) && this._control.addImagelayer(n), r.getLayerType() === LayerType.WMS) {
          const l = r;
          let u = r._options;
          var o = {
            layers: u.layer == "" ? u.layers : u.layer,
            //图层名称
            style: u.style,
            format: u.format,
            transparent: u.transparent,
            tileMatrixSet: u.crs,
            maxZoom: u.maxZoom,
            service: "WMS"
            // bounds:[],
          };
          defined(u.bounds);
          let h = leafletSrcExports.tileLayer.wms(l._options.url, o);
          return h.addTo(this._map), l._layer = h, l._map = this._map, this._imageryLayersCollection.push(l), l;
        } else if (r.getLayerType() === LayerType.WMTS) {
          const l = r;
          let u = r._options, h = {
            layer: u.layer,
            //图层名称
            style: u.style,
            format: u.format,
            transparent: u.transparent,
            tileMatrixSet: u.crs,
            maxZoom: u.maxZoom
          }, c = new leafletSrcExports.TileLayer.WMTS(u.url, h);
          return c.addTo(this._map), l._layer = c, l._map = this._map, this._imageryLayersCollection.push(l), l;
        } else if (r.getLayerType() === LayerType.XYZ) {
          const l = r;
          return l._layer = leafletSrcExports.tileLayer(l._options.url, {
            maxZoom: this._props.maxZoom,
            minZoom: this._props.minZoom,
            tms: !1
          }).addTo(this._map), l._map = this._map, this._imageryLayersCollection.push(l), l;
        }
      }
    } catch (l) {
      console.log(l);
    }
    return new Object();
  }
  /*
  *  //移除瓦片图层
  * layer 要移除的图层
  * */
  removeImageryLayer(n) {
    if (defined(n))
      if (defined(this._control) && this._control.removeImagelayer(n), this._map.hasLayer(n._layer) && this._imageryLayersCollection.find((r) => r._id == n._id)) {
        n._layer.remove(), this._imageryLayersCollection = [...this._imageryLayersCollection.filter((r) => r !== n)];
        return;
      } else
        return !1;
    return !1;
  }
  addFeatureLayer(n) {
    return defined(n) ? (n._map = this, this._featureLayerCollection.push(n), defined(this._control) && this._control.addFeatureLayer(n), n) : null;
  }
  getImageryLayerByID(n) {
  }
  getImageryLayerByName(n) {
    return [];
  }
  addPlotLayer(n) {
    if (defined(n)) {
      let r = n;
      return defined(this._control) && this._control.addFeatureLayer(r), r._isEditing && this._featureLayerCollection.forEach((o) => {
        if (o._layerType == LayerType.PLOT) {
          let l = o;
          l._isEditing && l.endEdite();
        }
      }), r._map = this, this._featureLayerCollection.push(r), n;
    }
    return null;
  }
  removePlotLayer(n) {
    if (defined(n))
      if (n.endEdite(), this._featureLayerCollection.find((r) => r._id == n._id)) {
        n.removeAll(), this._featureLayerCollection = [...this._featureLayerCollection.filter((r) => r !== n)], delete n._drawHandler, n = null;
        return;
      } else
        return !1;
    return !1;
  }
  //地图释放事件
  _zoom(n) {
    this._featureLayerCollection.forEach((r) => {
      r.redraw();
    });
  }
  _mapMoveend(n) {
    this._lonLatGridLayer && this._lonLatGridLayer.redraw(), this._KiloMeterGrigLayer && this._KiloMeterGrigLayer.redraw();
  }
  LoadPlotTreeJson(n) {
    return defined(n) && defined(this._control) ? (this._control.loadPlotTreeJson(n, this._control), !0) : !1;
  }
  removeFeatureLayer(n) {
    if (defined(n))
      if (defined(this._control) && this._control.removeFeaturelayer(n), this._featureLayerCollection.find((r) => r._id == n._id)) {
        n.removeAll(), this._featureLayerCollection = [...this._featureLayerCollection.filter((r) => r !== n)], n = null;
        return;
      } else
        return !1;
    return !1;
  }
  getLayerByID(n) {
    let r = this._imageryLayersCollection.find((o) => o._id == n);
    return defined(r) ? r : (r = this._featureLayerCollection.find((o) => o._id == n), defined(r) ? r : null);
  }
  getGeoMeasureToos() {
    return this._geoMeasuretools;
  }
  getGeoCommonTools() {
    return this._geoCommonTools;
  }
  addMouseEvent(n, r) {
    this._userMouseEvents.push({ type: n, callback: r });
  }
  removeMouseEvent(n, r) {
    var o = this._userMouseEvents.find((l) => l.type == n && l.callback == r);
    if (o) {
      const l = this._userMouseEvents.indexOf(o);
      return l > -1 && this._userMouseEvents.splice(l, 1), !0;
    }
    return !1;
  }
  _userMouseLClickEvent(n) {
    this._userMouseEvents.forEach((r) => {
      r.type == MouseEventType.MouseLClick && r.callback({
        containerPoint: n.containerPoint,
        layerPoint: n.layerPoint,
        positions: new GeoPoint3D(n.latlng.lng, n.latlng.lat),
        type: MouseEventType.MouseLClick
      });
    });
  }
  /**
   * @作者: Wangjianbo
   * @时间: 2024/04/15 10:28:07
   * @描述:恢复初始化的地图中心和层级
   * @参数：
   */
  reset() {
    this._map.setView(leafletSrcExports.latLng(this._props.center.getLat(), this._props.center.getLon()), this._props.zoom);
  }
};
class Entity extends Feature {
  constructor(n, r = null) {
    super(FeatureType.Entity, r), this._symbol._options = n, this._symbol.controlPoints = [n.position];
  }
}
class XYZImageryLayer extends ImageryLayer {
  constructor(n) {
    super(n), this._options = n, this._layerType = LayerType.XYZ, this._layer = null, this._className = "WebMapTileServiceImageryLayer";
  }
}
export {
  Entity,
  Feature,
  FeatureLayer,
  GeoCommonTools,
  GeoMeasureMethods,
  GeoPoint2D,
  GeoPoint3D,
  LonLatGridLayer,
  Map$1 as Map,
  Defineds as Options,
  PlotLayer,
  TypesDefined as TypeDefineds,
  WebMapServiceImageryLayer,
  XYZImageryLayer,
  WebMapTileServiceImageryLayer as webMapTileServiceImageryLayer
};
